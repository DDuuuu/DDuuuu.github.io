# Prism 简介


 

## 简介

注意：该版本为Prism6,最新版已有较大改动。

Prism需要.Framework4.5，包含MVVM（Model-View-ViewModel）模式，Navigation，和MEF（Managed Extensibility Framework）

## 前期准备

学习Prism需要一些WPF的概念，需要了解和熟悉

- **XAML**(**Extensible Application Markup Language**)。在WPF应用程序中以声明方式定义和初始化用户界面的语言。
- **数据绑定**(**Binding**)。这就是UI元素如何连接到WPF中的组件和数据。
- **资源**(**Resources**)。这些是在WPF中创建和管理样式，数据模板和控件模板的方式。
- **命令**(**Commands**)。这些是用户手势和输入连接到控件的方式。
- **用户控件**(**User Controls**)。这些是提供自定义行为或自定义外观的组件。
- **依赖属性**(**Dependency properties**)。这些是公共语言运行时（CLR）属性系统的扩展，用于启用属性设置和监视，以支持数据绑定，路由命令和事件。
- **行为**(**Behaviors**)。行为是封装交互功能的对象，可以轻松应用于用户界面中的控件。

## 关键概念

Prism提供了您可能不熟悉的功能和设计模式，特别是如果您是设计模式和复合应用程序开发的新手。本节简要概述了Prism背后的主要概念，并定义了您将在整个文档和代码中使用的一些术语。

- **模块**（**Modules**）。模块是可以独立开发，测试和（可选）部署的功能包。在许多情况下，模块由不同的团队开发和维护。典型的Prism应用程序由多个模块构建。**模块可用于表示特定的业务相关功能**（例如，配置文件管理），**并封装实现该功能所需的所有视图，服务和数据模型**。模块还可用于封装可在多个应用程序中重用的常见应用程序基础结构或服务（例如，日志记录和异常管理服务）。
- **模块目录**（**Module Catalog**）。在复合应用程序中，必须由主机应用程序在运行时发现和加载模块。在Prism中，**模块目录用于指定要加载哪些模块，何时加载以及按什么顺序加载**。模块目录由**ModuleManager**和**ModuleLoader**组件使用，如果模块是远程的，则负责下载模块，将模块的程序集加载到应用程序域中，以及初始化模块。Prism允许以不同方式指定模块目录，包括以编程方式使用代码，以声明方式使用XAML或使用配置文件。如果需要，您还可以实现自定义模块目录。
- **壳**（**Shell**）。shell是加载模块的宿主应用程序。shell定义了**应用程序的整体布局和结构**，但它通常不知道它将托管的确切模块。它通常实现常见的应用程序服务和基础结构，但大多数应用程序的功能和内容都是在模块中实现的。shell还提供顶级窗口或可视元素，然后将托管由加载的模块提供的不同UI组件。
- **视图**（**Views**）。视图是UI控件，用于封装应用程序的特定功能或功能区域的UI。视图与MVVM模式结合使用，MVVM模式用于在UI与应用程序的表示逻辑和数据之间提供关注点的清晰分离。视图用于封装UI并定义用户交互行为，从而允许独立于底层应用程序功能更新或替换视图。视图使用数据绑定与视图模型类交互。
- **视图模型**（**View models**）。视图模型是封装应用程序的表示逻辑和状态的类。它们是MVVM模式的一部分。View模型封装了应用程序的大部分功能。视图模型定义属性，命令和事件，视图中的控件可以对其进行数据绑定。
- **模型**（**Models**）。模型类封装了应用程序数据和业务逻辑。它们用作MVVM模式的一部分。模型封装了数据以及任何相关的验证和业务规则，以确保数据的一致性和完整性。
- **命令**（**Commands**）。命令用于封装应用程序功能，允许独立于应用程序的UI定义和测试它们。它们可以在视图模型中定义为命令对象或命令方法。Prism提供**DelegateCommand**类和**CompositeCommand**类。后者用于表示一起调用的命令集合。
- **地区**（**Regions**）。区域是在应用程序的UI（**在shell或视图中）中定义的逻辑占位符**，其中显示视图。区域允许更新应用程序UI的布局，而无需更改应用程序逻辑。许多常用控件可用作区域，允许视图自动显示在控件中，例如**ContentControl**，**ItemsControl**，**ListBox**或**TabControl**。可以以编程方式或自动方式在区域内显示视图。Prism还为实施区域导航提供支持。区域可以通过**RegionManager**组件由其他组件**定位**，该组件使用**RegionAdapter**和**RegionBehavior**组件，以协调特定区域内的视图显示。
- **导航**（**Navigation**）。导航定义为**应用程序通过其与应用程序或内部应用程序状态更改进行交互而更改其UI**的过程。Prism支持两种导航样式：基于状态的导航，其中现有视图的状态被更新以实现简单的导航场景;以及视图切换导航，其中创建新视图并在应用程序的UI内替换旧视图。视图切换导航使用基于统一资源标识符（URI）的导航机制与Prism区域相结合，以允许实现灵活的导航方案。
- **事件聚合**（**EventAggregator**）。复合应用程序中的组件通常需要以松散耦合的方式与应用程序中的其他组件和服务进行通信。为了支持这一点，Prism提供了**EventAggregator**组件，它实现了pub-sub事件机制，从而允许组件发布事件和其他组件来订阅这些事件，而不需要引用另一个事件。所述**EventAggregator**经常被用来允许在不同的模块中定义的部件彼此通信。
- **依赖注入容器**（**Dependency injection container**）。整个Prism使用依赖注入（DI）模式来允许管理组件之间的依赖关系。依赖注入允许在运行时实现组件依赖性，并且它支持可扩展性和可测试性。Prism旨在与Unity或MEF一起使用，或通过**ServiceLocator**与任何其他依赖注入容器一起使用。
- **服务**（**Services**）。服务是封装非UI相关功能的组件，例如**日志记录，异常管理和数据访问**。服务可以由应用程序定义，也可以在模块内定义。服务通常在依赖注入容器中注册，以便它们可以根据需要定位或构造，并由依赖于它们的其他组件使用。
- **控制器**（**Controllers**）。控制器是用于协调要在应用程序UI中的区域中显示的视图的构造和初始化的类。控制器封装了表示要显示哪些视图的表示逻辑。控制器将使用Prism的视图切换导航机制，该机制提供可扩展的基于URI的导航机制，以协调区域内视图的构造和放置。Application Controller模式定义了映射到此职责的抽象。
- **引导程序**（**Bootstrapper**）。该**引导程序**组件应用程序使用来初始化各个棱镜组件和服务。它用于初始化依赖注入容器，以便向其注册任何应用程序级组件和服务。它还用于配置和初始化模块目录以及shell的视图和视图模型或演示者。

Prism的设计使您可以单独使用任何前述功能和设计模式，也可以根据您的要求和应用场景一起使用。您可以以任意组合使用MVVM模式，模块化，区域，命令或事件，而无需采用所有这些模式。当然，如果您想充分利用分离关注点和松散耦合提供的好处，您通常会将Prism的许多功能和设计模式相互结合使用。下图显示了典型的Prism应用程序体系结构，并展示了Prism的所有各种功能如何在多模块复合应用程序中协同工作。

![Prism架构](/prism/Ch1IntroFig3.png)

**使用Prism库的典型复合应用程序架构**

大多数Prism应用程序由一个shell应用程序组成，该应用程序定义用于显示顶级视图的区域和可由加载的模块访问的共享服务。shell定义了一个合适的Module catalog，以指定在启动时加载哪些模块（如果适用）。还定义了依赖注入容器，其允许在运行时实现组件依赖性。应用程序启动时，**Bootstrapper**在容器中注册共享服务和组件。

各个模块封装了整个应用程序功能的一部分，并使用分离的表示模式（如MVVM）定义视图，视图模型，模型和服务组件。加载模块时，模块中定义的视图将显示在shell定义的区域内。初始化完成后，用户然后使用基于状态或视图切换的导航在应用程序内导航，以协调应用程序区域内的新视图的可视更新或显示。


---

> 作者: [AndrewDu](https://github.com/DDuuuu)  
> URL: https://DDuuuu.github.io/2019/06/prism1-introduce/  

