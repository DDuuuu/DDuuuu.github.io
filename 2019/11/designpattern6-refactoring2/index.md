# 重构改善既有代码 重新组织函数


对函数的重构方法

### 1、提炼函数 

&#43; ExtractMethod
  &#43; ![1572396877904](/designpattern/1572396877904.png)
&#43; 动机
  &#43; 每个函数的颗粒度都比较小，高层函数读起来就像是注释
  &#43; 颗粒度比较小覆写也比较容易
&#43; 什么时候需要提炼函数
  &#43; 当函数体的语义与函数名称偏离的时候就需要提取
&#43; 怎么提取
  &#43; 将代码提取出来用函数的意图来命名（做什么）
  &#43; 如果该代码段中有读取或改变临时变量
    &#43; 该临时变量在原函数中有没有使用，
      &#43; 优先考虑用查询取代临时变量
      &#43; 没有直接将临时变量的声明移植到函数体中
      &#43; 在函数体之前使用，作为参数传入
      &#43; 在函数体之后使用，作为函数返回值返回
      &#43; 之前之后都使用，作为参数传入，在作为返回值返回
  &#43; 如果临时变量非常多，
    &#43; 需要考虑这个函数体是否真的属于这个类
    &#43; 以**查询替代**临时变量

### 2、内联函数

&#43; Inline Method
  &#43; ![1572396856168](/designpattern/1572396856168.png)
&#43; 什么时候需要内联
  &#43; 当函数的本体和名称同样清楚易懂的时候
  &#43; 当有一大群组织不太合理的函数，想重构的时候，**将一大群函数内联然后重新提取**
  &#43; 有太多的间接层，所有函数似乎都是对另一个函数的简单委托
&#43; 怎么内联
  &#43; 检查函数，确定它不具有多态。
  &#43; 找出该函数的所有引用点，用函数体替换（最好用文本查找的方式找）

### 3、内联临时变量

&#43; Inline Temp
  &#43; ![1572396842515](/designpattern/1572396842515.png)
&#43; 动机
&#43; 什么时候做
  &#43; 有一个临时变量，只被简单表达式赋值一次，而它妨碍其他重构手法
&#43; 怎么做

### 4、以查询取代临时变量*

&#43; Replace Temp with Query
  &#43; ![1572396817819](/designpattern/1572396817819.png)
&#43; 动机
  &#43; 临时变量是暂时的，如果这个临时变量需要被**使用多次**就考虑需要用查询取代，这边的查询可以直接使用.net中的属性。
  &#43; 临时变量会驱使函数变长，如果变成查询，类中的其他成员也可以访问。
&#43; 什么时候需要查询取代
  &#43; 用一个临时变量保存其某一表达式的运算结果，需要一个查询函数取代临时变量
&#43; 怎么取代
  &#43; 需要分解临时变量（临时变量**被赋值超过一次**），以查询取代临时变量，然后再替换临时变量
  &#43; 首先应该将查询设置为私有的，当日后需要的时候再开放保护。
  &#43; 不用考虑细微的性能问题，因为首先需要良好的架构才能使得程序正常运行。然后再考虑性能问题。

### 5、引入解释性变量

&#43; Introduce Explaining Variable
  &#43; 在引入解释性变量之后，可以使用导出方法或者用查询取代临时变量将临时变量替换掉。
  &#43; ![1572396792964](/designpattern/1572396792964.png)
&#43; 动机
  &#43; 使得复杂表达式可以阅读和管理
&#43; 什么时候需要引入
  &#43; 有一个复杂的表达式
&#43; 怎么引入
  &#43; 讲一个复杂表达式（或一部分）的结果放进一个临时变量，以此变量名称来解释表达式的用途
&#43; 与提炼函数的区别
  &#43; 再提炼函数需要花费更大的工作量的时候

### 6、分解临时变量

&#43; Split Temporary Variable
  &#43; ![1572396764394](/designpattern/1572396764394.png)
&#43; 动机
  &#43; 如果一个临时变量承担太多的职责，会使得阅读者糊涂
&#43; 什么时候分解
  &#43; 程序中有**某个临时变量被赋值超过一次**，它既不是循环变量也不是收集计算结果。
&#43; 怎么分解
  &#43; 修改临时变量的名称并声明为常量

### 7、移除对参数的赋值*

&#43; Remove Assignments to Parameters
  &#43; 这边的是针对函数参数体成员
  &#43; 对参数的赋值的想法是比较危险的，一旦为参数进行赋值如果混淆值类型和引用类型非常容易产生不易察觉的错误。
  &#43; ![1572396741479](/designpattern/1572396741479.png)
&#43; 动机
  &#43; 因为面向对象的方式，所以数值类型的改变并不会改变原来传入的值，但是引用类型就会变化
  &#43; 导致混用按值传递和按引用传递
&#43; 什么时候移除
  &#43; 代码对函数的一个参数进行赋值时
&#43; 怎么移除
  &#43; 通过建立一个临时变量，对临时变量进行修改，然后返回临时变量。
  &#43; 如果需要返回一大堆函数，可以将返回的一大堆函数变成一个单一的对象，或者为每个返回值设置一个独立函数。
  &#43; 还可以在函数的每个参数中增加一个const，这个方法只是在函数体较长的时候才可以使用。

### 8、以函数对象取代函数

&#43; Replace Method with Method Object
  &#43; ![1572396709204](/designpattern/1572396709204.png)
&#43; 动机
  &#43; 小型函数优美动人
&#43; 什么时候取代
  &#43; 有一个大型函数，对其中的局部变量的使用无法采用提炼方法的手段
&#43; 怎么提取
  &#43; 建立一个新类，将所有的局部变量变成字段，然后将原函数体中的逻辑变成方法。

### 9、替换算法

&#43; Substitute Algorithm
  &#43; ![1572396971680](/designpattern/1572396971680.png)
&#43; 动机
  &#43; 发现一个算法的效率更高的时候
&#43; 什么时候替换
  &#43; 想法把某个算法换成另一个更为清晰的算法


---

> 作者: [AndrewDu](https://github.com/DDuuuu)  
> URL: https://DDuuuu.github.io/2019/11/designpattern6-refactoring2/  

