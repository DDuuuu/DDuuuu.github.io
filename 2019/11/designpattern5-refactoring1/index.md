# 重构改善既有代码 坏代码的味道


&#43; 第一次做某件事情的时候尽管去做，第二次做类似的事会产生反感，第三次再做类似的事，你就应该重构。

&#43; 小型函数优美动人

&#43; 一个类最好是常量类，任何的改变都是调用该类本身的接口实现。

## 0 **坏代码的味道**

### 1、重复代码 

&#43; Duplicated Code
&#43; 同一类中的两个函数含有相同的表达式，提取到方法
&#43; 互为兄弟的子类含有相同表达式，将两个子类的相同代码提取方法推入超类
  &#43; 如果有相似代码，通过提炼方法将相似和差异部分分割开，并使用疏凿模板方法，并将模板方法上移到超类中。
&#43; 如果两个毫不相关的类出现重复代码，将重复代码提炼到一个提炼类中，两个类都使用这个提炼类。

### 2、过长函数

&#43; Long Method
&#43; 间接层所能带来的全部利益——解释能力、共享能力、选择能力
&#43; 小函数的价值是巨大的
&#43; 每当感觉需要注释来说明什么的时候，就需要把说明的东西写进一个独立函数中，并以其用途命名。
&#43; 函数内有大量的临时变量和参数。需要运用提炼方法，可以将临时变量作为参数传入，也可以使用以查询替代临时变量，当方法参数特别多的时候可以提炼参数类，传递参数类实体。如果这么做还有很多的参数，那么就应该用方法对象来取代方法了。
&#43; 选择提炼哪一段代码
  &#43; 寻找注释，有注释的地方都在提醒你需要提炼方法了，注释名称就是很好的方法名
  &#43; 条件表达式和循环也是型号，可以用 分解条件表达式，循环应该将循环中的代码提炼到独立函数中。

### 3、过大的类

&#43; Large Class
&#43; 如果单个类做太多是事情，往往会导致出现太多的实例变量，一旦如此，重复代码就接踵而至了。
&#43; 可以使用提炼类将几个变量和方法提炼出来，如果数个变量存在着相同的前缀或字尾，就以为着有机会可以把它们提炼到某个组件中。如果这个组件适合一个子类，还可以使用提炼子类。
&#43; 如果一个拥有太多代码，可以先确定客户端如何使用它们，然后运用提炼接口，为每一种使用方法提炼出一个接口，这可以看清楚如何分解这个类。
&#43; 如果超大类是一个GUI类，可以把数据和行为移到一个独立的领域对象去，可能需要两边保留一些重复代码，并保持两边同步。

### 4、过长的参数列

&#43; Long Parameter List
&#43; 如果向已有的对象发出一条请求就可以取代一个参数，那么就可以使用用方法取代参数方法。
&#43; 还可以使用保持整个对象，传递整个对象，
&#43; 提炼参数对象
&#43; 造成函数关联需要慎重考虑

### 5、发散式变化

&#43; Divergent Chane
&#43; 软件再怎么说就应该是软的，一旦需要修改，希望能够跳到系统的某一点，只在该处做修改。如果不能的化就有一种刺鼻味道了。
&#43; 某个类经常因为不同原因在不同不同方向上发生变化发散式变化就出现了，
&#43; 一旦出现这种发散式变化那么就需要将对象分解成多个对象或者会更好，当出现多个类后还可以提炼超类等。

### 6、霰弹式修改

&#43; Shotgun Surgery
&#43; 正对某一项变化需要在许多不同类种做出需要小修改，所面临的味道就是霰弹式修改，
&#43; 这种情况应该使用移动方法和移动字段，把所有修改的代码放进同一个类，如果没有现存的类可以按值这些代码就创造一个，使用内联类可以将一系列相关行为放进同一个类。
&#43; 这也可能造成少量的发散式变化，

### 7、依恋情结

&#43; Feature Envy
&#43; 对象技术的全部要点在于：这是一种将数据和对数据的操作行为包装在一起的技术，有一中经典的气味是:函数对某个类的兴趣高于对自己所处类的兴趣。
&#43; 使用移动方法把某些方法移动带它该去的地方，有的时候还需要提炼方法
&#43; 如果某个函数需要需要几个类的功能，判断哪个类拥有最多被此函数使用的数据，然后就把这个函数和那些数据摆在一起，可以先将函数分解成多个较小函数分别置于不同地点。
&#43; 将总是一起变化的东西放在一块，数据和引用这些数据的行为总是一起变化的。
&#43; 策略和访问者模式可以轻松修改函数行为，付出了多一层的代价

### 8、数据泥团

&#43; Data Clumps
&#43; 数据项会成群结队出现。
&#43; 如果删除总舵数据中的一项，其他数据有没有失去意义，如果它们不再有意义，就是一个明确的信号，应该产生一个新对象。

### 9、基本类型偏执

&#43; Primitive Obsession
&#43; 结构类型允许你将数据组织成有意义的形式，对象的极大价值在于打破了横亘于基本数据和较大类之间的界限。
&#43; 积极的使用使用对象替换数据值，用类替换类型码，用状态/策略模式替代类型码

### 10、swithc惊悚现身

&#43; Switch Statements
&#43; 面向对象程序的最明显特征就是少用switch，使用switch的问题在于重复，在修改上，如果switch散布于不同地点，就要添加新的case子句
&#43; 如果看到switch语句的时候需要考虑用多态来替换它，问题在于多态出现在哪儿
&#43; 使用提炼函数将switch提炼到独立函数中，再用移动方法将它搬移到需要多态性的类中，用子类替代类型码或者使用state/strategy替代类型码，完成之后再用使用多态替代条件。

### 11、平行继承体系

&#43; Parallel Inheritance Hierarchies
&#43; 如果为某个类增加一个子类的时候必须要为另一类相应增加一个子类。
&#43; 如果某个继承体系的类名称前缀和两一个继承体系的类的名称前缀完全相同
&#43; 让一个继承体系的实例引用另一个继承体系的实例，再使用移动方法和字段，就可以将引用端的继承体系消除。

### 12、冗赘类

&#43; Lazy Class

&#43; 创建的每个类都有人去理解它维护它，如果一个类不值得其身价就应该消失。

### 13、夸夸其谈的未来性

&#43; Speculative Generality
&#43; 总有一天需要做这件事，企图以各式各样的勾子和特殊情况来处理一些非必要事情会造成程序难以理解。不需要

### 14、令人迷惑的暂时字段

&#43; Temporary Field
&#43; 某个实例变量仅为某种特定情况而设置。
&#43; 使用提炼类给这些孤儿创造一个家，然后把所有和这个变量相关的代码都放进这个新家，还可以使用空对象方法创建一个空对象。

### 15、过度耦合的消息链

&#43; Message Chains
&#43; 一个对象请求一个对象，然后后者请求另一个对象，等等
&#43; 使用隐藏委托。

### 16、中间人

&#43; Middle Man
&#43; 对象的基本特征之一就是封装，对外部世界隐藏内部细节，封装往往伴随着委托，但有可能过度使用委托，移除中间人

### 17、狎昵关系

&#43; Inappropriate Intimacy
&#43; 两个类过于亲密，移动方法和字段让他们划清界限。如果划清不了就使用提炼类让他们融为一体吧

### 18、异曲同工类

&#43; Alternative Classes with Different Interfaces
&#43; 重命名方法，提炼子类

### 19、不完美的库类

&#43; Incomplete Library Class
&#43; 给库类加入新的方法，外部方法和本地扩展。

### 20、纯稚的数据类

&#43; Data Class
&#43; 不会说话的数据容器一定被其他类过分的操控着，运用封装字段封装，移动设置方法，移动方法，提炼方法。

### 21、被拒绝的遗赠

&#43; Refused Bequest
&#43; 子类不愿全部继承，为这个子类创建一个兄弟类，在运用下移方法和字段把用不到的函数下推给那个兄弟，这样一来，超类就只持有所有子类共享的东西。
&#43; 用委托替换继承

### 22、过多注释

&#43; Comments
&#43; 提炼方法。


---

> 作者: [AndrewDu](https://github.com/DDuuuu)  
> URL: https://DDuuuu.github.io/2019/11/designpattern5-refactoring1/  

