# 重构改善既有代码 在对象之间搬移特性




在面向对象的设计中，决定把责任放在哪里。

先使用移动字段，在移动方法

### 1、搬移函数

&#43; Move  Method
  &#43; ![1572397619571](/designpattern/1572397619571.png)
&#43; 动机
  &#43; 一个类与另一个类高度耦合，就会搬移函数，通过这种手段，可以使得类更加简单。
&#43; 什么时候搬移
  &#43; 有个函数与其所属类之外的另一个类有更多的交流。
  &#43; 当不能肯定是否需要移动一个函数，需要继续观察其他函数，先移动其它函数就会使决定变得容易一些。
&#43; 怎么搬移
  &#43; 检查所有字段，属性和函数，考虑是否应该被搬移
  &#43; 在该函数最常用引用中建立一个有类似行为的新函数
  &#43; 将旧函数变成一个单纯的委托函数，或是将旧函数完全移除。
  &#43; 有多个函数使用这个需要搬移的特性，应考虑使用该特性的所有函数被一起搬移。
  &#43; 检查所有子类和超类，看看是否有该函数其他声明
  &#43; 如果目标函数使用了源类中的特性，可以将**源对象的引用**当作参数（多个参数或则存在方法需要调用），传给新建立的目标函数。
  &#43; 如果目标函数需要太多源类特性，就得进一步重构，会将目标函数分解并将其中一部分移回源类。

### 2、搬移字段

&#43; Move Field
  &#43; ![1572397877822](/designpattern/1572397877822.png)
&#43; 动机
  &#43; 随着项目类的增加和扩充，有一些字段放在原来的类中已经不太合适
&#43; 什么时候搬移
  &#43; 某个字段在另一个类中被更多的用到
&#43; 怎么搬移
  &#43; 修改源字段的所有用户，令它们改用新字段
  &#43; 决定如何在源对象中引用目标对象，方法，新建字段引用
  &#43; 新类中自我封装SetValue, GetValue。

### 3、提炼类*？

&#43; Extract Class
  &#43; ![1572397904071](/designpattern/1572397904071.png)
&#43; 动机
  &#43; 将复合类的职责提炼出新的类
  &#43; 或者需要将类的子类化，分解原来的类
&#43; 什么时候提炼
  &#43; 某个类做了应该由两个类做的事
&#43; 怎么提炼
  &#43; 建立一个新类，将相关的字段和函数从旧类搬移到新类
  &#43; 有可能需要一个双向连接， 但是在真正需要它之前，不要建立从新类往旧类的连接，如果建立起双向连接，检查是否可以将它改为单向连接。

### 4、将类内联化

&#43; Inline Class
  &#43; ![1572400836706](/designpattern/1572400836706.png)
&#43; 动机
  &#43; 一个类不再承担足够责任，不再由单独存在的理由。
&#43; 什么时候内联
  &#43; 某个类没有做太多的事情
&#43; 怎么内联
  &#43; 将这个类是多有特性搬移到另一个类中，然后移除原类
  &#43; 修改所有源类引用点，改而引用目标类

### 5、隐藏“委托关系”

&#43; Hide Delegate

  &#43; 局限性是每当客户要使用受托类的新特性时，就必须在服务段添加一个简单委托函数，受托类的特性越来越多，这一过程会越来越痛苦。

    

  &#43; ![1572400926241](/designpattern/1572400926241.png)

  &#43; 简单委托关系![1572400978816](/designpattern/1572400978816.png)

&#43; 动机

  &#43; 封装意味着每个对象都应该尽可能少的了解系统的其他部分，
  &#43; 如果客户调用对象字段得到另一个对象，然后再调用后者的函数，那么客户就必须知道这一层关系。将委托关系隐藏起来不会波及客户。

&#43; 什么时候隐藏

  &#43; 客户通过一个委托类来调用另一个对象

&#43; 怎么隐藏

  &#43; 在服务类上建立客户所需的所有函数，用以隐藏委托关系
  &#43; ![1572253642885](/designpattern/1572253642885.png)
  &#43; manager=john.getDepartment().getManager();隐藏=&gt;manager=john.getManager();隐藏了调用关系。

### 6、移除中间人

&#43; Remove Middle Man
  &#43; 与隐藏委托关系相反
  &#43; ![1572401291820](/designpattern/1572401291820.png)
&#43; 动机
  &#43; 针对隐藏委托的局限性，当委托的方法越来越多时，服务类就完全变成一个中间人，此时应该让客户直接调用受托类。
&#43; 什么时候移除
  &#43; 某个类做了过多的简单委托动作
&#43; 怎么移除
  &#43; 让客户直接调用受托类

### 7、引入外加函数

&#43; Introduce Foreign Method
  &#43; ![1572401389300](/designpattern/1572401389300.png)
&#43; 动机
  &#43; 发现一个好用的工具类不能修改工具类，添加方法
  &#43; 但外加函数终归是权益之计，
&#43; 什么时候需要引入外加函数
  &#43; 需要为提供服务的类增加一个函数，但无法修改这个类。
&#43; 怎么引入
  &#43; 在客户类中建立一个函数，并以第一参数形式传入一个服务类实例

### 8、引入本地扩展

&#43; Introduce Local Extension
  &#43; ![1572401403718](/designpattern/1572401403718.png)
&#43; 动机
  &#43; 在不能修改的类中添加方法，方法的数量超过2个的时候外加函数难以控制，需要将函数组织到一起，通过两种标准对象技术：**子类化和包装**，子类化和包装叫做本地扩展。
  &#43; 在子类化和包装中优先选择子类，
  &#43; 使用包装会造成A=B，B不等于A的逻辑，子类等于包装类，包装类不等于子类
&#43; 什么时候引入
  &#43; 需要为服务类提供一些额外函数，但无法修改类。
&#43; 怎么引入
  &#43; 建立一个新类，使它包含这些额外函数，让这个扩展品成为源类的子类或包装类。
  &#43; 子类化方案，转型构造函数应该调用适当的超类构造函数
  &#43; 包装类方案，转型构造函数应该传入参数以实例变量的形式保存起来，用作接受委托的原对象。


---

> 作者: [AndrewDu](https://github.com/DDuuuu)  
> URL: https://DDuuuu.github.io/2019/11/designpattern7-refactoring3/  

