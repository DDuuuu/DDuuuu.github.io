# 重构改善既有代码 处理继承关系


### 1、字段上移

&#43; Pull Up Field
  &#43; ![1572577009547](/designpattern/1572577009547.png)
&#43; 动机
  &#43; 减少重复
&#43; 什么时候做
  &#43; 两个子类拥有相同的字段
&#43; 怎么做
  &#43; 将该字段移至超类

### 2、函数上移

&#43; Pull Up Method
  &#43; ![1572577175581](/designpattern/1572577175581.png)
&#43; 动机
  &#43; 滋生错误
  &#43; 避免重复
&#43; 什么时候做
  &#43; 有些函数在各个子类中产生完全相同的结果
&#43; 怎么做
  &#43; 将该函数移至超类
  &#43; 最烦的一点就是，被提升的函数可能会引用子类中出现的特性，如果被引用的是一个函数可以将这个函数一同提升至超类，或则在超类中建立一个抽象函数。
  &#43; 如果两个函数相似但不相同，可以先借助塑造模板函数。

### 3、构造函数本体上移

&#43; Pull Up Constructor Body
  &#43; ![1572577601688](/designpattern/1572577601688.png)
&#43; 引用
  &#43; 如果重构过程过于复杂，可以考虑使用工厂方法。
&#43; 什么时候做
  &#43; 在各个子类中拥有一些构造函数，它们的本体机会完全一致
&#43; 怎么做
  &#43; 在超类中新建一个构造函数，并在子类构造函数中调用它。

### 4、函数下移

&#43; Push Down Method
  &#43; ![1572577790347](/designpattern/1572577790347.png)
&#43; 动机
  &#43; 把某些行为从超类移动到特定的子类中。
&#43; 什么时候做
  &#43; 超类中某个函数只与部分子类有关
&#43; 怎么做
  &#43; 将这个函数移到相关的那些子类中
  &#43; 如果移动的函数需要使用超类中的某个字段，则需要将超类中的字段的开放protected.

### 5、字段下移

&#43; Push Down Field
  &#43; ![1572577916400](/designpattern/1572577916400.png)
&#43; 动机
&#43; 什么时候做
  &#43; 超类中的某个字段只被部分子类用到
&#43; 怎么做
  &#43; 将这个字段移到需要它的那些子类去

### 6、提炼子类*？

&#43; Extract Subclass
  &#43; ![1572578034339](/designpattern/1572578034339.png)
&#43; 动机
  &#43; 类中的某些行为只被一部分实例用到，其他实例不需要，有时候这些行为上的差异是通过类型码分区的，可以使用子类替换类型码，或则使用状态或策略模式替代类型码。
  &#43; 抽象类和抽象子类则是委托和继承之间的抉择
  &#43; 抽象子类会更加容易，但是一旦对象建立完成，无法再改变与类型相关的行为。
&#43; 什么时候做
  &#43; 类中的某些特性只被某些实例用到
&#43; 怎么做
  &#43; 新建一个子类，将上面所说的那一部分特性移到子类中
  &#43; 为源类定一个新的子类
  &#43; 为这个新的子类提供构造函数
    &#43; 让子类构造函数接受与超类构造函数相同的参数，并通过super调用超类的构造函数。
    &#43; 用工厂替换构造函数
  &#43; 找出调用结果超类构造函数的所有地点，新建子类
  &#43; 下移方法和字段

### 7、提炼超类*？

&#43; Extract Superclass

  &#43; ![1572578336169](/designpattern/1572578336169.png)

&#43; 动机

&#43; 什么时候做

  &#43; 两个类有相似特性

&#43; 怎么做

  &#43; 为这两个类建立一个超类，将相同特性移至超类。

&#43; 新建一个空白抽象类

  &#43; 上移字段和方法
    &#43; 先搬移字段
    &#43; 子类函数中有相同的签名，但函数体不同，可以抽象函数
    &#43; 如果方法中有相同算法，可以使用提炼算法，将其封装到同一个函数中。

  ### 8、提炼接口

  &#43; Extract Interface
    &#43; ![1572579063782](/designpattern/1572579063782.png)
  &#43; 动机
    &#43; 类之间彼此互用的方式有若干种，某一种客户只使用类责任区的一个特定子集。
    &#43; 某个类在不同环境下扮演截然不同的角色，使用接口就是一个好主意。
  &#43; 什么时候做
    &#43; 若干客户使用类接口中同一个子集，或者两个类的接口有部分相同
  &#43; 怎么做
    &#43; 将相同的子类提炼到一个独立接口中。

### 9、折叠继承关系

&#43; Collapse Hierarchy
  &#43; ![1572579987774](/designpattern/1572579987774.png)
&#43; 动机
&#43; 什么时候做
  &#43; 超类和子类之间无太大区别
&#43; 怎么做
  &#43; 将它们合为一体

### 10、塑造模板函数

&#43; Form Template Method
  &#43; ![1572580131316](/designpattern/1572580131316.png)
&#43; 动机
  &#43; 既避免重复也保持差异。
&#43; 什么时候做
  &#43; 有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同。
&#43; 怎么做
  &#43; 将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同的，然后将原函数上移至超类

### 11、以委托取代继承

&#43; Replace Inheritance with Delegation
  &#43; ![1572580380411](/designpattern/1572580380411.png)
&#43; 动机
  &#43; 超类中有许多操作并不真正适用于子类，这种情况下，你所拥有的接口并未真正反映出子类的功能。
&#43; 什么时候做
  &#43; 某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据
&#43; 怎么做
  &#43; 在子类中新建一个字段用以保存超类，调整子类函数，令它改而委托超类，然后去掉两者之间的继承关系。
  &#43; 在子类中新建一个字段，使其引用超类的实例
  &#43; 修改子类中的所有函数，让它们不再使用超类，转而使用上述那个受托字段。

### 12、以继承取代委托

&#43; Replace Delegation with Inheritance
  &#43; ![1572583811463](/designpattern/1572583811463.png)
&#43; 动机
  &#43; 如果并没有使用受托类的所有函数，就不应该使用用继承替换委托，
  &#43; 可以使用去除中间层的方法让客户端自己调用受托函数。
&#43; 什么时候做
  &#43; 在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数。
&#43; 怎么做


---

> 作者: [AndrewDu](https://github.com/DDuuuu)  
> URL: https://DDuuuu.github.io/2019/11/designpattern11-refactoring7/  

