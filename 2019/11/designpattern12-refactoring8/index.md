# 重构改善既有代码 大型重构


## 大型重构

### 1、梳理并分解继承体系

&#43; Tease Apart Inheritance
  &#43; 就是让每个类的职责更明确更单一，当一个类的职责混乱时，通过绘制职责图来分离职责，并创建另一个超类，将相关的字段和方法都移动到另一个超类
  &#43; ![1572653896760](/designpattern/1572653896760.png)
&#43; 动机
  &#43; 混乱的继承体系是一个严重的问题，会导致重复代码，而后者正是程序员生涯的致命毒药。还会使修改变得困难，因为特定问题的解决决策被坟山到了整个继承体系。
&#43; 什么时候做
  &#43; 某个继承体系同时承担两项责任
&#43; 怎么做
  &#43; 建立两个继承体系，并通过委托关系让其中一个可以调用另一个
  &#43; 首先识别出继承体系所承担的不同责任，然后建立一个二维表格（或则三位乃至四维表格），并以坐标轴标示不同的任务，
  &#43; 判断哪一项责任更重一些，并准备将它留在当前的继承体系中，准备将另一项责任移到另一个继承体系中。
  &#43; 使用抽象类方法从当前的超类提炼出一个新类，用以表示重要性稍低的责任，并在原超类中添加一个实例变量，用以保存新类的实例。
  &#43; 对应于原继承体系中的每个子类，创建上述新类的一个子类，在原继承体系的子类中，将前一步骤所添加的实例变量初始化为新建子类的实例。
  &#43; 针对原继承体系中的每个子类，使用搬移函数的方法迁移到与之对应的子类中。
  &#43; ![1572658453762](/designpattern/1572658453762.png)
  &#43; ![1572658467189](/designpattern/1572658467189.png)
  &#43; ![1572658478819](/designpattern/1572658478819.png)
  &#43; ![1572658495471](/designpattern/1572658495471.png)
  &#43; ![1572658514062](/designpattern/1572658514062.png)

### 2、将过程化设计转化为对象设计

&#43; Convert Procedural Design to Objects
  &#43; ![1572659942645](/designpattern/1572659942645.png)
&#43; 动机
&#43; 什么时候做
  &#43; 有一些传统过程化风格的代码
&#43; 怎么做
  &#43; 将数据记录变成对象，将大块的行为分为小块，并将行为移入相关对象之中。
  &#43; 针对每一个记录类型，将其转变为只含访问函数的哑数据对象
  &#43; 针对每一处过程化风格，将该出的代码提炼到一个独立类中。
  &#43; 针对每一段长长的程序，试试提炼方法将长方法分解并将分解后的方法移动到相关的哑数据类。

### 3、将领域和表诉/显示分离

&#43; Separate Domain from Presentation

  &#43; ![1572660551940](/designpattern/1572660551940.png)

&#43; 动机

  &#43; MVC模式最核心的价值在于，它将用户界面代码（即视图：亦即现今常说的展现层）和领域逻辑（即模型）分离了，展现类只含用以处理用户界面的逻辑：领域类包含任何与程序外观相关的代码，只含业务逻辑相关代码，将程序中这两块复杂的部分加以分离，程序未来的修改将变得更加容易，同时也使用同意业务逻辑的多种展现方式称为可能。

&#43; 什么时候做

  &#43; 某些GUI类中包含了领域逻辑

&#43; 怎么做

  &#43; 将领域逻辑分离出来，为它们建立独立的邻域类。

  &#43; 为每个窗口建立一个领域类，

  &#43; 如果窗口内含有一张表格，新建一个类来表示其中的行，再以窗口所对应之领域类中的一个集合来容纳所有行领域对象

  &#43; 检查窗口中的数据，如果数据只被用于UI，就把它留着，如果数据被领域逻辑使用，而且不显示与窗口上，我们就可以使用移动方法将它搬移到领域类中，如果数据同时被UI和领域逻辑使用，就对它实施复制被监视数据，使它同时存在于两处，并保持两处之间的同步。

  &#43; 展现类中的逻辑，实施提炼方法将展现逻辑从邻域逻辑中分开，一旦隔离了邻域逻辑，在运用搬移方法将它移到邻域类。

  &#43; ![1572661870682](/designpattern/1572661870682.png)

  &#43; ![1572661971112](/designpattern/1572661971112.png)

    

### 4、提炼继承体系

&#43; Extract Hierarchy
  &#43; ![1572662102757](/designpattern/1572662102757.png)
&#43; 动机
  &#43; 一开始设计者只想以一个类实现一个概念，但随着设计方案的演化，最后可能一个类实现两个三乃至十个不同的概念。
&#43; 什么时候做
  &#43; 有某个类做了太多的工作，其中一部分工作是以大量条件表达式完成的
&#43; 怎么做
  &#43; 建立继承体系，以一个子类表示一种特殊情况。
  &#43; 有两种重构的手法
    &#43; 无法确定哪些地方会发生变化
  &#43; 不确定哪些地方会发生变化
    &#43; 鉴别出一中变化情况，
      &#43; 如果这种拜年话可能在对象声明周期的不同阶段而有不同体现就用提炼方法将它提炼为一个独立的类
    &#43; 针对这种变化情况，新建一个子类，并对原始类实施工厂方法替代构造函数，再次修改工厂方法，令它返回适当的子类实例。
    &#43; 将含有条件逻辑的函数，一个个复制到子类
      &#43; 有必要隔离函数中的条件逻辑和非条件逻辑。
    &#43; 删除超类中那些被所有子类覆写的函数本体，并将它们声明为抽象函数。
  &#43; 确定原始类中每一种变化
    &#43; 针对原始类中每一种变化情况，建立一个子类，
    &#43; 使用工厂方法替代构造函数将原始类的构造函数转变成工厂函数，并令它针对每一种变化情况返回适当的子类实例。
      &#43; 如果原始类中的各种变化情况是以类型码标示，使用子类替换类型码，如果那些变化情况在对象周期的不同阶段会有不同体现，使用状态和策略模式替换类型码
    &#43; 针对带有条件逻辑的函数，实施用多态替换条件如果非整个函数的行为有所变化，请先运行提炼方法将变化部分和不变部分分隔开来

## 8 案例

&#43; 有一个影片商店客户端，需要计算每一个客户的消费，常客积分
&#43; 客户customer
&#43; 租赁rental
&#43; 影片movie，普通Regular，儿童Children，新片Release
  &#43; Regular:2天内2元，大于2天1.5一天
  &#43; Release:每天三元
  &#43; Childrens:3天内1.5元，大于3天1.5一天
&#43; 计费函数![1573259169717](/designpattern/1573259169717.png)

### **提炼方法**

这个计费函数太复杂

1. ![1573259228808](/designpattern/1573259228808.png)
2. ![1573259287998](/designpattern/1573259287998.png)
3. 修改参数名![1573259324947](/designpattern/1573259324947.png)

搬移方法

1. amountfor没有使用customer任何信息，只是使用了rental类的，将其搬移到rental类中
2. ![1573259534803](/designpattern/1573259534803.png)
3. 修改原customer中函数调用
4. ![1573259672194](/designpattern/1573259672194.png)

### 用查询替换临时变量

1. ![1573259727949](/designpattern/1573259727949.png)
2. 用同样的方法来处理计算常客积分的部分
3. ![1573259779713](/designpattern/1573259779713.png)
4. ![1573259796208](/designpattern/1573259796208.png)

### 使用多态替换Switch

1. 原来的switch,在rental类中
   1. ![1573259960856](/designpattern/1573259960856.png)
   2. **不要再另一个对象属性上使用switch**，将其移动到方法中
   3. 移动过后![1573260126077](/designpattern/1573260126077.png)
   4. 常客积分![1573260159422](/designpattern/1573260159422.png)
   5. 继承机制![1573260256295](/designpattern/1573260256295.png)
   6. 一个影片可以再生命周期内修改自己的分类，一个对象却不能再生命周期内修改自己所属的类，这里需要使用用状态或策略模式替换type，搬移方法到超类，用多态替换条件
   7. ![1573260377382](/designpattern/1573260377382.png)
   8. ![1573260501787](/designpattern/1573260501787.png)
   9. 提炼超类![1573260529472](/designpattern/1573260529472.png)
   10. ![1573260687072](/designpattern/1573260687072.png)
   11. 修改原来movie中的getcharge方法，
       1. 首先getcharge移动方法![1573260840828](/designpattern/1573260840828.png)
       2. 用多态替换getcharge方法
       3. ![1573260958502](/designpattern/1573260958502.png)
       4. ![1573260975738](/designpattern/1573260975738.png)
       5. ![1573261195865](/designpattern/1573261195865.png)
       6. ![1573261209260](/designpattern/1573261209260.png)





---

> 作者: [AndrewDu](https://github.com/DDuuuu)  
> URL: https://DDuuuu.github.io/2019/11/designpattern12-refactoring8/  

