# 重构改善既有代码 重新组织数据


**对于这个类的任何修改都应该通过该类的方法。类拥有一些数据却无所觉，拥有一些依赖无所觉是非常危险的。**所以才要封装字段，封装集合，监视数据，用对象替代数组，用对象替代集合，关联改动。

### 1、自封装字段

&#43; Self Encapsulate 
  &#43; ![1572401773280](/designpattern/1572401773280.png)
&#43; 动机
  &#43; 直接访问变量的好处：**子类可以通过覆写一个函数而改变获取数据的途径**，它还支持更灵活的数据管理方式，如延迟初始化等，
  &#43; 直接访问变量的好处：代码比较容易阅读，
  &#43; 优先选择直接访问的方式，直到这种访问方式带来麻烦位置。
&#43; 什么时候需要自封装字段
  &#43; 直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。
&#43; 怎么自封装
  &#43; 为这个字段建立取值/设值函数，并且只以这些函数来访问字段。

### 2、以对象取代数据值

&#43; Replace Data Value with Object
  &#43; ![1572402017495](/designpattern/1572402017495.png)
&#43; 动机
  &#43; 简单数据不再简单，
  &#43; 注意：**原来的数据值是值对象，改成对象可能变成引用类型**，这样面临的问题是多个实例就不是同一个对象。需要用将引用对象改成值对象方法，
&#43; 什么时候需要对象取代
  &#43; 有一个数据项，需要与其他数据和行为一起使用才有意义。
&#43; 怎么对象取代
  &#43; 为替换值新建一个新类，其中声明final字段，修改原字段的引用，都修改为对象。

### 3、将值对象改成引用对象

&#43; Change Value to Reference
  &#43; 对于值类型来说，equals和==的功能是相等的都是比较变量的值、
  &#43; **对于引用类型来说，==是b比较两个引用是否相等，equals是比较的引用类型的内容是否相等，而使用equals是需要重写的，不然就是调用object中的equals**
  &#43; ![1572402839811](/designpattern/1572402839811.png)
&#43; 动机
  &#43; 值对象一般是基本数据类型，并不在意是否有副本的存在，
  &#43; 引用对象是否相等，直接使用==操作符
&#43; 什么时候改引用
  &#43; **一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象**
  &#43; 类的**每个实例中的字段都是独立，就是值类型**，每个实例都对应一个字段对象。
  &#43; 引用类型多个实例可以共用一个字段对象。**不是所有**
&#43; 怎么改
  &#43; 创建简单工厂和注册表，工厂负责生产字段对象，注册表负责保存所有的字段对象
  &#43; 类实例通过工厂请求字段实例，工厂通过访问注册表返回字段实例引用。
&#43; 例子
  &#43; ![1572403867513](/designpattern/1572403867513.png)
  &#43; ![1572403915291](/designpattern/1572403915291.png)
  &#43; ​    ![1572403943801](/designpattern/1572403943801.png)
  &#43; **目前为止customer对象还是值对象，即使多个订单属于同一客户但每个order对象还是拥有自己的customer对象。**
  &#43; 使用工厂方法替代构造函数![1572404251004](/designpattern/1572404251004.png)
  &#43; ![1572404268577](/designpattern/1572404268577.png)
  &#43; ![1572404275823](/designpattern/1572404275823.png)
  &#43; 此时值对象才变成引用对象，多个实例间都共享同一个引用对象

### 4、将引用对象改成值对象

&#43; Change Reference to value
  &#43; 这边引用对象改成值对象并不是说需要把引用类型改成基本类型，而是即使引用类型是不同副本，那么相同内容的引用内容也是相等（重写Equals()）
  &#43; ![1572404484481](/designpattern/1572404484481.png)
&#43; 动机
  &#43; 如果引用对象开始变得难以使用，或许就应该将它改成值对象。
  &#43; 引用对象必须被某种方式控制，而且必须向其控制者请求适当的引用对象，**会造成区域之间错综复杂的关联。**
  &#43; 值对象应该是不可变的（无论何时，调用同一个对象的同一个查询函数都应该得到相同的结果），**如果需要改变就需要重新创建一个所属类的实例，而不是在现有对象上修改。**
&#43; 什么时候更改
  &#43; 有一个引用对象，很小且不可变，而且不易管理。
&#43; 怎么更改
  &#43; 检查重构目标是否为不可变对象，建立equals和hashcode方法
  &#43; new Currency(&#34;USD&#34;).equals(new Currency(&#34;USD&#34;))；返回false。重写equal和hashcode使其返回true，这样对象就是值对象，不可变。

### 5、以对象取代数组

&#43; Replace Array with Object
  &#43; ![1572405339305](/designpattern/1572405339305.png)
&#43; 动机
  &#43; 数组是常见的组织数据的结构，只用于以某种顺序容纳一组相似对象。
&#43; 什么时候需要取代
  &#43; 有一个数组，其中的元素各自代表不同的东西
&#43; 怎么取代
  &#43; 将数组的每个不同意思都抽象称字段

### 6、复制被监视的数据

&#43; Duplicate Observed Data
  &#43; ![1572405469613](/designpattern/1572405469613.png)
&#43; 动机
  &#43; 一个分层良好的系统，用户界面和处理业务逻辑的代码分开
  &#43; MVC模式
&#43; 什么时候需要复制
  &#43; 有一些领域数据置身于GUI控件中，而邻域函数需要访问这些数据
&#43; 怎么复制
  &#43; 将该数据复制到一个领域对象中，建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据

### 7、将单向关联改成双向关联

&#43; Change Unidirectional Association to Bidirectional

  &#43; 有点像观察者模式，控制者是订阅端，被控制者是主题，主题存在辅助函数，用于修改反向指针，订阅端调用辅助函数来修改反向指针。
  &#43; ![1572405656193](/designpattern/1572405656193.png)

&#43; 动机

  &#43; 随着项目时间的推移需要双向关联

&#43; 什么时候改动

  &#43; 两个类都需要使用对方特性，但其间中有一条单向连接

&#43; 怎么实现

  &#43; 添加一个反向指针，并使修改函数能够同时更新两条连接。

  &#43; 在被引用的类中增加一个字段，保存反向指针。

  &#43; 控制端和被控制端

    &#43; 一对多的关系，可以使用**单一引用的一方(就是多的那一方)**承担控制者的角色。
    &#43; 对象是组成另一对象的部件，**该部件负责控制关联关系**。
    &#43; 如果两者都是引用对象，多对多，那么无所谓。

  &#43; 在**被控端**建立一个**辅助函数**，**负责修改反向指针**

  &#43; 如果既有的修改函数在控制端，让它负责控制修改反向指针

  &#43; 如果既有的修改函数在被控端，就在控制端建立一个控制函数，并让既有的修改函数调用这个新建的控制函数，来控制修改反向指针。

    

### 8、将双向关联改为单向关联

&#43; Change Bidirectional Association to Unidirectional
  &#43; ![1572406648238](/designpattern/1572406648238.png)
&#43; 动机
  &#43; 双向关联必须要符出代价，维护双向关联，确保对象被正确创建和删除而增加的复杂度。
  &#43; 双向关联还会造成僵尸对象，某个对象已经死亡却保留在系统中，因为它的引用还没有完全清楚。
  &#43; 双向关联也会迫使**两个类之间有了依赖**，对其中任一个类的修改，都可能引发另一个类的变化。
&#43; 什么时候需要
  &#43; 两个类之间有双向关联，但其中一个类不再需要另一个的特性
&#43; 怎么修改
  &#43; 去除不必要的关联
  &#43; 将私有字段去掉，需要依赖的函数，将依赖类作为参数传入，然后调用。
  &#43; 创建一个静态字典保存所有的依赖类，通过取值函数来获得字段遍历对比依赖的引用是否相同来获取依赖类。

### 9、以字面常量取代魔法数

&#43; Replace Magic Number with Symbolic Constant
  &#43; ![1572406815589](/designpattern/1572406815589.png)
&#43; 动机
&#43; 什么时候取代
  &#43; 有一个字面数值，并带有特别含义
&#43; 怎么取代
  &#43; 创造一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量。

### 10、封装字段

&#43; Encapsulate Field
  &#43; ![1572406832493](/designpattern/1572406832493.png)
&#43; 动机
  &#43; 数据声明为public被看做一种不好的做法，会降低模块化程度。
  &#43; 拥有该数据对象却毫无察觉，不是一件好事
&#43; 什么时候封装
  &#43; 类中存在一个public字段
&#43; 怎么封装
  &#43; 将原字段声明为private，并提供相应的访问函数

### 11、封装集合

&#43; Encapsulate Collection
  &#43; **除非通过封装的集合类，不然没有任何实例能够修改这个集合。**
  &#43; ![1572406851542](/designpattern/1572406851542.png)
&#43; 动机
  &#43; 在一个类中使用集合并将集合给取值函数，但类不应该返回集合自身，因为这回让用户得以修改集合内容而对集合的使用者一无所知。
  &#43; 不应该为集合提供一个设值函数，但应该为集合添加/移除元素的函数，这样集合的拥有者就可以控制集合元素的添加和移除。
&#43; 什么时候封装
  &#43; 有一个函数返回一个集合
&#43; 怎么封装
  &#43; 让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数

### 12、以数据类取代记录

&#43; Replace Record with Data Class
&#43; 动机
  &#43; 从数据库读取的记录，需要一个接口类，用来处理这些外来数据。
&#43; 什么时候做
  &#43; 需要面对传统编程环境中的记录结构
&#43; 怎么做
  &#43; 为该记录创建一个哑数据对象。
  &#43; 新建一个类，对于记录汇总的每一项数据，在新建的类中建立一个对应的private字段，并提供相应的取值和设值函数。

### 13、以类取代类型码

&#43; Replace Type Code with Class
  &#43; 原来的类型码可能是int类型，建立一个类型码的类，所有的int转换成类型码的类，其实有点像创建一个枚举类型，然后用枚举类型取代int。
  &#43; ![1572411176016](/designpattern/1572411176016.png)
&#43; 动机
  &#43; 类型码或枚举值很常见，但终究只是一个数值，如果是一个类就会进行类型检验，还可以为这个类提供工厂函数，保证只有合法的实例才会被创建出来。
  &#43; 如果有switch必须使用类型码，但任何switch都应该使用多态取代条件去掉。为了进行这样的重构还需要使用子类取代类型码，用状态或策略替换类型码。
&#43; 什么时候做
  &#43; 类之中有一个数值类型码，但它并不影响类的行为
&#43; 怎么做
  &#43; 以一个新的类替换该数值类型码
  &#43; 用以**记录类型码的字段**，其类型应该和类型码相同，还应该有**对应的取值函数**，还应该用一组**静态变量保存允许被创建的实例**，并以一个静态函数根据原本的类型码返回合适的实例。

### 14、以子类取代类型码

&#43; Replace Type Code with Subclasses
  &#43; ![1572486570053](/designpattern/1572486570053.png)
&#43; 动机
&#43; 什么时候做
  &#43; 有一个不可变的类型码，它会影响类的行为
  &#43; 如果类型码会影响宿主类的行为，最好的做好就是用多态来处理变化行为。就是switch和if else结构。
  &#43; 类型码值在对象船舰之后发生变化，类型码宿主类已经拥有子类，这两种情况下就需要使用状态/策略设计模式
&#43; 怎么做
  &#43; 以子类取代这个类型码

### 15、以State/Strategy取代类型码

&#43; Replace Type Code with State/Strategy
  &#43; 每个状态有特定的数据和动作。
  &#43; ![1572486550695](/designpattern/1572486550695.png)
&#43; 动机
&#43; 什么时候做
  &#43; 有一个类型码，它会影响类的行为，但无法通过继承手法消除它
&#43; 怎么做

### 16、以字段取代子类

&#43; Replace Subclass with Fields
  &#43; ![1572486531862](/designpattern/1572486531862.png)
&#43; 动机
&#43; 什么时候做
  &#43; 各个子类的唯一差别只在返回常量数据的函数身上
  &#43; 直接用该字段的不同值表示子类就可以了。
&#43; 怎么做
  &#43; 修改这些函数，使它们返回超类中某个(新增字段，然后销毁子类)


---

> 作者: [AndrewDu](https://github.com/DDuuuu)  
> URL: https://DDuuuu.github.io/2019/11/designpattern8-refactoring4/  

