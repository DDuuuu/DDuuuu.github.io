[{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 读写文件是应用中必不可少的操作，也是比较经典的问题。该问题一般要求： 允许多个读者对文件执行读操作。 只允许一个写者往文件中写信息。 任一写者写完前不允许其他读者或写者工作。 写者执行写操作前应让已有读者和写者全部退出。 实现要求的逻辑代码: //声明 Semaphore rwlock=1;//读写锁 int rcount=0;//读者数量 Semaphore countlock=1;//读者数量锁 Semaphore firstwlock=1;//写优先锁 //写逻辑 Write() { while(1) { firstwlock.WaitOne(); rwlock.WaitOne(); //Todo:写文件 rwlock.Set(); firstwlock.Set(); } } //读逻辑 Reader() { while(1) { firstwlock.WaitOne(); countlock.WaitOne(); if(rcount==0) rwlock.WaitOne(); rcount++; countlock.Set(); firstwlock.Set(); //Todo:读文件 countlock.WaitOne(); rcount--; if(rcount==0) rwlock.Set(); countlock.Set(); } } 下面看一下TouchSocket文件池解析: 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-12","objectID":"/2022/09/touchsocket4-filepool/:1:0","tags":["TouchSocket0.3.5","文件池"],"title":"TouchSocket 文件池","uri":"/2022/09/touchsocket4-filepool/"},{"categories":"TouchSocket0.3.5","content":"文件池FilePool\r池的作用是复用文件池中对于大文件缓存了文件句柄，对于小文件缓存了文件内容。这样多次对文件的操作就不需要频繁创建和销毁文件句柄。提高文件操作性能。 对于缓存元数据的封装为FileStorage，也是真正对文件操作的实现类。FilePool保存其字典进行复用。 为了便于对FileStorage的操作，将读写操作封装成FileStorageReader和FileStorageWriter 在写入文件时为了保存的实时写入状态，封装了TouchRpcFileStream，并将状态信息封装成TouchRpcFileInfo。 FilePool和FileStorage类中相关操作全部加锁以保证线程安全，并通过原子操作保证FileStorage引用数量 相关类图： 读写模式的互斥通过状态保证: /// \u003csummary\u003e /// 加载文件为读取流 /// \u003c/summary\u003e /// \u003cparam name=\"path\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static void LoadFileForRead(string path) { lock (m_locker) { if (string.IsNullOrEmpty(path)) { throw new System.ArgumentException($\"“{nameof(path)}”不能为 null 或空。\", nameof(path)); } path = Path.GetFullPath(path); if (pathStream.TryGetValue(path, out FileStorage storage)) { if (storage.Access != FileAccess.Read) { throw new Exception(\"该路径的文件已经被加载为写入模式。\"); } return; } if (FileStorage.TryCreateFileStorage(path, FileAccess.Read, out FileStorage fileStorage, out string msg)) { pathStream.TryAdd(path, fileStorage); } else { throw new Exception(msg); } } } 读写操作： /// \u003csummary\u003e /// 从指定位置，读取数据到缓存区。线程安全。 /// \u003c/summary\u003e /// \u003cparam name=\"stratPos\"\u003e\u003c/param\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"length\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public int Read(long stratPos, byte[] buffer, int offset, int length) { using (WriteLock writeLock = new WriteLock(this.m_lockSlim)) { if (this.m_disposedValue) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_fileAccess != FileAccess.Read) { throw new Exception(\"该流不允许读取。\"); } if (this.m_cache) { int r = (int)Math.Min(this.m_fileData.Length - stratPos, length); Array.Copy(this.m_fileData, stratPos, buffer, offset, r); return r; } else { this.m_fileStream.Position = stratPos; return this.m_fileStream.Read(buffer, offset, length); } } } /// \u003csummary\u003e /// 从指定位置，写入数据到存储区。线程安全。 /// \u003c/summary\u003e /// \u003cparam name=\"stratPos\"\u003e\u003c/param\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"length\"\u003e\u003c/param\u003e public void Write(long stratPos, byte[] buffer, int offset, int length) { using (WriteLock writeLock = new WriteLock(this.m_lockSlim)) { if (this.m_disposedValue) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_fileAccess != FileAccess.Write) { throw new Exception(\"该流不允许写入。\"); } this.m_fileStream.Position = stratPos; this.m_fileStream.Write(buffer, offset, length); this.m_fileStream.Flush(); } } ","date":"2022-09-12","objectID":"/2022/09/touchsocket4-filepool/:2:0","tags":["TouchSocket0.3.5","文件池"],"title":"TouchSocket 文件池","uri":"/2022/09/touchsocket4-filepool/"},{"categories":"TouchSocket0.3.5","content":"总结\r讲述了经典的读写问题，介绍了TouchSocket中FilePool的封装，该封装并不复杂，但我觉得一个简单且功能强大的设计才是一个优秀的设计。 ","date":"2022-09-12","objectID":"/2022/09/touchsocket4-filepool/:3:0","tags":["TouchSocket0.3.5","文件池"],"title":"TouchSocket 文件池","uri":"/2022/09/touchsocket4-filepool/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 池是高性能组件中必不可少的东西，池最主要的功能是复用，在软件中创建和销毁对象是有成本的，消耗的资源也特别多。在需要大量使用相同或相似对象的场景下使用池，需要使用对象时去池中取，用完之后再放回到池中，避免创建和销毁对象，从而提高软件的性能。 池在设计时要注意以下几点： 池中对象的存储尽量利用高速缓冲区，这样可以更快速访问对象。 池中对象可以用原型模式加以改造。 池中对象的使用需要注意内存泄漏问题。因为对象使用完并没有销毁。 TouchSocket用到很多的池，字节池 (BytePool)、等待处理池(WaitHandlePool)、文件池(FilePool)、对象池(ObjectPool)，本文介绍字节池和等待处理池 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:1:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"字节池BytePool\r字节数组的复用是非常常见的做法，在高速IO中一定可以看见它的身影，微软对其也进行了各种封装。 TouchSocket字节池保存所有创建的字节数组，并根据数组的长度将其放在字典中等待复用，相同长度的数组通过队列进行缓存，最终字节此的样子 private static readonly ConcurrentDictionary\u003clong, BytesQueue\u003e bytesDictionary = new ConcurrentDictionary\u003clong, BytesQueue\u003e(); long:表示数组长度 BytesQueue:表示该长度数组队列。内部就是private readonly ConcurrentQueue\u003cbyte[]\u003e bytesQueue = new ConcurrentQueue\u003cbyte[]\u003e(); 字节池并没有直接对外暴露字节数组，而是将其封装成ByteBlock，字节数组的装饰对象：ByteBlock，内部使用字节数组实现功能，并装饰Stream的对象。 写入数据可以自动扩容，扩容基数1.5倍。 m_needDis控制Dispose时字节数组是否返回给池中 /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e /// \u003cparam name=\"byteSize\"\u003e默认64K\u003c/param\u003e /// \u003cparam name=\"equalSize\"\u003e默认false\u003c/param\u003e public ByteBlock(int byteSize = 1024 * 64, bool equalSize = false) { this.m_needDis = true; this.m_buffer = BytePool.GetByteCore(byteSize, equalSize); this.m_using = true; } /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e /// \u003cparam name=\"bytes\"\u003e\u003c/param\u003e public ByteBlock(byte[] bytes) { this.m_buffer = bytes ?? throw new ArgumentNullException(nameof(bytes)); this.m_length = bytes.Length; this.m_using = true; } /// \u003csummary\u003e /// 扩容增长比，默认为1.5， /// min：1.5 /// \u003c/summary\u003e public static float Ratio { get =\u003e m_ratio; set { if (value \u003c 1.5) { value = 1.5f; } m_ratio = value; } } /// \u003csummary\u003e /// 读取数据，然后递增Pos /// \u003c/summary\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"length\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e /// \u003cexception cref=\"ObjectDisposedException\"\u003e\u003c/exception\u003e public override int Read(byte[] buffer, int offset, int length) { if (!this.m_using) { throw new ObjectDisposedException(this.GetType().FullName); } int len = this.m_length - this.m_position \u003e length ? length : this.CanReadLen; Array.Copy(this.m_buffer, this.m_position, buffer, offset, len); this.m_position += len; return len; } /// \u003csummary\u003e /// 写入 /// \u003c/summary\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"count\"\u003e\u003c/param\u003e /// \u003cexception cref=\"ObjectDisposedException\"\u003e\u003c/exception\u003e public override void Write(byte[] buffer, int offset, int count) { if (count == 0) { return; } if (!this.m_using) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_buffer.Length - this.m_position \u003c count) { int need = this.m_buffer.Length + count - ((int)(this.m_buffer.Length - this.m_position)); int lend = this.m_buffer.Length; while (need \u003e lend) { lend = (int)(lend * m_ratio); } this.SetCapacity(lend, true); } Array.Copy(buffer, offset, this.m_buffer, this.m_position, count); this.m_position += count; this.m_length = Math.Max(this.m_position, this.m_length); } /// \u003csummary\u003e /// 重新设置容量 /// \u003c/summary\u003e /// \u003cparam name=\"size\"\u003e新尺寸\u003c/param\u003e /// \u003cparam name=\"retainedData\"\u003e是否保留元数据\u003c/param\u003e /// \u003cexception cref=\"ObjectDisposedException\"\u003e\u003c/exception\u003e public void SetCapacity(int size, bool retainedData = false) { if (!this.m_using) { throw new ObjectDisposedException(this.GetType().FullName); } byte[] bytes = new byte[size]; if (retainedData) { Array.Copy(this.m_buffer, 0, bytes, 0, this.m_buffer.Length); } BytePool.Recycle(this.m_buffer); this.m_buffer = bytes; } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"disposing\"\u003e\u003c/param\u003e protected sealed override void Dispose(bool disposing) { if (this.m_holding) { return; } if (this.m_needDis) { if (Interlocked.Decrement(ref this.m_dis) == 0) { GC.SuppressFinalize(this); BytePool.Recycle(this.m_buffer); this.Dis(); } } base.Dispose(disposing); } 该字节池具有如下特性 每隔1小时自动清理所有缓存的字节数组 最大缓存的不同字节数组的数量为100 回收的数组可以设置是否清零 缓存的最大字节数512M 缓存字节数组的范围1KB~20M 自动清理功能，每1个小时会自动清理池中所有的字节数组 static BytePool() { m_timer = new Timer((o) =\u003e { BytePool.Clear(); }, null, 1000 * 60 * 60, 1000 * 60 * 60);//1小时 m_keyCapacity = 100; m_autoZero = false; m_maxSize = 1024 * 1024 * 512;//512M SetBlockSize(1024, 1024 * 1024 * 20);//1KB~ 20M AddSizeKey(10240);//10KB } /// \u003csummary\u003e /// 清理 /// \u003c/summary\u003e public static void Clear() { bytesDictionary.Clear(); GC.Collect(); } /// \u003csummary\u003e /// 获取内存核心。获取的核心可以不用归还。 /// \u003c/summary\u003e /// \u003cparam name=\"byteSize\"\u003e\u003c/param\u003e /// \u003cparam na","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:2:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"等待处理池WaitHandlePool\u003cT\u003e\r该池的主要是为了复用WaitData\u003cT\u003e对象，该对象的功能是：交由外部系统处理对象并返回数据。当给外部系统发送命令，等待外部系统执行命令，并在规定时间内返回数据。 该功能的传统实现方式是： 创建命令队列，将所有已发送外部系统的命令装进命令队列中，同时记录命令的发送时间； 当外部系统返回数据时，去队列中找到对应的命令执行命令成功的方法；如果命令队列中没有对应的命令，调用未知数据处理方法； 设置定时器定期扫描命令队列，将超期没有接收到返回数据的命令移除，并调用对应命令异常执行方法； 该池的实现方式是构造WaitData\u003cT\u003e对象集合，发送命令前构建WaitData对象，发送完命令后该对象使用信号量阻塞发送命令的线程，当收到返回数据时，信号量置位继续执行，处理对应接收数据；信号量阻塞的时候可以设置阻塞时间，时间到则执行对应异常方法。 由于WaitData对象需要构建信号量，创建和销毁的代价比较大。WaitHandlePool构建 ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e waitQueue;队列保存空闲WaitData。 ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e waitQueue;保存所有已经使用WaitData。 /// \u003csummary\u003e /// 等待数据对象 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public class WaitData\u003cT\u003e : DisposableObject { private WaitDataStatus m_status; private readonly AutoResetEvent m_waitHandle; private T m_waitResult; /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e public WaitData() { this.m_waitHandle = new AutoResetEvent(false); } /// \u003csummary\u003e /// 状态 /// \u003c/summary\u003e public WaitDataStatus Status =\u003e this.m_status; /// \u003csummary\u003e /// 等待数据结果 /// \u003c/summary\u003e public T WaitResult =\u003e this.m_waitResult; /// \u003csummary\u003e /// 取消任务 /// \u003c/summary\u003e public void Cancel() { this.m_status = WaitDataStatus.Canceled; this.m_waitHandle.Set(); } /// \u003csummary\u003e /// 释放 /// \u003c/summary\u003e /// \u003cparam name=\"disposing\"\u003e\u003c/param\u003e protected override void Dispose(bool disposing) { this.m_status = WaitDataStatus.Disposed; this.m_waitResult = default; this.m_waitHandle.Dispose(); base.Dispose(disposing); } /// \u003csummary\u003e /// Reset。 /// 设置\u003csee cref=\"WaitResult\"/\u003e为null。然后重置状态为\u003csee cref=\"WaitDataStatus.Default\"/\u003e，waitHandle.Reset() /// \u003c/summary\u003e public bool Reset() { this.m_status = WaitDataStatus.Default; this.m_waitResult = default; return this.m_waitHandle.Reset(); } /// \u003csummary\u003e /// 使等待的线程继续执行 /// \u003c/summary\u003e public bool Set() { this.m_status = WaitDataStatus.SetRunning; return this.m_waitHandle.Set(); } /// \u003csummary\u003e /// 使等待的线程继续执行 /// \u003c/summary\u003e /// \u003cparam name=\"waitResult\"\u003e等待结果\u003c/param\u003e public bool Set(T waitResult) { this.m_waitResult = waitResult; this.m_status = WaitDataStatus.SetRunning; return this.m_waitHandle.Set(); } /// \u003csummary\u003e /// 加载取消令箭 /// \u003c/summary\u003e /// \u003cparam name=\"cancellationToken\"\u003e\u003c/param\u003e public void SetCancellationToken(CancellationToken cancellationToken) { if (cancellationToken.CanBeCanceled) { cancellationToken.Register(this.Cancel); } } /// \u003csummary\u003e /// 载入结果 /// \u003c/summary\u003e public void SetResult(T result) { this.m_waitResult = result; } /// \u003csummary\u003e /// 等待指定毫秒 /// \u003c/summary\u003e /// \u003cparam name=\"millisecond\"\u003e\u003c/param\u003e public WaitDataStatus Wait(int millisecond) { if (!this.m_waitHandle.WaitOne(millisecond)) { this.m_status = WaitDataStatus.Overtime; } return this.m_status; } } /// \u003csummary\u003e /// 等待处理数据 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public class WaitHandlePool\u003cT\u003e : IDisposable where T : IWaitResult { private readonly SnowflakeIDGenerator idGenerator; private readonly ConcurrentDictionary\u003clong, WaitData\u003cT\u003e\u003e waitDic; private readonly ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e waitQueue; /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e public WaitHandlePool() { this.waitDic = new ConcurrentDictionary\u003clong, WaitData\u003cT\u003e\u003e(); this.waitQueue = new ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e(); this.idGenerator = new SnowflakeIDGenerator(4); } /// \u003csummary\u003e /// 销毁 /// \u003c/summary\u003e /// \u003cparam name=\"waitData\"\u003e\u003c/param\u003e public void Destroy(WaitData\u003cT\u003e waitData) { if (waitData.DisposedValue) { throw new ObjectDisposedException(nameof(waitData)); } if (this.waitDic.TryRemove(waitData.WaitResult.Sign, out _)) { waitData.Reset(); this.waitQueue.Enqueue(waitData); } } /// \u003csummary\u003e /// 释放 /// \u003c/summary\u003e public void Dispose() { foreach (var item in this.waitDic.Values) { item.Dispose(); } foreach (var item in this.waitQueue) { item.Dispose(); } this.waitDic.Clear(); this.waitQueue.Clear(); } /// \u003csummary\u003e /// 获取一个可等待对象 /// \u003c/summary\u003e /// \u003cparam name=\"result\"\u003e\u003c/param\u003e /// \u003cparam name=\"autoSign\"\u003e设置为false时，不会生成sign\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public WaitData\u003cT\u003e GetWaitData(T result, bool autoSign = true) { WaitData\u003cT\u003e waitData; if (this.waitQ","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:3:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"总结\r主要介绍了字节池和等待处理池，详细介绍了相关特性和业务功能的实现。对于等待处理池我觉得还可以使用TaskCompletionSource\u003cTResult\u003e来实现，消耗比信号量更小，同时是异步执行，不会阻塞线程。 ","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:4:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 容器现在已经成为各种组件的标配了，为什么容器这么火，确实是太好用了。 表面上容器解决的是耦合问题，实际上容器实现了框架对流程的控制。 表面的耦合问题：没有容器，高层逻辑想要实现某个具体功能，只能依赖某个具体类或者具体工厂。当变化越来越多，改动越来越大，具体类之间依赖关系就像麻绳。里氏替换和依赖倒置根本无法实现。容器的出现将所有的具体类都保存在容器中，实现依赖倒置和里氏替换，系统高层和底层实现解耦。 框架对流程的控制问题：框架实现了整个应用流程的编排，流程中肯定需要具体的执行类。一旦依赖某个执行类就无法应对变化，具体类和流程严重耦合。整个框架就像被焊死，无法应对任何变化。容器就像是活页，连接着具体类和框架流程，当具体类发生变化，对框架没有任何影响，这也就使得框架的应用范围更广，实现的功能更多，框架中任何部件都是可以改变的。 唯一不变的就是改变，如果没有改变，也就不需要任何模式了。我们痛恨变化，同时也热爱变化，在痛苦中追求无限可能。 言归正传，TouchSocket框架实现了一个简易版的依赖注入容器。一起来看一下。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-09","objectID":"/2022/09/touchsocket2-dependencyinjection/:1:0","tags":["TouchSocket0.3.5","依赖注入容器"],"title":"TouchSocket 依赖注入容器","uri":"/2022/09/touchsocket2-dependencyinjection/"},{"categories":"TouchSocket0.3.5","content":"依赖注入\r简单点，容器其实就是一个字典，一个包含一个key和具体类的字典，将框架中所有依赖具体类的地方换成key，当执行到key的时候去字典中根据key取出具体类就可以了。 当然字典也需要生成，就是在应用开始的时候根据需求构建出字典。以后即使变化，也只变化开始构建的部分，最大程度减少修改。 真正的容器就是将字典改造一下，既然由容器管理，就应该负责到底，管理具体类的生命周期，什么时候创建，什么时候销毁，怎么创建。 首先字典中的具体类需要改造一下，变成描述类。 生命周期分为:单例，瞬态，域。 /// \u003csummary\u003e /// 注入依赖对象 /// \u003c/summary\u003e public class DependencyDescriptor { /// \u003csummary\u003e /// 初始化一个单例实例。 /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"instance\"\u003e\u003c/param\u003e public DependencyDescriptor(Type fromType, object instance) { this.FromType = fromType; this.ToInstance = instance; this.Lifetime = Lifetime.Singleton; this.ToType = instance.GetType(); } /// \u003csummary\u003e /// 初始化一个完整的服务注册 /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"toType\"\u003e\u003c/param\u003e /// \u003cparam name=\"lifetime\"\u003e\u003c/param\u003e public DependencyDescriptor(Type fromType, Type toType, Lifetime lifetime) { this.FromType = fromType; this.Lifetime = lifetime; this.ToType = toType; } /// \u003csummary\u003e /// 实例类型 /// \u003c/summary\u003e public Type ToType { get; } /// \u003csummary\u003e /// 实例 /// \u003c/summary\u003e public object ToInstance { get; set; } /// \u003csummary\u003e /// 生命周期 /// \u003c/summary\u003e public Lifetime Lifetime { get; } /// \u003csummary\u003e /// 注册类型 /// \u003c/summary\u003e public Type FromType { get; } } /// \u003csummary\u003e /// 注入项的生命周期。 /// \u003c/summary\u003e public enum Lifetime { /// \u003csummary\u003e /// 单例对象 /// \u003c/summary\u003e Singleton, /// \u003csummary\u003e /// 以\u003csee cref=\"IScopedContainer\"/\u003e接口为区域实例单例。 /// \u003c/summary\u003e Scoped, /// \u003csummary\u003e /// 瞬时对象 /// \u003c/summary\u003e Transient } 字典中的key改成FromType+Name。 最终字典变成了 private readonly ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e registrations = new ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e();这样。 看一下怎么实现注入和解析的。下面是原代码，Resolve方法根据生命周期实现解析逻辑；Create方法负责创建，同时各种注入方式；Register实现构建字典。 该容器有一些特点： 在注入容器时，提供了一个Name，key被构建成FromType+Name。这样的好处是可以根据Name来获取具体类。 同时对于多态的问题，同一个接口的多个实现没有实现注入，只能通过Name来区别了。 如果FromType不是抽象类，不需要注入，也可以Resolve出来。 Resolve会根据所有构造函数参数的个数最多的那个构造函数。 可以使用DependencyInject，DependencyParamterInject特性进行控制。 实现了构造函数注入，属性注入和方法注入 /// \u003csummary\u003e /// IOC容器 /// \u003c/summary\u003e public class Container : IContainer { private readonly ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e registrations = new ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e(); /// \u003csummary\u003e /// 初始化一个IOC容器 /// \u003c/summary\u003e public Container() { this.RegisterSingleton\u003cIContainer\u003e(this); } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public bool IsRegistered(Type fromType, string key = \"\") { return this.registrations.ContainsKey($\"{fromType.FullName}{key}\"); } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"descriptor\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e public void Register(DependencyDescriptor descriptor, string key = \"\") { string k = $\"{descriptor.FromType.FullName}{key}\"; this.registrations.AddOrUpdate(k, descriptor, (k, v) =\u003e { return descriptor; }); } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"ps\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public object Resolve(Type fromType, object[] ps = null, string key = \"\") { if (fromType == typeof(IScopedContainer)) { return this.GetScopedContainer(); } string k; DependencyDescriptor descriptor; if (fromType.IsGenericType) { Type type = fromType.GetGenericTypeDefinition(); k = $\"{type.FullName}{key}\"; if (this.registrations.TryGetValue(k, out descriptor)) { if (descriptor.Lifetime == Lifetime.Singleton) { if (descriptor.ToInstance != null) { return descriptor.ToInstance; } lock (descriptor) { if (descriptor.ToInstance != null) { return descriptor.ToInstance; } if (descriptor.ToType.IsGenericType) { return descriptor.ToInstance = this.Create(descriptor.ToType.MakeGenericType(fromType.GetGenericArguments()), ps); } else { return descriptor.ToInstance = this.Create(descriptor.ToType, ps); } } } if (descriptor.ToType.IsGenericType) { return this.Create(descriptor.ToType.MakeGenericType(fromType.GetGenericArguments()), ps); } el","date":"2022-09-09","objectID":"/2022/09/touchsocket2-dependencyinjection/:2:0","tags":["TouchSocket0.3.5","依赖注入容器"],"title":"TouchSocket 依赖注入容器","uri":"/2022/09/touchsocket2-dependencyinjection/"},{"categories":"TouchSocket0.3.5","content":"总结\r该容器虽然简单，但是足够使用，小巧紧致，非常值得学习。不需要注入直接解析对象的方式，虽然有点违反依赖倒置原则，但是在使用中确实是一个非常实用的功能。有一点缺陷是没有实现Dispose和瞬态对象的弱引用，当域生命周期结束的时候，Dispose容器同时销毁所有域创建出的瞬态对象。 ","date":"2022-09-09","objectID":"/2022/09/touchsocket2-dependencyinjection/:3:0","tags":["TouchSocket0.3.5","依赖注入容器"],"title":"TouchSocket 依赖注入容器","uri":"/2022/09/touchsocket2-dependencyinjection/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 该框架实现了广泛的Socket应用，NAT，各种RPC，文件传输，WebAPI，WebSocket，非常优秀的框架，学习一下，有问题可以相互探讨。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index 本章主要介绍TouchSocket的主要特性之一：依赖属性 ","date":"2022-09-07","objectID":"/2022/09/touchsocket1-dependencyproperties/:1:0","tags":["TouchSocket0.3.5","依赖属性"],"title":"TouchSocket 依赖属性","uri":"/2022/09/touchsocket1-dependencyproperties/"},{"categories":"TouchSocket0.3.5","content":"依赖属性\r用过WPF都知道依赖属性，其是绑定，动画，样式的基础，提供了属性值，更改通知等功能，该框架中的依赖属性相当于简易版本，提供了应用的思路。 依赖属性可以看成是Key和Value的封装。依赖属性类：名称，所属类型，值类型和值，还包含了一个工厂方法，用来创建依赖属性，创建时可以提供初始值。 /// \u003csummary\u003e /// 依赖项属性 /// \u003c/summary\u003e [DebuggerDisplay(\"Name={Name},Type={ValueType}\")] public class DependencyProperty { /// \u003csummary\u003e /// 属性名称 /// \u003c/summary\u003e protected string m_name; /// \u003csummary\u003e /// 所属类型 /// \u003c/summary\u003e protected Type m_owner; /// \u003csummary\u003e /// 值类型 /// \u003c/summary\u003e protected Type m_valueType; private object m_value; /// \u003csummary\u003e /// 依赖项属性 /// \u003c/summary\u003e private DependencyProperty() { } /// \u003csummary\u003e /// 默认值 /// \u003c/summary\u003e public object DefauleValue =\u003e this.m_value; /// \u003csummary\u003e /// 属性名 /// \u003c/summary\u003e public string Name =\u003e this.m_name; /// \u003csummary\u003e /// 所属类型 /// \u003c/summary\u003e public Type Owner =\u003e this.m_owner; /// \u003csummary\u003e /// 值类型 /// \u003c/summary\u003e public Type ValueType =\u003e this.m_valueType; internal void DataValidation(object value) { if (value == null) { if (typeof(ValueType).IsAssignableFrom(this.m_valueType)) { throw new Exception($\"属性“{this.m_name}”赋值类型不允许出现Null\"); } } else if (!this.m_valueType.IsAssignableFrom(value.GetType())) { throw new Exception($\"属性“{this.m_name}”赋值类型与注册类型不一致，应当注入“{this.m_valueType}”类型\"); } } internal void SetDefauleValue(object value) { this.DataValidation(value); this.m_value = value; } /// \u003csummary\u003e /// 注册依赖项属性。 /// \u003cpara\u003e依赖属性的默认值，可能会应用于所有的\u003csee cref=\"IDependencyObject\"/\u003e\u003c/para\u003e /// \u003c/summary\u003e /// \u003cparam name=\"propertyName\"\u003e\u003c/param\u003e /// \u003cparam name=\"valueType\"\u003e\u003c/param\u003e /// \u003cparam name=\"owner\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e依赖项属性值，一般该值应该是值类型，因为它可能会被用于多个依赖对象。\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static DependencyProperty Register(string propertyName, Type valueType, Type owner, object value) { DependencyProperty dp = new DependencyProperty { m_name = propertyName, m_valueType = valueType, m_owner = owner }; dp.SetDefauleValue(value); return dp; } } 如何管理依赖属性，类中创建依赖属性，并设置和获取依赖属性的值。首先实现接口，可以获取和设置依赖属性的值，实现一个基类，实现该接口，所有包含依赖属性的类继承该基类，就可以实现操作依赖属性了。 该框架做了进一步扩展，在基类中添加了一个依赖属性字典，可以添加外部依赖属性。 也就是在基类中保存了一个Key，Value的字典，通过特定的Key获取到Value，在配置的时候特别有用，配置类Option/Config怎么应对变化，写组件的时候发现配置项多需要添加属性怎么办，修改配置项，违反开放封闭原则；使用继承，显得太重；增加一个配置类，还不如使用继承。 把配置项修改成字典，所有信息通过key,value保存，可以应对开放封闭原则。显然该框架就说这样干的，key是依赖属性，vlaue是依赖属性的值。 /// \u003csummary\u003e /// 依赖对象接口 /// \u003c/summary\u003e public interface IDependencyObject : System.IDisposable { /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e object GetValue(DependencyProperty dp); /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public T GetValue\u003cT\u003e(DependencyProperty dp); /// \u003csummary\u003e /// 设置依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e\u003c/param\u003e public DependencyObject SetValue(DependencyProperty dp, object value); } /// \u003csummary\u003e /// 依赖项对象. /// 线程安全。 /// \u003c/summary\u003e public class DependencyObject : DisposableObject, IDependencyObject, System.IDisposable { /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e public DependencyObject() { this.m_dp = new ConcurrentDictionary\u003cDependencyProperty, object\u003e(); } [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)] private readonly ConcurrentDictionary\u003cDependencyProperty, object\u003e m_dp; /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public object GetValue(DependencyProperty dp) { if (this.m_dp.TryGetValue(dp, out object value)) { return value; } else { return dp.DefauleValue; } } /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public T GetValue\u003cT\u003e(DependencyProperty dp) { try { return (T)this.GetValue(dp); } catch { return default; } } /// \u003csummary\u003e /// 设置依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e\u003c/param\u003e public DependencyObject SetValue(DependencyProperty dp, object value) { dp.DataValidation(value); if (this.m_dp.ContainsKey(dp)) { this.m_dp[dp] = value; } els","date":"2022-09-07","objectID":"/2022/09/touchsocket1-dependencyproperties/:2:0","tags":["TouchSocket0.3.5","依赖属性"],"title":"TouchSocket 依赖属性","uri":"/2022/09/touchsocket1-dependencyproperties/"},{"categories":"TouchSocket0.3.5","content":"总结\r依赖属性这样的应用方式非常优秀，满足了扩展开放，单一职责。如果有其他的应用方式欢迎评论。 ","date":"2022-09-07","objectID":"/2022/09/touchsocket1-dependencyproperties/:3:0","tags":["TouchSocket0.3.5","依赖属性"],"title":"TouchSocket 依赖属性","uri":"/2022/09/touchsocket1-dependencyproperties/"},{"categories":null,"content":"关于我\r92年，儿子、丈夫、父亲，新时代农民工。 从事上位机开发多年，熟悉制药(层析超滤)和IVD(生化免疫)设备软件。 喜欢研究和学习各类技术，保持好奇心，持续探索。 熟悉的编程语言：C#,C,C++,Vue。 可以通过邮件978089234@qq.com与我联系！ Blog\r小时候夏天很长，长大了一年很短。每天都感觉很忙碌，却不知道在忙些什么。 想要记录些东西，证明那些年真的存在过。 写的文章，分享的想法观点可能早就有人写过，分享过。但自我成长和探索，是贯穿一生的事情。而在这个过程中，记录显得尤为重要，因为没有记录就没有发生，没有记录就会被遗忘。整理自己学到的，记录自己有共鸣的，对世界输出一些什么，通过创造来学习更多。 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]