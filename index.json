[{"categories":"LeeCode","content":"题目\r题目链接 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。 示例 1： 输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2： 输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3： 输入：nums = [], target = 0 输出：[-1,-1] 提示： 0 \u003c= nums.length \u003c= 105 -109 \u003c= nums[i] \u003c= 109 nums 是一个非递减数组 -109 \u003c= target \u003c= 109 ","date":"2022-11-16","objectID":"/2022/11/leecode34/:0:1","tags":["LeeCode","34","数组","查找第一个和最后一个位置"],"title":"LeeCode-34-数组-查找第一个和最后一个位置","uri":"/2022/11/leecode34/"},{"categories":"LeeCode","content":"解题\r二分法类似题，解题方案和前面两个相似 存在的变化，有重复数据，需要返回两个位置 尝试使用二分，找到值的序号后，向左，向右定位到上下限。 public int[] Search(int[] nums, int target) { //[left，right] var left = 0; var right = nums.Length - 1; var result = new int[] {-1, -1}; var mid = 0; while (left \u003c= right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { var min = mid; while (--min\u003e=left)//确定下限，使用遍历 { if(nums[min] != target) break; } result[0] = min + 1; var max = mid; while (++max \u003c= right)//确定上限，使用遍历 { if (nums[max] != target) break; } result[1] = max-1; break; } else if (target\u003cnums[mid]) { right = mid - 1; } else { left = mid + 1; } } return result; } 如果数组中的重复项比较多，中间使用遍历可以优化为二分，同时判定目标值是否在数组中也改成递归进行统一。 public int[] SearchPlus(int[] nums, int target) { var result = new int[] { -1, -1 }; if (nums.Length == 0) return result; //[left，right] var left = 0; var right = nums.Length - 1; var mid = 0; //遍历定位左右限，type 0:返回下限序号，1返回上限序号 ,2找到即返回, //返回[left right,index] int[] InnterSearch(int[] nums, int target, int left, int right, int type) { if (left \u003c= right) { mid = (left + right) \u003e\u003e 1; if (type == 2 \u0026\u0026 target == nums[mid]) { return new[] {left, right, mid}; } else if ( target \u003c nums[mid]||(type == 0 \u0026\u0026 target == nums[mid])) { right = mid - 1; } else if (target \u003e nums[mid] || (type == 1 \u0026\u0026 target == nums[mid])) { left = mid + 1; } return InnterSearch(nums, target, left, right, type); } if (type == 2)//不在数组中 { return new[] {left, right, -1}; } var index = type==1 ? left-1 : right+1; return new[] {left, right, nums[index] == target ? index : -1}; } var indexarray = InnterSearch(nums, target, left, right, 2);//数组中存在 if (indexarray[2] == -1) return result; result[0]= InnterSearch(nums, target, indexarray[0], indexarray[2], 0)[2];//找到下限 [left,mid]中二分 result[1] = InnterSearch(nums, target, indexarray[2], indexarray[1], 1)[2];//找到上限 [mid,right]中二分 return result; } InnterSearch方法承担了三个职责，目标值是否在数组中，寻找上限，寻找下限。导致内部实现用了很多的判定，看上去有点乱，通过字典封装判断逻辑，一目了然，如果以后需求变化，改动字典即可，尽可能满足开放封闭原则。 public int[] SearchPlusPro(int[] nums, int target) { var result = new int[] { -1, -1 }; if (nums.Length == 0) return result; //[left，right] var left = 0; var right = nums.Length - 1; var mid = 0; //遍历定位左右限，type 0:返回下限序号，1返回上限序号 ,2找到即返回, //返回[left right,index] var searchtypes = new Dictionary\u003cint, Func\u003cint[], int, int, int,int, int[]\u003e\u003e() { {//下限 0, (_nums, _target, _left, _right,_mid) =\u003e { if (_target \u003c= _nums[_mid]) { _right = _mid - 1; } else //target\u003enums[mid] { _left = _mid + 1; } return new []{_left,_right,-1}; } }, {//上限 1, (_nums, _target, _left, _right,_mid) =\u003e { if (_target \u003c _nums[_mid]) { _right = _mid - 1; } else //target\u003e=nums[mid] { _left = _mid + 1; } return new []{_left,_right,-1}; } }, {//找到立即返回 2, (_nums, _target, _left, _right,_mid) =\u003e { if (_target == _nums[_mid]) { return new[] {_left, _right, _mid}; } else if ( _target \u003c _nums[_mid]) { _right = _mid - 1; } else { _left = _mid + 1; } return new []{_left,_right,-1}; } } }; int[] InnterSearch(int[] nums, int target, int left, int right, int type) { if (left \u003c= right) { mid = (left + right) \u003e\u003e 1; var temresult = searchtypes[type](nums, target, left, right, mid); if (temresult[2] != -1) return temresult; return InnterSearch(nums, target, temresult[0], temresult[1], type); } return new[] {left, right, -1}; } var indexarray = InnterSearch(nums, target, left, right, 2);//数组中存在 if (indexarray[2] == -1) return result; result[0] = InnterSearch(nums, target, indexarray[0], indexarray[2], 0)[0];//找到下限 [left,mid]中二分 result[1] = InnterSearch(nums, target, indexarray[2], indexarray[1], 1)[1];//找到上限 [mid,right]中二分 return result; } ","date":"2022-11-16","objectID":"/2022/11/leecode34/:0:2","tags":["LeeCode","34","数组","查找第一个和最后一个位置"],"title":"LeeCode-34-数组-查找第一个和最后一个位置","uri":"/2022/11/leecode34/"},{"categories":"LeeCode","content":"网络解析\r网络解析有以下几种方式： 对数组使用两次二分查找上限和下限。 先判断目标在数组中，再使用二分查找上下限 public class Solution { public int[] SearchRange(int[] nums, int target) { if (nums.Length == 0) return new int[] { -1, -1 }; int l = binarySearch(nums, target, true); int r = binarySearch(nums, target, false) - 1; if (l \u003c= r \u0026\u0026 r \u003c nums.Length \u0026\u0026 nums[l] == target \u0026\u0026 nums[r] == target) return new int[] { l, r }; return new int[] { -1, -1 }; } int binarySearch(int[] nums,int target,bool lower) { int n = nums.Length; int l = 0, r = n - 1; while (l \u003c= r) { int m = (l + r) / 2; if (nums[m] \u003e target || (lower \u0026\u0026 nums[m] \u003e= target)) { r = m - 1; n = m; } else l = m + 1; } return n; } } public class Solution { public int[] SearchRange(int[] nums, int target) { int[] res = new int[2]; int left=0; int right = nums.Length-1; while(left\u003c= right) { int mid = left+(right-left)/2; if(nums[mid] \u003ctarget) { left = mid+1; }else if(nums[mid] \u003etarget) { right = mid-1; }else if (nums[mid]==target) { right = mid-1; } } if(left==nums.Length) { res[0] = -1; }else { res[0] = nums[left]==target?left:-1; } left=0; right = nums.Length-1; while(left\u003c= right) { int mid = left+(right-left)/2; if(nums[mid] \u003ctarget) { left = mid+1; }else if(nums[mid] \u003etarget) { right = mid-1; }else if (nums[mid]==target) { left = mid+1; } } if(left-1 \u003c0) { res[1] = -1; }else { res[1] = nums[left-1]==target?left-1:-1; } return res; } } ","date":"2022-11-16","objectID":"/2022/11/leecode34/:0:3","tags":["LeeCode","34","数组","查找第一个和最后一个位置"],"title":"LeeCode-34-数组-查找第一个和最后一个位置","uri":"/2022/11/leecode34/"},{"categories":"LeeCode","content":"题目\r题目链接 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例 1: 输入: nums = [1,3,5,6], target = 5 输出: 2 示例 2: 输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3: 输入: nums = [1,3,5,6], target = 7 输出: 4 提示: 1 \u003c= nums.length \u003c= 104 -104 \u003c= nums[i] \u003c= 104 nums 为 无重复元素 的 升序 排列数组 -104 \u003c= target \u003c= 104 解题\r","date":"2022-11-15","objectID":"/2022/11/leecode35/:0:0","tags":["LeeCode","35","数组","搜索插入位置"],"title":"LeeCode-35-数组-搜索插入位置","uri":"/2022/11/leecode35/"},{"categories":"LeeCode","content":"二分\r思考，排序数组，无重复，升序，规定时间复杂度，好像只有二分了，递归是否可以，因为递归也是Logn public int Search(int[] nums, int target) { //[left,right] var left = 0; var right = nums.Length - 1; var mid = 0; while (left \u003c= right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { left = mid; break; } else if (target\u003cnums[mid]) { right = mid - 1; } else { left = mid + 1; } } return left; } public int SearchPlus(int[] nums, int target) { //[right,left) var left = 0; var right = nums.Length; var mid = 0; while (left != right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { left = mid; break; } else if (target \u003c nums[mid]) { right = mid; } else { left = mid + 1; } } return left; } ","date":"2022-11-15","objectID":"/2022/11/leecode35/:1:0","tags":["LeeCode","35","数组","搜索插入位置"],"title":"LeeCode-35-数组-搜索插入位置","uri":"/2022/11/leecode35/"},{"categories":"LeeCode","content":"递归\rpublic int SearchPro(int[] nums, int target) { //[right,left] var left = 0; var right = nums.Length - 1; var mid = 0; int InnerCore(int[] nums, int target, int left, int right) { if (left \u003c= right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { return mid; } else if (target \u003c nums[mid]) { return InnerCore(nums, target, left, mid-1); } else { return InnerCore(nums, target, mid + 1, right); } } return left; } return InnerCore(nums,target,left,right); } public int SearchProPlus(int[] nums, int target) { //[right,left) var left = 0; var right = nums.Length; var mid = 0; int InnerCore(int[] nums, int target, int left, int right) { if (left != right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { return mid; } else if (target \u003c nums[mid]) { return InnerCore(nums, target, left, mid); } else { return InnerCore(nums, target, mid + 1, right); } } return left; } return InnerCore(nums, target, left, right); } 网络解析\rpublic int SearchInsert(int[] nums, int target) { int searchIdx; int searchLower = 0, searchHigher = nums.Length - 1; int middle = 0; while (searchLower \u003c= searchHigher) { middle = searchLower + (searchHigher - searchLower) / 2; if (nums[middle] == target) { return middle; } if (nums[middle] \u003e target) { searchHigher = middle - 1; } else { searchLower = middle + 1; } } if (target \u003c= nums[middle]) return middle; if (target \u003e nums[middle]) return middle + 1; return -1; } public class Solution { public int SearchInsert(int[] nums, int target) { return Rank(nums,0,nums.Length - 1,target); } public int Rank(int[] arr,int left,int right,int target) { if(target \u003c arr[left]) return left; if(target \u003e arr[right]) return right + 1; int mid = (left + right)/2; if(target == arr[mid]) return mid; if(target\u003carr[mid]) return Rank(arr,left,mid-1,target); else return Rank(arr,mid+1,right,target); } } ","date":"2022-11-15","objectID":"/2022/11/leecode35/:2:0","tags":["LeeCode","35","数组","搜索插入位置"],"title":"LeeCode-35-数组-搜索插入位置","uri":"/2022/11/leecode35/"},{"categories":"LeeCode","content":"题目\r给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示: 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 解题\r如果使用遍历，最好情况O(1)，最坏情况O(n)。 使用二分法是O(logn)。 尝试使用二分，二分肯定有上下限和中间值，通过中间值和目标值比较，不断缩小上下限最后得到结果。 从中考虑While的判断是什么？ 上下限的范围怎么划定？ 初版： public int Search(int[] nums, int target) { var maxindex = nums.Length-1; var minindex = 0; var index = (maxindex + minindex) / 2; while (maxindex != minindex) { if (target == nums[index]) { break; } if (target \u003c nums[index]) { maxindex = index; } else { minindex = index+1; } index = (maxindex + minindex) / 2; } if (target == nums[index]) return index; return -1; } 测试用例通过了，但是有效率不高，有很多重复代码，改进一下 public int SearchPro(int[] nums, int target) { var maxindex = nums.Length - 1; var minindex = 0; var midindex=0; while (minindex\u003c=maxindex) { midindex = (maxindex + minindex) / 2; if (target == nums[midindex]) { return midindex; } if (target \u003c nums[midindex]) { maxindex = midindex - 1; } else { minindex = midindex + 1; } } return -1; } 最佳答案 public int StandardSearch(int[] nums, int target) { int left = 0, right = nums.Length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } if (nums[mid] \u003e target) { right = mid - 1; } else { left = mid + 1; } } return -1; } 对比： 想一下变量用left和right应该更简介一点。mid在循环体中声明，每次会在栈中创建新的临时变量。 网络解析\rtarget 是在一个在左闭右闭的区间里，也就是[left, right] ，这种就是上面的标准写法 while (left \u003c= right) 要使用 \u003c= ，因为left == right是有意义的，所以使用 \u003c= if (nums[middle] \u003e target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 target 是在一个在左闭右开的区间里，也就是[left, right) while (left \u003c right)，这里使用 \u003c ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] \u003e target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] public int SearchPlus(int[] nums, int target) { var maxindex = nums.Length; var minindex = 0; var midindex = 0; while (minindex \u003c maxindex) { midindex = (maxindex + minindex) / 2; if (target == nums[midindex]) { return midindex; } if (target \u003c nums[midindex]) { maxindex = midindex; } else { minindex = midindex+1; } } return -1; } ","date":"2022-11-14","objectID":"/2022/11/leecode704/:0:0","tags":["LeeCode","704","数组","二分查找"],"title":"LeeCode-704-数组-二分查找","uri":"/2022/11/leecode704/"},{"categories":"DotNet基础","content":"概述\r高性能的套接字编程围绕着两个方面：异步和复用。异步：高性能就是最大化计算机资源的利用，是不可能让线程有阻塞的，所以就有了各种异步模式。复用：计算机资源最好是能重复使用的，频繁的创建和销毁相同的对象也是对资源的浪费，所以就有了各种池和零拷贝；CPU在访问相邻资源的时候有特别的优势可以利用缓存区，所以池中对象尽量相邻创建。 Socket套接字编程历史悠久，发展出好几种方式，对应着DotNet异步编程的发展，分别：异步编程模式(Asynchronous Programming Model ,APM)、基于事件的异步模式(Event-based Asynchronous Pattern ,EAP)和基于任务的异步模式(Task-based Asynchronous Pattern,TAP)。 本文将简要介绍几种异步编程对应Socket的实现，每一种都写了一个简单的Socket服务端以供学习。 ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:1:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"面向连接的套接字\r套接字流程如下，在Accept，Read，Write，Connect和Disconnect方法均涉及到异步编程。为什么会异步，简单来说就是线程执行速度很快，网络传输的IO速度很慢，线程发出IO操作的指令后，不可能一直等待指令执行完。所以线程设置一个回调函数的入口地址，让IO执行完之后调用该入口地址，之后线程就去干其他事情了，等该IO调用该入口地址，线程再回来继续工作。 ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:2:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"阻塞式套接字\rSocket接口，下面是用阻塞方法创建的一个简单服务端。可以分析出该服务的性能是很差的，没有做任何的异步和复用。 //服务端 public static void Run(string m_ip, int m_port) { var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); var ip = IPAddress.Parse(m_ip); var endpoint = new IPEndPoint(ip, m_port); socket.Bind(endpoint); socket.Listen(0); socket.ReceiveTimeout = -1; //线程池中后台线程执行 Task.Run(() =\u003e { while (true) { var acceptSocket = socket.Accept();//线程阻塞等待连接请求队列 if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { //线程池中后台线程执行 Task.Run(() =\u003e { byte[] receiveBuffer = new byte[1024];//每一个连接都在重新创建缓冲区 int result = 0; do { if (acceptSocket.Connected) { result = acceptSocket.Receive(receiveBuffer, 0, receiveBuffer.Length, SocketFlags.None, out SocketError error);//线程阻塞等待缓冲区数据 if (error == SocketError.Success \u0026\u0026 result \u003e 0) { var recestr = Encoding.UTF8.GetString(receiveBuffer, 0, result); var Replaystr = $\"Server收到消息:{recestr};Server收到消息的时间:{DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss:fff\")}\"; var strbytes = Encoding.UTF8.GetBytes(Replaystr); acceptSocket.Send(strbytes, 0, strbytes.Length, SocketFlags.None);//线程阻塞等待发送完缓冲区数据 if (recestr.Contains(\"stop\")) { break; } } } else { break; } } while (result \u003e 0); }).ContinueWith((t) =\u003e { System.Threading.Thread.Sleep(1000); acceptSocket.Disconnect(false); acceptSocket.Dispose(); }); } } }).Wait(); } ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:3:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"异步编程模式(Asynchronous Programming Model ,APM)\rBeginXXX方法并不会阻塞线程，而EndXXX会，dotnet提供Task\u003cT\u003e.Factory.FromAsync可以将APM转成TAP模式异步模式以提高性能，下面提供一个示例，同时使用ArrayPool复用缓冲区，处理分包，粘包等问。 public static Socket Run(string m_ip, int m_port) { var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); var ip = IPAddress.Any; if (!string.IsNullOrEmpty(m_ip)) { ip = IPAddress.Parse(m_ip); } var endpoint = new IPEndPoint(ip, m_port); socket.Bind(endpoint); Console.WriteLine($\"[{DateTime.Now.GetFormString()}] Server Established localEndpoint:[{socket.LocalEndPoint.ToString()}]\"); socket.Listen(200); socket.ReceiveTimeout = -1; //后台线程执行 Task.Run(async () =\u003e { while (true) { var acceptSocket = await Task\u003cSocket\u003e.Factory.FromAsync( socket.BeginAccept(null,null) ,socket.EndAccept);//APM转TAP异步 if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { //后台线程来处理Receive逻辑 var task = Task.Run(async () =\u003e { byte[] buffer = ArrayPool\u003cbyte\u003e.Shared.Rent(1024);//从内存池中获取缓冲区 var bytesBuffered = 0; var bytesConsumed = 0; while (true) { if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { var temremaining = bytesBuffered - bytesConsumed; if (temremaining == 0)//缓存区全部解析完 { bytesBuffered = 0; bytesConsumed = 0; } else if (temremaining \u003c buffer.Length \u0026\u0026 temremaining \u003e 0)//最后一个包不完整，部分数据未解析 { var newbuffer = ArrayPool\u003cbyte\u003e.Shared.Rent(buffer.Length); Buffer.BlockCopy(buffer, bytesConsumed, newbuffer, 0, temremaining); ArrayPool\u003cbyte\u003e.Shared.Return(buffer); buffer = newbuffer; bytesBuffered = temremaining; bytesConsumed = 0; } else //包不够大，分包了 { var newbuffer = ArrayPool\u003cbyte\u003e.Shared.Rent(buffer.Length * 2); Buffer.BlockCopy(buffer, 0, newbuffer, 0, buffer.Length); ArrayPool\u003cbyte\u003e.Shared.Return(buffer); buffer = newbuffer; } var bytesRemaining = buffer.Length - bytesBuffered; try { var bytesread = await Task\u003cint\u003e.Factory.FromAsync( acceptSocket.BeginReceive(buffer, bytesBuffered, bytesRemaining, SocketFlags.None, null, null), acceptSocket.EndReceive);//APM转TAP异步 if (bytesread == 0) { break; } bytesbuffered += bytesread; var lineposition = -1; do { lineposition = array.indexof(buffer, (byte)0x23, bytesconsumed,bytesbuffered - bytesconsumed); if (lineposition \u003e= 0) { var lineLength = linePosition - bytesConsumed; ProcessLine(acceptSocket, buffer, bytesConsumed, bytesread); bytesConsumed += bytesread; } } while (linePosition \u003e= 0);//包解析 } catch (Exception e) { break; } } else { break; } } ArrayPool\u003cbyte\u003e.Shared.Return(buffer); }).ContinueWith((t) =\u003e { Console.WriteLine($\"[{DateTime.Now.GetFormString()}] ServerClient Disconnected localEndpoint:[{acceptSocket?.LocalEndPoint.ToString()}] remoteEndpoint:[{acceptSocket?.RemoteEndPoint.ToString()}]\"); acceptSocket?.Shutdown(SocketShutdown.Both); acceptSocket?.Close(); acceptSocket = null; }); } } }); return socket; } ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:4:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"基于事件异步的完成端口模型(Event-based Asynchronous Pattern ,EAP)\r目前应用最广的Socket模型，完成端口模型还是按照\"回调函数\"的方式进行来实现异步，其本质是线程池，该线程池的核心工作就是去调用IO操作完成时的回调函数。另外因为IO操作毕竟是慢速的操作，所以几个线程就已经足可以应付成千上万的输入输出完成操作的请求(前提就是你的回调函数做的工作要足够少)，所以这个模型的性能是非常高的。也是现在Windows平台上性能最好的输入输出模型。自定义构造了内存池，将一大块内存切分成一定数据量的连续小内存，分别分配给不同的SocketAsyncEventArgs对象以提高服务性能，非常巴适；目前看到的FastSocket,SuperSocket,TouchSocket,NewLife等网络框架均采用这种模式，最主要的原因是应用范围广。 框架 版本 .NET Core 1.0, Core 1.1, Core 2.0, Core 2.1, Core 2.2, Core 3.0, Core 3.1, 5, 6, 7 Preview 7 .NET Framework 2.0, 3.0, 3.5, 4.0, 4.5, 4.5.1, 4.5.2, 4.6, 4.6.1, 4.6.2, 4.7, 4.7.1, 4.7.2, 4.8 .NET Standard 1.3, 1.4, 1.6, 2.0, 2.1 UWP 10.0 Xamarin.iOS 10.8 Xamarin.Mac 3.0 public class MyIOCPSocket { private static int m_numConnections;//最大连接数 private static int m_receiveBufferSize;//接收缓存区数量 private static int m_sendBufferSize;//发送缓存区大小 private static byte[] m_receivebuffer;//接收缓存区 private static Stack\u003cint\u003e m_freeReceiveIndexPool;//可用的接收缓存索引栈 private static int m_currentReceiveIndex;//当前的接收缓存区索引 private static byte[] m_sendbuffer;//发送缓存区 private static Stack\u003cint\u003e m_freeSendIndexPool;//可用的发送缓存索引栈 private static int m_currentSendIndex;//当前的发送缓存区索引 private static Stack\u003cSocketAsyncEventArgs\u003e m_ReadPool;//接收SocketAsyncEventArgs池 private static Stack\u003cSocketAsyncEventArgs\u003e m_WritePool;//发送SocketAsyncEventArgs池 private static Semaphore m_maxNumberAcceptedClients;//最大连接锁 private static int m_numConnectedSockets;//连接的Socket数量 private static int m_totalBytesRead;//总的接收字节数 private static Socket listenSocket;//监听Socket public static void Run(string m_ip, int m_port, int numConnections, int m_receiveBuffer, int m_sentBuffer) { //初始化 m_numConnections = numConnections; m_receiveBufferSize = m_receiveBuffer; m_sendBufferSize = m_sentBuffer; m_receivebuffer = new byte[m_receiveBufferSize * m_numConnections]; m_freeReceiveIndexPool = new Stack\u003cint\u003e(); m_currentReceiveIndex = 0; m_sendbuffer = new byte[m_sendBufferSize * m_numConnections]; m_freeSendIndexPool = new Stack\u003cint\u003e(); m_currentSendIndex = 0; m_ReadPool = new Stack\u003cSocketAsyncEventArgs\u003e(m_numConnections); m_WritePool = new Stack\u003cSocketAsyncEventArgs\u003e(m_numConnections); m_maxNumberAcceptedClients = new Semaphore(m_numConnections, m_numConnections); m_numConnectedSockets = 0; m_totalBytesRead = 0; //接收缓存分配 for (int i = 0; i \u003c m_numConnections; i++) { var readEventArg = new SocketAsyncEventArgs(); readEventArg.Completed += new EventHandler\u003cSocketAsyncEventArgs\u003e(ReadWriteIOComleted); readEventArg.UserToken = new AsyncUserToken(); if (m_freeReceiveIndexPool.Count \u003e 0) { readEventArg.SetBuffer(m_receivebuffer, m_freeReceiveIndexPool.Pop(), m_receiveBufferSize); } else { if ((m_receiveBufferSize * m_numConnections - m_receiveBufferSize) \u003c m_currentReceiveIndex) { new ArgumentException(\"接收缓存设置异常\"); } readEventArg.SetBuffer(m_receivebuffer, m_currentReceiveIndex, m_receiveBufferSize); m_currentReceiveIndex += m_receiveBufferSize; } m_ReadPool.Push(readEventArg); //发送缓存分配 var writeEventArg = new SocketAsyncEventArgs(); writeEventArg.Completed += new EventHandler\u003cSocketAsyncEventArgs\u003e(ReadWriteIOComleted); writeEventArg.UserToken = new AsyncUserToken(); if (m_freeSendIndexPool.Count \u003e 0) { writeEventArg.SetBuffer(m_sendbuffer, m_freeSendIndexPool.Pop(), m_sendBufferSize); } else { if ((m_sendBufferSize * m_numConnections - m_sendBufferSize) \u003c m_currentSendIndex) { new ArgumentException(\"发送缓存设置异常\"); } writeEventArg.SetBuffer(m_sendbuffer, m_currentSendIndex, m_sendBufferSize); m_currentSendIndex += m_sendBufferSize; } m_WritePool.Push(writeEventArg); } //设置监听socket listenSocket = new Socket(new IPEndPoint(IPAddress.Parse(m_ip), m_port).AddressFamily, SocketType.Stream, ProtocolType.Tcp); //绑定端口 listenSocket.Bind(new IPEndPoint(IPAddress.Parse(m_ip), m_port)); listenSocket.Listen(100); StartAccept(null); Console.WriteLine(\"Press any key to terminate the server process....\"); Console.ReadKey(); } public static void ReadWriteIOComleted(object sender, SocketAsyncEventArgs e) { switch (e.LastOperation) { case SocketAsyncO","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:5:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"基于任务的异步模式(Task-based Asynchronous Pattern,TAP)\r相对于前几个模型，基于任务的网络模型是比较新的模型，但是性能是最好的，最主要的原因是微软提供了System.Net.Sockets.SocketTaskExtensions封装TAP的异步方法；System.IO.Pipelines管道模型，在 .NET 中执行高性能 I/O 更加容易。该管道可以实现流量控制和反压。PipeScheduler可以进行回调线程控制。PipeReader和PipeWriter封装了对内存数据的直接操作，实现零拷贝得以大大提供业务流的性能。可惜的是应用范围比较小，目前框架只支持2.1, 2.2, 3.0, 3.1, 5, 6, 7 Preview 7，Framework不支持。 private static Pipe pipe; public static Socket Run(string m_ip, int m_port) { //监听Socket var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); var ip = IPAddress.Parse(m_ip); var endpoint = new IPEndPoint(ip, m_port); socket.Bind(endpoint); //绑定端口和IP socket.Listen(200); //允许同时监听的队列 socket.ReceiveTimeout = -1; Task.Run(async () =\u003e { while (true) { var acceptSocket = await socket.AcceptAsync(); //TAP异步接收 if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { pipe = new Pipe(); var writer = pipe.Writer; var reader = pipe.Reader; var writetaskr = Task.Run(async () =\u003e { while (true) { var memory = writer.GetMemory(1024); try { //TAP 异步读取数据 int bytesRead = await acceptSocket.ReceiveAsync(memory, SocketFlags.None); if (bytesRead == 0) { break; } //告诉 PipeWriter 写入多少数据。 writer.Advance(bytesRead); } catch (Exception e) { break; } //刷新写入 FlushResult result = await writer.FlushAsync(); if (result.IsCompleted) { break; } } // 完成写入 await writer.CompleteAsync(); }).ContinueWith((t) =\u003e { acceptSocket?.Shutdown(SocketShutdown.Both); //acceptSocket?.Disconnect(true); acceptSocket?.Dispose(); acceptSocket = null; }); var readingtask= Task.Run(async() =\u003e { while (true) { try { //从管道中读取 ReadResult result = await reader.ReadAsync(); ReadOnlySequence\u003cbyte\u003e buffer = result.Buffer; while (TryReadLine(ref buffer, out ReadOnlySequence\u003cbyte\u003e line))//解析 { ProcessLine(acceptSocket, line); } //实际读了多少 reader.AdvanceTo(buffer.Start, buffer.End); //是否写已经结束 if (result.IsCompleted) { break; } } catch (Exception e) { break; } } await reader.CompleteAsync(); }).ContinueWith((t) =\u003e { acceptSocket?.Shutdown(SocketShutdown.Both); acceptSocket?.Dispose(); acceptSocket = null; } ); } } }); return socket; } ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:6:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"总结\r主要讲述在套接字编程中，如何实现异步和复用以提高性能。讲述了异步编程(APM)、基于事件的异步模型(EAP)和基于任务的异步模型(TAP)；复用方面从内存池(ArrayPool)，到自定义构建内存池(利用高速缓存)和完成端口池，再到最新的管道模型，实现零拷贝。 ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:7:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 TouchSocket提供插件方式的扩展，这种方式对原框架的耦合较小。用插件基类封装了底层框架中所有的插件扩展接口，插件子类重写对应的接口就可注入相关业务。框架插件的注入和调用通过PluginsManager进行管理。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:1:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"插件架构\r插件接口在框架中的位置可以在TouchSocket 封装和扩展查看，插件基类封装了所有接口。 下图为插件基类。 插件管理负责插件的注入和调用，通过一些扩展方法封装各种插件注入方式。 下图为插件管理： 插件的注入方式比较特别，通过反射方式找到类中所有插件接口并构造PluginMethod封装方法，该封装主要封装了异步方法，调用时会等待异步结果再进行返回。 ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:2:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"重连插件\r当客户端连接断开时，提供自动重连。 通过扩展方法提供注入接口: /// \u003csummary\u003e /// 使用断线重连。 /// \u003cpara\u003e该效果仅客户端在完成首次连接，且为被动断开时有效。\u003c/para\u003e /// \u003c/summary\u003e /// \u003cparam name=\"pluginsManager\"\u003e\u003c/param\u003e /// \u003cparam name=\"successCallback\"\u003e成功回调函数\u003c/param\u003e /// \u003cparam name=\"tryCount\"\u003e尝试重连次数，设为-1时则永远尝试连接\u003c/param\u003e /// \u003cparam name=\"printLog\"\u003e是否输出日志。\u003c/param\u003e /// \u003cparam name=\"sleepTime\"\u003e失败时，停留时间\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static IPluginsManager UseReconnection(this IPluginsManager pluginsManager, int tryCount = 10, bool printLog = false, int sleepTime = 1000, Action\u003cITcpClient\u003e successCallback = null) { var reconnectionPlugin = new ReconnectionPlugin\u003cITcpClient\u003e(client=\u003e { int tryT = tryCount; while (tryCount \u003c 0 || tryT-- \u003e 0) { try { if (client.Online) { return true; } else { client.Connect(); } successCallback?.Invoke(client); return true; } catch (Exception ex) { if (printLog) { client.Logger.Debug(LogType.Error, client, \"断线重连失败。\", ex); } Thread.Sleep(sleepTime); } } return true; }); pluginsManager.Add(reconnectionPlugin); return pluginsManager; } ReconnectionPlugin继承TcpPluginBase，并重写OnDisconnected方法。通过Task.Run异步执行。 /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"client\"\u003e\u003c/param\u003e /// \u003cparam name=\"e\"\u003e\u003c/param\u003e protected override void OnDisconnected(ITcpClientBase client, ClientDisconnectedEventArgs e) { base.OnDisconnected(client, e); if (client is ITcpClient tcpClient) { if (e.Manual) { return; } Task.Run(() =\u003e { while (true) { try { if (this.m_tryCon.Invoke((TClient)tcpClient)) { break; } } catch { } } }); } } 框架调用： 通过PluginsManager调用插件接口，注意如果e.Handled在重写的方法里置为true，将不会调用Client.DisConnected和Client.OnDisConnected。 private void PrivateOnDisconnected(ClientDisconnectedEventArgs e) { if (this.m_usePlugin) { this.PluginsManager.Raise\u003cITcpPlugin\u003e(\"OnDisconnected\", this, e); if (e.Handled) { return; } } this.OnDisconnected(e); } ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:3:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"扩展插件横切面接口\rHTTPPlugin插件扩展了HTTP协议的相关接口 在HttpSocketClient中重写HandleReceivedData方法调用插件横切面。 /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"byteBlock\"\u003e\u003c/param\u003e /// \u003cparam name=\"requestInfo\"\u003e\u003c/param\u003e protected override void HandleReceivedData(ByteBlock byteBlock, IRequestInfo requestInfo) { if (requestInfo is HttpRequest request) { this.OnReceivedHttpRequest(request); } } /// \u003csummary\u003e /// 当收到到Http请求时。覆盖父类方法将不会触发插件。 /// \u003c/summary\u003e protected virtual void OnReceivedHttpRequest(HttpRequest request) { HttpContextEventArgs args = new HttpContextEventArgs(new HttpContext(request)); switch (request.Method) { case TouchSocketHttpUtility.Get: { this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnGet\", this, args); break; } case TouchSocketHttpUtility.Post: { this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnPost\", this, args); break; } case TouchSocketHttpUtility.Put: { this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnPut\", this, args); break; } case TouchSocketHttpUtility.Delete: { this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnDelete\", this, args); break; } default: this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnReceivedOtherHttpRequest\", this, args); break; } } ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:4:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"总结\r介绍了TouchSocket插件扩展，包括插件架构，利用重写默认的TcpPluginBase的方法实现业务注入；扩展插件横切面接口，这需要重写ClientBase的相关方法实现。 ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:5:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 TouchSocket的底层使用完成端口模型，基于事件的异步模式。关于完成端口模型的基础知识可以看Socket基础 。结合上篇横切面扩展(TouchSocket 封装和扩展)可以实现各种业务需求。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:1:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"Accept\r在TcpServer类中BeginListen方法，一个监听者用一个SocketAsyncEventArgs foreach (var networkMonitor in this.m_monitors) { SocketAsyncEventArgs e = new SocketAsyncEventArgs(); e.UserToken = networkMonitor.Socket; e.Completed += this.Args_Completed; if (!networkMonitor.Socket.AcceptAsync(e)) { this.OnAccepted(e); } } ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:2:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"Receive\r在SocketClient的BeginReceive方法中，缓存区使用了内存池进行复用，该内存池的细节可以看TouchSocket 字节池和待处理池，注意在处理完缓冲区后再HandleBuffer的finally中调用byteBlock的Dispose方法，将缓存区返回内存池，如果m_holding被设置为true，则由GC自己回收。 internal void BeginReceive(ReceiveType receiveType) { if (receiveType == ReceiveType.Auto) { SocketAsyncEventArgs eventArgs = new SocketAsyncEventArgs(); eventArgs.Completed += this.EventArgs_Completed; ByteBlock byteBlock = BytePool.GetByteBlock(this.BufferLength);//内存池获取缓冲区 eventArgs.UserToken = byteBlock; eventArgs.SetBuffer(byteBlock.Buffer, 0, byteBlock.Capacity); if (!this.m_mainSocket.ReceiveAsync(eventArgs)) { this.ProcessReceived(eventArgs); } } } private void HandleBuffer(ByteBlock byteBlock) { try { if (this.ClearType.HasFlag(ClearType.Receive)) { this.m_lastTick = DateTime.Now.Ticks; } if (this.OnHandleRawBuffer?.Invoke(byteBlock) == false) { return; } if (this.UsePlugin \u0026\u0026 this.PluginsManager.Raise\u003cITcpPlugin\u003e(\"OnReceivingData\", this, new ByteBlockEventArgs(byteBlock))) { return; } if (this.m_disposedValue) { return; } if (this.m_adapter == null) { this.Logger.Debug(LogType.Error, this, ResType.NullDataAdapter.GetDescription()); return; } this.m_adapter.ReceivedInput(byteBlock); } catch (System.Exception ex) { this.Logger.Debug(LogType.Error, this, \"在处理数据时发生错误\", ex); } finally { byteBlock.Dispose();//内存池回收 } } ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:3:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"Send\rSocketClient的SocketSend方法中使用Send同步方法发送，如果异步使用异步编程模式的BeginSend方法。 protected void SocketSend(byte[] buffer, int offset, int length, bool isAsync) { if (!this.m_online) { throw new NotConnectedException(ResType.NotConnected.GetDescription()); } if (this.HandleSendingData(buffer, offset, length)) { lock (this.m_sendLocker) { if (this.UseSsl) { this.m_workStream.Write(buffer, offset, length); } else { if (isAsync) { this.m_mainSocket.BeginSend(buffer, offset, length, SocketFlags.None, null, null); } else { while (length \u003e 0) { int r = this.m_mainSocket.Send(buffer, offset, length, SocketFlags.None); if (r == 0 \u0026\u0026 length \u003e 0) { throw new Exception(\"发送数据不完全\"); } offset += r; length -= r; } } } } if (this.ClearType.HasFlag(ClearType.Send)) { this.m_lastTick = DateTime.Now.Ticks; } } } ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:4:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"Connect\r在TcpClient的Connect方法中，使用异步编程模式的BeginConnect和EndConnect方法 /// \u003csummary\u003e /// 请求连接到服务器。 /// \u003c/summary\u003e public virtual ITcpClient Connect(int timeout = 5000) { if (this.m_online) { return this; } if (this.m_disposedValue) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_config == null) { throw new ArgumentNullException(\"配置文件不能为空。\"); } IPHost iPHost = this.m_config.GetValue\u003cIPHost\u003e(TouchSocketConfigExtension.RemoteIPHostProperty); if (iPHost == null) { throw new ArgumentNullException(\"iPHost不能为空。\"); } if (this.m_mainSocket != null) { this.m_mainSocket.Dispose(); } this.m_mainSocket = this.CreateSocket(iPHost); ClientConnectingEventArgs args = new ClientConnectingEventArgs(this.m_mainSocket); this.PrivateOnConnecting(args); var result = this.m_mainSocket.BeginConnect(iPHost.EndPoint, null, null);//APM if (result.AsyncWaitHandle.WaitOne(timeout)) { if (this.m_mainSocket.Connected) { this.m_mainSocket.EndConnect(result);//APM this.LoadSocketAndReadIpPort(); if (this.m_separateThreadSend) { this.m_asyncSender.SafeDispose(); this.m_asyncSender = new AsyncSender(this.m_mainSocket, this.m_mainSocket.RemoteEndPoint, this.OnSeparateThreadSendError); } this.BeginReceive(); this.m_online = true; this.PrivateOnConnected(new MsgEventArgs(\"连接成功\")); return this; } } this.m_mainSocket.Dispose(); throw new TimeoutException(); } ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:5:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"总结\r本篇讲述底层Socket实现，使用完成端口模型和内存池提高Socket性能。 ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:6:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 Socket模型中需要考虑对各种方法的封装，需要考虑对各种业务场景的扩展，在实现业务流的同时，针对业务流的各个横切面做扩展，甚至业务流本身可以被替换。常用的扩展方式有下面几种，并按耦合从高到低的顺序：继承/泛型，接口/委托/事件，插件/扩展方法。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-15","objectID":"/2022/09/touchsocket5-encapsulationextension/:1:0","tags":["TouchSocket0.3.5","封装和扩展"],"title":"TouchSocket 封装和扩展","uri":"/2022/09/touchsocket5-encapsulationextension/"},{"categories":"TouchSocket0.3.5","content":"Socket\rSocket模型如下图： TouchSocket封装。客户端所有接口封装成TCPClient；服务端将通讯部分桥接给SocketClient，外部接口封装成TCPServer，并通过泛型将SocketClient的类型传入；数据包封装成XXHandlingAdapter；参数设置TouchSocketConfig 可扩展的横切面，横切面主要有：虚方法用于继承重写，事件委托用于订阅，插件扩展方法用于插件扩展。 服务端： 客户端： ","date":"2022-09-15","objectID":"/2022/09/touchsocket5-encapsulationextension/:2:0","tags":["TouchSocket0.3.5","封装和扩展"],"title":"TouchSocket 封装和扩展","uri":"/2022/09/touchsocket5-encapsulationextension/"},{"categories":"TouchSocket0.3.5","content":"总结\r服务端封装成TCPServer,SocketClient；客户端封装成TCPClient，将通讯包封装成XXHandlingAdapter，参数设置封装TouchSocketConfig。 通过扩展方法/插件，事件/委托，虚方法提供横切面的扩展。 ","date":"2022-09-15","objectID":"/2022/09/touchsocket5-encapsulationextension/:3:0","tags":["TouchSocket0.3.5","封装和扩展"],"title":"TouchSocket 封装和扩展","uri":"/2022/09/touchsocket5-encapsulationextension/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 读写文件是应用中必不可少的操作，也是比较经典的问题。该问题一般要求： 允许多个读者对文件执行读操作。 只允许一个写者往文件中写信息。 任一写者写完前不允许其他读者或写者工作。 写者执行写操作前应让已有读者和写者全部退出。 实现要求的逻辑代码: //声明 Semaphore rwlock=1;//读写锁 int rcount=0;//读者数量 Semaphore countlock=1;//读者数量锁 Semaphore firstwlock=1;//写优先锁 //写逻辑 Write() { while(1) { firstwlock.WaitOne(); rwlock.WaitOne(); //Todo:写文件 rwlock.Set(); firstwlock.Set(); } } //读逻辑 Reader() { while(1) { firstwlock.WaitOne(); countlock.WaitOne(); if(rcount==0) rwlock.WaitOne(); rcount++; countlock.Set(); firstwlock.Set(); //Todo:读文件 countlock.WaitOne(); rcount--; if(rcount==0) rwlock.Set(); countlock.Set(); } } 下面看一下TouchSocket文件池解析: 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-14","objectID":"/2022/09/touchsocket4-filepool/:1:0","tags":["TouchSocket0.3.5","文件池"],"title":"TouchSocket 文件池","uri":"/2022/09/touchsocket4-filepool/"},{"categories":"TouchSocket0.3.5","content":"文件池FilePool\r池的作用是复用文件池中对于大文件缓存了文件句柄，对于小文件缓存了文件内容。这样多次对文件的操作就不需要频繁创建和销毁文件句柄。提高文件操作性能。 对于缓存元数据的封装为FileStorage，也是真正对文件操作的实现类。FilePool保存其字典进行复用。 为了便于对FileStorage的操作，将读写操作封装成FileStorageReader和FileStorageWriter 在写入文件时为了保存的实时写入状态，封装了TouchRpcFileStream，并将状态信息封装成TouchRpcFileInfo。 FilePool和FileStorage类中相关操作全部加锁以保证线程安全，并通过原子操作保证FileStorage引用数量 相关类图： 读写模式的互斥通过状态保证: /// \u003csummary\u003e /// 加载文件为读取流 /// \u003c/summary\u003e /// \u003cparam name=\"path\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static void LoadFileForRead(string path) { lock (m_locker) { if (string.IsNullOrEmpty(path)) { throw new System.ArgumentException($\"“{nameof(path)}”不能为 null 或空。\", nameof(path)); } path = Path.GetFullPath(path); if (pathStream.TryGetValue(path, out FileStorage storage)) { if (storage.Access != FileAccess.Read) { throw new Exception(\"该路径的文件已经被加载为写入模式。\"); } return; } if (FileStorage.TryCreateFileStorage(path, FileAccess.Read, out FileStorage fileStorage, out string msg)) { pathStream.TryAdd(path, fileStorage); } else { throw new Exception(msg); } } } 读写操作： /// \u003csummary\u003e /// 从指定位置，读取数据到缓存区。线程安全。 /// \u003c/summary\u003e /// \u003cparam name=\"stratPos\"\u003e\u003c/param\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"length\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public int Read(long stratPos, byte[] buffer, int offset, int length) { using (WriteLock writeLock = new WriteLock(this.m_lockSlim)) { if (this.m_disposedValue) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_fileAccess != FileAccess.Read) { throw new Exception(\"该流不允许读取。\"); } if (this.m_cache) { int r = (int)Math.Min(this.m_fileData.Length - stratPos, length); Array.Copy(this.m_fileData, stratPos, buffer, offset, r); return r; } else { this.m_fileStream.Position = stratPos; return this.m_fileStream.Read(buffer, offset, length); } } } /// \u003csummary\u003e /// 从指定位置，写入数据到存储区。线程安全。 /// \u003c/summary\u003e /// \u003cparam name=\"stratPos\"\u003e\u003c/param\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"length\"\u003e\u003c/param\u003e public void Write(long stratPos, byte[] buffer, int offset, int length) { using (WriteLock writeLock = new WriteLock(this.m_lockSlim)) { if (this.m_disposedValue) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_fileAccess != FileAccess.Write) { throw new Exception(\"该流不允许写入。\"); } this.m_fileStream.Position = stratPos; this.m_fileStream.Write(buffer, offset, length); this.m_fileStream.Flush(); } } ","date":"2022-09-14","objectID":"/2022/09/touchsocket4-filepool/:2:0","tags":["TouchSocket0.3.5","文件池"],"title":"TouchSocket 文件池","uri":"/2022/09/touchsocket4-filepool/"},{"categories":"TouchSocket0.3.5","content":"总结\r讲述了经典的读写问题，介绍了TouchSocket中FilePool的封装，该封装并不复杂，但我觉得一个简单且功能强大的设计才是一个优秀的设计。 ","date":"2022-09-14","objectID":"/2022/09/touchsocket4-filepool/:3:0","tags":["TouchSocket0.3.5","文件池"],"title":"TouchSocket 文件池","uri":"/2022/09/touchsocket4-filepool/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 池是高性能组件中必不可少的东西，池最主要的功能是复用，在软件中创建和销毁对象是有成本的，消耗的资源也特别多。在需要大量使用相同或相似对象的场景下使用池，需要使用对象时去池中取，用完之后再放回到池中，避免创建和销毁对象，从而提高软件的性能。 池在设计时要注意以下几点： 池中对象的存储尽量利用高速缓冲区，这样可以更快速访问对象。 池中对象可以用原型模式加以改造。 池中对象的使用需要注意内存泄漏问题。因为对象使用完并没有销毁。 TouchSocket用到很多的池，字节池 (BytePool)、等待处理池(WaitHandlePool)、文件池(FilePool)、对象池(ObjectPool)，本文介绍字节池和等待处理池 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:1:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"字节池BytePool\r字节数组的复用是非常常见的做法，在高速IO中一定可以看见它的身影，微软对其也进行了各种封装。 TouchSocket字节池保存所有创建的字节数组，并根据数组的长度将其放在字典中等待复用，相同长度的数组通过队列进行缓存，最终字节此的样子 private static readonly ConcurrentDictionary\u003clong, BytesQueue\u003e bytesDictionary = new ConcurrentDictionary\u003clong, BytesQueue\u003e(); long:表示数组长度 BytesQueue:表示该长度数组队列。内部就是private readonly ConcurrentQueue\u003cbyte[]\u003e bytesQueue = new ConcurrentQueue\u003cbyte[]\u003e(); 字节池并没有直接对外暴露字节数组，而是将其封装成ByteBlock，字节数组的装饰对象：ByteBlock，内部使用字节数组实现功能，并装饰Stream的对象。 写入数据可以自动扩容，扩容基数1.5倍。 m_needDis控制Dispose时字节数组是否返回给池中 /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e /// \u003cparam name=\"byteSize\"\u003e默认64K\u003c/param\u003e /// \u003cparam name=\"equalSize\"\u003e默认false\u003c/param\u003e public ByteBlock(int byteSize = 1024 * 64, bool equalSize = false) { this.m_needDis = true; this.m_buffer = BytePool.GetByteCore(byteSize, equalSize); this.m_using = true; } /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e /// \u003cparam name=\"bytes\"\u003e\u003c/param\u003e public ByteBlock(byte[] bytes) { this.m_buffer = bytes ?? throw new ArgumentNullException(nameof(bytes)); this.m_length = bytes.Length; this.m_using = true; } /// \u003csummary\u003e /// 扩容增长比，默认为1.5， /// min：1.5 /// \u003c/summary\u003e public static float Ratio { get =\u003e m_ratio; set { if (value \u003c 1.5) { value = 1.5f; } m_ratio = value; } } /// \u003csummary\u003e /// 读取数据，然后递增Pos /// \u003c/summary\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"length\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e /// \u003cexception cref=\"ObjectDisposedException\"\u003e\u003c/exception\u003e public override int Read(byte[] buffer, int offset, int length) { if (!this.m_using) { throw new ObjectDisposedException(this.GetType().FullName); } int len = this.m_length - this.m_position \u003e length ? length : this.CanReadLen; Array.Copy(this.m_buffer, this.m_position, buffer, offset, len); this.m_position += len; return len; } /// \u003csummary\u003e /// 写入 /// \u003c/summary\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"count\"\u003e\u003c/param\u003e /// \u003cexception cref=\"ObjectDisposedException\"\u003e\u003c/exception\u003e public override void Write(byte[] buffer, int offset, int count) { if (count == 0) { return; } if (!this.m_using) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_buffer.Length - this.m_position \u003c count) { int need = this.m_buffer.Length + count - ((int)(this.m_buffer.Length - this.m_position)); int lend = this.m_buffer.Length; while (need \u003e lend) { lend = (int)(lend * m_ratio); } this.SetCapacity(lend, true); } Array.Copy(buffer, offset, this.m_buffer, this.m_position, count); this.m_position += count; this.m_length = Math.Max(this.m_position, this.m_length); } /// \u003csummary\u003e /// 重新设置容量 /// \u003c/summary\u003e /// \u003cparam name=\"size\"\u003e新尺寸\u003c/param\u003e /// \u003cparam name=\"retainedData\"\u003e是否保留元数据\u003c/param\u003e /// \u003cexception cref=\"ObjectDisposedException\"\u003e\u003c/exception\u003e public void SetCapacity(int size, bool retainedData = false) { if (!this.m_using) { throw new ObjectDisposedException(this.GetType().FullName); } byte[] bytes = new byte[size]; if (retainedData) { Array.Copy(this.m_buffer, 0, bytes, 0, this.m_buffer.Length); } BytePool.Recycle(this.m_buffer); this.m_buffer = bytes; } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"disposing\"\u003e\u003c/param\u003e protected sealed override void Dispose(bool disposing) { if (this.m_holding) { return; } if (this.m_needDis) { if (Interlocked.Decrement(ref this.m_dis) == 0) { GC.SuppressFinalize(this); BytePool.Recycle(this.m_buffer); this.Dis(); } } base.Dispose(disposing); } 该字节池具有如下特性 每隔1小时自动清理所有缓存的字节数组 最大缓存的不同字节数组的数量为100 回收的数组可以设置是否清零 缓存的最大字节数512M 缓存字节数组的范围1KB~20M 自动清理功能，每1个小时会自动清理池中所有的字节数组 static BytePool() { m_timer = new Timer((o) =\u003e { BytePool.Clear(); }, null, 1000 * 60 * 60, 1000 * 60 * 60);//1小时 m_keyCapacity = 100; m_autoZero = false; m_maxSize = 1024 * 1024 * 512;//512M SetBlockSize(1024, 1024 * 1024 * 20);//1KB~ 20M AddSizeKey(10240);//10KB } /// \u003csummary\u003e /// 清理 /// \u003c/summary\u003e public static void Clear() { bytesDictionary.Clear(); GC.Collect(); } /// \u003csummary\u003e /// 获取内存核心。获取的核心可以不用归还。 /// \u003c/summary\u003e /// \u003cparam name=\"byteSize\"\u003e\u003c/param\u003e /// \u003cparam na","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:2:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"等待处理池WaitHandlePool\u003cT\u003e\r该池的主要是为了复用WaitData\u003cT\u003e对象，该对象的功能是：交由外部系统处理对象并返回数据。当给外部系统发送命令，等待外部系统执行命令，并在规定时间内返回数据。 该功能的传统实现方式是： 创建命令队列，将所有已发送外部系统的命令装进命令队列中，同时记录命令的发送时间； 当外部系统返回数据时，去队列中找到对应的命令执行命令成功的方法；如果命令队列中没有对应的命令，调用未知数据处理方法； 设置定时器定期扫描命令队列，将超期没有接收到返回数据的命令移除，并调用对应命令异常执行方法； 该池的实现方式是构造WaitData\u003cT\u003e对象集合，发送命令前构建WaitData对象，发送完命令后该对象使用信号量阻塞发送命令的线程，当收到返回数据时，信号量置位继续执行，处理对应接收数据；信号量阻塞的时候可以设置阻塞时间，时间到则执行对应异常方法。 由于WaitData对象需要构建信号量，创建和销毁的代价比较大。WaitHandlePool构建 ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e waitQueue;队列保存空闲WaitData。 ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e waitQueue;保存所有已经使用WaitData。 /// \u003csummary\u003e /// 等待数据对象 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public class WaitData\u003cT\u003e : DisposableObject { private WaitDataStatus m_status; private readonly AutoResetEvent m_waitHandle; private T m_waitResult; /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e public WaitData() { this.m_waitHandle = new AutoResetEvent(false); } /// \u003csummary\u003e /// 状态 /// \u003c/summary\u003e public WaitDataStatus Status =\u003e this.m_status; /// \u003csummary\u003e /// 等待数据结果 /// \u003c/summary\u003e public T WaitResult =\u003e this.m_waitResult; /// \u003csummary\u003e /// 取消任务 /// \u003c/summary\u003e public void Cancel() { this.m_status = WaitDataStatus.Canceled; this.m_waitHandle.Set(); } /// \u003csummary\u003e /// 释放 /// \u003c/summary\u003e /// \u003cparam name=\"disposing\"\u003e\u003c/param\u003e protected override void Dispose(bool disposing) { this.m_status = WaitDataStatus.Disposed; this.m_waitResult = default; this.m_waitHandle.Dispose(); base.Dispose(disposing); } /// \u003csummary\u003e /// Reset。 /// 设置\u003csee cref=\"WaitResult\"/\u003e为null。然后重置状态为\u003csee cref=\"WaitDataStatus.Default\"/\u003e，waitHandle.Reset() /// \u003c/summary\u003e public bool Reset() { this.m_status = WaitDataStatus.Default; this.m_waitResult = default; return this.m_waitHandle.Reset(); } /// \u003csummary\u003e /// 使等待的线程继续执行 /// \u003c/summary\u003e public bool Set() { this.m_status = WaitDataStatus.SetRunning; return this.m_waitHandle.Set(); } /// \u003csummary\u003e /// 使等待的线程继续执行 /// \u003c/summary\u003e /// \u003cparam name=\"waitResult\"\u003e等待结果\u003c/param\u003e public bool Set(T waitResult) { this.m_waitResult = waitResult; this.m_status = WaitDataStatus.SetRunning; return this.m_waitHandle.Set(); } /// \u003csummary\u003e /// 加载取消令箭 /// \u003c/summary\u003e /// \u003cparam name=\"cancellationToken\"\u003e\u003c/param\u003e public void SetCancellationToken(CancellationToken cancellationToken) { if (cancellationToken.CanBeCanceled) { cancellationToken.Register(this.Cancel); } } /// \u003csummary\u003e /// 载入结果 /// \u003c/summary\u003e public void SetResult(T result) { this.m_waitResult = result; } /// \u003csummary\u003e /// 等待指定毫秒 /// \u003c/summary\u003e /// \u003cparam name=\"millisecond\"\u003e\u003c/param\u003e public WaitDataStatus Wait(int millisecond) { if (!this.m_waitHandle.WaitOne(millisecond)) { this.m_status = WaitDataStatus.Overtime; } return this.m_status; } } /// \u003csummary\u003e /// 等待处理数据 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public class WaitHandlePool\u003cT\u003e : IDisposable where T : IWaitResult { private readonly SnowflakeIDGenerator idGenerator; private readonly ConcurrentDictionary\u003clong, WaitData\u003cT\u003e\u003e waitDic; private readonly ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e waitQueue; /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e public WaitHandlePool() { this.waitDic = new ConcurrentDictionary\u003clong, WaitData\u003cT\u003e\u003e(); this.waitQueue = new ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e(); this.idGenerator = new SnowflakeIDGenerator(4); } /// \u003csummary\u003e /// 销毁 /// \u003c/summary\u003e /// \u003cparam name=\"waitData\"\u003e\u003c/param\u003e public void Destroy(WaitData\u003cT\u003e waitData) { if (waitData.DisposedValue) { throw new ObjectDisposedException(nameof(waitData)); } if (this.waitDic.TryRemove(waitData.WaitResult.Sign, out _)) { waitData.Reset(); this.waitQueue.Enqueue(waitData); } } /// \u003csummary\u003e /// 释放 /// \u003c/summary\u003e public void Dispose() { foreach (var item in this.waitDic.Values) { item.Dispose(); } foreach (var item in this.waitQueue) { item.Dispose(); } this.waitDic.Clear(); this.waitQueue.Clear(); } /// \u003csummary\u003e /// 获取一个可等待对象 /// \u003c/summary\u003e /// \u003cparam name=\"result\"\u003e\u003c/param\u003e /// \u003cparam name=\"autoSign\"\u003e设置为false时，不会生成sign\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public WaitData\u003cT\u003e GetWaitData(T result, bool autoSign = true) { WaitData\u003cT\u003e waitData; if (this.waitQ","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:3:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"总结\r主要介绍了字节池和等待处理池，详细介绍了相关特性和业务功能的实现。对于等待处理池我觉得还可以使用TaskCompletionSource\u003cTResult\u003e来实现，消耗比信号量更小，同时是异步执行，不会阻塞线程。 ","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:4:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 容器现在已经成为各种组件的标配了，为什么容器这么火，确实是太好用了。 表面上容器解决的是耦合问题，实际上容器实现了框架对流程的控制。 表面的耦合问题：没有容器，高层逻辑想要实现某个具体功能，只能依赖某个具体类或者具体工厂。当变化越来越多，改动越来越大，具体类之间依赖关系就像麻绳。里氏替换和依赖倒置根本无法实现。容器的出现将所有的具体类都保存在容器中，实现依赖倒置和里氏替换，系统高层和底层实现解耦。 框架对流程的控制问题：框架实现了整个应用流程的编排，流程中肯定需要具体的执行类。一旦依赖某个执行类就无法应对变化，具体类和流程严重耦合。整个框架就像被焊死，无法应对任何变化。容器就像是活页，连接着具体类和框架流程，当具体类发生变化，对框架没有任何影响，这也就使得框架的应用范围更广，实现的功能更多，框架中任何部件都是可以改变的。 唯一不变的就是改变，如果没有改变，也就不需要任何模式了。我们痛恨变化，同时也热爱变化，在痛苦中追求无限可能。 言归正传，TouchSocket框架实现了一个简易版的依赖注入容器。一起来看一下。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-09","objectID":"/2022/09/touchsocket2-dependencyinjection/:1:0","tags":["TouchSocket0.3.5","依赖注入容器"],"title":"TouchSocket 依赖注入容器","uri":"/2022/09/touchsocket2-dependencyinjection/"},{"categories":"TouchSocket0.3.5","content":"依赖注入\r简单点，容器其实就是一个字典，一个包含一个key和具体类的字典，将框架中所有依赖具体类的地方换成key，当执行到key的时候去字典中根据key取出具体类就可以了。 当然字典也需要生成，就是在应用开始的时候根据需求构建出字典。以后即使变化，也只变化开始构建的部分，最大程度减少修改。 真正的容器就是将字典改造一下，既然由容器管理，就应该负责到底，管理具体类的生命周期，什么时候创建，什么时候销毁，怎么创建。 首先字典中的具体类需要改造一下，变成描述类。 生命周期分为:单例，瞬态，域。 /// \u003csummary\u003e /// 注入依赖对象 /// \u003c/summary\u003e public class DependencyDescriptor { /// \u003csummary\u003e /// 初始化一个单例实例。 /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"instance\"\u003e\u003c/param\u003e public DependencyDescriptor(Type fromType, object instance) { this.FromType = fromType; this.ToInstance = instance; this.Lifetime = Lifetime.Singleton; this.ToType = instance.GetType(); } /// \u003csummary\u003e /// 初始化一个完整的服务注册 /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"toType\"\u003e\u003c/param\u003e /// \u003cparam name=\"lifetime\"\u003e\u003c/param\u003e public DependencyDescriptor(Type fromType, Type toType, Lifetime lifetime) { this.FromType = fromType; this.Lifetime = lifetime; this.ToType = toType; } /// \u003csummary\u003e /// 实例类型 /// \u003c/summary\u003e public Type ToType { get; } /// \u003csummary\u003e /// 实例 /// \u003c/summary\u003e public object ToInstance { get; set; } /// \u003csummary\u003e /// 生命周期 /// \u003c/summary\u003e public Lifetime Lifetime { get; } /// \u003csummary\u003e /// 注册类型 /// \u003c/summary\u003e public Type FromType { get; } } /// \u003csummary\u003e /// 注入项的生命周期。 /// \u003c/summary\u003e public enum Lifetime { /// \u003csummary\u003e /// 单例对象 /// \u003c/summary\u003e Singleton, /// \u003csummary\u003e /// 以\u003csee cref=\"IScopedContainer\"/\u003e接口为区域实例单例。 /// \u003c/summary\u003e Scoped, /// \u003csummary\u003e /// 瞬时对象 /// \u003c/summary\u003e Transient } 字典中的key改成FromType+Name。 最终字典变成了 private readonly ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e registrations = new ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e();这样。 看一下怎么实现注入和解析的。下面是原代码，Resolve方法根据生命周期实现解析逻辑；Create方法负责创建，同时各种注入方式；Register实现构建字典。 该容器有一些特点： 在注入容器时，提供了一个Name，key被构建成FromType+Name。这样的好处是可以根据Name来获取具体类。 同时对于多态的问题，同一个接口的多个实现没有实现注入，只能通过Name来区别了。 如果FromType不是抽象类，不需要注入，也可以Resolve出来。 Resolve会根据所有构造函数参数的个数最多的那个构造函数。 可以使用DependencyInject，DependencyParamterInject特性进行控制。 实现了构造函数注入，属性注入和方法注入 /// \u003csummary\u003e /// IOC容器 /// \u003c/summary\u003e public class Container : IContainer { private readonly ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e registrations = new ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e(); /// \u003csummary\u003e /// 初始化一个IOC容器 /// \u003c/summary\u003e public Container() { this.RegisterSingleton\u003cIContainer\u003e(this); } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public bool IsRegistered(Type fromType, string key = \"\") { return this.registrations.ContainsKey($\"{fromType.FullName}{key}\"); } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"descriptor\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e public void Register(DependencyDescriptor descriptor, string key = \"\") { string k = $\"{descriptor.FromType.FullName}{key}\"; this.registrations.AddOrUpdate(k, descriptor, (k, v) =\u003e { return descriptor; }); } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"ps\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public object Resolve(Type fromType, object[] ps = null, string key = \"\") { if (fromType == typeof(IScopedContainer)) { return this.GetScopedContainer(); } string k; DependencyDescriptor descriptor; if (fromType.IsGenericType) { Type type = fromType.GetGenericTypeDefinition(); k = $\"{type.FullName}{key}\"; if (this.registrations.TryGetValue(k, out descriptor)) { if (descriptor.Lifetime == Lifetime.Singleton) { if (descriptor.ToInstance != null) { return descriptor.ToInstance; } lock (descriptor) { if (descriptor.ToInstance != null) { return descriptor.ToInstance; } if (descriptor.ToType.IsGenericType) { return descriptor.ToInstance = this.Create(descriptor.ToType.MakeGenericType(fromType.GetGenericArguments()), ps); } else { return descriptor.ToInstance = this.Create(descriptor.ToType, ps); } } } if (descriptor.ToType.IsGenericType) { return this.Create(descriptor.ToType.MakeGenericType(fromType.GetGenericArguments()), ps); } el","date":"2022-09-09","objectID":"/2022/09/touchsocket2-dependencyinjection/:2:0","tags":["TouchSocket0.3.5","依赖注入容器"],"title":"TouchSocket 依赖注入容器","uri":"/2022/09/touchsocket2-dependencyinjection/"},{"categories":"TouchSocket0.3.5","content":"总结\r该容器虽然简单，但是足够使用，小巧紧致，非常值得学习。不需要注入直接解析对象的方式，虽然有点违反依赖倒置原则，但是在使用中确实是一个非常实用的功能。有一点缺陷是没有实现Dispose和瞬态对象的弱引用，当域生命周期结束的时候，Dispose容器同时销毁所有域创建出的瞬态对象。 ","date":"2022-09-09","objectID":"/2022/09/touchsocket2-dependencyinjection/:3:0","tags":["TouchSocket0.3.5","依赖注入容器"],"title":"TouchSocket 依赖注入容器","uri":"/2022/09/touchsocket2-dependencyinjection/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 该框架实现了广泛的Socket应用，NAT，各种RPC，文件传输，WebAPI，WebSocket，非常优秀的框架，学习一下，有问题可以相互探讨。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index 本章主要介绍TouchSocket的主要特性之一：依赖属性 ","date":"2022-09-07","objectID":"/2022/09/touchsocket1-dependencyproperties/:1:0","tags":["TouchSocket0.3.5","依赖属性"],"title":"TouchSocket 依赖属性","uri":"/2022/09/touchsocket1-dependencyproperties/"},{"categories":"TouchSocket0.3.5","content":"依赖属性\r用过WPF都知道依赖属性，其是绑定，动画，样式的基础，提供了属性值，更改通知等功能，该框架中的依赖属性相当于简易版本，提供了应用的思路。 依赖属性可以看成是Key和Value的封装。依赖属性类：名称，所属类型，值类型和值，还包含了一个工厂方法，用来创建依赖属性，创建时可以提供初始值。 /// \u003csummary\u003e /// 依赖项属性 /// \u003c/summary\u003e [DebuggerDisplay(\"Name={Name},Type={ValueType}\")] public class DependencyProperty { /// \u003csummary\u003e /// 属性名称 /// \u003c/summary\u003e protected string m_name; /// \u003csummary\u003e /// 所属类型 /// \u003c/summary\u003e protected Type m_owner; /// \u003csummary\u003e /// 值类型 /// \u003c/summary\u003e protected Type m_valueType; private object m_value; /// \u003csummary\u003e /// 依赖项属性 /// \u003c/summary\u003e private DependencyProperty() { } /// \u003csummary\u003e /// 默认值 /// \u003c/summary\u003e public object DefauleValue =\u003e this.m_value; /// \u003csummary\u003e /// 属性名 /// \u003c/summary\u003e public string Name =\u003e this.m_name; /// \u003csummary\u003e /// 所属类型 /// \u003c/summary\u003e public Type Owner =\u003e this.m_owner; /// \u003csummary\u003e /// 值类型 /// \u003c/summary\u003e public Type ValueType =\u003e this.m_valueType; internal void DataValidation(object value) { if (value == null) { if (typeof(ValueType).IsAssignableFrom(this.m_valueType)) { throw new Exception($\"属性“{this.m_name}”赋值类型不允许出现Null\"); } } else if (!this.m_valueType.IsAssignableFrom(value.GetType())) { throw new Exception($\"属性“{this.m_name}”赋值类型与注册类型不一致，应当注入“{this.m_valueType}”类型\"); } } internal void SetDefauleValue(object value) { this.DataValidation(value); this.m_value = value; } /// \u003csummary\u003e /// 注册依赖项属性。 /// \u003cpara\u003e依赖属性的默认值，可能会应用于所有的\u003csee cref=\"IDependencyObject\"/\u003e\u003c/para\u003e /// \u003c/summary\u003e /// \u003cparam name=\"propertyName\"\u003e\u003c/param\u003e /// \u003cparam name=\"valueType\"\u003e\u003c/param\u003e /// \u003cparam name=\"owner\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e依赖项属性值，一般该值应该是值类型，因为它可能会被用于多个依赖对象。\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static DependencyProperty Register(string propertyName, Type valueType, Type owner, object value) { DependencyProperty dp = new DependencyProperty { m_name = propertyName, m_valueType = valueType, m_owner = owner }; dp.SetDefauleValue(value); return dp; } } 如何管理依赖属性，类中创建依赖属性，并设置和获取依赖属性的值。首先实现接口，可以获取和设置依赖属性的值，实现一个基类，实现该接口，所有包含依赖属性的类继承该基类，就可以实现操作依赖属性了。 该框架做了进一步扩展，在基类中添加了一个依赖属性字典，可以添加外部依赖属性。 也就是在基类中保存了一个Key，Value的字典，通过特定的Key获取到Value，在配置的时候特别有用，配置类Option/Config怎么应对变化，写组件的时候发现配置项多需要添加属性怎么办，修改配置项，违反开放封闭原则；使用继承，显得太重；增加一个配置类，还不如使用继承。 把配置项修改成字典，所有信息通过key,value保存，可以应对开放封闭原则。显然该框架就说这样干的，key是依赖属性，vlaue是依赖属性的值。 /// \u003csummary\u003e /// 依赖对象接口 /// \u003c/summary\u003e public interface IDependencyObject : System.IDisposable { /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e object GetValue(DependencyProperty dp); /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public T GetValue\u003cT\u003e(DependencyProperty dp); /// \u003csummary\u003e /// 设置依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e\u003c/param\u003e public DependencyObject SetValue(DependencyProperty dp, object value); } /// \u003csummary\u003e /// 依赖项对象. /// 线程安全。 /// \u003c/summary\u003e public class DependencyObject : DisposableObject, IDependencyObject, System.IDisposable { /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e public DependencyObject() { this.m_dp = new ConcurrentDictionary\u003cDependencyProperty, object\u003e(); } [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)] private readonly ConcurrentDictionary\u003cDependencyProperty, object\u003e m_dp; /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public object GetValue(DependencyProperty dp) { if (this.m_dp.TryGetValue(dp, out object value)) { return value; } else { return dp.DefauleValue; } } /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public T GetValue\u003cT\u003e(DependencyProperty dp) { try { return (T)this.GetValue(dp); } catch { return default; } } /// \u003csummary\u003e /// 设置依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e\u003c/param\u003e public DependencyObject SetValue(DependencyProperty dp, object value) { dp.DataValidation(value); if (this.m_dp.ContainsKey(dp)) { this.m_dp[dp] = value; } els","date":"2022-09-07","objectID":"/2022/09/touchsocket1-dependencyproperties/:2:0","tags":["TouchSocket0.3.5","依赖属性"],"title":"TouchSocket 依赖属性","uri":"/2022/09/touchsocket1-dependencyproperties/"},{"categories":"TouchSocket0.3.5","content":"总结\r依赖属性这样的应用方式非常优秀，满足了扩展开放，单一职责。如果有其他的应用方式欢迎评论。 ","date":"2022-09-07","objectID":"/2022/09/touchsocket1-dependencyproperties/:3:0","tags":["TouchSocket0.3.5","依赖属性"],"title":"TouchSocket 依赖属性","uri":"/2022/09/touchsocket1-dependencyproperties/"},{"categories":"算法","content":"实现队列的一些思路\r数组的优劣： 读取：连续的地址空间，数组全部或者部分元素被连续存在CPU缓存里面，读取速度非常快。 插入/删除/扩容：插入和删除，需要修改该元素之前或之后所有元素的位置，扩容时需要重新找较大的内存块，将原数组中所有数据复制到新内存块中。这些操作都非常耗时。 链表的优劣： 读取：链表的节点分散在堆空间中，无法利用CPU缓存，读写速度比较慢，是数组的33倍 插入/删除/扩容：不需要改变原来元素的位置，仅仅修改节点信息即可。但是频繁的插入删除会导致堆中有大量碎片化内存。 链表每个节点不仅需要保存数据还需要保存下一个节点的位置。 较好的方式是结合数组和链表的优势，用链表节点将固定大小的数组连接起来组成大的内存块，即易于扩展又在一定范围内保持良好的访问速度。 在需要构建内存池，缓存队列等应用场景中均可使用此方法进行优化。 ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:1:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"队列接口\rpublic interface IQueue\u003cTItem\u003e : IEnumerable\u003cTItem\u003e, IDisposable { bool IsEmpty { get; } int Length { get; } void Enqueue(TItem item); TItem Dequeue(); } ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:2:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"基于数组的扩容队列\rpublic class SGResizingArrayQueue\u003cTItem\u003e : IQueue\u003cTItem\u003e { public SGResizingArrayQueue() { _first = 0; _last = 0; _items = new TItem[2]; } public IEnumerator\u003cTItem\u003e GetEnumerator() { if (!IsEmpty) { for (var i = _first; i \u003c _last; i++) { yield return _items[i]; } } } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } public void Dispose() { Dispose(true); } protected virtual void Dispose(bool disposing) { if (disposing) { if (!IsEmpty) { for (var i = _first; i \u003c _last; i++) { _items[i] = default; } _items = null; } } } private TItem[] _items; private int _first; private int _last; public bool IsEmpty =\u003e (_last - _first) == 0; public int Length =\u003e _last - _first; private void resize(int size) { var temitems = new TItem[size]; var temlength = Length; Array.Copy(_items, _first, temitems, 0, Length); _first = 0; _last = temlength; _items = temitems; } public void Enqueue(TItem item) { if (_last == _items.Length) resize(Length * 2); _items[_last++] = item; } public TItem Dequeue() { if (IsEmpty) return default; var item = _items[_first++]; if (Length \u003c _items.Length / 4) resize(_items.Length / 2); return item; } } ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:3:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"基于链表的扩容队列\rpublic class SGLinkedQueue\u003cTItem\u003e : IQueue\u003cTItem\u003e { private Node _first; private Node _last; private int _length; public SGLinkedQueue() { _length = 0; } private class Node { public TItem Item { set; get; } public Node Next { set; get; } } public IEnumerator\u003cTItem\u003e GetEnumerator() { if (!IsEmpty) { var temnode = _first; while (temnode != default) { var item = temnode.Item; temnode = temnode.Next; yield return item; } } } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } public void Dispose() { Dispose(true); } protected virtual void Dispose(bool disposing) { if (disposing) { if (!IsEmpty) { var temfirst = _first; while (temfirst != default) { temfirst.Item = default; temfirst = temfirst.Next; } _length = 0; } } } public bool IsEmpty =\u003e _length == 0; public int Length =\u003e _length; public void Enqueue(TItem item) { var temnode = _last; _last = new Node(); _last.Item = item; _last.Next = null; if (IsEmpty) _first = _last; else temnode.Next = _last; _length++; } public TItem Dequeue() { if (_length \u003e 0) { var temitem = _first.Item; _first = _first.Next; _length--; return temitem; } return default; } } ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:4:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"结合数组和链表的扩容队列\rclass SGArraySegment\u003cTItem\u003e { public TItem[] Array { get; private set; } public SGArraySegment\u003cTItem\u003e Next { get; set; } public int Offset { get; set; } public int End { get; set; } = -1; public SGArraySegment(TItem[] array) { Array = array; } public bool IsAvailable { get { return Array.Length \u003e (End + 1); } } public void Write(TItem value) { Array[++End] = value; } } class SGPipeQueue\u003cTItem\u003e : IValueTaskSource\u003cTItem\u003e, IDisposable { private const int _segmentSize = 5; private SGArraySegment\u003cTItem\u003e _first; private SGArraySegment\u003cTItem\u003e _current; private object _syncRoot = new object(); private static readonly ArrayPool\u003cTItem\u003e _pool = ArrayPool\u003cTItem\u003e.Shared; private ManualResetValueTaskSourceCore\u003cTItem\u003e _taskSourceCore; private bool _waiting = false; private bool _lastReadIsWait = false; private int _length; public SGPipeQueue() { SetBufferSegment(CreateSegment()); _taskSourceCore = new ManualResetValueTaskSourceCore\u003cTItem\u003e(); } SGArraySegment\u003cTItem\u003e CreateSegment() { return new SGArraySegment\u003cTItem\u003e(_pool.Rent(_segmentSize)); } void SetBufferSegment(SGArraySegment\u003cTItem\u003e segment) { if (_first == null) _first = segment; var current = _current; if (current != null) current.Next = segment; _current = segment; } public int Write(TItem target) { lock (_syncRoot) { if (_waiting) { _waiting = false; _taskSourceCore.SetResult(target); return _length; } var current = _current; if (!current.IsAvailable) { current = CreateSegment(); SetBufferSegment(current); } current.Write(target); _length++; return _length; } } public ValueTask\u003cTItem\u003e ReadAsync() { lock (_syncRoot) { if (TryRead(out TItem value)) { if (_lastReadIsWait) { _taskSourceCore.Reset(); _lastReadIsWait = false; } _length--; if (_length == 0) OnWaitTaskStart(); return new ValueTask\u003cTItem\u003e(value); } _waiting = true; _lastReadIsWait = true; _taskSourceCore.Reset(); OnWaitTaskStart(); return new ValueTask\u003cTItem\u003e(this, _taskSourceCore.Version); } } private bool TryRead(out TItem value) { var first = _first; if (first.Offset \u003c first.End) { value = first.Array[first.Offset]; first.Array[first.Offset] = default; first.Offset++; return true; } else if (first.Offset == first.End) { if (first == _current) { value = first.Array[first.Offset]; first.Array[first.Offset] = default; first.Offset = 0; first.End = -1; return true; } else { value = first.Array[first.Offset]; first.Array[first.Offset] = default; _first = first.Next; _pool.Return(first.Array); return true; } } value = default; return false; } protected virtual void OnWaitTaskStart() { } public virtual void Clear() { lock (_syncRoot) { if (_lastReadIsWait) { _taskSourceCore.Reset(); _lastReadIsWait = false; } var first = _first; if (first.Offset \u003c= first.End) { while (first != _current) { for (int i = first.Offset; i \u003c= first.End; i++) { first.Array[i] = default; } _first = first.Next; _pool.Return(first.Array); first = _first; } for (int i = first.Offset; i \u003c= first.End; i++) { first.Array[i] = default; } first.Offset = 0; first.End = -1; } } } public void Dispose() { lock (_syncRoot) { var segment = _first; while (segment != null) { _pool.Return(segment.Array); segment = segment.Next; } _first = null; _current = null; } } TItem IValueTaskSource\u003cTItem\u003e.GetResult(short token) { return _taskSourceCore.GetResult(token); } ValueTaskSourceStatus IValueTaskSource\u003cTItem\u003e.GetStatus(short token) { return _taskSourceCore.GetStatus(token); } void IValueTaskSource\u003cTItem\u003e.OnCompleted(Action\u003cobject?\u003e continuation, object? state, short token, ValueTaskSourceOnCompletedFlags flags) { _taskSourceCore.OnCompleted(continuation, state, token, flags); } } 该队列额外实现2个功能，以提高队列的性能： 异步出队列，当队列为空时，异步等待。 当压入队列时，如果发现有异步等待对象，则不进入队列，直接给等待对象。 ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:5:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"随笔","content":"计划\r","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:0:0","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"长期计划\r要把计划列成一个详细的清单，而且要注明时间和完成期限 只是一个计划告诉你方向 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:1:0","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"短期计划\r细计划 把一个三年的学习计划，按照某种规律（逻辑、类型、阶段等等）分成三份，安排到每一年， 每年的学习内容细化，安排到每一个月。因为一个月有三十天，所以可以把一个月分为三个周期：第一个十天，第二个十天，第三个十天，十天就是一个周期。确定这个周期学习什么，下个周期学习什么，以此类推。 画一张每日工作表，自己每天晚上计划一下第二天的学习内容。 将整个计划分成若干阶段，每个阶段20小时阶段（2+2+2+2+2+5+5，每周20小时，工作日2小时，周末5小时），每周20小时，每天学习完进行练习，每周学习完进行测试。 计划调整 有时计划会低估或则高估自己的学习能力，根据每天的学习内容即时调整 执行\r快速浏览： 看目录：知道每一章重点在哪一节，用来解决什么问题 看课后习题，圈出术语和知识点 详细阅读： 根据重点和术语有重点的看书中概念，案例，图表 做题： 做课后习题 回顾： 看着目录知道这一章讲哪些内容，有哪些专业术语和知识点 测试： 学完课程后去网上找试卷进行测试 总结： 读一本书要写读书笔记，学知识要写总结 目的是把书中的知识和自己的理解结合起来形成自己的想法和思路，将自己的笔记标注时间，以后可以复习 定向输出： 找一个平台定向输出自己的所学。在写作的过程中，需要不断回忆自己学到的知识，并且利用自己的语言将它表达出来。还要思考文章的结构，怎么才能循序渐进地把一个复杂的道理讲得明白，讲得令人心服口服，讲得让人无懈可击。如果有某些细节自己不知道、不清楚，为了避免文中出现疏漏，你就会去查阅资料或者翻阅书籍，这就完成了一个巩固与复习的过程。 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:2:0","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"学习障碍\r","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:0","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"仪式感\r人藉由这种仪式带来的仪式感，来给自己一种强烈的自我暗示———这种自我暗示能够使自我变革，把自己的专注力、反应能力、运动能力迅速提升； 睡觉前，想一想今天学了哪些内容，第二天要学习哪些内容； 醒来，想一下今天又哪些任务； ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:1","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"预热\r提前半小时到达学习地点，准备好学习所需的物品； 翻看今天要学习的内容，浏览重要的概念和例题； 最后一分钟什么也不做，静心； ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:2","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"放松\r身体能量:每隔50分钟吃点东西喝点水 情绪能量:听音乐，做运动 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:3","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"厌倦感\r在高效学习的晚上，还有一部分愉悦的学习热情的时候中断学习，这样第二天可以更快进入学习状态 在讨厌某件事情的时候立马做，在开心的余热中立刻结束。 运动趋向运动，静止趋向静止 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:4","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"能量爆发期\r规划自己一天当中哪几个阶段学习热情比较高，效率高，为这几个阶段做提前准备，为了下午的学习，中午先休息一会，在工作之余听听音乐 在疲劳来临之前休息放松是最好的缓解疲劳的方法 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:5","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"计划被中断\r当天的某个计划被中断，没什么大不了，继续计划就可以 60分的完成也好过不完成。不要放弃 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:6","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"奖惩机制\r每天锻炼，没做好每天多做 看视频，没做好每天不看视频来锻炼 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:7","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"自我经营\r人与人最大的差别，不是他们的社会地位和收入水平，而是他们在业余时间学什么、做什么。 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:8","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"当机立断\r无论学什么，一定要当机立断，今天写计划，今天就执行，别等别拖别准备。 总结\r自学的本质就是管理自己，经营自己，掌控自己，驾驭自己，最后得到时间上的盈利——时间价值最大化。 人，终究是要学会使用自己，而不是放纵自己。 参考文献\rhttps://www.zhihu.com/question/21107510 https://www.zhihu.com/question/36766890/answer/70795756 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:9","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"Web","content":"DOM(document object medol)文档对象模型。 DOM就是HTML页面的模型，将每个标签都做为一个对象，JavaScript通过调用DOM中的属性、方法就可以对网页中的文本框、层等元素进行编程控制。比如通过操作文本框的DOM对象，就可以读取文本框中的值、设置文本框中的值。 JavaScript→Dom就是C#→.Net Framwork。没有.net，C#只能for、while，连WriteLine、MessageBox都不行。Dom就是一些让JavaScript能操作HTML页面控件的类、函数。 DOM也像WinForm一样，通过事件、属性、方法进行编程。 CSS+JavaScript+DOM=DHTML 学习阶段只考虑IE。用IE Collection安装IE所有版本，学习使用IE6（要调试必须使用本机安装的版本）。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:0:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"事件\r事件：\u003cbody onmousedown=\"alert('哈哈')\"\u003e当点击鼠标的时候执行onmousedown中的代码。有时间事件响应的代码太多，就放到单独的函数中： \u003cscript type=\"text/javascript\"\u003e function bodymousedown() { alert(\"网页被点坏了，赔吧！\"); alert(\"逗你玩的！\"); } \u003c/script\u003e \u003cbody onmousedown=\"bodymousedown()\"\u003e bodymousedown后的括号不能丢（ onmousedown=“bodymousedown” ），因为表示onmousedown事件发生时调用bodymousedown函数，而不是onmousedown事件的响应函数是bodymousedown。 \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function setTxt() { t1.value = \"1234\"; } \u003c/script\u003e \u003c/head\u003e \u003cbody onload=\"setTxt();\" onunload=\"alert('欢迎下次光临！')\" onbeforeunload=\"window.event.returnValue='确定关闭？'\"\u003e \u003cinput id=\"t1\" type=\"text\" value=\"\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:1:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"动态设置事件\r可以在代码中动态设置事件响应函数，就像.Net中btn.Click+=一样 function f1() { alert(\"1\"); } function f2(){ alert(\"2\"); } \u003cinput type=\"button\" onclick=\"document.ondblclick=f1\" value=\"关联事件1\" /\u003e//注意f1不要加括号。如果加上括号就变成了执行f1函数，并且将函数的返回值复制给document.ondblclick \u003cinput type=\"button\" onclick=\"document.ondblclick=f2\" value=\"关联事件2\" /\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function load() { alert('地球日'); alert('2012不远了'); } function f1() { alert(\"f1\"); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"按钮\" onclick=\"document.onclick=f1\" /\u003e \u003cinput type=\"button\" value=\"关闭\" onclick=\"window.close()\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:2:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"window对象\rwindow对象代表当前浏览器窗口，使用window对象的属性、方法的时候可以省略window，比如window.alert(‘a’)可以省略成alert(‘aa’)。 alert方法，弹出消息对话框 confirm方法，显示“确定”、“取消”对话框，如果按了【确定】按钮，就返回true，否则就false if (confirm(\"是否继续？\")) { alert(\"确定\"); } else { alert(\"取消\"); } + 重新导航到指定的地址：navigate(\"http://www.rupeng.com\");\r+ setInterval每隔一段时间执行指定的代码，第一个参数为代码的字符串，第二个参数为间隔时间（单位毫秒），返回值为定时器的标识\r`setInterval(\"alert('hello')\", 5000);`\r+ clearInterval取消setInterval的定时执行，相当于Timer中的Enabled=False。因为setInterval可以设定多个定时，所以clearInterval要指定清除那个定时器的标识，即setInterval的返回值。\rvar intervalId = setInterval(\"alert('hello')\", 5000);\rclearInterval(intervalId); + setTimeout也是定时执行，但是不像setInterval那样是重复的定时执行，只执行一次，clearTimeout也是清除定时。很好区分：Interval：间隔；timeout：超时。 var timeoutId = setTimeout(\"alert('hello')\", 2000); + showModalDialog弹出模态对话框，注意showModalDialog必须在onClick等用户手动触发的事件中才会执行，否则可能会被最新版本的浏览器当成广告弹窗而拦截。\r+ 第一个参数为弹出模态窗口的页面地址。\r+ 在弹出的页面中调用window.close()（不能省略window.close()中的window.）关闭窗口，只有在对话框中调用window.close()才会自动关闭窗口，否则浏览器会提示用户进行确认。\r+ 除了有特有的属性之外，当然还有通用的HTML元素的事件：onclick（单击）、ondblclick（双击）、onkeydown（按键按下）、onkeypress（点击按键）、onkeyup（按键释放）、onmousedown（鼠标按下）、onmousemove（鼠标移动）、onmouseout（鼠标离开元素范围）、onmouseover（鼠标移动到元素范围）、onmouseup（鼠标按键释放）等。\r\u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e1234567890\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e var tid; function setTimeoutDemo() { tid = setTimeout(\"alert('下课了')\", 3000); } function clearTimeoutDemo() { //判断tid是否初始化 if (tid) { clearTimeout(tid); } } var dir = \"left\"; function scroll() { var title = window.document.title; if (dir == \"left\") { var first = title.charAt(0); var last = title.substring(1, title.length); //start 从0数 end从1数 } else if (dir == \"right\") { var last = title.charAt(title.length - 1); var first = title.substring(0, title.length - 1); } window.document.title = last + first; } setInterval(\"scroll()\", 500); function setDir(str) { dir = str; } function scrollRight() { var title = window.document.title; var last = title.charAt(title.length - 1); var first = title.substring(0, title.length - 1); title = last + first; window.document.title = title; } window.showModalDialog(\"1-.htm\"); function showDialog() { window.showModalDialog(\"1-.htm\"); } function show() { window.showModelessDialog(\"1-.htm\"); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"启动\" onclick=\"setTimeoutDemo();\" /\u003e \u003cinput type=\"button\" value=\"取消\" onclick=\"clearTimeoutDemo();\" /\u003e \u003cinput type=\"button\" value=\"向左\" onclick=\"setDir('left')\" /\u003e \u003cinput type=\"button\" value=\"向右\" onclick=\"setDir('right')\" /\u003e \u003cbr /\u003e \u003cinput type=\"button\" value=\"模式窗口\" onclick=\"showDialog()\" /\u003e \u003cinput type=\"button\" value=\"非模式窗口\" onclick=\"show()\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e var times = 10; function count() { var btn = document.getElementById(\"btn\"); if (times \u003e 0) { btn.value = \"同意(倒计时\" + times + \")\"; times--; } else { btn.value = \"同意\"; btn.disabled = false; clearInterval(tid); } } var tid = setInterval(\"count()\", 1000); \u003c/script\u003e \u003c/head\u003e \u003cbody onload=\"count()\"\u003e 注册协议 \u003cbr /\u003e \u003cinput id=\"btn\" type=\"button\" value=\"同意\" disabled=\"disabled\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:3:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"window对象属性\rwindow.location.href='http://www.itcast.cn'，重新导向新的地址，和navigate方法效果一样。window.location.reload() 刷新页面 window.event是非常重要的属性，用来获得发生事件时的信息，事件不局限于window对象的事件，所有元素的事件都可以通过event属性取到相关信息。类似于winForm中的e(EventArg). altKey属性，bool类型，表示发生事件时alt键是否被按下，类似的还有ctrlKey、shiftKey属性，例子 \u003cinput type=\"button\" value=\"点击\" onclick=\"if(event.altKey){alert('Alt点击')}else{alert('普通点击')}\" /\u003e ； clientX、clientY 发生事件时鼠标在客户区的坐标；screenX、screenY 发生事件时鼠标在屏幕上的坐标；offsetX、offsetY 发生事件时鼠标相对于事件源（比如点击按钮时触发onclick）的坐标。 returnValue属性，如果将returnValue设置为false，就会取消默认事件的处理。在超链接的onclick里面禁止访问href的页面。在表单校验的时候禁止提交表单到服务器，防止错误数据提交给服务器、防止页面刷新。 srcElement，获得事件源对象。几个事件共享一个事件响应函数用。 keyCode，发生事件时的按键值。 button，发生事件时鼠标按键，1为左键，2为右键，3为左右键同时按。\u003cbody onmousedown=\"if(event.button==2){alert('禁止复制');}\"\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:4:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"（*）screen对象，屏幕的信息\ralert(\"分辨率：\" + screen.width + \"*\" + screen.height); if (screen.width \u003c 1024 || screen.height \u003c 768){ alert(\"分辨率太低！\"); } ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:5:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"clipboardData对象\r对粘贴板的操作。clearData(“Text”)清空粘贴板；getData(“Text”)读取粘贴板的值，返回值为粘贴板中的内容；setData(“Text”,val)，设置粘贴板中的值。 案例：复制地址给友好。见备注。 当复制的时候body的oncopy方法被触发，直接return false就是禁止复制。\u003cbody oncopy=“alert(‘禁止复制！’);return false;” 很多元素也有oncopy、onpaste事件： 案例：禁止粘贴帐号。见备注。 在网站中复制文章的时候，为了防止那些拷贝党不添加文章来源，自动在复制的内容后添加版权声明。 function modifyClipboard() { clipboardData.setData('Text', clipboardData.getData('Text') + '本文来自传智播客技术专区，转载请注明来源。' + location.href); } + `oncopy=\"setTimeout('modifyClipboard()',100)\"`。用户复制动作发生0.1秒以后再去改粘贴板中的内容。100ms只是一个经常取值，写1000、10、50、200……都行。不能直接在oncopy里修改粘贴板。\r+ 不能直接在oncopy中执行对粘贴板的操作，因此设定定时器，0.1秒以后执行，这样就不再oncopy的执行调用栈上了。\rhistory操作历史记录 window.history.back()后退；window.history.forward()前进。也可以用window.history.go(-1)、window.history.go(1)前进 \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function getXY() { document.title = window.event.clientX + \" \" + window.event.clientY; } function turnInto(right) { if (right) { alert(\"欢迎进入\"); } else { alert(\"非法入侵\"); window.event.returnValue = false; alert(\"123123\"); } } function btnClick() { return false; alert(\"abc\"); } function txtKeyDown() { var txt = window.event.srcElement; if (txt.id == \"txtNums\") { if (window.event.keyCode \u003e= 48 \u0026\u0026 window.event.keyCode \u003c= 57) { } else { return false; } } else if (txt.id = \"txt\") { } } \u003c/script\u003e \u003c/head\u003e \u003cbody onmousemove=\"getXY()\" onmousedown=\"if(window.event.button==2){alert('禁止复制')}\"\u003e \u003cinput type=\"button\" value=\"url\" onclick=\"alert(window.location.href);\" /\u003e \u003cinput type=\"button\" value=\"转向\" onclick=\"window.location.href='2-window对象.htm'\" /\u003e \u003cinput type=\"button\" value=\"reload\" onclick=\"window.location.reload()\" /\u003e \u003cinput type=\"button\" value=\"ctrlKey\" onclick=\"if(window.event.ctrlKey){alert('按下ctrl')}else{alert('没有按下')}\" /\u003e \u003cbr /\u003e \u003ca href=\"1-.htm\" onclick=\"turnInto(0)\"\u003e超链接\u003c/a\u003e \u003cinput type=\"button\" value=\"returnValue\" onclick=\"btnClick();\" /\u003e \u003cform action=\"http://www.baidu.com\"\u003e \u003cinput type=\"submit\" onclick=\"alert('请输入用户名密码');window.event.returnValue=false\"/\u003e \u003c/form\u003e \u003cinput id=\"txtNums\" type=\"text\" value=\"\" onkeydown=\"return txtKeyDown()\" /\u003e \u003cinput id=\"txt\" type=\"text\" value=\"\" onkeydown=\"txtKeyDown()\" /\u003e \u003cinput type=\"button\" value=\"screen\" onclick=\"alert(window.screen.width + ' ' + window.screen.height)\" /\u003e \u003chr /\u003e 手机号：\u003cinput type=\"text\" value=\"\" oncopy=\"alert('禁止复制');return false\" /\u003e\u003cbr /\u003e 重复手机号：\u003cinput type=\"text\" value=\"\" onpaste=\"alert('请输入');return false\" /\u003e \u003chr /\u003e \u003cinput id=\"tabc\" type=\"text\" value=\"213123123\" /\u003e\u003cinput type=\"button\" value=\"copy\" onclick=\"window.clipboardData.setData('text',tabc.value);alert('复制成功');\" /\u003e\u003cbr /\u003e \u003cinput id=\"t123\" type=\"text\" value=\"\" /\u003e\u003cinput type=\"button\" value=\"paste\" onclick=\"t123.value=clipboardData.getData('text')\" /\u003e\u003cbr /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function setClip() { var text = window.clipboardData.getData(\"text\"); text = text + \"转载请注明：\" + window.location.href; window.clipboardData.setData(\"text\",text); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003ctextarea id=\"t1\" oncopy=\"setTimeout('setClip()',50)\"\u003e asdfasdfasdf asdfasdfasdf \u003c/textarea\u003e \u003ca href=\"6-history.htm\"\u003e链接\u003c/a\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"后退\" onclick=\"window.history.back()\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:6:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"document属性。\r是最复杂的属性之一。后面讲解详细使用。 document是window对象的一个属性，因为使用window对象成员的时候可以省略window.，所以一般直接写document document的方法： write：向文档中写入内容。writeln，和write差不多，只不过最后添加一个回车 \u003cinput type=\"button\" value=\"点击\" onclick=\"document.write('\u003cfont color=red\u003e你好\u003c/font\u003e')\" /\u003e + 在onclick等事件中写的代码会冲掉页面中的内容，只有在页面加载过程中write才会与原有内容融合在一起\r\u003cscript type=\"text/javascript\"\u003e document.write('\u003cfont color=red\u003e你好\u003c/font\u003e'); \u003c/script\u003e + write经常在广告代码、整合资源代码中被使用。见备注\r内容联盟、广告代码、cnzz，不需要被主页面的站长去维护内容，只要被嵌入的js内容提供商修改内容，显示的内容就变了。 getElementById方法（非常常用），根据元素的Id获得对象，网页中id不能重复。也可以直接通过元素的id来引用元素，但是有有效范围、form1.textbox1之类的问题，因此不建议直接通过id操作元素，而是通过getElementById （*）getElementsByName，根据元素的name获得对象，由于页面中元素的name可以重复，比如多个RadioButton的name一样，因此getElementsByName返回值是对象数组。 （*）getElementsByTagName，获得指定标签名称的元素数组，比如getElementsByTagName(“p”)可以获得所有的标签。 案例：实现checkbox的全选，反选 案例：点击一个按钮，被点击的按钮显示“呜呜”，其他按钮显示“哈哈”。 案例：十秒钟后协议文本框下的注册按钮才能点击，时钟倒数。(btn.disabled = true ) \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function writeDemo() { document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); } document.writeln(\"123\u003cbr/\u003e\"); document.writeln(\"123\u003cbr/\u003e\"); document.writeln(\"\u003ca href='123.htm'\u003e123\u003c/a\u003e\"); document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); document.write(\"\u003cul\u003e\u003cli\u003e开始\u003c/li\u003e\u003cli\u003e运行\u003c/li\u003e\u003cli\u003e结束\u003c/li\u003e\u003c/ul\u003e\"); //document.write(\"\u003cscript type='text/javascript'\u003ealert('hello world');\u003c\\/script\u003e\"); \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv\u003eabc \u003cscript type=\"text/javascript\"\u003e document.writeln(\"123\u003cbr/\u003e\"); document.writeln(\"123\u003cbr/\u003e\"); \u003c/script\u003eabc \u003c/div\u003e \u003cdiv\u003e sdfsd \u003c/div\u003e \u003cinput type=\"button\" value=\"按钮\" onclick=\"writeDemo()\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function setText() { var txt = document.getElementById(\"t1\"); txt.value = \"123\"; //t1.value = \"123\"; } function setText2() { var txt = document.getElementById(\"t2\"); txt.value = \"abc\"; //form1.t2.value = \"abc\"; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput id=\"t1\" type=\"text\" value=\"\" /\u003e \u003cform id=\"form1\"\u003e \u003cinput id=\"t2\" type=\"text\" value=\"\" /\u003e \u003c/form\u003e \u003cinput type=\"button\" value=\"按钮\" onclick=\"setText()\" /\u003e \u003cinput type=\"button\" value=\"按钮2\" onclick=\"setText2()\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function btnClick() { var chks = document.getElementsByName(\"hobby\"); //错误 // for (var c in chks) { // alert(c); // } for (var i = 0; i \u003c chks.length; i++) { //alert(chks[i].value); chks[i].checked = \"checked\"; } } function checkAll() { var chkAll = document.getElementById(\"chkAll\"); var chks = document.getElementsByName(\"hobby\"); for (var i = 0; i \u003c chks.length; i++) { chks[i].checked = chkAll.checked; } } function reverseCheck() { var chks = document.getElementsByName(\"hobby\"); for (var i = 0; i \u003c chks.length; i++) { chks[i].checked = !chks[i].checked; } } function checkSingle() { var b = true; //假设全被选中 var chkAll = document.getElementById(\"chkAll\"); var chks = document.getElementsByName(\"hobby\"); for (var i = 0; i \u003c chks.length; i++) { //查找所有子的checkbox，判断是否被选中 //如果有一个checkbox没有被选中，则退出循环，最终全选的checkbox为false if (!chks[i].checked) { b = false; break; } } chkAll.checked = b; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"checkbox\" value=\"cf\" onclick=\"checkSingle()\" name=\"hobby\"/\u003e吃饭\u003cbr /\u003e \u003cinput type=\"checkbox\" value=\"sj\" onclick=\"checkSingle()\" name=\"hobby\"/\u003e睡觉\u003cbr /\u003e \u003cinput type=\"checkbox\" value=\"ddd\" onclick=\"checkSingle()\" name=\"hobby\"/\u003e打豆豆\u003cbr /\u003e \u003cbr /\u003e\u003cbr /\u003e \u003cinput id=\"chkAll\" type=\"checkbox\" onclick=\"checkAll()\"/\u003e全选 \u003cinput type=\"button\" value=\"反选\" onclick=\"reverseCheck()\" /\u003e \u003cinput type=\"button\" value=\"全选\" onclick=\"btnClick()\" /\u003e \u003cbr /\u003e \u003cinput type=\"checkbox\" value=\"ctl\" /\u003e春天里\u003cbr /\u003e \u003cinput type=\"checkbox\" value=\"xtl\" /\u003e夏天里\u003cbr /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"htt","date":"2019-04-04","objectID":"/2019/04/web4-dom/:6:1","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"dom动态创建\rdocument.write只能在页面加载过程中才能动态创建。 可以调用document的createElement方法来创建具有指定标签的DOM对象，然后通过调用某个元素的appendChild方法将新创建元素添加到相应的元素下 function showit() { var divMain = document.getElementById(\"divMain\"); var btn = document.createElement(\"input\"); btn.type = \"button\"; btn.value = \"我是动态的！\"; divMain.appendChild(btn); } \u003cdiv id=\"divMain\"\u003e\u003c/div\u003e \u003cinput type=\"button\" value=\"ok\" onclick=\"showit()\" /\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function createBtn() { var btn = document.createElement(\"input\"); btn.type = \"button\"; btn.value = \"新按钮\"; btn.onclick = function() { alert(\"我是新来的\"); } var d = document.getElementById(\"d1\"); d.appendChild(btn); } function createLink() { var link = document.createElement(\"a\"); link.href = \"http://www.baidu.com\"; link.innerText = \"百度\"; link.target = \"_blank\"; var d = document.getElementById(\"d1\"); d.appendChild(link); } function btnClick(){ alert(\"我是新来的\"); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"创建按钮\" onclick=\"createBtn()\" /\u003e \u003cinput type=\"button\" value=\"创建超链接\" onclick=\"createLink()\" /\u003e \u003cdiv id=\"d1\"\u003eabc\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e Value 获取表单元素 几乎所有DOM元素都有innerText、innerHTML属性（注意大小写），分别是元素标签内内容的文本表示形式和HTML源代码，这两个属性是可读可写的。 \u003ca href=\"http://www.itcast.cn\" id=\"link1\"\u003e传\u003cfont color=\"Red\"\u003e智\u003c/font\u003e播客\u003c/a\u003e \u003cinput type=\"button\" value=\"inner*\" onclick=\"alert(document.getElementById('link1').innerText);alert(document.getElementById('link1').innerHTML);\" /\u003e 用innerHTML也可以替代createElement，属于简单、粗放型、后果自负的创建 function createlink() { var divMain = document.getElementById(\"divMain\"); divMain.innerHTML = \"\u003ca href='http://www.rupeng.com'\u003e如鹏网\u003c/a\u003e\"; } \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function getLinkText() { var link = document.getElementById(\"link1\"); alert(link.innerText); alert(link.innerHTML); } function setDiv() { var div = document.getElementById(\"d1\"); //div.innerText = \"\u003cfont color='red'\u003e123123\u003c/font\u003e\"; //div.innerHTML = \"\u003cfont color='red'\u003e123123\u003c/font\u003e\"; //div.innerHTML = \"\u003cul\u003e\u003cli\u003e春天里\u003c/li\u003e\u003cli\u003e怒放\u003c/li\u003e\u003c/ul\u003e\"; //div.innerHTML = \"\u003cinput type='text' value='1234' /\u003e\"; //div.innerText = div.innerText + \"123123\"; //Node节点 Element元素的区别 //html文档里所有的内容都是节点 标签 属性 文本 //元素 一个完整的标签 //var txtNode = document.createTextNode(\"123123\"); // div.appendChild(txtNode); div.innerHTML = \"\u003cscript type='text/javascript'\u003efunction test(){alert('hello');}\u003c\\/script\u003e\"; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003ca id=\"link1\" href=\"http://www.itcast.cn\"\u003e传智\u003cfont color=\"red\"\u003e播客\u003c/font\u003e\u003c/a\u003e \u003cinput type=\"button\" value=\"按钮\" onclick=\"getLinkText()\" /\u003e \u003cdiv id=\"d1\"\u003eabcd\u003c/div\u003e \u003cinput type=\"button\" value=\"set div\" onclick=\"setDiv() \" /\u003e \u003cinput type=\"button\" value=\"test\" onclick=\"test()\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function createTable() { var div = document.getElementById(\"d1\"); var dic = { \"baidu\": \"http://www.baidu.com\", \"传智播客\": \"http://www.itcast.cn\", \"cnbeta\": \"http://www.cnbeta.com\" }; var table = document.createElement(\"table\"); table.border = 1; for (var key in dic) { var tr = document.createElement(\"tr\"); var td0 = document.createElement(\"td\"); td0.innerText = key; //把td0加到tr中 tr.appendChild(td0); var td1 = document.createElement(\"td\"); td1.innerHTML = \"\u003ca href='\" + dic[key] + \"'\u003e\" + dic[key] + \"\u003c/a\u003e\"; tr.appendChild(td1); //把tr添加到table中 table.appendChild(tr); } //把table添加到div中 div.appendChild(table); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"d1\"\u003e\u003c/div\u003e \u003cinput type=\"button\" value=\"load。。。\" onclick=\"createTable()\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:7:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"浏览器兼容性的例子\rie6，ie7对table.appendChild(“tr”)的支持和IE8不一样，用insertRow、insertCell来代替或者为表格添加tbody，然后向tbody中添加tr。FF不支持InnerText。 所以动态加载网站列表的程序修改为： var tr = tableLinks.insertRow(-1);//FF必须加-1这个参数 var td1 = tr.insertCell(-1); td1.innerText = key; var td2 = tr.insertCell(-1); td2.innerHTML = \"\u003ca href='\" + value + \"'\u003e\" + value + \"\u003c/a\u003e\"; 或者： \u003ctable id=\"tableLinks\"\u003e \u003ctbody\u003e\u003c/tbody\u003e \u003c/table\u003e，然后tableLinks. tBodies[0].appendChild(tr); \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function add() { var name = document.getElementById(\"txtName\").value; var content = document.getElementById(\"txtContent\").value; var tr = document.createElement(\"tr\"); var td0 = document.createElement(\"td\"); td0.innerText = name; tr.appendChild(td0); var td1 = document.createElement(\"td\"); td1.innerText = content; tr.appendChild(td1); var table = document.getElementById(\"re\"); table.appendChild(tr); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003e 最新新闻 \u003c/p\u003e \u003ctable id=\"re\"\u003e\u003c/table\u003e \u003chr /\u003e 评论： \u003cinput id=\"txtName\" type=\"text\" value=\"\" /\u003e\u003cbr /\u003e \u003ctextarea id=\"txtContent\" cols=\"50\" rows=\"10\"\u003e\u003c/textarea\u003e \u003cbr /\u003e \u003cinput type=\"button\" value=\"评论\" onclick=\"add()\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function add() { var name = document.getElementById(\"txtName\").value; var content = document.getElementById(\"txtContent\").value; var table = document.getElementById(\"re\"); var tr = table.insertRow(-1); var td = tr.insertCell(-1); td.innerHTML = name; var td1 = tr.insertCell(-1); td1.innerHTML = content; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003e 最新新闻 \u003c/p\u003e \u003ctable id=\"re\"\u003e\u003c/table\u003e \u003chr /\u003e 评论： \u003cinput id=\"txtName\" type=\"text\" value=\"\" /\u003e\u003cbr /\u003e \u003ctextarea id=\"txtContent\" cols=\"50\" rows=\"10\"\u003e\u003c/textarea\u003e \u003cbr /\u003e \u003cinput type=\"button\" value=\"评论\" onclick=\"add()\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:8:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"事件冒泡\r事件冒泡：如果元素A嵌套在元素B中，那么A被点击不仅A的onclick事件会被触发，B的onclick也会被触发。触发的顺序是“由内而外” 。验证：在页面上添加一个table、table里有tr、tr里有td，td里放一个p，在p、td、tr、table中添加onclick事件响应，见备注。 \u003ctable onclick=\"alert('table onclick');\"\u003e \u003ctr onclick=\"alert('tr onclick');\"\u003e \u003ctd onclick=\"alert('td onclick');\"\u003e\u003cp onclick=\"alert('p onclick');\"\u003eaaaa\u003c/p\u003e\u003c/td\u003e \u003ctd\u003ebbb\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function btn3() { alert(event.srcElement.value); } //事件响应函数的调用函数 function btn4() { alert(this.value); } function initBtn5() { var btn = document.getElementById(\"btn5\"); //事件响应函数 btn.onclick = btn4; } \u003c/script\u003e \u003c/head\u003e \u003cbody onload=\"initBtn5()\"\u003e \u003ctable onclick=\"alert('table')\"\u003e \u003ctr onclick=\"alert('tr')\"\u003e \u003ctd onclick=\"alert('td')\"\u003e \u003cdiv onclick=\"alert('div')\"\u003easd\u003c/div\u003e\u003c/td\u003e \u003ctd\u003e2\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003cinput type=\"button\" value=\"click1\" onclick=\"alert(event.srcElement.value)\" /\u003e\u003cbr /\u003e \u003c!-- 事件响应函数--\u003e \u003cinput type=\"button\" value=\"click2\" onclick=\"alert(this.value)\" /\u003e \u003cinput type=\"button\" value=\"click3\" onclick=\"btn3()\" /\u003e \u003cinput type=\"button\" value=\"click4\" onclick=\"btn4()\" /\u003e \u003cinput id=\"btn5\" type=\"button\" value=\"click5\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:8:1","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"this\r事件中的this。 除了可以使用event.srcElement在事件响应函数中 this表示发生事件的控件。 只有在事件响应函数才能使用this获得发生事件的控件，在事件响应函数调用的函数中不能使用，如果要使用则要将this传递给函数或者使用event.srcElement。 (*)this和event.srcElement的语义是不一样的，this就是表示当前监听事件的这个对象，event.srcElement是引发事件的对象：事件冒泡。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:9:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"修改样式\r易错：修改元素的样式不是设置class属性，而是className属性。案例：网页开关灯的效果。 修改元素的样式不能this.style=\"background-color:Red\"。 易错：单独修改样式的属性使用“style.属性名”。注意在css中属性名在JavaScript中操作的时候属性名可能不一样，主要集中在那些属性名中含有-的属性，因为JavaScript中-是不能做属性、类名的。所以CSS中背景颜色是background-color，而JavaScript则是style.backgroundColor；元素样式名是class，在JavaScript中是className属性；font-size→style.fontSize；margin-top→style.marginTop 单独修改控件的样式\u003cinput type=\"button\" value=\"AAA\" onclick=\"this.style.color='red'\" /\u003e。技巧，没有文档的情况下的值属性名，随便给一个元素设定id，然后在js中就能id.style.出来能用的属性。 \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e .light{ background-color:White; } .dark { background-color:Black; } \u003c/style\u003e \u003cscript type=\"text/javascript\"\u003e function open1() { document.body.className = \"light\"; } function close1() { document.body.className = \"dark\"; } function change() { var txt = document.getElementById(\"txt1\"); //错误 不能这样用。可以把style看成一个只读属性 //txt.style = \"background-color:Green\"; txt.style.backgroundColor = \"Green\"; txt.style.color = \"red\"; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"开灯\" onclick=\"open1()\" /\u003e \u003cinput type=\"button\" value=\"关灯\" onclick=\"close1()\" /\u003e \u003cinput id=\"txt1\" type=\"text\" value=\"123\" /\u003e \u003cinput type=\"button\" value=\"click\" onclick=\" change() \" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function initTxt() { var txts = document.getElementsByTagName(\"input\"); for (var i = 0; i \u003c txts.length; i++) { if (txts[i].type == \"text\") { //事件响应函数 txts[i].onblur = iBlur; } } } function iBlur() { if (this.value.length \u003c= 0) { this.style.backgroundColor = \"red\"; } else { this.style.backgroundColor = \"white\"; } } function iFocus(txt) { txt.value = \"\"; } \u003c/script\u003e \u003c/head\u003e \u003cbody onload=\"initTxt()\"\u003e \u003cinput type=\"text\" value=\"\"/\u003e \u003cinput type=\"text\" value=\"\" /\u003e \u003cinput type=\"text\" value=\"\" /\u003e \u003cinput type=\"button\" value=\"click\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function iBlur(txt) { var t2 = document.getElementById(\"t2\"); t2.style.backgroundColor = txt.style.backgroundColor; t2.style.color = txt.style.color; t2.style.width = txt.style.width; t2.value = txt.value; } function iFocus(txt) { var t1 = document.getElementById(\"t1\"); txt.style.backgroundColor = t1.style.backgroundColor; txt.style.color = t1.style.color; txt.style.width = t1.style.width; txt.value = t1.value; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput id=\"t1\" type=\"text\" value=\"\" style=\"background-color:Green; color:Red; width:300px\" /\u003e \u003cinput type=\"text\" onfocus=\"iFocus(this)\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function init() { var table = document.getElementById(\"rating\"); var tds = table.getElementsByTagName(\"td\"); for (var i = 0; i \u003c tds.length; i++) { //事件响应函数 tds[i].onmouseover = change; tds[i].onclick = stop; tds[i].style.cursor = \"pointer\"; } } //记录是否点鼠标，默认没点 var isClick = false; function stop() { isClick = true; } function indexOf(arr,element){ var j = -1; for(var i=0;i\u003carr.length;i++){ if(arr[i] == element) { j = i; break; } } return j; } function change() { //当没点鼠标的时候去执行 if (!isClick) { var table = document.getElementById(\"rating\"); var tds = table.getElementsByTagName(\"td\"); var n = indexOf(tds, this); for (var i = 0; i \u003c= n; i++) { //tds[i].style.backgroundColor = \"red\"; tds[i].innerText = \"★\"; } for (var i = n + 1; i \u003c tds.length; i++) { //tds[i].style.backgroundColor = \"white\"; tds[i].innerText = \"☆\"; } } } \u003c/script\u003e \u003c/head\u003e \u003cbody onload=\"init()\"\u003e \u003ctable id=\"rating\"\u003e \u003ctr\u003e \u003ctd\u003e☆\u003c/td\u003e\u003ctd\u003e☆\u003c/td\u003e\u003ctd\u003e☆\u003c/td\u003e\u003ctd\u003e☆\u003c/td\u003e\u003ctd\u003e☆\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function init() { var d1 = document.getElementById(\"d1\"); var links = d1.getElementsByTagName(\"a\"); for (var i = 0; i \u003c links.length; i++) { links[i].onclick = linkClick; } } function linkClick() { var d1 = document.getElementById(\"d1\"); var links = d1.getElementsByTagName(\"a\")","date":"2019-04-04","objectID":"/2019/04/web4-dom/:10:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"控制层显示\r修改style.display，例子：切换层的显示 function togglediv() { var div1 = document.getElementById('div1'); if (div1.style.display == '') { div1.style.display = 'none';//不显示 } else { div1.style.display = '';//显示 } } 案例：注册页面，点击“高级”CheckBox，则显示高级选项，否则隐藏 案例：鼠标放到一个超链接的时候，在鼠标的位置显示一个黄色背景，带图片的悬浮提示，鼠标离开就消失。提示：鼠标进入控件的事件是onmouseover，离开的事件是onmouseout。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:11:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"Body事件的范围\rIE中如果在body上添加onclick、onmousemove等事件响应，那么如果页面没有满，则 “body 中最后一个元素以下（横向不限制）” 的部分是无法响应事件的，必须使用代码在document上监听那些事件，比如document.onmousemove = MovePic FF中也差不多。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:12:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"元素的位置、大小单位\r通过dom读取元素的top、left、width、height等取到的值不是数字，而是“10px”这样的字符串；为这些属性设值的时候IE可以是80、90这样的数字，FF必须是“80px”、“90%”等这样的字符串形式，为了兼容统一用字符串形式。 易错：不要写成div1.style.width=80px，而是div1.style.width=‘80px’ 如果要修改元素的大小（宽度加10），则首先要取出元素的宽度，然后用parseInt将宽度转换为数字（parseInt可以将\"20px\"这样数字开头的包含其他内容的字符串解析为20，）；然后加上一个值，再加上px赋值回去。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:13:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"层的操作\r元素的position 样式值：static（无定位，显示在默认位置）、absolute（绝对定位）、fixed（相对于窗口的固定定位，位置不会随着浏览器的滚动而变化，IE6不支持）、relative（相对元素默认位置的定位）。如果要通过代码修改元素的坐标则一般使用absolute，然后修改元素的top（上边缘距离）、left（左边缘距离）两个样式值。left、top都是指的层的左上角的坐标 案例：跟着鼠标飞的图片。提示：鼠标移动的事件是onmousemove（一边移动事件一边触发，而不是移动开始或者移动完成才触发），通过window.event的clientX、clientY属性获得鼠标的位置。 案例：放三个超链接，鼠标放上时候动态生成一个层，层显示在鼠标的位置，鼠标离开的时候移除该层removeChild 案例：点击按钮层动态变大。提示：英文字母连续单词不会在中间自动换行的陷阱 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:14:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"易错\r易错：不要写成div1.style.width=80px，而是div1.style.width=‘80px’ 修改元素的样式不能this.style=“background-color:Red”，哪怕可以的话也是把以前所有样式都冲掉了。单独修改控件的样式this.style. background=‘red’，只修改要修改的样式。技巧，没有文档的情况下的值属性名，随便给一个元素设定id，然后在js中就能id.style.出来能用的属性。 createElement的两种用法，注意innerText的问题 var input = document.createElement(\"\")快速创建元素，并且赋值，但是注意设置的inner部分不会被设置var link = document.createElement(\"百度\") label.setAttribute(“for”, “username”); //设定一些Dom元素属性名特殊的属性,label.for = “username\"会有问题。label.setAttribute(“xuehao”,“33333”) ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:15:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"form对象\rdocument.getElementById(‘btn1’).click() form对象是表单的Dom对象。 方法：submit()提交表单，但是不会触发onsubmit事件。 实现autopost，也就是焦点离开控件以后页面立即提交，而不是只有提交submit按钮以后才提交，当光标离开的时候触发onblur事件，在onblur中调用form的submit方法。代码见备注。 在点击submit后form的onsubmit事件被触发，在onsubmit中可以进行数据校验，数据数据有问题，返回false即可取消提交 \u003cform name=\"form1\" action=\"a.aspx\" method=\"get\" onsubmit=\"if(document.getElementById('txtname').value.length\u003c=0){alert('姓名必填');return false;}\"\u003e 自动提交 \u003cform name=\"form1\" action=\"a.aspx\" method=\"get\"\u003e \u003cinput type=\"text\" onblur=\"form1.submit()\" /\u003e \u003cinput type=\"text\" /\u003e \u003c/form\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:16:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"不同浏览器差异\r面试题：说说开发项目的时候不同浏览器的不同点，你是怎么解决的？Button,appendChild,insertCell,px 不同浏览器中对DOM支持的方法不一样 获取网页中那个元素触发了事件：在IE里使用srcElement ；在FireFox里使用target 使用Dom获取和更改网页标签元素内文本：在IE里使用innerText ；在FireFox里使用textContent 动态为网页或元素绑定事件：在IE中绑定事件的方法是attachEvent ；在FireFox中绑定事件的方法是addEventListener 更多http://www.360doc.com/content/09/0319/12/16915_2855107.shtml。 不同浏览器中对CSS的支持不一样，所以出现在IE中显示正常的网页，在FF下全部乱掉了。哀悼网页使用的CSS只有IE支持，FF都不支持。 JQuery之类的框架进行了封装，将不同浏览器的差异帮开发人员处理了，开发人员只要调用JQuery的方法，JQuery会帮助在不同浏览器中进行翻译。用JQuery就可以解决不同浏览器上Dom的不同。对于CSS的不同是美工的事，IETester、FF、Chrome。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:17:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"弹出对话框处理\r复习，使用window.showModalDialog(‘dialog.htm’)弹出模态对话框 给对话框传递参数，使用showModalDialog的第二个参数传递参数，在对话框中用window.dialogArguments获得传递的参数值；对话框中给window.parent.returnValue设定返回值，这样在父窗口中就可以通过showModalDialog返回值读取设置的返回值了。例子：弹出对话框询问用户姓名，向用户问好；弹出含有“是”、“否”、“取消”三个按钮的模态窗口，点击按钮的时候窗口关闭，然后主窗口显示用户点击的按钮。 传递多个参数，将参数包装到数组中，然后仍然是通过第二个参数传递，返回多个返回值也可以返回数组：var arr = new Array();arr[0]=30;arr[1]=“tom”; 练习（面试题），弹出一个含有确定、取消、重试三个按钮的对话框，并且得知用户的选择。 给对话框传递参数，使用showModalDialog的第二个参数传递参数，在对话框中用window.dialogArguments获得传递的参数值；对话框中给window.parent.returnValue设定返回值，这样在父窗口中就可以通过showModalDialog返回值读取设置的返回值了： dialog.htm： function getData() { return document.getElementById('mytext1').value; } \u003cbody onLoad=\"javascript:document.getElementById('mytext1').value=window.dialogArguments;\"\u003e \u003cinput type=\"text\" id=\"mytext1\"/\u003e \u003cinput type=\"button\" value=\"确定\" onclick=\"javascript:window.parent.returnValue=getData();window.close();\"\u003e \u003c/body\u003e 主页面： var result=window.showModalDialog('dialog2.htm',777); alert(result); 传递多个参数，将参数包装到数组中即可：var arr = new Array();arr[0]=30;arr[1]=“tom”; ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:18:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"JS正则表达式\rJavaScript中创建正则表达式类的方法： var regex = new RegExp(”\\d{5}\") 或者 var regex = /\\d{5}/ /表达式/是JavaScript中专门为简化正则表达式编写而提供的语法，写在//中的正则表达式就不用管转义符了。 RegExp对象的方法： （1）test(str)判断字符串str是否匹配正则表达式，相当于IsMatch var regex = /.+@.+/; alert(regex.test(\"a@b.com\")); alert(regex.test(\"ab.com\")); （2）exec(str)进行搜索匹配，返回值为匹配结果，没找到返回null() （3）compile编译表达式，提高运行速度。 () ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:19:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"string 的正则表达\rReplace match String对象中提供了一些与正则表达式相关的方法，相当于对于RegExp类的包装，简化调用： match(regexp)，相当于调用exec var s = \"aaa@163.com\"; var regex = /(.+)@(.+)/; var match = s.match(regex); alert(RegExp.$1 + \"，服务器：\" + RegExp.$2); 练习：光标离开Email地址框的时候用正则表达式校验是否是合法的Email地址，如果不是的话Email地址框变红，并且注册按钮禁用，否则Email地址框颜色为白色，启用注册按钮。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:20:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"HTML JS压缩\rHTML、JavaScript的压缩和混淆。去掉空格、缩短变量名，让js、html尺寸更小，提高下载速度。 HTML、JS压缩、混淆有动态和静态两种方案。HTML压缩器，比如HTML Compress，JavaScript压缩工具：Google Closure Compiler、YUI Compressor 等。 很多js库都提供了.min.js、compress.js的压缩版本。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:21:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"什么是JAVASCRIPT\rHTML只是描述网页长相的标记语言，没有计算、判断能力，如果所有计算、判断（比如判断文本框是否为空、判断两次密码是否输入一致）都放到服务器端执行的话网页的话页面会非常慢、用起来也很难用，对服务器的压力也很大，因此要求能在浏览器中执行一些简单的运算、判断。JavaScript就是一种在浏览器端执行的语言。HTML内容，css衣服，修饰，js控制 JavaScript的Java没直接的关系，唯一的关系就是JavaScript原名LiveScript，后来吸收了Java的一些特性，升级为JavaScript。JavaScript有时被简称为JS。 JavaScript是解释型语言，无需编译就可以随时运行，这样哪怕语法有错误，没有语法错误的部分还是能正确运行。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:1:0","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"JAVASCRIPT开发环境\rVS中JavaScript、JQuery的自动完成功能：在VS2010中直接有，VS2008需要安装VisualStudio 2008SP1（http://www.microsoft.com/downloads/details.aspx?displaylang=zh-cn\u0026familyid=27673c47-b3b5-4c67-bd99-84e525b5ce61）和VS90SP1-KB958502-x86（http://code.msdn.microsoft.com/KB958502/Release/ProjectReleases.aspx?ReleaseId=1736）补丁会更强更好用。如果实在“.” 不出来也没关系，不影响运行。注意：先安装2008SP1，再安装VS90SP1-KB958502-x86。 JS是非常灵活的动态语言，不像C#等静态语言那样严谨，开发工具中的JS完成功能只是一个辅助、建议，“.”出来的成员调用可能不能用，“.”不出来的成员也许也能调用，因此不要因为“点儿不出来”而担心代码有问题。 VS2008的HTML编辑器中触发JavaScript自动完成：Ctrl+J。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:2:0","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"入门\r\u003cscript type=\"text/javascript\"\u003e alert(new Date().toLocaleDateString()); \u003c/script\u003e \u003cscript language=\"....\u003e已经不推荐使用。 JavaScript代码放到\u003cscript\u003e标签中，script可以放到\u003chead\u003e、\u003cbody\u003e等任意位置，而且可以有不止一个\u003cscript\u003e标签。alert函数是弹出消息窗口，new Date()是创建一个Date类的对象，默认值就是当前时间。 JS是大小写敏感的。 放到\u003chead\u003e中的\u003cscript\u003e在body加载之前就已经运行了。写在body中的\u003cscript\u003e是随着页面的加载而一个个执行的。 除了可以在页面中声明JavaScript以外，还可以将JavaScript写到单独的js文件中，然后在页面中引入：\u003cscript src=\"test.js\" type=\"text/javascript\"\u003e\u003c/script\u003e。声明到单独的js文件的好处是多页面也可以共享、减小网络流量。js文件的CDN(*)内容分发布网络(CDN),将别的服务器上的库 注意：不要写成\u003cscript src=\"test.js\" type=\"text/javascript\"/\u003e否则会有问题，这是一个比较特殊的地方。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:0","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"事件\r在超链接的点击里执行JavaScript：\u003ca href=\"javascript:alert(88)\"\u003e发发\u003c/a\u003e JavaScript中也有事件的概念，当按钮被点击的时候也可以执行JavaScript： \u003cinput type=\"button\" onclick=\"alert(99)\" value=\"久久\"/\u003e 只有超链接的href中的JavaScript中才需要加““javascript:”，因为它不是事件，而是把““javascript:”看成像“http:”、“ftp:”、“thunder://”、“ed2k://”、“mailto:”一样的网络协议，交由js解析引擎处理。只有href中这是这是一个特例。 \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e var sum = 0; for(int i = 0;i\u003c=100;i++){ sum += i; } alert(sum); function test() { var sum = 0; for(int i = 0;i\u003c=100;i++){ sum += i; } alert(sum); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003ca href=\"javascript:test()\"\u003eClick me\u003c/a\u003e \u003ca href=\"win.htm\" onclick=\"alert('123')\"\u003eClick me\u003c/a\u003e \u003cinput type=\"button\" value=\"按钮\" ondblclick=\"test()\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:1","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"变量\rJavaScript中即可以使用双引号声明字符串，也可以使用单引号声明字符串。主要是为了方便和html集成，避免转义符的麻烦。只有一种类型var JavaScript中有null、undefined两种，null表示变量的值为空，undefined则表示变量还没有指向任何的对象，未初始化。两者的区别参考资料。 JavaScript是弱类型，声明变量的时候无法：int i=0；只能通过var i=0;声明变量，和C#中的var不一样，不是C#中那样的类型推断。 JavaScript中也可以不用var声明变量，直接用，这样的变量是“全局变量”，因此除非确实想用全局变量，否则使用的时候最好加上var。 JS是动态类型的，因此var i=0;i=“abc”;是合法的。并且可以把方法放到var中， \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e var x = \"abc\"; if (!null) { alert(\"null\"); } if (!undefined) { alert(\"undefined\"); } if (x == null) { alert(\"null\"); } if (typeof(x) == \"undefined\") { alert(\"undefined\"); } if (!x) { alert(\"未初始化 0\"); } if (x) { alert(x); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:2","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"除错和调试\r如果JavaScript中的代码有语法错误，浏览器会弹出报错信息，查看报错信息就能帮助排查错误。 JavaScript的调试，使用VS可以很方便的进行JavaScript的调试，调试时需要注意几点： IE6的调试选项要打开，Internet选项→高级，去掉“禁用脚本调试”前的勾选。 以调试方式运行网页。 设置断点、监视变量等操作和C#一样。 案例：用循环语句的方法计算1到100之间整数的和 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:3","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"判断变量初始化\rJavaScript中判断变量、参数是否初始化 的三种方法： var x; if (x == null) { alert(\"null\"); } if (typeof (x) == \"undefined\") { alert('undefined'); } if (!x) {alert('不x');} if(x){}//变量被初始化了或者变量不为空或者变量不为0. 推荐用最后一种方法。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:4","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"函数声明\rJavaScript中声明函数的方式： function add(i1, i2) { return i1 + i2; } int add(int i1,int i2)//C#写法 不需要声明返回值类型、参数类型。函数定义以function开头。 var r = add(1, 2); alert(r); r = add(\"你好\", \"tom\"); alert(r); JavaScript中不像C#中那样要求所有路径都有返回值，没有返回值就是undefined。 易错：自定义函数名不要和js内置、dom内置方法重名，比如selectall、focus等函数名不要用。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:5","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"匿名函数\rvar f1 = function(i1, i2) { return i1 + i2; } alert(f1(1,2)); 类似于C#中的匿名函数。 这种匿名函数的用法在JQuery中的非常多 alert(function(i1, i2) { return i1 + i2; }(10,10));//直接声明一个匿名函数，立即使用。用匿名函数省得定义一个用一次就不用的函数，而且免了命名冲突的问题，js中没有命名空间的概念，因此很容易函数名字冲突。通过例子发现一旦命名冲突以最后声明的为准 必须\u003cscript src=\"my1.js\" type=\"text/javascript\"\u003e\u003c/script\u003e不能：\u003cscript src=\"my1.js\" type=\"text/javascript\"/\u003e ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:6","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"面向对象基础\rJavaScript中没有类的语法，是用函数闭包（closure）模拟出来的，下面讲解的时候还是用C#中的类、构造函数的概念，JavaScript中String、Date等“类”都被叫做“对象”，挺怪，方便初学者理解，不严谨。JavaScript中声明类（类不是类，是对象）： function Person(name,age) { this.name = name; this.age =age; this.sayHello=function(){ alert(\"你好，我是\"+this.name+\"，我\"+this.age+\"岁了\"); } } var p1 = new Person(\"tom\",20); p1.sayHello(); 必须要声明类名，function Person(name,age)可以看做是声明构造函数，Name、Age这些属性也是使用者动态添加了。var p1 = new Person(“tom”, 30);//不要丢了new，否则就变成调用函数了，p1为undefined。new 相当于创建了函数的一个实例 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:7","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"string 对象\rlength属性； charAt方法；取第几个字符 indexOf lastIndexOf Substr(start,length)、substring(start,end) split match、replace(只会替换一个，替换多个要用正则表达式)、search方法，正则表达式相关 var str = \"我爱北京天安门,北京天安门爱我\"; var reg = /我/g; alert(str.replace(\"我\", \"你\")); //replace()当第一个参数是字符串，只替换源字符串中的第一个匹配到的字符 如果是reg，就可以全部替换成功alert(str.replace(reg, \"你\")); 是正则表达式，是一个object ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:8","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"ARRAY对象\rJavaScript中的Array对象就是数组，首先是一个动态数组，而且是一个像C#中数组、ArrayList、Hashtable等的超强综合体。 var names = new Array(); names[0] = \"tom\"; names[1] = \"jerry\"; names[2] = \"lily\"; for (var i = 0; i \u003c names.length; i++) { alert(names[i]); } 无需预先制定大小，动态。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:9","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"dictionary\rJS中的Array是一个宝贝，不仅是一个数组，还是一个Dictionary，还是一个Stack。 var pinyins = new Array(); pinyins[\"人\"] = \"ren\"; pinyins[\"口\"] = \"kou\"; pinyins[\"手\"] = \"shou\"; alert(pinyins[\"人\"]); alert(pinyins.人); 像Hashtable、Dictionary那样用，而且像它们一样效率高。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:10","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"array简化\rArray还可以有简化的创建方式 var arr = [3, 5, 6, 8, 9]; 普通数组初始化 这种数组可以看做是pinyins[“人”] = “ren”;的特例，也就是key为0、1、2…… 字典风格的简化创建方式： var arr = {\"tom\":30,\"jim\":20}; ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:11","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"数组，for其他\r对于数组风格的Array来说，可以使用join方法拼接为字符串 var arr = [\"tom\",\"jim\",\"lily\"];\ralert(arr.join(\",\"));//JS中join是array的方法，不像.Net中是string的方法 for循环可以像C#中的foreach一样用 for循环还可以获得一个对象所有的成员，类似于.Net中的反射 for (var e in document) { alert(e); } 有了它没有文档也可以进行开发。 var p1 = new Object();//创建一个Object对象，动态增加属性、方法s p1.Name = \"tom\"; p1.Age = 30; p1.SayHello = function() { alert(\"hello\"); }; p1.SayHello(); for(var e in p1) {//对象的成员都是对象的key alert(e); } ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:12","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"扩展方法\r通过类对象的prototype设置扩展方法，下面为String对象增加quote（两边加字符）方法 String.prototype.quote = function(quotestr) { if (!quotestr) { quotestr = \"\\\"\"; } return quotestr + this + quotestr; }; alert(\"abc\".quote());alert(\"abc\".quote(\"|\")); 扩展方法的声明要在使用扩展方法之前执行。JS的函数没有专门的函数默认值的语法，但是可以不给参数传值，不传值的参数值就是undefined，自己做判断来给默认值。 一门新的语言学：数据类型，程序接口，类库 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:13","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"DotNet基础","content":"在windows form开发过程中还是有很多坑需要注意，包括一些重要代码记不得，在这个文件中进行汇总更新。 ","date":"2018-12-05","objectID":"/2018/12/dotnetbase5-winform/:0:0","tags":["DotNet基础","winform"],"title":"DotNet基础 winform","uri":"/2018/12/dotnetbase5-winform/"},{"categories":"DotNet基础","content":"命名规则\rM结尾表示model A结尾表示消息 Object表示 ,底层接口 Presenter表示，逻辑类 Transaction表示，具体逻辑 View表示界面接口 Helper：表示静态函数 Statements：表示字符串 E表示enum ~BTN按钮 私有变量m_ 获得Get 建立Build 生成Generate listbox 为 LB ","date":"2018-12-05","objectID":"/2018/12/dotnetbase5-winform/:1:0","tags":["DotNet基础","winform"],"title":"DotNet基础 winform","uri":"/2018/12/dotnetbase5-winform/"},{"categories":"DotNet基础","content":"一个项目体验\rusing System; using System.Windows.Forms; namespace AerationSystem { static class Program { /// \u003csummary\u003e /// 应用程序的主入口点。 /// \u003c/summary\u003e [STAThread] static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); GetAllFrom getform = new GetAllFrom(); getform.MakeLoginForm(); getform.login.ShowDialog(); if(getform.login.DialogResult==DialogResult.OK) { getform.MakeAllForm(); Application.Run(getform.currentMain); //Application.Run(new Form1()); } } } } 读取xml标签类 public class XMLHelper { /// \u003csummary\u003e /// 读取多行同一标签属性 /// \u003c/summary\u003e /// \u003cparam name=\"filename\"\u003e地址\u003c/param\u003e /// \u003cparam name=\"nodeflag\"\u003e标签\u003c/param\u003e /// \u003cparam name=\"strflag\"\u003e属性\u003c/param\u003e /// \u003creturns\u003e多行同一标签属性\u003c/returns\u003e public static string[] ReadMultipleTagOneAttribute(string filename,string nodeflag, string strflag) { try { XmlDocument xl = new XmlDocument(); xl.Load(filename); XmlNodeList xnl = xl.GetElementsByTagName(\"appSettings\")[0].ChildNodes; List\u003cstring\u003e vs = new List\u003cstring\u003e(); foreach (XmlNode cn in xnl) { if (cn.Name.Equals(nodeflag)) { vs.Add(cn.Attributes.GetNamedItem(strflag).Value); } } return vs.ToArray(); } catch (Exception ex) { Console.WriteLine(ex.StackTrace + ex.Message); } return null; } /// \u003csummary\u003e /// 读取同一标签多个属性,如果有多个同标签则返回null /// \u003c/summary\u003e /// \u003cparam name=\"filename\"\u003e地址\u003c/param\u003e /// \u003cparam name=\"nodeflag\"\u003e标签\u003c/param\u003e /// \u003cparam name=\"strflag\"\u003e多个属性\u003c/param\u003e /// \u003creturns\u003e多个属性值\u003c/returns\u003e public static string[] ReadMultipleAttributeOneTag(string filename, string nodeflag, string[] strflag) { try { XmlDocument xl = new XmlDocument(); xl.Load(filename); XmlNodeList xnl = xl.GetElementsByTagName(\"appSettings\")[0].ChildNodes; List\u003cstring\u003e vs = new List\u003cstring\u003e(); int tagcount = 0; foreach (XmlNode cn in xnl) { if (cn.Name.Equals(nodeflag)) { foreach (string s in strflag) { vs.Add(cn.Attributes.GetNamedItem(s).Value); } tagcount++; } } if (tagcount \u003e 1) { throw new Exception(\"出现多个相同标签\"); } return vs.ToArray(); } catch (Exception ex) { Console.WriteLine(ex.StackTrace + ex.Message); } return null; } } SQLHelper类 public class SQLDatabaseHelper { /// \u003csummary\u003e /// 返回多个表 /// \u003c/summary\u003e /// \u003cparam name=\"dbname\"\u003e数据库URL\u003c/param\u003e /// \u003cparam name=\"sqlstr\"\u003e执行语句\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static DataSet QueryDs(String dbname, String sqlstr) { OleDbConnection Connection = new OleDbConnection(dbname); try { Connection.Open(); OleDbDataAdapter oleDbAdapter = new OleDbDataAdapter(sqlstr, Connection); DataSet ds = new DataSet(); oleDbAdapter.Fill(ds); return ds; } catch (Exception ex) { Console.WriteLine(\"打开数据库连接异常:\" + ex.Message + \"\\r\\n\"); } finally { Connection.Close(); } return null; } /// \u003csummary\u003e /// 执行语句返会受影响函数 /// \u003c/summary\u003e /// \u003cparam name=\"dbname\"\u003e数据库URL\u003c/param\u003e /// \u003cparam name=\"sqlstr\"\u003e执行语句\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static int Execute(String dbname, String sqlstr) { OleDbConnection Connection = new OleDbConnection(dbname); try { Connection.Open(); OleDbCommand oleDbCommand = new OleDbCommand(sqlstr, Connection); return oleDbCommand.ExecuteNonQuery(); } catch (Exception ex) { Console.WriteLine(ex.Message); } finally { Connection.Close(); } return 0; } /// \u003csummary\u003e /// 执行多条语句 /// \u003c/summary\u003e /// \u003cparam name=\"dbname\"\u003e数据库url\u003c/param\u003e /// \u003cparam name=\"sqlstrs\"\u003e受影响的行数\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static int ExecuteAll(string dbname, string[] sqlstrs) { int count = 0; foreach (string s in sqlstrs) { count = count + Execute(dbname, s); } return count; } /// \u003csummary\u003e /// 返回表 /// \u003c/summary\u003e /// \u003cparam name=\"dbname\"\u003e数据库URL\u003c/param\u003e /// \u003cparam name=\"sqlstr\"\u003e执行语句\u003c/param\u003e /// \u003creturns\u003e受影响行数\u003c/returns\u003e public static DataTable QueryDt(String dbname, String sqlstr) { OleDbConnection Connection = new OleDbConnection(dbname); try { Connection.Open(); OleDbDataAdapter oleDbAdapter = new OleDbDataAdapter(sqlstr, Connection); OleDbCommandBuilder oleDbBuilder = new OleDbCommandBuilder(oleDbAdapter); DataSet ds = new DataSet(); oleDbAdapter.Fill(ds); return ds.Tables[0]; } catch (Exception ex) { Console.Writ","date":"2018-12-05","objectID":"/2018/12/dotnetbase5-winform/:2:0","tags":["DotNet基础","winform"],"title":"DotNet基础 winform","uri":"/2018/12/dotnetbase5-winform/"},{"categories":"DotNet基础","content":"自定义控件\rScreen.PrimaryScreen.WorkingArea.Width;获取桌面宽度，hight高度 this.size程序宽度 base.Invalidate(this.MenuRect)重绘矩形区域 this.FormBorderStyle = FormBorderStyle.None;无边框 this.SetStyle( ControlStyles.AllPaintingInWmPaint | ControlStyles.OptimizedDoubleBuffer | ControlStyles.ResizeRedraw | ControlStyles.Selectable | ControlStyles.ContainerControl | ControlStyles.UserPaint, true); this.SetStyle(ControlStyles.Opaque, false); this.UpdateStyles(); 绘制控件样式 Graphics g = e.Graphics;获取画布，如果是创建的使用完后要注销 FormWindowState.Maximized窗口状态 FormStartPosition.CenterParent窗体开启位置 继承form的重载类中WndProc有窗体循环，在该循环中提前捕获消息进行拦截。 设置背景图片 totalpic.ImageLocation = System.Windows.Forms.Application.StartupPath + “\\img\\” + comboBox2.Text.ToString() + “.jpg”; 使得panel1不可见的时候panel2填满panel1的区域，让panel1的dock设置为top，panel2的dock设置为fill。 ","date":"2018-12-05","objectID":"/2018/12/dotnetbase5-winform/:3:0","tags":["DotNet基础","winform"],"title":"DotNet基础 winform","uri":"/2018/12/dotnetbase5-winform/"},{"categories":"DotNet基础","content":"多线程和异步函数\r当异步线程在工作完成时如何通知调用线程 当异步线程出现异常的时候该如何处理 异步线程工作的进度如何实时的通知调用线程 如何在调用线程中取消正在工作的异步线程，并进行回滚操作 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:1:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"异步函数模型\r异步函数编程模式，只要是使用委托对象封装的函数都可以实现该函数的异步调用。因为委托类型有BeginInvoke和EndInvoke这两个方法来支持异步调用。 BeginInvoke无参数 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate void DoWork(); static void Main(string[] args) { DoWork d = new DoWork(WorkPro); d.BeginInvoke(null, null); for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread: {i}\"); } Console.WriteLine(\"Main Thread Done\"); Console.ReadKey(); } private static void WorkPro() { for (int i = 0; i \u003c 10; i++) { Thread.Sleep(10); Console.WriteLine($\"Asyn Thread: {i}\"); } Console.WriteLine(\"Asyn Thread Done\"); } } } 结果 Main Thread: 0 Asyn Thread: 0 Main Thread: 1 Asyn Thread: 1 Main Thread: 2 Asyn Thread: 2 Main Thread: 3 Asyn Thread: 3 Main Thread: 4 Main Thread Done Asyn Thread: 4 Asyn Thread: 5 Asyn Thread: 6 Asyn Thread: 7 Asyn Thread: 8 Asyn Thread: 9 Asyn Thread Done BeginInvoke有参数， BeginInvoke，IAsyncResult ，EndInvoke，使用这三个函数会等，异步调用EndInvoke返回再开启主线程，异步调用时间比主线程长，主线程会处于阻塞状态，阻塞位置在EndInvoke函数 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { DoWork d = new DoWork(WorkPro); IAsyncResult r = d.BeginInvoke(1000, null, null); int result = d.EndInvoke(r); Console.WriteLine($\"Asyn result:{result}\"); for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread: {i}\"); } Console.WriteLine(\"Main Thread Done\"); Console.ReadKey(); } private static int WorkPro(int count) { int sum = 0; for (int i = 0; i \u003c 10; i++) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread: {i}\"); } Console.WriteLine(\"Asyn Thread Done\"); return sum; } } } 结果： Asyn Thread: 0 Asyn Thread: 1 Asyn Thread: 2 Asyn Thread: 3 Asyn Thread: 4 Asyn Thread: 5 Asyn Thread: 6 Asyn Thread: 7 Asyn Thread: 8 Asyn Thread: 9 Asyn Thread Done Asyn result:45 Main Thread: 0 Main Thread: 1 Main Thread: 2 Main Thread: 3 Main Thread: 4 Main Thread Done 当调整EndInvoke的位置时， using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { DoWork d = new DoWork(WorkPro); IAsyncResult r = d.BeginInvoke(1000, null, null); for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread: {i}\"); } int result = d.EndInvoke(r); Console.WriteLine($\"Asyn result:{result}\"); Console.WriteLine(\"Main Thread Done\"); Console.ReadKey(); } private static int WorkPro(int count) { int sum = 0; for (int i = 0; i \u003c 10; i++) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread: {i}\"); } Console.WriteLine(\"Asyn Thread Done\"); return sum; } } } 结果： Main Thread: 0 Asyn Thread: 0 Main Thread: 1 Asyn Thread: 1 Main Thread: 2 Asyn Thread: 2 Main Thread: 3 Asyn Thread: 3 Main Thread: 4 Asyn Thread: 4 Asyn Thread: 5 Asyn Thread: 6 Asyn Thread: 7 Asyn Thread: 8 Asyn Thread: 9 Asyn Thread Done Asyn result:45 Main Thread Done 主线程执行时间比异步调用的长，并未看见阻塞 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { DoWork d = new DoWork(WorkPro); IAsyncResult r = d.BeginInvoke(1000, null, null); for (int i = 0; i \u003c 10; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread: {i}\"); } int result = d.EndInvoke(r); Console.WriteLine($\"Asyn result:{result}\"); Console.WriteLine(\"Main Thread Done\"); Console.ReadKey(); } private static int WorkPro(int count) { int sum = 0; for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread: {i}\"); } Console.WriteLine(\"Asyn Thread Done\"); return sum; } } } Main","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:1:1","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"自动通知主线程完成\r上面两个例子这并不是理想的状态，理想状态是，异步调用完成后自动通知主线程完成，主线程调用。 BeginInvoke 方法启动异步调用。该方法具有与你要异步执行的方法相同的参数，另加两个可选参数。 第一个参数是一个 AsyncCallback 委托，此委托引用在异步调用完成时要调用的方法。 第二个参数是一个用户定义的对象object，该对象将信息传递到回调方法。 BeginInvoke 将立即返回，而不会等待异步调用完成。 BeginInvoke 返回可用于监视异步调用的进度的 IAsyncResult。 EndInvoke 方法用于检索异步调用的结果。 它可以在调用 BeginInvoke之后的任意时间调用。 如果异步调用尚未完成，那么 EndInvoke 将阻止调用线程，直到完成异步调用。 EndInvoke 的参数包括要异步执行的方法的 out 和 ref 参数，以及 BeginInvoke 返回的 IAsyncResult。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { DoWork d = new DoWork(WorkPro); IAsyncResult r = d.BeginInvoke(1000, CallBack, d); for (int i = 0; i \u003c 10; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread: {i}\"); } Console.WriteLine(\"Main Thread Done\"); Console.ReadKey(); } private static int WorkPro(int count) { int sum = 0; for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread: {i}\"); } Console.WriteLine(\"Asyn Thread Done\"); return sum; } public static void CallBack(IAsyncResult r) { DoWork d = (DoWork)r.AsyncState; Console.WriteLine($\"Asyn result:{d.EndInvoke(r)}\"); } } } Main Thread: 0 Asyn Thread: 0 Main Thread: 1 Asyn Thread: 1 Main Thread: 2 Asyn Thread: 2 Main Thread: 3 Asyn Thread: 3 Main Thread: 4 Asyn Thread: 4 Asyn Thread Done Asyn result:10 Main Thread: 5 Main Thread: 6 Main Thread: 7 Main Thread: 8 Main Thread: 9 Main Thread Done 改进查看CallBack的执行情况 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { DoWork d = new DoWork(WorkPro); IAsyncResult r = d.BeginInvoke(1000, CallBack, d); for (int i = 0; i \u003c 10; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread: {i}\"); } Console.WriteLine(\"Main Thread Done\"); Console.ReadKey(); } private static int WorkPro(int count) { int sum = 0; for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread: {i}\"); } Console.WriteLine(\"Asyn Thread Done\"); return sum; } public static void CallBack(IAsyncResult r) { for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"CallBack: {i}\"); } DoWork d = (DoWork)r.AsyncState; Console.WriteLine($\"Asyn result:{d.EndInvoke(r)}\"); } } } Main Thread: 0 Asyn Thread: 0 Main Thread: 1 Main Thread: 2 Asyn Thread: 1 Asyn Thread: 2 Main Thread: 3 Asyn Thread: 3 Main Thread: 4 Asyn Thread: 4 Asyn Thread Done Main Thread: 5 Main Thread: 6 CallBack: 0 Main Thread: 7 CallBack: 1 Main Thread: 8 CallBack: 2 Main Thread: 9 Main Thread Done CallBack: 3 CallBack: 4 Asyn result:10 回调函数也处于另一个线程中，与主线程并行执行，并且执行时间不等 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:1:2","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"正常的线程调用\r.net在System.Threading和System.Threading.Tasks这两个命名空间中提供了Thread，ThreadPool，和Task三个类来处理多线程的问题，其中Thread是建立一个专用线程，ThreadPool是使用线程池中工作线程，而Task类是采用任务的方式，其内部也是使用线程池中的工作线程。 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:2:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"Thread类\r使用方法很简单，它开辟的是一个专用线程，不是线程池中的工作线程，不由线程池去管理。该类提供4个重载版本，常见的使用前面两个就好了。 public Thread( ThreadStart start )：其中ThreadStart是一个无参无返回值的委托类型。 public Thread( ParameterizedThreadStart start )：其中ParameterizedThreadStart 是一个带有一个Object类型的参数，无返回值的委托类型。 从Thread类提供了两个构造函数可以看出，Thread类能够异步调用无参无返回值的函数，也能够异步调用带一个Object类型的无返回值的函数。下面就给出一个例子简单的演示一下如何使用Thread异步执行一个带参数的函数。 using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { class Program { int interval = 200; static void Main(string[] args) { Program p = new Program(); Thread nonParameterThread = new Thread(new ThreadStart(p.NonParameterRun)); nonParameterThread.Start(); } /// \u003csummary\u003e /// 不带参数的启动方法 /// \u003c/summary\u003e public void NonParameterRun() { for (int i = 0; i \u003c 10; i++) { Console.WriteLine(\"系统当前时间毫秒值：\"+DateTime.Now.Millisecond.ToString()); Thread.Sleep(interval);//让线程暂停 } } } } 结果： 系统当前时间毫秒值：384 系统当前时间毫秒值：591 系统当前时间毫秒值：792 系统当前时间毫秒值：993 系统当前时间毫秒值：194 系统当前时间毫秒值：394 系统当前时间毫秒值：595 系统当前时间毫秒值：796 系统当前时间毫秒值：997 系统当前时间毫秒值：198 请按任意键继续. . . ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:2:1","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"带参数的线程\r线程输出10个值后就终止执行了，用ThreadStart委托作为构造函数来实例化thread是不带参数的，带参数的委托ParameterizedThreadStart，其带有一个Object参数的方法 using System; using System.Threading; namespace StartThread { class Program { int interval = 200; static void Main(string[] args) { Program p = new Program(); Thread parameterThread = new Thread(new ParameterizedThreadStart(p.ParameterRun)); parameterThread.Name = \"Thread A:\"; parameterThread.Start(5); } /// \u003csummary\u003e /// 带参数的启动方法 /// \u003c/summary\u003e /// \u003cparam name=\"ms\"\u003e让线程在运行过程中的休眠间隔\u003c/param\u003e public void ParameterRun(object ms) { int j = 10; int.TryParse(ms.ToString(), out j);//这里采用了TryParse方法，避免不能转换时出现异常 for (int i = 0; i \u003c j; i++) { Console.WriteLine(Thread.CurrentThread.Name + \"系统当前时间毫秒值：\" + DateTime.Now.Millisecond.ToString()); Thread.Sleep(j);//让线程暂停 } } } } 结果： Thread A:系统当前时间毫秒值：127 Thread A:系统当前时间毫秒值：136 Thread A:系统当前时间毫秒值：142 Thread A:系统当前时间毫秒值：148 Thread A:系统当前时间毫秒值：154 请按任意键继续. . . ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:3:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"两个线程参数不一样\r第一个线程启动后，线程实例就不需要存在了 两个线程间隔时间不一样 using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { class Program { int interval = 200; static void Main(string[] args) { Program p = new Program(); Thread parameterThread = new Thread(new ParameterizedThreadStart(p.ParameterRun)); parameterThread.Name = \"Thread A:\"; parameterThread.Start(30); //启动第二个线程 parameterThread = new Thread(new ParameterizedThreadStart(p.ParameterRun)); parameterThread.Name = \"Thread B:\"; parameterThread.Start(60); } /// \u003csummary\u003e /// 带参数的启动方法 /// \u003c/summary\u003e /// \u003cparam name=\"ms\"\u003e让线程在运行过程中的休眠间隔\u003c/param\u003e public void ParameterRun(object ms) { int j = 10; int.TryParse(ms.ToString(), out j);//这里采用了TryParse方法，避免不能转换时出现异常 for (int i = 0; i \u003c 10; i++) { Console.WriteLine(Thread.CurrentThread.Name+\"系统当前时间毫秒值：\" + DateTime.Now.Millisecond.ToString()); Thread.Sleep(j);//让线程暂停 } } } } 结果： Thread A:系统当前时间毫秒值：294 Thread B:系统当前时间毫秒值：294 Thread A:系统当前时间毫秒值：326 Thread B:系统当前时间毫秒值：357 Thread A:系统当前时间毫秒值：357 Thread A:系统当前时间毫秒值：388 Thread B:系统当前时间毫秒值：418 Thread A:系统当前时间毫秒值：419 Thread A:系统当前时间毫秒值：450 Thread B:系统当前时间毫秒值：479 Thread A:系统当前时间毫秒值：481 Thread A:系统当前时间毫秒值：511 Thread B:系统当前时间毫秒值：540 Thread A:系统当前时间毫秒值：543 Thread A:系统当前时间毫秒值：574 Thread B:系统当前时间毫秒值：600 Thread B:系统当前时间毫秒值：661 Thread B:系统当前时间毫秒值：723 Thread B:系统当前时间毫秒值：784 Thread B:系统当前时间毫秒值：845 请按任意键继续. . . ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:4:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"传递多参数\r如果需要传递两个参数怎么办呢，有两种方法 调用ParameterizedThreadStart，将参数封装成类，或者结构进行调用 构造线程类，将自己的线程和参数封装在一起 using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { class MyThreadParameter { private int interval; private int loopCount; /// \u003csummary\u003e /// 循环次数 /// \u003c/summary\u003e public int LoopCount { get { return loopCount; } } /// \u003csummary\u003e /// 线程的暂停间隔 /// \u003c/summary\u003e public int Interval { get { return interval; } } /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e /// \u003cparam name=\"interval\"\u003e线程的暂停间隔\u003c/param\u003e /// \u003cparam name=\"loopCount\"\u003e循环次数\u003c/param\u003e public MyThreadParameter(int interval,int loopCount) { this.interval = interval; this.loopCount = loopCount; } } class Program { int interval = 200; static void Main(string[] args) { Program p = new Program(); Thread parameterThread = new Thread(new ParameterizedThreadStart(p.MyParameterRun)); parameterThread.Name = \"Thread A:\"; MyThreadParameter paramter = new MyThreadParameter(50, 5); parameterThread.Start(paramter); } /// \u003csummary\u003e /// 带多个参数的启动方法 /// \u003c/summary\u003e /// \u003cparam name=\"ms\"\u003e方法参数\u003c/param\u003e public void MyParameterRun(object ms) { MyThreadParameter parameter = ms as MyThreadParameter;//类型转换 if (parameter != null) { for (int i = 0; i \u003c parameter.LoopCount; i++) { Console.WriteLine(Thread.CurrentThread.Name + \"系统当前时间毫秒值：\" + DateTime.Now.Millisecond.ToString()); Thread.Sleep(parameter.Interval);//让线程暂停 } } } } } 结果： Thread A:系统当前时间毫秒值：215 Thread A:系统当前时间毫秒值：270 Thread A:系统当前时间毫秒值：321 Thread A:系统当前时间毫秒值：372 Thread A:系统当前时间毫秒值：423 请按任意键继续. . . using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { class MyThreadParameter { private int interval; private int loopCount; private Thread thread; /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e /// \u003cparam name=\"interval\"\u003e线程的暂停间隔\u003c/param\u003e /// \u003cparam name=\"loopCount\"\u003e循环次数\u003c/param\u003e public MyThreadParameter(int interval,int loopCount) { this.interval = interval; this.loopCount = loopCount; thread = new Thread(new ThreadStart(Run)); } public void Start() { if (thread != null) { thread.Start(); } } private void Run() { for (int i = 0; i \u003c loopCount; i++) { Console.WriteLine(\"系统当前时间毫秒值：\" + DateTime.Now.Millisecond.ToString()); Thread.Sleep(interval);//让线程暂停 } } } class Program { static void Main(string[] args) { MyThreadParameter parameterThread = new MyThreadParameter(30, 5); parameterThread.Start(); } } } 结果 系统当前时间毫秒值：438 系统当前时间毫秒值：471 系统当前时间毫秒值：502 系统当前时间毫秒值：533 系统当前时间毫秒值：563 请按任意键继续. . . ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:5:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"多线程同干一件事\r多线程同干一件事的时候对发生一些问题 using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { public class ThreadLock { private Thread threadOne; private Thread threadTwo; private List\u003cstring\u003e ticketList; private object objLock = new object(); public ThreadLock() { threadOne = new Thread(new ThreadStart(Run)); threadOne.Name = \"Thread_1\"; threadTwo = new Thread(new ThreadStart(Run)); threadTwo.Name = \"Thread_2\"; } static void Main(string[] args) { ThreadLock th = new ThreadLock(); th.Start(); } public void Start() { ticketList = new List\u003cstring\u003e(10); for (int i = 1; i \u003c= 10; i++) { ticketList.Add(i.ToString().PadLeft(3, '0'));//实现3位的票号，如果不足3位数，则以0补足3位 } threadOne.Start(); threadTwo.Start(); } private void Run() { while (ticketList.Count \u003e 0)//① { string ticketNo = ticketList[0];//② Console.WriteLine(\"{0}:售出一张票，票号：{1}\", Thread.CurrentThread.Name, ticketNo); ticketList.RemoveAt(0);//③ Thread.Sleep(1); } } } } 结果： Thread_1:售出一张票，票号：001 Thread_2:售出一张票，票号：001 Thread_1:售出一张票，票号：003 Thread_2:售出一张票，票号：004 Thread_1:售出一张票，票号：005 Thread_2:售出一张票，票号：006 Thread_1:售出一张票，票号：007 Thread_2:售出一张票，票号：008 Thread_1:售出一张票，票号：008 Thread_2:售出一张票，票号：010 Thread_1:售出一张票，票号：010 未经处理的异常: System.ArgumentOutOfRangeException: 索引超出范围。必须为非负值并小于集合大小。 参数名: index 在 System.ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource) 在 System.Collections.Generic.List`1.RemoveAt(Int32 index) 在 StartThread.ThreadLock.Run() 位置 C:\\Users\\DuJinfeng\\Desktop\\C#源码\\test\\test\\练习\\test\\Program.cs:行号 79 在 System.Threading.ThreadHelper.ThreadStart_Context(Object state) 在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) 在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) 在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state) 在 System.Threading.ThreadHelper.ThreadStart() 请按任意键继续. . . 该程序在③处会出现问题，如果第一个线程在③处的时间片段正好用完第二个线程调用就会出现一张票被卖两次的问题 同步问题的解决方法： lock、 Mutex、 Monitor、 Semaphore、 Interlocked ReaderWriterLock等 同步策略可以有同步上下文、同步代码区、手动同步 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"上下文同步策略\r上下文同步： 同步上下文的策略主要是依靠SynchronizationAttribute类来实现 using System; using System.Collections.Generic; using System.Text; //需要添加对System.EnterpriseServices.dll这个类库的引用采用使用这个dll using System.EnterpriseServices; namespace StartThread { [Synchronization(SynchronizationOption.Required)]//确保创建的对象已经同步 public class SynchronizationAttributeClass { public void Run() { } } } 所有在同一个上下文域的对象共享同一个锁。这样创建的对象实例属性、方法和字段就具有线程安全性，需要注意的是类的静态字段、属性和方法是不具有线程安全性的。 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:1","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"同步代码区\r同步代码区是另外一种策略，它是针对特定部分代码进行同步的一种方法 lock同步 private void Run() { while (ticketList.Count \u003e 0)//① { lock (objLock) { if (ticketList.Count \u003e 0)//必须要再一次判断在1之后可能进入其他线程 { string ticketNo = ticketList[0];//② Console.WriteLine(\"{0}:售出一张票，票号：{1}\", Thread.CurrentThread.Name, ticketNo); ticketList.RemoveAt(0);//③ Thread.Sleep(1); } } } } Monitor类同步 private void Run() { while (ticketList.Count \u003e 0)//① { Monitor.Enter(objLock); if (ticketList.Count \u003e 0) { string ticketNo = ticketList[0];//② Console.WriteLine(\"{0}:售出一张票，票号：{1}\", Thread.CurrentThread.Name, ticketNo); ticketList.RemoveAt(0);//③ Thread.Sleep(1); } Monitor.Exit(objLock); } } 使用lock关键字的代码实际上是用Monitor来实现的。 lock (objLock){ //同步代码 } //等价于 try{ Monitor.Enter(objLock); //同步代码 } finally { Monitor.Exit(objLock); } Monitor类除了Enter()和Exit()方法之外，还有Wait()和Pulse()方法。 Wait()方法是临时释放当前活得的锁，并使当前对象处于阻塞状态 Pulse()方法是通知处于等待状态的对象可以准备就绪了，它一会就会释放锁 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Collections; using System.Threading; public class ThreadDemo { private Thread threadOne; private Thread threadTwo; private ArrayList stringList; private event EventHandler OnNumberClear;//数据删除完成引发的事件 public static void Main() { ThreadDemo demo = new ThreadDemo(10); demo.Action(); Console.ReadKey(); } public ThreadDemo(int number) { Random random = new Random(100); stringList = new ArrayList(number); for (int i = 0; i \u003c number; i++) { stringList.Add(random.Next().ToString()); } threadOne = new Thread(new ThreadStart(Run));//两个线程共同做一件事情 threadTwo = new Thread(new ThreadStart(Run));//两个线程共同做一件事情 threadOne.Name = \"线程1\"; threadTwo.Name = \"线程2\"; for (int i = 0; i \u003c number; i++) { Console.WriteLine($\"主线程1：{i.ToString()}\"); } OnNumberClear += new EventHandler(ThreadDemo_OnNumberClear); } /// \u003csummary\u003e /// 开始工作 /// \u003c/summary\u003e public void Action() { threadOne.Start(); threadTwo.Start(); } /// \u003csummary\u003e /// 共同做的工作 /// \u003c/summary\u003e private void Run() { string stringValue = null; while (true) { Monitor.Enter(this);//锁定，保持同步 stringValue = (string)stringList[0]; Console.WriteLine(Thread.CurrentThread.Name + \"删除了\" + stringValue); stringList.RemoveAt(0);//删除ArrayList中的元素 if (stringList.Count == 0) { OnNumberClear(this, new EventArgs());//引发完成事件 } Monitor.Exit(this);//取消锁定 Thread.Sleep(5); } } //执行完成之后，停止所有线程 void ThreadDemo_OnNumberClear(object sender, EventArgs e) { Console.WriteLine(\"执行完了，停止了所有线程的执行。\"); threadTwo.Abort(); threadOne.Abort();//终止线程调用 } } 结果： 主线程1：0 主线程1：1 主线程1：2 主线程1：3 主线程1：4 主线程1：5 主线程1：6 主线程1：7 主线程1：8 主线程1：9 线程1删除了2080427802 线程2删除了341851734 线程1删除了1431988776 线程2删除了1938005744 线程1删除了761513014 线程2删除了2037243568 线程1删除了1528357293 线程2删除了1311292502 线程1删除了749943798 线程2删除了319576108 执行完了，停止了所有线程的执行。 using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { public class ThreadWaitAndPluse { private object lockObject; private int number; private Random random; public ThreadWaitAndPluse() { lockObject = new object(); random = new Random(); } //显示生成数据的线程要执行的方法 public void ThreadMethodOne() { Monitor.Enter(lockObject);//获取对象锁 Console.WriteLine(\"当前进入的线程：\" + Thread.CurrentThread.GetHashCode()); for (int i = 0; i \u003c 5; i++) { Monitor.Wait(lockObject);//释放对象锁，并阻止当前线程 Console.WriteLine(\"WaitAndPluse1:工作\"); Console.WriteLine(\"WaitAndPluse1:得到了数据，number=\" + number + \",Thread ID=\" + Thread.CurrentThread.GetHashCode()); //通知其它等待锁的对象状态已经发生改变,当这个对象释放锁之后等待锁的对象将会活得锁 Monitor.Pulse(lockObject); } Console.WriteLine(\"退出当前线程：\" + Thread.CurrentThread.GetHashCode()); Monitor.Exit(lockObject);//释放对象锁 } //生成随机数据线程要执行的方法 public void ThreadMethodTwo() { Monitor.Enter(lockObject);//获取对象锁 Console.WriteLine(\"当前进入的线程：\" + Thread.CurrentThread.GetHashCode()); for (int i = 0; i \u003c 5; i++) { //通知其它等待锁的对象状态已经发生改变,当这个对象释放锁之后等待锁的对象将会活得锁 Monitor.Pulse(lockObject); Console.WriteLine(\"WaitAndPluse2:工作\"); number =random.Next(DateTime.Now.Millisecond);//生成随机数 Console.WriteLine(\"WaitAndPluse2:生成了数据，number=\" + number + \",Thread ID=\"","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:2","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"手动同步\rReaderWriterLock：ReaderWriterLock支持单个写线程和多个读线程的锁，使用ReaderWriterLock来进行读写同步比使用监视的方式（如Monitor）效率要高 .NET Framework 具有两个读取器 / 编写器锁， ReaderWriterLockSlim 和 ReaderWriterLock。 ReaderWriterLockSlim 建议将所有新的开发的。 ReaderWriterLockSlim 类似于 ReaderWriterLock, ，只是简化了递归、 升级和降级锁定状态的规则。 ReaderWriterLockSlim 可避免潜在的死锁的很多情况。 此外，性能的 ReaderWriterLockSlim 明显优于 ReaderWriterLock。 ReaderWriterLock 用于同步对资源的访问。 在任何给定时间，它允许多个线程的并发读访问权限，或者一个单独的线程的写访问权限。 在某个资源，很少更改的情况下 ReaderWriterLock 提供了更好的吞吐量比简单的一次锁，如 Monitor。 ReaderWriterLock 其中大多数的访问权限是读取，而写入是很少和持续时间较短的效果最佳。 多个读取器交替使用单个编写器，以便读取器和编写器都不被阻止较长时间 下面的示例演示如何使用 ReaderWriterLock 若要保护的共享的资源，一个整数值，名为 resource, ，即并发读取和写入以独占方式由多个线程。 请注意， ReaderWriterLock 以便对所有线程可见的类级别声明。 using System; using System.Threading; public class Example { static ReaderWriterLock rwl = new ReaderWriterLock(); // 定义受ReaderWriterLock保护的共享资源。 static int resource = 0; /// \u003csummary\u003e /// 线程数量 /// \u003c/summary\u003e const int numThreads = 10; /// \u003csummary\u003e /// 线程启动开关 /// \u003c/summary\u003e static bool running = true; /// \u003csummary\u003e /// 随机 /// \u003c/summary\u003e static Random rnd = new Random(); // 读取超时时间 static int readerTimeouts = 0; //写入超时时间 static int writerTimeouts = 0; //读取次数 static int reads = 0; //写入次数 static int writes = 0; public static void Main() { // 启动一系列线程以随机读取和写入共享资源。 Thread[] t = new Thread[numThreads]; for (int i = 0; i \u003c numThreads; i++) { t[i] = new Thread(new ThreadStart(ThreadProc)); t[i].Name = new String(Convert.ToChar(i + 65), 1); t[i].Start(); Console.WriteLine($\"线程：{t[i].Name }启动\"); if (i \u003e 10) Thread.Sleep(300); } // 告诉线程关闭并等待它们全部完成。 running = false; for (int i = 0; i \u003c numThreads; i++) { t[i].Join();//阻止调用线程，直到某个线程终止时为止。 Console.WriteLine($\"线程：{t[i].Name }阻止\"); } // 显示统计信息 Console.WriteLine($\"\\n{reads} 次读, {writes} 次写, 读取请求超时时间{readerTimeouts} , 写请求超时时间{writerTimeouts} .\"); Console.Write(\"退出 \"); Console.ReadLine(); } static void ThreadProc() { // 随机选择线程从共享资源中读取和写入的方式 while (running) { double action = rnd.NextDouble();//返回一个0-1之间的随机数 if (action \u003c .7) ReadFromResource(10);//80%读 else if (action \u003c .81) ReleaseRestore(50); else if (action \u003c .90) UpgradeDowngrade(100); else WriteToResource(100); } } // 请求并释放读卡器锁，并处理超时。 static void ReadFromResource(int timeOut) { try { rwl.AcquireReaderLock(timeOut);//获取读线程锁。//使用一个int超时值获取读线程 try { // 此线程可以安全地从共享资源中读取。 Display(\"读取资源值:\" + resource); Interlocked.Increment(ref reads);//对资源操作 } finally { // 确保已释放锁定。 rwl.ReleaseReaderLock();//减少锁计数。 } } catch (ApplicationException) { //读卡器锁定请求超时。 Interlocked.Increment(ref readerTimeouts);//时间增加 } } // 请求并释放写入程序锁定，并处理超时。 static void WriteToResource(int timeOut) { try { rwl.AcquireWriterLock(timeOut);//获取写线程锁。//使用一个int超时值获取写线程 try { // 此线程可以安全地从共享资源进行访问。 resource = rnd.Next(100); Display(\"写资源值: \" + resource); Interlocked.Increment(ref writes);//写入次数 } finally { // 确保已释放锁定。 rwl.ReleaseWriterLock();//减少写线程上锁的计数 } } catch (ApplicationException) { // The writer lock request timed out. Interlocked.Increment(ref writerTimeouts); } } // 请求读取器锁定，将读取器锁定升级到写入器锁定，并再次将其降级为读取器锁定。 static void UpgradeDowngrade(int timeOut) { try { rwl.AcquireReaderLock(timeOut);//通过设置的读时间int值获取读线程锁 try { // 这个线程从共享资源中读取是安全的。 Display(\"读资源值: \" + resource); Interlocked.Increment(ref reads); // 要写入资源，要么释放读取器锁定并请求写入程序锁定，要么升级读取器锁定。 //升级读取器锁将线程置于写入队列中，位于可能正在等待写入器锁定的任何其他线程之后。 try { LockCookie lc = rwl.UpgradeToWriterLock(timeOut);//将一个设置超时int值的读线程锁升级为写线程锁 try { // 此线程可以安全地从共享资源读取或写入。 resource = rnd.Next(100); Display(\"从读锁变成写锁写资源值: \" + resource); Interlocked.Increment(ref writes);//写值 } finally { // 确保已释放锁定。 rwl.DowngradeFromWriterLock(ref lc);//将线程的锁状态还原为调用 UpgradeToWriterLock 前的状态。 } } catch (ApplicationException) { // 更新写线程时间 Interlocked.Increment(ref writerTimeouts); } // 如果锁被降级，从资源中读取仍然是安全的。 Display(\"从读锁变成写锁再变读锁读资源值: \" + resource); Interlocked.Increment(ref reads); } finally { // 确保已释放锁定。 rwl.ReleaseReaderLock(); } } catch (ApplicationException) { // 读卡器锁定请求超时。 Interlocked.Increment(ref readerTimeouts); } } //释放所有锁，然后恢复锁定状态。 //使用序列号来确定另一个线程是否已获得写入器锁定，因为此线程上次访问该资源。 static void ReleaseRestore(int timeOut) { ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:3","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"AutoResetEvent 类\r通知正在等待的线程已发生事件。MSCN介绍中，终止状态就是有信号 AutoResetEvent（bool isover）：构造函数指示是否指示是否将初始状态设置为终止的 Reset:将事件状态设置为非终止状态，导致线程阻止。 Set:将事件状态设置为终止状态，允许一个或多个等待线程继续。将事件状态设置为有信号 WaitOne():阻止当前线程，直到当前 WaitHandle 收到信号。会自动改变信号，讲有信号自动变成无信号，需要自己调用set WaitOne(Int32):阻止当前线程，直到当前 WaitHandle 收到信号，同时使用 32 位带符号整数指定时间间隔 using System; using System.Threading; class Example { //mscn中终止状态就是有信号 //全局 private static AutoResetEvent event_1 = new AutoResetEvent(true);//初始化为终止状态，有信号 private static AutoResetEvent event_2 = new AutoResetEvent(false);//初始状态为非终止状态，没有信号 static void Main() { Console.WriteLine(\"按Enter键创建三个线程并启动它们。\\r\\n\" + \"线程在创建的AutoResetEvent1上等待\\r\\n\" + \"在信号状态，所以第一个线程被释放。\\r\\n\" + \"这使AutoResetEvent1进入无信号状态.\"); Console.ReadLine(); for (int i = 1; i \u003c 4; i++) { Thread t = new Thread(ThreadProc); t.Name = i+ \"号线程\"; Console.WriteLine(\"{0}号线程开始\",t.Name); t.Start(); } Thread.Sleep(250); for (int i = 0; i \u003c 2; i++) { Console.WriteLine(\"按Enter键以释放另一个线程。\"); Console.ReadLine(); event_1.Set(); Thread.Sleep(250); } Console.WriteLine(\"\\r\\n所有线程现在都在等待AutoResetEvent＃2。\"); for (int i = 0; i \u003c 3; i++) { Console.WriteLine(\"按Enter键以释放线程。\"); Console.ReadLine(); event_2.Set(); Thread.Sleep(250); } } static void ThreadProc() { string name = Thread.CurrentThread.Name; Console.WriteLine(\"{0} 等待AutoResetEvent # 1。\", name); event_1.WaitOne(); Console.WriteLine(\"{0} 从AutoResetEvent # 1中释放。\", name); Console.WriteLine(\"{0} 等待AutoResetEvent # 2。\", name); event_2.WaitOne(); Console.WriteLine(\"{0} 从AutoResetEvent # 2中释放。\", name); Console.WriteLine(\"{0} 结束。\", name); } } 结果 按Enter键创建三个线程并启动它们。 线程在创建的AutoResetEvent1上等待 在信号状态，所以第一个线程被释放。 这使AutoResetEvent1进入无信号状态. 1号线程号线程开始 2号线程号线程开始 1号线程 等待AutoResetEvent # 1。 1号线程 从AutoResetEvent # 1中释放。 1号线程 等待AutoResetEvent # 2。 2号线程 等待AutoResetEvent # 1。 3号线程号线程开始 3号线程 等待AutoResetEvent # 1。 按Enter键以释放另一个线程。 2号线程 从AutoResetEvent # 1中释放。 2号线程 等待AutoResetEvent # 2。 按Enter键以释放另一个线程。 3号线程 从AutoResetEvent # 1中释放。 3号线程 等待AutoResetEvent # 2。 所有线程现在都在等待AutoResetEvent＃2。 按Enter键以释放线程。 1号线程 从AutoResetEvent # 2中释放。 1号线程 结束。 按Enter键以释放线程。 2号线程 从AutoResetEvent # 2中释放。 2号线程 结束。 按Enter键以释放线程。 3号线程 从AutoResetEvent # 2中释放。 3号线程 结束。 请按任意键继续. . . ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:4","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"ManualResetEvent 类\r通知一个或多个正在等待的线程已发生事件。 ManualResetEvent：用一个指示是否将初始状态设置为终止的布尔值初始化，初始状态是否有信号 set:将事件状态设置为终止状态，允许一个或多个等待线程继续。,设置有信号,设为有信号后就一直有信号，即使waitone后也信号，直到reset将其设为无信号 WaitOne()：阻止当前线程，直到当前 WaitHandle 收到信号。 WaitOne(Int32)：阻止当前线程，直到当前 WaitHandle 收到信号，同时使用 32 位带符号整数指定时间间隔（以毫秒为单位）。 Reset：将事件状态设置为非终止状态，导致线程阻止。 using System; using System.Threading; public class Example { private static ManualResetEvent mre = new ManualResetEvent(false);//初始状态没有信号 static void Main() { Console.WriteLine(\"\\n启动3个在ManualResetEvent上阻塞的命名线程：\\n\"); for (int i = 0; i \u003c= 2; i++) { Thread t = new Thread(ThreadProc); t.Name = i+\"号线程\"; Console.WriteLine(\"{0}开始\", t.Name); t.Start(); } Thread.Sleep(500); Console.WriteLine(\"\\n当所有三个线程都已启动时，按Enter键调用Set（）\" + \"\\n释放所有线程。\\n\"); Console.ReadLine(); mre.Set(); Thread.Sleep(500); Console.WriteLine(\"\\n发出ManualResetEvent信号时，调用WaitOne（）的线程\" + \"\\n不要阻止。 按Enter键显示此信息。\\n\"); Console.ReadLine(); for (int i = 3; i \u003c= 4; i++) { Thread t = new Thread(ThreadProc); t.Name = i + \"号线程\"; t.Start(); } Thread.Sleep(500); Console.WriteLine(\"\\n按Enter键调用Reset（），以便线程再次阻止\" + \"\\n当他们调用WaitOne（）时.\\n\"); Console.ReadLine(); mre.Reset(); // Start a thread that waits on the ManualResetEvent. Thread t5 = new Thread(ThreadProc); t5.Name = \"Thread_5\"; t5.Start(); Thread.Sleep(500); Console.WriteLine(\"\\nPress Enter to call Set() and conclude the demo.\"); Console.ReadLine(); mre.Set(); } private static void ThreadProc() { string name = Thread.CurrentThread.Name; Console.WriteLine(name + \" 启动并调用mre.WaitOne（）\"); mre.WaitOne(); Console.WriteLine(name + \" ends.\"); } } 结果： 启动3个在ManualResetEvent上阻塞的命名线程： 0号线程开始 1号线程开始 0号线程 启动并调用mre.WaitOne（） 2号线程开始 1号线程 启动并调用mre.WaitOne（） 2号线程 启动并调用mre.WaitOne（） 当所有三个线程都已启动时，按Enter键调用Set（） 释放所有线程。 2号线程 ends. 0号线程 ends. 1号线程 ends. 发出ManualResetEvent信号时，调用WaitOne（）的线程 不要阻止。 按Enter键显示此信息。 3号线程 启动并调用mre.WaitOne（） 3号线程 ends. 4号线程 启动并调用mre.WaitOne（） 4号线程 ends. 按Enter键调用Reset（），以便线程再次阻止 当他们调用WaitOne（）时. Thread_5 启动并调用mre.WaitOne（） Press Enter to call Set() and conclude the demo. Thread_5 ends. 请按任意键继续. . . ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:5","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"Interlocked 类\r为多个线程共享的变量提供原子操作。 Increment(Int32)：以原子操作的形式递增指定变量的值并存储结果。 Add(Int32, Int32)：对两个 32 位整数进行求和并用和替换第一个整数，上述操作作为一个原子操作完成。 CompareExchange(Double, Double, Double)：比较两个双精度浮点数是否相等，如果相等，则替换第一个值。 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:6","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"waithandle\rWaitHandle类是一个抽象类，有多个类直接或者间接继承自WaitHandle类 在WaitHandle类中SignalAndWait、WaitAll、WaitAny及WaitOne这几个方法都有重载形式，其中除WaitOne之外都是静态的。 WaitHandle方法常用作同步对象的基类。WaitHandle对象通知其他的线程它需要对资源排他性的访问，其他的线程必须等待，直到WaitHandle不再使用资源和等待句柄没有被使用。 WaitHandle方法有多个Wait的方法，这些方法的区别如下： WaitAll：等待指定数组中的所有元素收到信号。 WaitAny：等待指定数组中的任一元素收到信号。 WaitOne：当在派生类中重写时，阻塞当前线程，直到当前的 WaitHandle 收到信号。 MSCN上面的代码 using System; using System.Threading; namespace AutoResetEvent_Examples { class MyMainClass { //Initially not signaled. const int numIterations = 5; static AutoResetEvent myResetEvent = new AutoResetEvent(false); static int number; static void Main() { //Create and start the reader thread. Thread myReaderThread = new Thread(new ThreadStart(MyReadThreadProc)); myReaderThread.Name = \"ReaderThread\"; myReaderThread.Start(); for (int i = 1; i \u003c= numIterations; i++) { Console.WriteLine(\"Writer thread writing value: {0}\", i); number = i; //Signal that a value has been written. myResetEvent.Set(); //Give the Reader thread an opportunity to act. Thread.Sleep(1); } //Terminate the reader thread. myReaderThread.Abort(); } static void MyReadThreadProc() { while (true) { //The value will not be read until the writer has written // at least once since the last read. myResetEvent.WaitOne();//等待set Console.WriteLine(\"{0} reading value: {1}\", Thread.CurrentThread.Name, number); } } } } 结果 Writer thread writing value: 1 ReaderThread reading value: 1 Writer thread writing value: 2 ReaderThread reading value: 2 Writer thread writing value: 3 ReaderThread reading value: 3 Writer thread writing value: 4 ReaderThread reading value: 4 Writer thread writing value: 5 ReaderThread reading value: 5 请按任意键继续. . . using System; using System.Threading; public class Example { // mre is used to block and release threads manually. It is // created in the unsignaled state. private static ManualResetEvent mre = new ManualResetEvent(false);//设为非终止状态，线程会被阻塞 static void Main() { Console.WriteLine(\"\\n启动在MalualReSeTebug上阻止的3个命名线程:\\n\"); for (int i = 0; i \u003c= 2; i++) { Thread t = new Thread(ThreadProc); t.Name = i+\"线程\"; t.Start(); } Thread.Sleep(500); Console.WriteLine(\"\\n当所有三个线程都已启动时，按Enter调用SET（）\" + \"\\n释放所有线程。\\n\"); Console.ReadLine(); mre.Set();//事件状态被设置为有信号，允许线程执行，3个线程执行，同时ManualResetEvent 被设置为终止状态，线程不会阻塞 Thread.Sleep(500); Console.WriteLine(\"\\n当一个MavaReSeTeEvices被发出信号时，调用WAOTIONE（）的线程\" + \"\\n不要阻塞。按Enter显示这一点。\\n\"); Console.ReadLine(); for (int i = 3; i \u003c= 4; i++) { Thread t = new Thread(ThreadProc); t.Name = i + \"线程\"; t.Start(); } Thread.Sleep(500); Console.WriteLine(\"\\n按Enter调用REST（），使线程再次阻塞\" + \"\\n当他们调用WAOTIFEL（）时。\\n\"); Console.ReadLine(); mre.Reset();//将ManualResetEvent 重新设为非终止状态 // Start a thread that waits on the ManualResetEvent. Thread t5 = new Thread(ThreadProc); t5.Name = \"5线程\"; t5.Start(); Thread.Sleep(500); Console.WriteLine(\"\\n按Enter调用SET（）并结束演示。\"); Console.ReadLine(); mre.Set(); // If you run this example in Visual Studio, uncomment the following line: //Console.ReadLine(); } private static void ThreadProc() { string name = Thread.CurrentThread.Name; Console.WriteLine(name + \" starts and calls mre.WaitOne()\"); mre.WaitOne();//当ManualResetEvent 设为非终止状态时，线程会被阻塞 Console.WriteLine(name + \" ends.\"); } } 启动在MalualReSeTebug上阻止的3个命名线程: 0线程 starts and calls mre.WaitOne() 2线程 starts and calls mre.WaitOne() 1线程 starts and calls mre.WaitOne() 当所有三个线程都已启动时，按Enter调用SET（） 释放所有线程。 1线程 ends. 0线程 ends. 2线程 ends. 当一个MavaReSeTeEvices被发出信号时，调用WAOTIONE（）的线程 不要阻塞。按Enter显示这一点。 3线程 starts and calls mre.WaitOne() 3线程 ends. 4线程 starts and calls mre.WaitOne() 4线程 ends. 按Enter调用REST（），使线程再次阻塞 当他们调用WAOTIFEL（）时。 5线程 starts and calls mre.WaitOne() 按Enter调用SET（）并结束演示。 这个讲的是一个计算过程，最终的计算结果为第一项＋第二项＋第三项，在计算第一、二、三项时需要使用基数来进行计算。在代码中使用了线程池也就是ThreadPool来操作 using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { //下面的代码摘自MSDN，笔者做了中文代码注释 //周公 public class EventWaitHandleDemo { double baseNumber, firstTerm, secondTerm, thirdTerm; AutoResetEvent[] autoEvents; ManualResetEvent ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:7","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"线程池\r为了处理短时间内大量创建对象，简单处理下，又要销毁损耗性能的行为，线程过多后会增加操作系统资源的占用，多线程资源竞争变得复杂 线程池的优点： 缩短程序的响应时间 不必维护管理生存周期短暂的问题 线程池会根据当前系统特点对池内的线程进行优化处理 在.NET中有一个线程的类ThreadPool，它提供了线程池的管理 ThreadPool是一个静态类，它没有构造函数，对外提供的函数也全部是静态的。其中有一个QueueUserWorkItem方法，它有两种重载形式，如下： public static bool QueueUserWorkItem(WaitCallback callBack):将方法排入队列以便执行。此方法在有线程池线程变得可用时执行。 public static bool QueueUserWorkItem(WaitCallback callBack,Object state):将方法排入队列以便执行，并指定包含该方法所用数据的对象。此方法在有线程池线程变得可用时执行。 QueueUserWorkItem方法中使用的的WaitCallback参数表示一个delegate，它的声明如下： public delegate void WaitCallback(Object state) 如果需要传递任务信息可以利用WaitCallback中的state参数，类似于ParameterizedThreadStart委托 using System.Threading; using System.Collections; using System.Diagnostics; using System; using System.ComponentModel; namespace ThreadPoolDemo { class ThreadPoolDemo1 { public ThreadPoolDemo1() { } public void Work() { ThreadPool.QueueUserWorkItem(new WaitCallback(CountProcess)); ThreadPool.QueueUserWorkItem(new WaitCallback(GetEnvironmentVariables)); } /// \u003csummary\u003e /// 统计当前正在运行的系统进程信息 /// \u003c/summary\u003e /// \u003cparam name=\"state\"\u003e\u003c/param\u003e private void CountProcess(object state) { Process[] processes = Process.GetProcesses(); foreach (Process p in processes) { try { Console.WriteLine(\"Id:{0},ProcessName:{1},StartTime:{2}\", p.Id, p.ProcessName, p.StartTime); } catch (Win32Exception e) { Console.WriteLine(\"ProcessName:{0}\", p.ProcessName); } finally { } } Console.WriteLine(\"获取进程信息完毕。\"); } /// \u003csummary\u003e /// 获取当前机器系统变量设置 /// \u003c/summary\u003e /// \u003cparam name=\"state\"\u003e\u003c/param\u003e public void GetEnvironmentVariables(object state) { IDictionary list=System.Environment.GetEnvironmentVariables(); foreach (DictionaryEntry item in list) { Console.WriteLine(\"key={0},value={1}\", item.Key, item.Value); } Console.WriteLine(\"获取系统变量信息完毕。\"); } static void Main(string[] args) { ThreadPoolDemo1 tpd1 = new ThreadPoolDemo1(); tpd1.Work(); Thread.Sleep(5000); Console.WriteLine(\"OK\"); Console.ReadLine(); } } } 在上面的代码中我们使用了线程池，并让它执行了两个任务，一个是列出系统当前所有环境变量的值，一个是列出系统当前运行的进程名和它们的启动时间。 当然，优点和缺点总是同时存在的，使用ThreadPool也有一些缺点，使用线程池有如下缺点： 1、一旦加入到线程池中就没有办法让它停止，除非任务执行完毕自动停止； 2、一个进程共享一个线程池； 3、要执行的任务不能有返回值（当然，线程中要执行的方法也是不能有返回值，如果确实需要返回值必须采用其它技巧来解决）； 4、在线程池中所有任务的优先级都是一样的，无法设置任务的优先级； 5、不太适合需要长期执行的任务（比如在Windows服务中执行），也不适合大的任务； 6、不能为线程设置稳定的关联标识，比如为线程池中执行某个特定任务的线程指定名称或者其它属性。 如果我们要面临的情况正好是线程池的缺点，那么我们只好继续使用线程而不是线程池。不过在某些情况下使用线程池确实可以带来很多方便的，比如在WEB服务器中，可以使用线程池来处理来自客户端的请求，可以以比较高的性能运行。 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:8","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"UI界面卡顿的问题\r在开发Windows应用程序时经常会使用到线程。对于耗时的操作如果不使用线程将会是UI界面长时间处于停滞状态，这种情况是用户非常不愿意看到的，在这种情况下我们希望使用线程来解决这个问题。 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Text; using System.Windows.Forms; using System.Threading; namespace ThreadPoolDemo { public partial class ThreadForm : Form { public ThreadForm() { InitializeComponent(); } private void btnThread_Click(object sender, EventArgs e) { Thread thread = new Thread(new ThreadStart(Run)); thread.Start(); } private void Run() { while (progressBar.Value \u003c progressBar.Maximum) { progressBar.PerformStep(); } } } } 本意是点击“启动”按钮来启动模拟一个操作，在进度条中显示操作的总体进度。不过如果我们真的点击“启动”按钮会很失望，因为它会抛出一个System.InvalidOperationException异常，异常描述就是“线程间操作无效: 从不是创建控件‘progressBar’的线程访问它。” 解决方案 CheckForIllegalCrossThreadCalls属性 因为在.NET中做了限制，不允许在调试环境下使用线程访问并非它自己创建的UI控件，这么做可能是怕在多线程环境下对界面控件进行操作会出现不可预知的情况， using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using System.Threading; namespace ThreadPoolDemo { public partial class ThreadForm : Form { public ThreadForm() { InitializeComponent(); } private void btnThread_Click(object sender, EventArgs e) { //指示是否对错误线程的调用，即是否允许在创建UI的线程之外访问线程 CheckForIllegalCrossThreadCalls = false; Thread thread = new Thread(new ThreadStart(Run)); thread.Start(); } private void Run() { while (progressBar.Value \u003c progressBar.Maximum) { progressBar.PerformStep(); } } } } 不过使用上面的代码我们可能还有些犯嘀咕，毕竟是不允许直接在线程中直接操作界面的，那么我们还可以用Invoke方法。 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using System.Threading; namespace ThreadPoolDemo { public partial class ThreadForm : Form { //定义delegate以便Invoke时使用 private delegate void SetProgressBarValue(int value); public ThreadForm() { InitializeComponent(); } private void btnThread_Click(object sender, EventArgs e) { progressBar.Value = 0; //指示是否对错误线程的调用，即是否允许在创建UI的线程之外访问线程 //CheckForIllegalCrossThreadCalls = false; Thread thread = new Thread(new ThreadStart(Run)); thread.Start(); } //使用线程来直接设置进度条 private void Run() { while (progressBar.Value \u003c progressBar.Maximum) { progressBar.PerformStep(); } } private void btnInvoke_Click(object sender, EventArgs e) { progressBar.Value = 0; Thread thread = new Thread(new ThreadStart(RunWithInvoke)); thread.Start(); } //使用Invoke方法来设置进度条 private void RunWithInvoke() { int value = progressBar.Value; while (value\u003c progressBar.Maximum) { //如果是跨线程调用 if (InvokeRequired) { this.Invoke(new SetProgressBarValue(SetProgressValue), value++); } else { progressBar.Value = ++value; } } } //跟SetProgressBarValue委托相匹配的方法 private void SetProgressValue(int value) { progressBar.Value = value; } } } 还可以使用BackgroundWorker类来完成同样的功能。 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using System.Threading; namespace ThreadPoolDemo { public partial class ThreadForm : Form { //定义delegate以便Invoke时使用 private delegate void SetProgressBarValue(int value); private BackgroundWorker worker; public ThreadForm() { InitializeComponent(); } private void btnThread_Click(object sender, EventArgs e) { progressBar.Value = 0; //指示是否对错误线程的调用，即是否允许在创建UI的线程之外访问线程 //CheckForIllegalCrossThreadCalls = false; Thread thread = new Thread(new ThreadStart(Run)); thread.Start(); } //使用线程来直接设置进度条 private void Run() { while (progressBar.Value \u003c progressBar.Maximum) { progressBar.PerformStep(); } } private void btnInvoke_Click(object sender, EventArgs e) { progressBar.Value = 0; Thread thread = new Thread(new ThreadStart(RunWithInvoke)); thread.Start(); } //使用Invoke方法来设置进度条 private void RunWithInvoke() { int value = progressBar.Value; while (value\u003c progressBar.Maximum) { //如果是跨线程调用 if (InvokeRequired) { this.Invoke(ne","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:7:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"Task类\rTask类是封装的一个任务类，内部使用的是ThreadPool类，提供了内建机制，让你知道什么时候异步完成以及如何获取异步执行的结果，并且还能取消异步执行的任务。下面看一个例子是如何使用Task类来执行异步操作的。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { Task t = new Task((c) =\u003e { int count = (int)c; for (int i = 0; i \u003c count; i++) { Thread.Sleep(10); Console.WriteLine($\"Asyn Thread:{i}\"); } Console.WriteLine(\"Asyn Thread Done\"); }, 10);//10为传递的参数C N0.1 t.Start(); for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread:{i}\"); } Console.WriteLine(\"Main Thread done\"); Console.ReadKey(); } } } Main Thread:0 Asyn Thread:0 Asyn Thread:1 Main Thread:1 Asyn Thread:2 Main Thread:2 Asyn Thread:3 Main Thread:3 Asyn Thread:4 Main Thread:4 Main Thread done Asyn Thread:5 Asyn Thread:6 Asyn Thread:7 Asyn Thread:8 Asyn Thread:9 Asyn Thread Done no.1处使用Task的构造函数为： public Task( Action\u003cObject\u003e action, Object state )一个Action\u003cObject\u003e类型的委托（即异步调用函数具有一个Object类型的参数），和一个Object类型的参数，也就是传递给异步函数的参数， Task类还有几种方式的重载，我们还可以传递一些TaskCreationOptions标志来控制Task的执行方式。在这里我使用的是lambda表达去写委托的，这样使得程序的结构更加的清晰，使用Start()来启动异步函数的调用。 有返回值，主线程阻塞 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { Task\u003cint\u003e t = new Task\u003cint\u003e((c) =\u003e { int count = (int)c; int sum = 0; for (int i = 0; i \u003c count; i++) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread:{i}\"); } Console.WriteLine(\"Asyn Thread Done\"); return sum; }, 10);//no.1 t.Start(); t.Wait(); Console.WriteLine($\"Asyn Result:{t.Result}\"); for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread:{i}\"); } Console.WriteLine(\"Main Thread done\"); Console.ReadKey(); } } } Asyn Thread:0 Asyn Thread:1 Asyn Thread:2 Asyn Thread:3 Asyn Thread:4 Asyn Thread:5 Asyn Thread:6 Asyn Thread:7 Asyn Thread:8 Asyn Thread:9 Asyn Thread Done Asyn Result:45 Main Thread:0 Main Thread:1 Main Thread:2 Main Thread:3 Main Thread:4 Main Thread done 如果任务中出现了异常，那么异常会被吞噬掉，并存储到一个集合中去，而线程可以返回到线程池中去。但是如果在代码中调用了Wait方法或者是Result属性，任务有异常发生就会被引发，不会被吞噬掉。其中Result属性内部本身也调用了Wati方法。Wait方法和上一节中的委托的EndInvoke方法类似，会使得调用线程阻塞直到异步任务完成。 取消正在运行的任务 取消任务要引用一个CancellationTokenSource 对象。在需要异步执行的方法中增加一个CancellationToken类型的形参。然后在异步函数的for循环代码中用一个if语句判断CancellationToken的CanBeCanceled属性，这个属性可以用来判断在调用线程是否取消任务的执行， 除CanBeCanceled属性之外，还可以使用ThrowIfCancellationRequested方法，该方法的作用是如果在调用线程调用CancellationTokenSource对象的Cancel方法，那么就会引发一个异常，然后在调用线程进行捕捉就好了，这是在异步函数中的处理方式。 no.1在构建任务之前需要建立一个CancellationTokenSource ， no2.并且把CancellationTokenSource传递给异步调用函数，传递的是CancellationTokenSource对象的Toke属性，该属性是一个CancellationToken类型的对象。这样就完成任务的取消模式，如果想在调用线程中取消任务的执行，只需要调用CancellationTokenSource 的Cancel方法就行啦。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { CancellationTokenSource cts = new CancellationTokenSource();//NO.1 Task\u003cint\u003e t = new Task\u003cint\u003e((c) =\u003e Sum(cts.Token, (int)c), 10);//NO.2 t.Start(); //cts.Cancel();//NO.3如果任务没有完成，但是Task有可能完成了 for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread:{i}\"); } cts.Cancel(); Console.WriteLine(\"Main Thread done\"); Console.ReadKey(); } static int Sum(CancellationToken ct, int count) { int sum = 0; for (int i = 0; i \u003c count; i++) { //if (!ct.CanBeCanceled) if (!ct.IsCancellationRequested) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread:{i}\"); } else { Console.WriteLine(\"任务取消\"); //return -1; } } Console.WriteLine(\"Asyn Thread Done\"); return sum; } } } 结果 Main Thread:0 Asyn Thread:0 Main Thread:1 Asyn Thread:1 Main Thread:2 Asyn Thread:2 Main Thread:3 Asyn Thread:3 Main Thread:4 Main Thread done","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:8:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"多线程UI的例子\rusing System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; using System.Threading; namespace testthreadui { public partial class Form1 : Form { private readonly TaskScheduler contextTaskScheduler;//声明一个任务调度器 public Form1() { InitializeComponent(); contextTaskScheduler = TaskScheduler.FromCurrentSynchronizationContext();//no.1获得一个上下文任务调度器 } private void button1_Click(object sender, EventArgs e) { Task\u003cint\u003e t = new Task\u003cint\u003e((n) =\u003e Sum((int)n), 100); t.Start(); t.ContinueWith(task =\u003e this.textBox1.Text = task.Result.ToString(), contextTaskScheduler);//当任务执行完之后执行 t.ContinueWith(task =\u003e MessageBox.Show(\"任务出现异常\"), CancellationToken.None, TaskContinuationOptions.OnlyOnFaulted, contextTaskScheduler);//当任务出现异常时才执行 for (int i = 0; i \u003c 10; i++) { textBox1.Text = i.ToString(); textBox2.Text = i.ToString(); Thread.Sleep(100); } } int Sum(int count) { try { int sum = 0; for (int i = 0; i \u003c count; i++) { Thread.Sleep(10); sum += i; //throw new Exception(\"错误\"); } Console.WriteLine(\"任务处理完成\"); return sum; } catch (Exception e) { MessageBox.Show(\"任务出现异常\"); } return -1; } private void button2_Click(object sender, EventArgs e) { textBox1.Text = 100.ToString(); } } } //未发现异常 实现实时更新UI 首先建立一个winform项目，在主窗体上拖入一个button，一个progressbar，一个lable。如下图所示。 编写一个处理数据的类（WriteDate），源代码如下 public class DataWrite { public delegate void UpdateUI(int step);//声明一个更新主线程的委托 public UpdateUI UpdateUIDelegate; public delegate void AccomplishTask();//声明一个在完成任务时通知主线程的委托 public AccomplishTask TaskCallBack; public void Write(object lineCount) { StreamWriter writeIO = new StreamWriter(\"text.txt\", false, Encoding.GetEncoding(\"gb2312\")); string head = \"编号,省,市\"; writeIO.Write(head); for (int i = 0; i \u003c (int)lineCount; i++) { writeIO.WriteLine(i.ToString() + \",湖南,衡阳\"); //写入一条数据，调用更新主线程ui状态的委托 UpdateUIDelegate(1); } //任务完成时通知主线程作出相应的处理 TaskCallBack(); writeIO.Close(); } } 主界面中的代码如下： 首先要建立一个委托来实现非创建控件的线程更新控件。 delegate void AsynUpdateUI(int step); 然后编写多线程去启动写入数据的方法以及回调的函数。 private void btnWrite_Click(object sender, EventArgs e) { int taskCount = 10000; //任务量为10000 this.pgbWrite.Maximum = taskCount; this.pgbWrite.Value = 0; DataWrite dataWrite = new DataWrite();//实例化一个写入数据的类 dataWrite.UpdateUIDelegate += UpdataUIStatus;//绑定更新任务状态的委托 dataWrite.TaskCallBack += Accomplish;//绑定完成任务要调用的委托 Thread thread = new Thread(new ParameterizedThreadStart(dataWrite.Write)); thread.IsBackground = true; thread.Start(taskCount); } //更新UI private void UpdataUIStatus(int step) { if (InvokeRequired) { this.Invoke(new AsynUpdateUI(delegate(int s) { this.pgbWrite.Value += s; this.lblWriteStatus.Text = this.pgbWrite.Value.ToString() + \"/\" + this.pgbWrite.Maximum.ToString(); }), step); } else { this.pgbWrite.Value += step; this.lblWriteStatus.Text = this.pgbWrite.Value.ToString() + \"/\" + this.pgbWrite.Maximum.ToString(); } } //完成任务时需要调用 private void Accomplish() { //还可以进行其他的一些完任务完成之后的逻辑处理 MessageBox.Show(\"任务完成\"); } 完整代码 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; using System.Threading; using System.IO; namespace testthreadui { public partial class Form1 : Form { delegate void AsynUpdateUI(int step); public Form1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { int taskCount = 10000; //任务量为10000 this.pgbWrite.Maximum = taskCount; this.pgbWrite.Value = 0; DataWrite dataWrite = new DataWrite();//实例化一个写入数据的类 dataWrite.UpdateUIDelegate += UpdataUIStatus;//绑定更新任务状态的委托 dataWrite.TaskCallBack += Accomplish;//绑定完成任务要调用的委托 Thread thread = new Thread(new ParameterizedThreadStart(dataWrite.Write)); thread.IsBackground = true; thread.Start(taskCount); } private void UpdataUIStatus(int step) { if (InvokeRequired) { this.Invoke(new AsynUpdateUI(delegate (int s) { ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:8:1","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"基本信息\r","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:1:0","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"CIL和JIT\rCIL通用中间语言 JIT just-in-time使得CIT代码仅在需要时才编译 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:1:1","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"程序集\r包含可执行文件.exe和库函数.dll和资源文件，不必把程序集集中到一个地方，全局程序缓存 程序集完全自描述的，逻辑单元而不是物理单元 可执行代码和库代码使用相同程序集结构，可执行文件多了一个主程序入口点。 程序集的一个重要特征是它们包含元数据描述了对应代码中定义的类型和方法。 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:1:2","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"CLR\r公共语言运行库CLR：包含实时编译器JIT,在程序运行时，JIT编译器会从IL代码生成本地代码，其他部分是垃圾回收器GC,调试器扩展和线程实用工具。垃圾回收器负责回收内存，调试扩展器允许在不同编程语言之间启动调试会话，线程实用工具负责在底层平台创建线程。 管理着正在执行的代码包括管理内存，处理安全以及跨语言调试 代码托管最重要的是内存回收机制 winform基于像素 wpf基于pirectX CLR执行应用程序之前，编写好源代码都需要编译，编译分为两个阶段 将源代码编译成microsoft中间语言IL CLR将I编译成平台专用的的本地代码 clr还有一个类型加载器的类型系统，类型加载器负责从程序集中加载类型。 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:1:3","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"编译过程\r.net兼容语言编写程序，托管语言 将代码编译为中间代码CIL，这未必是单文件，可以有多个源代码文件，再把链接带一个程序集中，称之为链接 使用JIT编译为本机代码 在托管的CLR环境下运行本机代码 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:1:4","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"基本语法\r","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:0","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"注释\r/* */和一行// ///可以通过配置，将这些注释提取出来组成文档文件 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:1","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"命名空间\r","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:2","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"代码大纲功能\r#region Using directives #endregion，大纲的名字为Using directives ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:3","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"变量\r先声明后使用 变量初始化：变量是类或结构中的字段，如果没有显式初始化，则创建这些变量时，其默认值就是0.方法的局部变量必须在代码中显示初始化。 整数 sbyte System.SByte -128~127 byte System.Byte 0~255 short System.Int16 -32768~32767 ushort System.UInt16 0~65535 int System.Int32 -21亿~21亿 uint System.UInt32 42亿 long System.Int64 19位数字 ulong System.UInt64 20位数字 浮点类型 位是最小数据单位，只能表示0-1 字节，8个二进制位构成1个字节，是存储空间的基本计量单位， 字：由若干字节构成，不同计算机有不同的字长，8位计算机一个字等于一个字节，16位一个字等于两个字节，字是计算机数据处理和运算的单位 1kb等于1024个字节 1M等于1024KB 1G等于1024M 1T等于1024G float System.Single 4字节 double System.Double 8个字节 decimal System.Decimal 16个字节 布尔和文本 char System.Char Unicode 0~65535 2个字节 bool System.Boolean 1个字节 string System.String 转义字符 ' 单引号 0x0027 '’ 双引号 0x0022 \\ 反斜杠 0x005c \\0 空 0x0000 \\a 警告 0x0007 \\b 退格 0x0008 \\f 换页 0x000C \\n 换行 0x0000A \\r 回车 0x000D \\t 水平制表符 0x0009 \\v 垂直制表符 0x000B @转义字符，避免大量使用\\ 全局变量：Program.全局变量，在声明变量前要进行初始化 常量： 常量必须初始化，指定值后不能更改。 常量总是隐式静态的， 值类型和引用类型：值类型存储在栈中，应用类型存储在堆中。值类型和引用类型互换要经过装箱拆箱，在传递函数参数时，值类型会进行复制，而引用相当于传递指针，返回值相同。引用类型由垃圾回收器进行回收，值类型不需要，超出其作用域就会在内存中删除。 ref:如果是结构类型使用ref传递参数，则变成传递引用，**但如果是引用类型，即使参数在函数中变化了引用，新的应用还是会传递回去。**ref传递的值要先初始化。 out：用法基本和ref一样，但传入的值只需要定义 可空类型：int? 和int,唯一的多开销是一个可以确定它是否为空 的布尔成员，值可以直接转换可空，int?=int;可空转换成值需要强制int=(int)int?;但如果为空会生成一个异常，最好的方法是int=int?.hasvalue?int?.value:-1；可以转换成较短短语int=int??-1 枚举也是值类型：默认情况下，枚举是int,也可以改变成其他整数类型，强制转换将int转换成枚举，当分配给常量是不同位时，flags属性需要枚举设置，获得所有枚举，var day in Enum.GetName(typeof(Color)); 结构：值类型，不能继承，每个结构都自动由ValueType派生。 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:4","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"基本运算符\r一目运算符 二目运算符 = += -= *= /= %= 运算符优先级 ++,–(前缀);(),+,-,!,~ *,/,% +,- \u003e\u003e ,« \u003c,\u003e,\u003c=，\u003e= ==,！= \u0026 ^ | \u0026\u0026 || =,+=,-=,*=,/=,%= ++,–后缀 布尔运算符 ！ \u0026 | ^一真一否才为真 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:5","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"基本语句\rgoto语句 goto \u003clabelName\u003e \u003clabelName\u003e: if语句 if(\u003ctest\u003e) { \u003ccode executed if \u003ctestis true\u003e; } else { \u003ccode executed if \u003ctestis false\u003e; } switch switch(\u003ctestvar\u003e) { case\u003ccomparsionVall\u003e: \u003ccode to execute if \u003ctestVar\u003e\u003e==\u003ccomparisonvall\u003e\u003e break; ........ default: \u003ccode to execute if \u003ctestVar\u003e\u003e!=\u003ccomparisonvall\u003e\u003e break; } do do { \u003ccode to be looped\u003e } while(\u003cTest\u003e) while while(\u003ctest\u003e) { \u003ccode to looped\u003e } for for(\u003cinitialization\u003e;\u003ccondition\u003e;\u003coperation\u003e) { \u003ccode to loop\u003e } foreach foreach(\u003cbaseType\u003e\u003cname\u003ein\u003carray\u003e) { //can use \u003cnamefor each element }//该函数只能只读 循环中的中断 循环的中断： break立刻终止循环 continue立刻终止当前循环 goto可以跳出循环 return跳出循环,即包含循环的函数 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:6","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"基本数据结构\r转换 隐式转换：编译器执行转换 显示转换：需要额外转换 (\u003cdestinationType\u003e)\u003csourceVar\u003e 显示转换的检查：checked和unchecked checked( \u003cexpression\u003e)检查是否会溢出，溢出则出现错误 unchecked(\u003cexpression\u003e)溢出不出现错误 可以通过设置属性，使得显示转换都默认检查checked 枚举 enum\u003ctypename\u003e:\u003cunderlyingType\u003e { \u003cvalue1\u003e, \u003cvalue2\u003e=\u003cactualValue2\u003e, ... } 结构体：值类型 struct\u003ctypename\u003e:\u003cunderlyingType\u003e { \u003cmemberDeclarations\u003e, ... } 数组 数组声明：\u003cbaseType\u003e[]\u003cname\u003e; 二维数组声明：\u003cbaseType\u003e[,]\u003cname\u003e; 数组调用：frendName[index] 锯齿数组 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:7","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"基本函数\rConsole Console.WriteLine(“字符串”); Console.WriteLine(\"{0}{1}{2}\",n_a,n_b,n_c); str=Console.ReadLine(); Convert n_double=Convert.ToDouble();强制转换成double n_int=Convert.ToInt32();强制转换成int ToBase64CharArray 将 8 位无符号整数数组的子集转换为用 Base 64 数字编码的 Unicode 字符数组的等价子集。 ToBase64String 将 8 位无符号整数数组的值转换为它的等效 String 表示形式（使用 base 64 数字编码）。 ToBoolean 将指定的值转换为等效的布尔值。 ToByte 将指定的值转换为 8 位无符号整数。 ToChar 将指定的值转换为 Unicode 字符。 ToDateTime 将指定的值转换为 DateTime。 ToDecimal 将指定值转换为 Decimal 数字。 ToDouble 将指定的值转换为双精度浮点数字。 ToInt16 将指定的值转换为 16 位有符号整数。 ToInt32 将指定的值转换为 32 位有符号整数。 ToInt64 将指定的值转换为 64 位有符号整数。 ToSByte 将指定的值转换为 8 位有符号整数。 ToSingle 将指定的值转换为单精度浮点数字。 ToString 将指定值转换为其等效的 String 表示形式。 ToUInt16 将指定的值转换为 16 位无符号整数。 ToUInt32 将指定的值转换为 32 位无符号整数。 ToUInt64 将指定的值转换为 64 位无符号整数。 Convert.ReadKey( ); enum (enumerationType)Enum.Parse(typeof (enumerationType),enumerationValueString);字符串转换成枚举 string .ToCharArray()这个函数可以将String编程char[]数组 .Length字符串长度 .ToLower字符串全部小写 .ToUpper字符串全部大写 .Trim字符串删除空格 .PadLeft()和.PadRight()字符串左边或者右边添加空格 .IndexOf(’,’);定位到，的下标 .Split(’ ‘);切片 object 类的函数基本是object函数 .ToString()输出类名； 函数格式 static \u003creturnType\u003cFunctionName\u003e(\u003cparamType\u003e\u003cparaName\u003e,...) { ... renturn \u003creturnValue\u003e; }//普通函数定义 可以直接定义表达式函数public bool IsSquare(Reactangle rect)=\u003erect.height==rect.width; 参数函数 参数数组，C#允许函数指定一个特殊参数，该参数必须是函数的最后一个，称为参数素组， static \u003creturnType\u003cFunctionName\u003e(\u003cp1Type\u003e\u003cp1Name\u003e,...Params\u003ctype\u003e[]\u003cname\u003e) { ... renturn \u003creturnValue\u003e; } class Prigram { static int SunVals(params int [] vals) { int sum=0; foreach(int val in vals) { sum+=val; } return sum; } static void Main(string [] args) { int sum=SumVals(1,5,2,9,8); console.writeline(\"summed values={0}\",sum); } } 可选参数 public void TestMethod(int i,int j=12) { } 引用参数 引用参数，需要用关键字ref 调用引用函数\u003cFunctionName\u003e(ref \u003cparaName\u003e) static \u003creturnType\u003cFunctionName\u003e(ref \u003cparamType\u003e\u003cparaName\u003e,...) { ... renturn \u003creturnValue\u003e; } 扩展方法 public static int GetWordCount(this string s)=\u003es.split().length; 调用int wordcount=fox.GetWordCount(); 函数重载 特征标不一样就行 引用和非引用也属于重载 委托 委托，和重载差不多，只不过重载特征表不同，而委托特征标相同而函数名不同，可以根据需求NEW出不同的函数，委托的利用在于可以将其当成参数传递给函数，让函数因需求执行不同的操作，类似于多态 委托是一种存储函数引用的类型 委托声明类似于函数，但是不带函数体，且要使用关键字delegate，委托指定了一个返回类型和一个参数列表 定义了委托后，就可以声明该委托类型的变量，接着把这个变量初始化为与委托具有相同返回类型和参数列表的函数引用，之后就可以使用委托变量调用这个函数 例子，可以把委托变量作为参数传递给一个函数，这样，该函数就可以使用委托调用它引用的任何函数 class Program { delegate double ProcessDelegate(double param1, double param2); static double Multiply(double param1, double param2) { return param1 * param2; } static double Divide(double param1, double param2) { return param1 / param2; } static void Main(string[] args) { ProcessDelegate process; Console.WriteLine(\"imput two intege：\"); string input = Console.ReadLine(); string [] commaPos = input.Split(','); double param1 = Convert.ToDouble(commaPos[0]); double param2 = Convert.ToDouble(commaPos[1]); Console.WriteLine(\"Enter M to Multiply or D to divide:\"); input = Console.ReadLine(); if (input == \"M\") process = new ProcessDelegate(Multiply);//process=Multiply; else process = new ProcessDelegate(Divide);//process=Divide; Console.WriteLine(\"result :{0}\", process(param1, param2)); Console.ReadKey(); } } ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:3:0","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"调试\r","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:4:0","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"断点\r可以查看输出窗口，输出/调试， 语句Debug.WriteLine()将调试信息显示到调试窗口 Trace.WriteLine()，用法相同，可以用于发布 Debug.WriteLine(“Add 1 to i”,“MyFunc”);结果为： MyFunc:Add 1 to i; using System.Diagnostics; Debug.WriteLineIf()增加一个必选项，当是真的时候进行输出 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:4:1","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"跟踪点\r有点类似于Debug.WriteLine() ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:4:2","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"Trace\rTrace.Assert(myVar\u003c0,\"variable out of bounds\",\"please contact vendor with the error code KCW001.\") ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:4:3","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"异常\rtry抛出异常，catch抛出异常时执行的代码，finally包含最终执行的代码 即使try中有return， finally还是会执行，在finally中还是会改变return中的值 try {...} catch(\u003cexceptionType\u003ee) {...} finally {...} 抛出异常包括内容 throw(new ArgumentOutOfRangeException(\"MyIntProp\",value,\"MyIntProp must be assigned a value between 0 and 10\")); catch中捕获异常显示 catch (Exception e) { Console.WriteLine(\"Exception {0} thrown.\", e.GetType().FullName); Console.WriteLine(\"Message:\\n\\\"{0}\\\"\", e.Message); } ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:4:4","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"面向对象编程\r类包括：字段/属性/方法/常量/构造函数/索引器/运算符/事件/类型/析构函数 字段：不应该被设置为public 属性：自动实现的属性也就是没有声明私有字段，就可以使用初始化器来初始化；public int Age{set;get;}=42; set和get可以被访问修饰符修饰，但get和set中必须有一个具有属性的访问级别，属性其实并不怎么消耗资源，因为在JIT中，被变成内联函数， readonly:readonly只能在构造函数中赋值，然后就不好修改。 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:0","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"构造函数\r静态构造函数 创建包含静态构造函数的类实例 访问包含静态构造函数的类的静态成员时，（无论创建多少个实例，静态构造函数只调用一次。） 构造函数和析构函数，和C++一样 静态类不能实例化对象，只能包含静态成员， 如果没有构造函数，编译器会自动添加一个默认构造函数 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:1","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"派生类构造函数的调用\r构造函数总是按照层次结构顺序调用的：先调用object的构造函数，然后从上到下一次调用，直到达到编译器要实例化的类为止 如果要调用基类的非默认构造函数就需要使用构造函数初始化器。 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:2","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"访问修饰符\rpublic/ 所有类型成员/任何代码均可以访问该项 protected/类型和内嵌类型的所有成员/只有派生类型能够访问该类 internal/所有类型和成员/只能包含他的程序集中能够访问该类 private/类型和内嵌类型的所有成员/只能在它所属的类型中访问该项 protected internal/类型和内嵌类型的所有成员/只能在包含他的程序集和派生类型的任何代码中访问该项 new/static /virtual/abstract/override/sealed/extern ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:3","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"字段和属性\r统一建模语言Unified Modeling Language(UML) ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:4","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"接口\r接口可以看成是类的引用，可以引用任何实现该接口的类 一般情况下接口只能包含：方法，属性，索引器，事件的声明 把公共实例(非静态)方法和属性组合起来，以封装特定功能的一个集合,接口不能实例化 IDisposable接口的对象必须实现其Dispose()方法，当不再需要某个对象时就调用这个方法，释放重要资源， C#简化了这种方法，using关键字可以在代码块中初始化使用重要资源的对象，这个代码块的结尾会自动调用Dispose()方法 \u003cClassName\u003e\u003cVariableName\u003e=new \u003cClassName\u003e(); ... using(\u003cVariableName\u003e) { ... } 或 using(\u003cClassName\u003e\u003cVariableName\u003e=new \u003cClassName\u003e()) {...} 接口可以彼此集成，和类的集成差不多 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:5","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"继承\rC#类可以派生自另一个类和多个接口，只有虚方法和抽象方法才能使用override重写，不然是不能重写的，如果不重写虚方法或抽象方法，需要使用关键字new，那么调用的时候调用子类方法就可以使用base.方法 纯虚基类，重写方法，也可以不重写，虚方法可以实现，也可以实现（同属性） 基类成员的访问性 protected\\privated\\public 抽象基类不能实例化，抽象基类必须被继承，成员没有实现代码，在派生类中实现他们 抽象基类在UML中为斜体 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:6","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"is and as\rIBankAccount account= o as IBankAccount; if(o is IBankAccount){IBankAccount account = (IBankAccount)o;} ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:7","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"多态\r通过实例化不同的派生类调用派生类的重写方法 将派生类赋给基类调用基类重写方法，实际上调用了基类的重写方法 接口的多态性，尽管不能实例化接口，可以建立接口类型的变量，然后就可以在支持该接口的对象上，使用这个变量来访问接口提供的方法和属性 例如不适用基类提供的方法，而是把该方法放在接口上，实例化也支持该接口，唯一的区别是方法的实现代码不一样（接口不包含方法的实现），通过接口可以实现访问多个对象的方法而不依赖于一个公共的基类 Cow myCow=new Cow(); Chicken myChicken=new Chicken(); IConsume consumeInterface; consumeInterface = myCow; consumeInterface.EatFood(); consumeInterface = myChicken; consumeInterface.EatFood(); 对象之间的关系 包含关系，这个成员字段可以是公共字段，此时是继承关系一样，容器对象的用户就可以访问它的方法和属性，与继承不同的是，不能访问类的内部代码，类变成其私有变量 集合关系，增加了功能的数组 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:8","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"密封类和密封方法\r如果不允许创建派生自某个自定义类的类，该自定义类就应该是密封的，sealed 使用密封类可以提高性能，编译器知道该类没有派生，因此就没有虚函数表 string是密封的 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:9","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"托管和非托管\r托管和非托管资源，存储在托管或本机堆中的对象，垃圾回收器释放存储在托管堆中的对象，却不会释放本机堆中的对象。 值数据类型：window使用虚拟寻址系统，可以将程序所使用的内存地址映射内存中的实际地址（编译器来做）。每个进程都会有4G的内存，该内存被称为虚拟内存，从0开始往下排。在虚拟内存中有一个地方叫做栈，栈存储的是不是对象成员的值数据类型，调用方法时，栈存储传递给方法的所有参数副本。 栈实际上是向下填充的，先0x800000,然后0x799999 int a=10; double b=7999; 在运行到a=10时，int是四个字节，0x799999-0x799996被10占用，下一个空闲单元是0x799995,double 8个字节，就是0x799987 超出b的定义域后就会加8个字节，超出a的定义域后就会加4个字节。 ab进入栈的顺序是由编译器来决定的，编译器会查看作用域的顺序来决定哪个先进栈哪个后进栈。 引用类型的堆：堆上的内存是向上分配的 void Work() { Customer arabel;//1 arabel= new Customer();//2 Customer othercustomer2=new Customer();//3 } 首先1声明一个customer的引用arabel，在栈上给这个引用分配存储空间，该引用为4个字节， 2分配堆上的内存，以存储一个真正的Customer对象，然后把变量arabel的值设置为新分配的customer对象的内存地址，该customer可能包含32个字节，类的字节数和类的字段等成员有关 3是声明一个customer的引用，放在栈上，实例化一个customer对象放在堆上，将堆上的地址放到栈的引用上。 非托管堆： 当一个引用变量超出作用域时，它的引用会从栈中删除，但引用的对象任然在堆中，一直到程序终止，或垃圾回收器回收他们。 垃圾回收，删除堆中不再有被引用的所有对象，垃圾回收器（C++垃圾回收）在引用跟表中找到所有引用对象，在引用对象树中查找，在完成删除后，堆会立即把对象分散开来，与已经释放的内存混在一起。 托管堆： 如果托管堆也是这样，其给新对象分配内存时就是一个很难处理的问题，运行库必须遍历整个堆，才能找到足够大内存来存储新的对象。但垃圾回收器不会让堆处在这种状态，它在释放完可以释放的资源后，会将其他对象回推到堆的底部，再次形成连续数据块，在移动时所用引用都要更新，这需要垃圾回收器来完成。 垃圾回收期的压缩操作就是托管堆和非托管堆的区别，托管堆虽然要压缩，但分配内存时，只需要地址就好，不需要遍历地址列表。 创建对象时，会把对象放到托管堆上称为0代，创建新对象会被移动到这一部分，第一次回收后，保留下来的内容会被压缩移动到堆的下一部分上或世代部分，第1代对应部分，此时第0代对应的部分为空，新的对象依然被放到这个部分，遗留下来的内容让在第1代部分，第二次回收，第1代被压缩到第2代部分，第0代被压缩到第1代，第0代为空，放新的内容。如果新的对象超出第0代部分就会进行垃圾回收 垃圾回收可以提供应用程序性能，可以在架构堆上处理较大对象的方式， .NET较大对象有自己的堆，称为大对象堆，对象大于85000个字节就会被放在这个堆上，而不是主堆上，因为较大对象的压缩代价比较大，所以不放在主堆上压缩 第二代和大对象堆的回收即压缩过程是在后台线程中进行的 强引用和弱引用 仍在引用的对象的内存为强引用，可以回收不在根表中直接或间接引用的托管内存 A引用B,B引用C,C引用A，则GC会销毁所有对象。 实例化一个类，只要有代码引用它就是强引用 var myclassVariable = new MyClass(); var myCache=new MyCache(); myCache.Add(myclassVariable); myclassVariable=null//3 当第3步运行时就不能释放myclassVariable所引用的内存，因为缓存中还存在引用。在弱引用中就可以避免这种现象。 弱引用可以创建和使用对象，但是如果垃圾回收器在运行就可以回收 弱引用是由WeakReference创建的。需要使用IsAlive属性来确认是否被回收，Target属性可以返回一个强引用，不为null就可以访问 var myWeakReference = new WeakRefernece(new DataObject()); if(myWeakReference.IsActive) { DataObject strongReference=myWeakReference.Target as DataTarget; if(strongReference!=null) {} } else {} 垃圾回收器不释放非托管资源 比如：文件句柄，网络连接，数据库连接，等 定义类时，可以有两种机制来自动释放非托管资源 声明一个析构函数（或则终结器），作为类成员 class MyClass { ~MyClass() { } } 编译器在编译析构函数时，会隐式把析构函数的代码编译为等价于重写Finalize()方法的代码，从而确保父类的Finalize（）会被执行 等价 protected override void Finalize() { try {} finally { base.Finally(); } } C#析构函数具有不确定性，无法确定析构函数会被何时执行，同时析构函数会延迟对象从内存中删除的时间，有析构函数两次才能删除对象，第一次调用析构函数，第二次调用才真正删除，同时会被另起一个线程来调用Finally() 实现System.IDisposable 接口 该接口替代析构函数 class MyClass:IDisposable { public void Dispose() { } } Dispose()方法的实现显示释放由对象直接使用的所有非托管资源。Dispose为何时释放非托管资源提供了精确的控制。 using语句会自动调用Dispose()方法 上面的两种方法都实现了释放非托管资源 下面是一个双重实现的代码： using System; public class ResourceHolder:IDisposable { private bool _isDisposed=false; public void Dispose() { DisPose(true); GC.SuppressFinalize(this); } protected virtual void Dispose(bool disposing) { if(!_isDisposed) { if(disposing) { //cleanup managed objects by calling their dispose() methods } //clean up unmanaged objects } _isDisposed = true; } ~ResourceHolder() { Dispose(false); } public void SomeMethod() { //enture object not already disposed before execution of any method if(_isDisposed) { throw new ObjectDisposedException(\"ResourceHolder\"); } //method implementation } } ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:10","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"指针\rC#也是可以使用指针的，unsafe{}，在C#高级编程5.5不安全代码。留坑 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:11","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"运算符重载\r","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:12","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"事件\r对象可以激活和使用事件，作为他们处理的一部分，事件非常重要，可以在代码的其他部分起作用，类似于异常，但是功能更强大 可以在Animal对象添加到Animal集合中，执行特性的代码，而这部分代码不是Animal类的一部分，也不是调用Add()方法的代码的一部分，为此，需要给代码添加事件处理程序，这是一种特殊类型的函数，在事件发生时调用，还需要配置这个处理程序，以监听自己感兴趣的事情 private void Button1_Click_1(object sender, RoutedEventArgs e) { ((Button)sender).Content = \"clicked\"; Button newButton = new Button(); newButton.Content = \"NEW Button\"; newButton.Margin = new Thickness(10, 10, 200, 200); newButton.Click += newButton_click; ((Grid)((Button)sender).Parent).Children.Add(newButton); } private void newButton_click(object sender, RoutedEventArgs e) { ((Button)sender).Content = \"clicked\"; } ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:13","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"引用类型还是值类型\r在C#中，数据根据变量的类型以两种方法中的一种存储在一个变量中： 值类型的内存的同一个地方存储它们和它们的内容，栈 引用类型存储指向内存中其他某个位置的引用，实际内容存储在这个位置，堆 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:14","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"定义类\r类声明为内部，只有当前项目的代码能够访问 internal(默认) 其他项目代码也能访问public 类是抽象的，不能实例化，只能继承abstract，密封的sealed不能继承,如果基类是抽象的，在派生类必须全部实现 无或internal 只能在当前项目中访问 public可以在任何地方访问类 abstract或internal abstract类只能在当前项目访问，不能实例化，只能被继承 public abstracrt类可以在任何地方访问，不能实例化，只能继承 sealed或internal sealed类只能在当前项目访问，不能被继承，只能实例化 public sealed类可以在任何地方访问，不能被继承只能实例化 public sealed class MyClass { //Class members } 派生类的可访问性不能高于基类 类还可以指定接口，同时必须实现该接口的所有成员，如果不想使用给定的接口成员，就可以提供一个空的实现方法，继承类（只能有一个）再继承接口，接口可以有多个 接口的定义,不能在接口中使用abstract或sealed，可以使用继承的方式继承接口 interface IMyInterface { .... } 所有类都隐式继承System.Object类 多态性便可以使用，比较重要的基类方法GetType()ToStrign() if(myObject.GetType()==typeof(MyComplexClass)) { } 初始化列表 ：base(i) :this(5,6)调用自己的两个参数的构造函数，可以伪装成默认构造函数 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:15","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"定义类成员\rpublic,private,internal,protected readonly表示字段只能在执行构造函数的过程中赋值，static 静态变量，const也是静态的 方法 virtual方法可以重写 abstract方法必须在非抽象的派生类中重写（只用于抽象类中） override方法重写了一个基类方法（如果方法被重写，就必须要使用关键字）,如果使用了override,也可以使用sealed来指定在派生类中不能对这个方法做进一步修改即这个方法不能由派生类重写 extern方法定义在其他地方 多态测试，使用virtual和override多态测试成功 属性 定义与字段类似，get和set关键字来定义，可以控制属性的访问级别 右击refactor(重构)-Encapsulate Field可以快熟添加属性 自动属性： public int MyIntProp { get;set; } + 按通常的方式定义属性的名称、类型和可访问性，但是没有提供get和set的实现代码，实现代码由编译器提供（私有字段的名字也由编译器提供，将set变成private set即变成只读）\rprivate int myInt; public int myIntProp { get { return myInt; } public set { if(value\u003e0\u0026\u0026value\u003c10) myInt=value; else throw(new ArgumentOutOfRangeException(\"MyIntProp\",value,\"MyIntProp must be assigned a value between 0 and 10\")); } } 隐藏 隐藏基类方法，会产生2个警告（如果要确定隐藏需要加上new）,无论基类怎样限制，只要派生类没有调用override都是影藏 要对派生类的用户隐藏继承的公共成员，但仍能访问其功能，要给继承的虚拟成员添加实现代码，而不是简单地用重写的新实现代码替换它，可以使用base关键字：base.DoSomething() this最常用的功能是将当前对象实例的引用传递给一个方法，该方法有一个参数是指向基类的，this关键字的另一个常用方法是限定局部类型成员 class Animal { public void EatFood() { Console.WriteLine(\"Animal is adjusted\"); } } class Chicken : Animal { public void EatFood()//new public void EatFood() { Console.WriteLine(\"Chicken is adjusted\"); } } class Cow : Animal { public void EatFood()//new public void EatFood() { Console.WriteLine(\"Cow is adjusted\"); } } 套嵌类型成员 public class MyClass { public class MyNestedClass { public int NestedClassField; } }//实例化时： MyClass.MyNestedClass myObj=new MyClass.MyNestedClass(); public class ClassA { private int state = -1; public int State { get { return state; } } public class ClassB { public void SetPrivateState(ClassA target, int newState) { target.state = newState; } } } class Program { static void Main(string[] args) { ClassA myObject = new ClassA(); Console.WriteLine(\"myObject.State = {0}\", myObject.State); ClassA.ClassB myOtherObject = new ClassA.ClassB(); myOtherObject.SetPrivateState(myObject, 999); Console.WriteLine(\"myObject.State = {0}\", myObject.State); Console.ReadKey(); } }//嵌套类修改只读变量 接口 接口不会有访问修饰符 接口成员没有实现 接口没有字段成员(但是接口可以定义自动属性) 不能有关键字static/virtual/abstract/sealed来定义接口 但接口是可以继承的，如果要隐藏基类成员，需要加关键字new public interface IMyInterface { void DoSomething(); void DoSomethingElse(); } public class MyClass:IMyInterface { public void DoSomething() { } public void DoSomethingElse() { } }//接口类必须包含接口的所有成员包括匹配的指定签名包括get和set public interface IMyInterface { void DoSomething(); void DoSomethingElse(); } public class MyBaseClass { public void DoSomething() { } } public class MyDerivedClass:MyBaseClass,IMyInterface { public void DoSomethingElse() { } } public interface IMyInterface { void DoSomething(); void DoSomethingElse(); } public class MyBaseClass:IMyInterface { public virtual void DoSomething() { } public virtual void DoSomethingElse() { } } public class MyDerivedClass:MyBaseClass { public override void DoSomethingElse() { } public override void DoSomethingElse() { } } + 实现接口\rMyClass myObj=new MyClass(); IMyInterface myInt=myObj; myInt.DoSomething(); public class MyClass :IMyInterface { void IMyInterface.DoSomething()//显示调用 { } public void DoSomething()//隐式调用 { } } public interface IMyInterface { int MyIntProperty { get; } } public class MyBaseClass:IMyInterface { public int MyIntProperty{get;protected set;} } + 把接口放在不同的文件中partial\r//定义类时使用 public partial class MyClass { } //部分方法定义 public partial class MyClass { partial void DoSomethingElse(); public void DoSomething() { console.writeline(\"do something started\"); DoSomethingElse(); console.writeline(\"do something ended\"); } } public partial class MyClass { partial void DoSomethingElse() { console.writeline(\"DoSomethingElse called\"); } } //如果删除部分方法的实现部分，编译时编译器会以为调用了一个空的部分方法会直接删除部分方法的调用 集合 可以使用集合来维护对象组 集合大多是通过System.Collections名称空间中的接口而获得的，集合的语法已经标准化了 System.Collections包括几个接口： IEnumerable可以迭代集合中的项foreach ICollection继承上一个接口，可以获取集合中项的个数，并能把项复制到一个简单的数组类型中count()copyto(),add(),remove(),clear() IList继承上两个接口，提供了集合的项列表，允许访问这些项，并提供一些基本功能insert(),removeat(),派生于Icollection\u003cT\u003e接口 ISet获取两个集合的交集 IDictionary继承与前两个接口，可以通过键值访问项列表 ILookup接口，键和值 Icomparer实现compar","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:16","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"泛型\r泛型是以实例化的过程中提供的类型或类为基础建立的，可以毫不费力的对对象进行强类型化,使用泛型强化为各种类型。与C++不同，C++是在编译期间来强类型化，而C#是在运行期间强类型化 CollectionClass\u003cItemClass\u003e items= new CollectionClass\u003cItemClass\u003e(); items.Add(new ItemClass); .net 提供的泛型，包括System.Collections.Generic名称空间 可空类型，引用类型可以为空，值类型必须有一个值，扩展值类型让其可为空，泛型使用了System.Nullable类型提供了值类型为空的一种方法 System.Nullable\u003cint\u003e nullableInt;变量nullableInt可以包含int类型的任意值，还可以拥有null nullableInt=null;等价于nullableInt=new System.Nullable\u003cint\u003e(); nullableInt.HasValue,该方法不适用于引用类型，引用类型本身可能为NULL int？ nullableInt；int？是System.Nullable\u003cint\u003e 的缩写 可控类型null+任何数都为null,null在布尔运算中的大小介于FALSE和TRUE之间 ？？运算符为空结合运算符，是一个二元运算符，允许给可能等于NULL的表达式提供另一个值，op1??op2等价于op1==null?op2:op1; List\u003cT\u003e myCollection=new List\u003cT\u003e(); Item 获取或设置指定索引处的元素。 Count 获取 List 中实际包含的元素数。 Add 将对象添加到 List 的结尾处。 AddRange 将指定集合的元素添加到 List 的末尾。 Clear 从 List 中移除所有元素。 Contains 确定某元素是否在 List 中。 ConvertAll 将当前 List 中的元素转换为另一种类型，并返回包含转换后的元素的列表。 Equals(Object) 确定指定的 Object 是否等于当前的 Object。 （继承自 Object。） Remove 从 List 中移除特定对象的第一个匹配项。 Sort() 使用默认比较器对整个 List 中的元素进行排序。 ToArray 将 List 的元素复制到新数组中。 ToString 返回表示当前对象的字符串。 （继承自 Object。） using System.Collections.Generic; List\u003cAnimal\u003e animalCollection = new List\u003cAnimal\u003e(); animalCollection.Add(new Cow(\"Jack\")); animalCollection.Add(new Chicken(\"Vera\")); foreach (Animal myAnimal in animalCollection) { myAnimal.Feed(); } 或者 public class Animals:List\u003cAnimal\u003e {} 对泛型进行排序 System.Collections.Generic名称空间包含List\u003cT\u003eT类型对象集合,Dictionary\u003cK,V\u003e与K类型的键值相关的V类型的项的集合 List\u003cT\u003e 使用泛型接口IComparer\u003cT\u003e和IComparable\u003cT\u003e int IComparable\u003cT\u003e.CompareTo(T otherObj) bool IComparable\u003cT\u003e.Equals(T otherObj) int IComparer\u003cT\u003e.Compare(T objectA,T objectB) bool ICompare\u003cT\u003e.Equals(T objectA,T objectB) int IComparer\u003cT\u003e.GetHashCode(T objectA) 给列表排序，需要有一个方法来比较两个T类型的对象，要在列表中搜索，需要用一个方法来检查T类型的对象 两个泛型委托： Comparison\u003cT\u003e int method(T objectA,TobjectB) Predicate\u003cT\u003e bool method(T targetObject) public class Vectors : List\u003cVector\u003e { public Vectors() { } public Vectors(IEnumerable\u003cVector\u003e initialItems) { foreach (Vector vector in initialItems) { Add(vector); } } public string Sum() { StringBuilder sb = new StringBuilder();//表示可变字符字符串 Vector currentPoint = new Vector(0.0, 0.0); sb.Append(\"origin\"); foreach (Vector vector in this) { sb.AppendFormat(\" + {0}\", vector); currentPoint += vector; } sb.AppendFormat(\" = {0}\", currentPoint); return sb.ToString(); } } public static class VectorDelegates { public static int Compare(Vector x, Vector y) { if (x.R \u003e y.R) { return 1; } else if (x.R \u003c y.R) { return -1; } return 0; } public static bool TopRightQuadrant(Vector target) { if (target.Theta \u003e= 0.0 \u0026\u0026 target.Theta \u003c= 90.0) { return true; } else { return false; } } } class Program { static void Main(string[] args) { Vectors route = new Vectors(); route.Add(new Vector(2.0, 90.0)); route.Add(new Vector(1.0, 180.0)); route.Add(new Vector(0.5, 45.0)); route.Add(new Vector(2.5, 315.0)); Console.WriteLine(route.Sum()); Comparison\u003cVector\u003e sorter = new Comparison\u003cVector\u003e(VectorDelegates.Compare);//委托 route.Sort(sorter);//这个个语句可以简化route.Sort(VectorDelegates.Compare); Console.WriteLine(route.Sum()); Predicate\u003cVector\u003e searcher = new Predicate\u003cVector\u003e(VectorDelegates.TopRightQuadrant);//委托 Vectors topRightQuadrantRoute = new Vectors(route.FindAll(searcher)); Console.WriteLine(topRightQuadrantRoute.Sum()); Console.ReadKey(); } } + `Dictionary\u003cK,V\u003e`该类型建立键/值对应这个类需要实例化两个类型，分别用于键和值\rDictionary\u003cstring ,int\u003ethings=new Directionary\u003cstring ,int \u003e() things.Add(\"Green Things\",29); foreach(strign key in things.Values) { using key; } foreach(int value in things.Values) { usign value } foreach(KeyValuePair\u003cstring,int \u003e thing in things) { using things.key and things.value } + 每个键都独立的，如果相同抛出异常`Dictionary\u003cstring ,int\u003ethings=new Directionary\u003cstring ,int \u003e(stringComparer.CurrentCultureIgnoreCase)`自己的类用作键，不区分发小写比较，这样同一个类就会出现异常\r定义泛型 要创建泛型类 class MyGenericClass\u003cT1,T2,T3\u003e { } + 定义泛型后就可以像使用其他数据类型一样使用它们\r+ default关键字,default(T1),如果T1是值类型使之默认为0，如果为引用就默认为null\r+ 约束\rclass MyGenericClass\u003cT1,T2,T3\u003e where T:constraint1,constraint2 { } //约束必须在继承后面 + struct类型必须为值类型\r+ class类型必须为引用类型\r+ ba","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:17","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"事件\r事件必须订阅，可以由多个订阅 using System.Timers; class Program { static int counter = 0; static string displayString = \"This string will appear one letter at a time. \"; static void Main(string[] args) { Timer myTimer = new Timer(100);//创建定时器，毫秒 myTimer.Elapsed += new ElapsedEventHandler(WriteChar);//Elapsed事件该事件必须匹配System.Timers.ElapsedEventHandler委托类型的返回值 //处理程序和事件订阅起来，事件处理方法初始化为一个新的委托实例 //可以直接写成myTimer.Elapsed +=WriteChar； myTimer.Start();//启动定时器 System.Threading.Thread.Sleep(200);//将当前线程阻塞指定的毫秒数 Console.ReadKey(); } static void WriteChar(object source, ElapsedEventArgs e) { Console.Write(displayString[counter++ % displayString.Length]); } } System.Timers.ElapsedEventHandler委托类型是标准委托之一， void \u003cMethodName\u003e(object source,ElapsedEventArgs e) 定义事件 public delegate void MessageHandler(string messageText);//定义委托，该委托用于定义的事件必须指明返回值的参数值 public class Connection { public event MessageHandler MessageArrived;//给时间命名并指定委托的类型 private Timer pollTimer;//定时器 public Connection() { pollTimer = new Timer(100);//定时器时间 pollTimer.Elapsed += new ElapsedEventHandler(CheckForMessage);//定时器的事件委托 } public void Connect() { pollTimer.Start();//定时器开始 } public void Disconnect() { pollTimer.Stop();//定时器结束 } private static Random random = new Random(); private void CheckForMessage(object source, ElapsedEventArgs e)//定时器的委托函数； { Console.WriteLine(\"Checking for new messages.\"); if ((random.Next(9) == 0) \u0026\u0026 (MessageArrived != null))///生成一个0-9的数，如果是0，并且事件有订阅者，则事件实现委托就使用委托来 { MessageArrived(\"Hello Mum!\"); } } } public class Display { public void DisplayMessage(string message) { Console.WriteLine(\"Message arrived: {0}\", message); } } class Program { static void Main(string[] args) { Connection myConnection = new Connection(); Display myDisplay = new Display(); myConnection.MessageArrived +=new MessageHandler(myDisplay.DisplayMessage);//将委托和函数绑定 myConnection.Connect(); System.Threading.Thread.Sleep(200); Console.ReadKey(); } } 多用途事件处理程序 Timer.Elapsed事件的委托包含了事件处理程序中常见的两类参数 object source:引发事件对象的引用 ElapsdEventArgs:由事件传送的参数 由不同对象引发的几个相同事件使用相同事件处理程序 public class MessageArrivedEventArgs : EventArgs//定义消息类 { private string message; public string Message { get { return message; } } public MessageArrivedEventArgs() { message = \"No message sent.\"; } public MessageArrivedEventArgs(string newMessage) { message = newMessage; } } public class Connection { public event EventHandler\u003cMessageArrivedEventArgs\u003e MessageArrived;//事件，EventHandler\u003cT\u003e为委托模板，将消息类传入 private Timer pollTimer; public string Name { get; set; } public Connection() { pollTimer = new Timer(100); pollTimer.Elapsed += new ElapsedEventHandler(CheckForMessage); } public void Connect() { pollTimer.Start(); } public void Disconnect() { pollTimer.Stop(); } private static Random random = new Random(); private void CheckForMessage(object source, ElapsedEventArgs e) { Console.WriteLine(\"Checking for new messages.\"); if ((random.Next(9) == 0) \u0026\u0026 (MessageArrived != null)) { MessageArrived(this, new MessageArrivedEventArgs(\"Hello Mum!\"));//发送消息 } } } public class Display//事件响应函数 { public void DisplayMessage(object source, MessageArrivedEventArgs e) { Console.WriteLine(\"Message arrived from: {0}\", ((Connection)source).Name); Console.WriteLine(\"Message Text: {0}\", e.Message); } } class Program { static void Main(string[] args) { Connection myConnection1 = new Connection(); myConnection1.Name = \"First connection.\"; Connection myConnection2 = new Connection(); myConnection2.Name = \"Second connection.\"; Display myDisplay = new Display(); myConnection1.MessageArrived += myDisplay.DisplayMessage; myConnection2.MessageArrived += myDisplay.DisplayMessage; myConnection1.Connect(); myConnection2.Connect(); System.Threading.Thread.Sleep(200); Console.ReadKey(); } } + .net提供了两个委托类型：EventHandler和`EventHandler\u003cT\u003e`\r+ 匿名方法，纯粹是为了用作委托目的而创建的\rdelegate(parameters) { } parameters参数化列表 myConnection1.MessageArrived += delegate(Connection source,MessageArriveEventArgs e) {Console.writeline(\"message arrived from{0}\",source.Name);} ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:18","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"特性，元数据\r可以为代码段标记一些信息，这些信息可以从外部读取 [DebuggerStepThrough] public void DullMethod() {}该特性说明，在调试的时候不进入该方法进行逐句调试，而是跳过该方法,该特性通过DebuggerStepThroughAttribute这个类来实现的，这个类位于System.Diagnostics名称空间中 特性的参数可以自己设置[DoesInterestingThings(1000, WhatDoesItDo = “voodoo”)] 读取特性需要用到反射,Type.GetCustomAttributes来实现 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:19","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"补充\r对象初始化器 省略构造函数的括号，自动调用无参数构造函数，之后调用初始化器 同时对象初始化器还可以进行嵌套 //初始化器,使用默认构造函数实现赋值 \u003cclassname\u003e \u003cvariableName\u003e=new \u003cclaseename\u003e { \u003cpropertyOrField1\u003e=\u003cvalue1\u003e, \u003cpropertyOrField2\u003e=\u003cvalue2\u003e, \u003cpropertyOrField3\u003e=\u003cvalue3\u003e, ... } Curry tastyCurry=new Curry { MainInte=\"ddddd\"; Origin=new restaurant { Name=\"ddd\"; } }; 集合初始化器 类型推理：var ,编译器来确定类型，var关键字还可以通过数组初始化器来推断数组的类型：var myarray=new [] {4,5,6,7};4,5,6,7必须遵循：相同的类型，相同的引用类型或空，所有元素的类型都可以隐式转换为同一类型 匿名对象：为了减少创建对象所消耗的时间，其理念就是让编辑器根据要存储的数据自动创建类型，而不是定义简单的数据存储类型 匿名类型 var curry=new { MainIngredient=\"lamb\", Style=\"Dhansnk\", Spiciness=5 }; + 使用var关键字，因为匿名类型没有可以使用的标识符，\r+ new后面没有指定类型的名称\r+ 匿名对象的属性被定义为只读，如果在存储对象中修改属性的值，就不能使用匿名对象。\r+ 使用动态查找功能可以处理未知的C#类型\rclass Program { static void Main(string[] args) { var curries = new[] { new { MainIngredient = \"Lamb\", Style = \"Dhansak\", Spiciness = 5 }, new { MainIngredient = \"Lamb\", Style = \"Dhansak\", Spiciness = 5 }, new { MainIngredient = \"Chicken\", Style = \"Dhansak\", Spiciness = 5 } }; Console.WriteLine(curries[0].ToString()); Console.WriteLine(curries[0].GetHashCode()); Console.WriteLine(curries[1].GetHashCode()); Console.WriteLine(curries[2].GetHashCode()); Console.WriteLine(curries[0].Equals(curries[1]));//比较状态，即每个属性的值 Console.WriteLine(curries[0].Equals(curries[2])); Console.WriteLine(curries[0] == curries[1]); Console.WriteLine(curries[0] == curries[2]); Console.ReadKey(); } } { MainIngredient = Lamb, Style = Dhansak, Spiciness = 5 } 294897435 294897435 621671265 True False False False 动态类型：dynamic myDynamicVar;在编译期间会被object替代， 默认参数类型 可变参数 命名参数：首先选定必选参数，再指定命名的可选参数 public static List\u003cstring\u003e GetWords( string sentence, bool capitalizeWords = false, bool reverseOrder = false, bool reverseWords = false) { List\u003cstring\u003e words = new List\u003cstring\u003e(sentence.Split(' ')); if (capitalizeWords) words = CapitalizeWords(words); if (reverseOrder) words = ReverseOrder(words); if (reverseWords) words = ReverseWords(words); return words; } words = WordProcessor.GetWords( sentence, reverseWords: true, capitalizeWords: true); 扩展方法 要创建和使用扩展方法必须： 创建一个非泛型静态类 使用扩展方法的语法，为所创建的类添加扩展方法，做为静态方法 确保使用扩展方法的代码用using语法导入包含扩展方法类的名称空间 通过扩展类型的一个实例调用扩展方法，与调用扩展类型的其他方法一样。 扩展方法的要求： 方法必须是静态的 方法必须包含一个参数，表示调用扩展方法的类型实例 实例参数必须是方法定义的第一个参数， 除了this关键字外，实例参数不能有其他修饰符 public static class ExtensionClass { public static \u003cReturnType\u003e \u003cExtensionMethodName\u003e(this \u003cTyprToExtend\u003e instance ,\u003cotherParamters\u003e) { ... } } public static class ExtensionClass { public static \u003cReturnType\u003e \u003cExtensionMethodName\u003e(this \u003cTyprToExtend\u003e instance ,\u003cotherParamters\u003e) { ... } } \u003cTypeToExtend\u003e myVar; //myVar is initialized by code not shown here myVar.\u003cExtensionMethodName\u003e(); \u003cTypeToExtend\u003e myVar; ExtensionClass.\u003cExtensionMethodName\u003e(myVar); //导入后可以通过IntelliSense查看扩展方法 //定义了一个扩展方法后还可以将其运用到派生于这个类型的子类型中 namespace ExtensionLib { public static class WordProcessor { public static List\u003cstring\u003e GetWords( this string sentence, bool capitalizeWords = false, bool reverseOrder = false, bool reverseWords = false) { List\u003cstring\u003e words = new List\u003cstring\u003e(sentence.Split(' ')); if (capitalizeWords) words = CapitalizeWords(words); if (reverseOrder) words = ReverseOrder(words); if (reverseWords) words = ReverseWords(words); return words; } public static string ToStringReversed(this object inputObject) { return ReverseWord(inputObject.ToString()); } } } using ExtensionLib; static void Main(string[] args) { Console.WriteLine(\"Enter a string to convert:\"); string sourceString = Console.ReadLine(); Console.WriteLine(\"String with title casing: {0}\", sourceString.GetWords(capitalizeWords: true) .AsSentence()); Console.WriteLine(\"String backwards: {0}\", sourceString.GetWords(reverseOrder: true, reverseWords: true).AsSentence()); Console.WriteLine(\"String length backwards: {0}\", sourceString.Length.ToStringReversed()); Console.ReadKey(); } lambda表达式 定义一个事件处理方法，其返回类型和参数匹配要订阅的事件需要委托返回类型和参数 声明一个委托类型的变量 把委托变量初始化为委托类型的实例，实例指向事件处理方法 把委托变量添加到时间的订阅者列表中 正常的事件 Timer myTimer =new Timer(1000); myTimer.Elapsed+=new ElapsedEvendHandler(WriteChar); //可以直接写成 myTimer.Elapsed+=WriteChar； //使","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:6:0","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数据库\r","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:0:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数据库概述\rDBMS(DataBase Management System,数据库管理系统)和数据库。平时谈到“数据库”可能有两种含义：MSSQLServer、Oracle等某种DBMS；存放一堆数据表的一个分类(Catalog) 数据库的构成-管理软件/服务/数据文件(表,视图…) 不同品牌的DBMS有自己的不同的特点：MYSQL、MSSQLServer、DB2、Oracle、Access、Sybase等。对于开发人员来讲，大同小异 除了Access、SQLServerCE等文件型数据库之外，大部分数据库都需要数据库服务器才能运行。学习\\开发时是连接本机的数据库，上线运行时是数据库运行在单独的服务器 为什么要用数据库：我们平时把数据以文件的方式存放在硬盘里，但当数据量庞大的时候：文件大，操作效率很低下。所以，便有了很多种数据库软件(Mssql,Ora,DB2…)，它们代替我们做数据文件的操作(mdf,ndf,ldf)并提供高效的存储和检索等操作。还提供了很多接口给其他程序语言调用。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:1:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"为什么要使用数据库\r用文件保存数据与用数据库的优劣： 高效维护大量数据-检索/增/删/改 处理各个表之间的关系 压缩表数据 安全 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:2:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数据库的概念\rCatalog(分类)(又叫数据库DataBase,表空间TableSpace),不同类的数据应该放到不同的数据库中 便于对各个Catalog进行个性化管理 避免命名冲突3安全性更高 Table(表):书都放到书架上,碗都放到橱柜中,不同类型的资料放到不同的“格子”中，将这种区域叫做“表”(Table)。不同的表根据放的数据不同进行空间的优化，找起来也方便。 列(Column)、字段(Field) 主键(Primary Key)：主键就是一个表中每个数据行的唯一标识。不会有重复值的列才能当主键。一个表可以没有主键，但是会非常难以处理，因此没有特殊理由表都要设定主键 主键有两种选用策略：业务主键和逻辑主键。业务主键是使用有业务意义的字段做主键，比如身份证号、银行账号等；逻辑主键是使用没有任何业务意义的字段做主键，完全给程序看的，业务人员不会看的数据。因为很难保证业务主键不会重复（身份证号重复）、不会变化（帐号升位），因此推荐用逻辑主键。 外键(Foreign Key)—记录表与表的关联 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:3:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"SQLSERVER管理\r需要安装SQLServer2005或者SQLServer2008，若要使用SQLServer管理工具进行开发还要安装SQL Server Management Studio，还可以使用VisualStudio进行管理 使用免费的SQL Server Express版本，Express版本的服务器名称. \\SQLEXPRESS，对于开发人员来讲和其他版本没有区别。 SQLServer的两种验证方式：用户名验证和Windows验证，开发时用Windows验证就行。 开发人员关注点在开发上,而不是配置/备份等之上,那是DBA做的事情。 创建数据库，创建表，设置主键 SQLServer2008中：编辑200行；SQLServer2005中：打开表。 常用字段类型：bit(可选值0、1)、datetime、int、varchar、nvarchar（可能含有中文用nvarchar） Nvarchar(50)、Nvarchar(MAX) varchar、nvarchar 和char(n)的区别： char(n)不足长度n的部分用空格填充。Var：Variable，可变的。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:4:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"SQL语句入门\rSQL语句是和DBMS“交谈”专用的语句，不同DBMS都认SQL语法 SQL语句中字符串用单引号。 SQL语句是大小写不敏感的,不敏感指的是SQL关键字,字符串值还是大小写敏感的 创建表、删除表不仅可以手工完成,还可以执行SQL语句完成,在自动化部署、数据导入中用的很多,CREATE TABLE T_Person(Id int NOT NULL,Name nvarchar(50),Age int NULL)、Drop table T_Person1 简单的Insert语句。INSERT INTO T_Person(Id,Name,Age) VALUES(1,'Jim',20) （*） SQL主要分DDL（数据定义语言）和DML（数据操作语言）两类。Create Table、Drop Table、Alter Table等属于DDL，Select、Insert、Update、Delete等属于DML ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:5:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"主键的选择\rSQLServer中两种常用的主键数据类型：int（或bigint）+标识列(又称自动增长字段);uniqueidentifier(又称Guid、UUID) 用标识列实现字段自增可以避免并发等问题，不要开发人员控制自增。用标识列的字段在Insert的时候不用指定主键的值。将字段的“是标识列”设置为“是”，一个表只能有一个标识列。 Guid算法是一种可以产生唯一标识的高效算法，它使用网卡MAC、地址、纳秒级时间、芯片ID码等算出来的，这样保证每次生成的GUID永远不会重复，无论是同一个计算机上还是不同的计算机。在公元3400年以前产生的GUID与任何其他产生过的GUID都不相同。SQLServer中生成GUID的函数newid()，.Net中生成Guid的方法：Guid.NewGuid()，返回是Guid类型。 （*）Int自增字段的优点：占用空间小、无需开发人员干预、易读；缺点：效率低；数据导入导出的时候很痛苦。 （*）Guid的优点：效率高、数据导入导出方便；缺点占用空间大、不易读。 业界主流倾向于使用Guid。 Globally Unique Identifier(全球唯一标识符),也称作 UUID(Universally Unique IDentifier) GUID：用于指示产品的唯一性安装。是通过特定算法产生的一个二进制长度为128位的数字。在空间上和时间上具有唯一性，保证同一时间不同地方产生的数字不同。在公元3400年以前产生的UUID/GUID与任何其他产生过的UUIDs/GUIDs都不相同 GUID的长度固定，并且相对而言较短小，非常适合于排序、标识和存储。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:6:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"新增\r新增表和参数 CREATE TABLE T_Employee (FNumber VARCHAR(20),FName VARCHAR(20),FAge INT,FSalary NUMERIC(10,2),PRIMARY KEY (FNumber)); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('DEV001','Tom',25,8300); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('DEV002','Jerry',28,2300.80); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('SALES001','John',23,5000); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('SALES002','Kerry',28,6200); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('SALES003','Stone',22,1200); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('HR001','Jane',23,2200.88); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('HR002','Tina',25,5200.36); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('IT001','Smith',28,3900); INSERT INTO T_Employee(FNumber,FAge,FSalary) VALUES('IT002',27,2800); 插入一列 ALTER TABLE T_Employee ADD FSubCompany VARCHAR(20); UPDATE T_Employee SET FSubCompany='Beijing',FDepartment='Development' WHERE FNumber='DEV001'; Insert语句可以省略表名后的列名，但是不推荐 如果插入的行中有些字段的值不确定，那么Insert的时候不指定那些列即可。 可以给字段默认值，如果Guid类型主键的默认值设定为newid()就会自动生成，很少这么干 主键： insert into Person3(Name,Age) values('lily',38); insert into Person4(Id,Name,Age) values(newid(),'tom',30); ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:7:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"更新\r更新一个列:UPDATE T_Person Set Age=30 更新多个列:UPDATE T_Person Set Age=30,Name=‘tom’ 更新一部分数据： UPDATE T_Person Set Age=30 where Name=‘tom’，用where语句表示只更新Name是’tom’的行，注意SQL中等于判断用单个=，而不是== Where中还可以使用复杂的逻辑判断UPDATE T_Person Set Age=30 where Name=‘tom’ or Age\u003c25，or相当于C#中的||（或者） update Person1 set NickName=N'二十岁' where (Age\u003e20 and Age\u003c30) or(Age=80) Where中可以使用的其他逻辑运算符：or、and、not、\u003c、\u003e、\u003e=、\u003c=、!=（或\u003c\u003e）等 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:8:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"删除\r删除表中全部数据：DELETE FROM T_Person。 Delete只是删除数据，表还在，和Drop Table不同。 Delete 也可以带where子句来删除一部分数据：DELETE FROM T_Person WHERE FAge \u003e 20 Truncate 删除所有行并重置标识 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:9:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"检索\r执行备注中的代码创建测试数据表。 简单的数据检索 ：SELECT * FROM T_Employee 只检索需要的列 ：SELECT FNumber FROM T_Employee 、SELECT FName,FAge FROM T_Employee 列别名：SELECT FNumber AS 编号,FName AS 姓名,FAge AS Age111 FROM T_Employee 使用where检索符合条件的数据：SELECT FName FROM T_Employee WHERE FSalary\u003c5000。故事：新员工的数据检索噩梦。 还可以检索不与任何表关联的数据：select 1+1;select newid();select getdate(); ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:10:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数据汇总\rSQL聚合函数：MAX（最大值）、MIN（最小值）、AVG （平均值）、SUM （和）、COUNT（数量） 大于25岁的员工的最高工资 ： SELECT MAX(FSalary) FROM T_Employee WHERE FAge\u003e25 最低工资和最高工资： SELECT MIN(FSalary),MAX(FSalary) FROM T_Employee ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:11:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"排序\rORDER BY子句位于SELECT语句的末尾，它允许指定按照一个列或者多个列进行排序，还可以指定排序方式是升序（从小到大排列，ASC）还是降序（从大到小排列，DESC）。 按照年龄升序排序所有员工信息的列表： SELECT * FROM T_Employee ORDER BY FAge ASC 按照年龄从大到小排序，如果年龄相同则按照工资从大到小排序 ：SELECT * FROM T_Employee ORDER BY FAge DESC,FSalary DESC（多个排序条件） ORDER BY子句要放到WHERE子句之后 ：SELECT * FROM T_Employee WHERE FAge\u003e23 ORDER BY FAge DESC,FSalary DESC ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:12:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"通配过滤符\r通配符过滤关键字使用LIKE 。 单字符匹配的通配符为半角下划线“_”，它匹配单个出现的字符。 eg:以任意字符开头，剩余部分为“erry” SELECT * FROM T_Employee WHERE FName LIKE '_erry' 多字符匹配的通配符为半角百分号“%”，它匹配任意次数（零或多个）出现的任意字符。 “k%”匹配以“k”开头、任意长度的字符串 eg:检索姓名中包含字母“n”的员工信息 SELECT * FROM T_Employee WHERE FName LIKE '%n%' ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:13:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"空值处理\r数据库中，一个列如果没有指定值，那么值就为null，这个null和C#中的null，数据库中的null表示“不知道”，而不是表示没有。 因此select null+1结果是null，因为“不知道”加1的结果还是“不知道”。 SELECT * FROM T_Employee WHERE FNAME=null ； SELECT * FROM T_Employee WHERE FNAME!=null ； 都没有任何返回结果，因为数据库也“不知道”。 SQL中使用is null、is not null来进行空值判断： SELECT * FROM T_Employee WHERE FNAME is null ； SELECT * FROM T_Employee WHERE FNAME is not null ； ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:14:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"多值匹配\r删除多条数据 Delete T_Employee where FId in (21,22) SELECT FAge,FNumber,FName FROM T_Employee WHERE FAge IN (23,25,28) 范围值： SELECT * FROM T_Employee WHERE FAGE\u003e=23 AND FAGE \u003c=27 SELECT * FROM T_Employee WHERE FAGE BETWEEN 23 AND 27 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:15:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数据分组\r按照年龄进行分组统计各个年龄段的人数：SELECT FAge,Count(*) FROM T_Employee GROUP BY Fage GROUP BY子句必须放到WHERE语句的之后 没有出现在GROUP BY子句中的列是不能放到SELECT语句后的列名列表中的 (聚合函数中除外) 错误： SELECT FAge,FSalary FROM T_Employee GROUP BY FAge 正确： SELECT FAge,AVG(FSalary) FROM T_Employee GROUP BY FAge ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:16:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"对分组进行过滤\r在Where中不能使用聚合函数，必须使用Having，Having要位于Group By之后： SELECT FAge,COUNT(*) AS 人数 FROM T_Employee GROUP BY FAge HAVING COUNT(*)\u003e1 在分组的时候对分组后的成员进行过滤 注意Having中不能使用未参与分组的列，Having不能替代where。作用不一样，Having是对组进行过滤。having和where不会同时出现 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:16:1","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"限制结果集行数\rSELECT top 5 * FROM T_Employee order by FSalary Desc （*）检索按照工资从高到低排序检索从第六名开始一共三个人的信息 ： SELECT top 3 * FROM T_Employee WHERE FNumber NOT IN (SELECT TOP 5 FNumber FROM T_Employee ORDER BY FSalary DESC) ORDER BY FSalary DESC 该语句用来分页语句。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:17:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"去掉重复数据\r执行备注中的SQL语句，Alter和Insert单独执行 SELECT FDepartment FROM T_Employee SELECT DISTINCT FDepartment FROM T_Employee DISTINCT是对整个结果集进行数据重复处理的，而不是针对每一个列，因此下面的语句并不会只保留Fdepartment进行重复值处理：SELECT DISTINCT FDepartment,FSubCompany FROM T_Employee ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:18:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"联合结果集\rCREATE TABLE T_TempEmployee (FIdCardNumber VARCHAR(20),FName VARCHAR(20),FAge INT, PRIMARY KEY (FIdCardNumber)); INSERT INTO T_TempEmployee(FIdCardNumber,FName,FAge) VALUES('1234567890121','Sarani',33); INSERT INTO T_TempEmployee(FIdCardNumber,FName,FAge) VALUES('1234567890122','Tom',26); INSERT INTO T_TempEmployee(FIdCardNumber,FName,FAge) VALUES('1234567890123','Yalaha',38); INSERT INTO T_TempEmployee(FIdCardNumber,FName,FAge) VALUES('1234567890124','Tina',26); INSERT INTO T_TempEmployee(FIdCardNumber,FName,FAge) VALUES('1234567890125','Konkaya',29); INSERT INTO T_TempEmployee(FIdCardNumber,FName,FAge) VALUES('1234567890126','Fotifa',46); 简单的结果集联合： SELECT FNumber,FName,FAge FROM T_Employee UNION SELECT FIdCardNumber,FName,FAge FROM T_TempEmployee 基本的原则：每个结果集必须有相同的列数；每个结果集的列必须类型相容。 SELECT FNumber,FName,FAge,FDepartment FROM T_Employee UNION SELECT FIdCardNumber,FName,FAge,‘临时工，无部门' FROM T_TempEmployee ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:19:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"union all\rSELECT FName FROM T_Employee UNION SELECT FName FROM T_TempEmployee UNION 合并两个查询结果集，并且将其中完全重复的数据行合并为一条 SELECT FName FROM T_Employee UNION ALL SELECT FName FROM T_TempEmployee Union因为要进行重复值扫描，所以效率低，因此如果确定不要合并重复行，那么就用UNION ALL ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:19:1","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数字函数\rABS() ：求绝对值。 CEILING()：舍入到最大整数 。3.33将被舍入为4、2.89将被舍入为3、-3.61将被舍入为-3。 Ceiling→天花板 FLOOR()：舍入到最小整数。3.33将被舍入为3、2.89将被舍入为2、-3.61将被舍入为-4。 Floor→地板。 ROUND()：四舍五入。舍入到“离我半径最近的数” 。Round→“半径”。Round(3.1425,2)。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:20:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"string\rLEN() ：计算字符串长度，求字符 Datalength():求字节 LOWER() 、UPPER () ：转小写、大写 LTRIM()：字符串左侧的空格去掉 RTRIM () ：字符串右侧的空格去掉 LTRIM(RTRIM(’ bb ‘)) SUBSTRING(string,start_position,length) 参数string为主字符串，start_position为子字符串在主字符串中的起始位置，length为子字符串的最大长度。SELECT SUBSTRING('abcdef111',2,3) ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:20:1","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"日期\rGETDATE() ：取得当前日期时间 DATEADD (datepart , number, date )，计算增加以后的日期。参数date为待计算的日期；参数number为增量；参数datepart为计量单位，可选值见备注。DATEADD(DAY, 3,date)为计算日期date3天后的日期，而DATEADD(MONTH ,-8,date)为计算日期date8个月之前的日期 DATEDIFF ( datepart , startdate , enddate ) ：计算两个日期之间的差额。 datepart 为计量单位，可取值参考DateAdd。 统计不同工龄的员工的个数： select DateDiff(year,FInDate,getdate()),count(*) from T_Employee group by DateDiff(year,FInDate,getdate()) DATEPART (datepart,date)：返回一个日期的特定部分 统计员工的入职年份个数： select DatePart(year,FInDate),count(*) from T_Employee group by DatePart(year,FInDate) ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:20:2","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"类型转换函数\rCAST ( expression AS data_type) CONVERT ( data_type, expression) SELECT FIdNumber, RIGHT(FIdNumber,3) as 后三位, CAST(RIGHT(FIdNumber,3) AS INTEGER) as 后三位的整数形式, CAST(RIGHT(FIdNumber,3) AS INTEGER)+1 as 后三位加1, CONVERT(INTEGER,RIGHT(FIdNumber,3))/2 as 后三位除以2 FROM T_Person ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:21:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"空值处理函数\rISNULL(expression,value) ： 如果expression不为空则返回expression，否则返回value SELECT ISNULL(FName,'佚名') as 姓名 FROM\rT_Employee ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:22:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"case\r单值判断，相当于switch case CASE expression WHEN value1 THEN returnvalue1 WHEN value2 THEN returnvalue2 WHEN value3 THEN returnvalue3 ELSE defaultreturnvalue END 例子SELECT SELECT FName, (CASE FLevel WHEN 1 THEN 'VIP客户' WHEN 2 THEN '高级客户' WHEN 3 THEN '普通客户' ELSE '客户类型错误' END) as FLevelName FROM T_Customer select FName, ( case when FSalary\u003c2000 then '低收入' when FSalary\u003e=2000 and FSalary\u003c=5000 then '中等收入' else '高收入' end ) as 收入水平 from T_Employee SELECT FName, FWeight, (CASE WHEN FWeight\u003c40 THEN '瘦瘦' WHEN FWeight\u003e50 THEN '肥肥' ELSE 'ok' END) as isnormal FROM T_Person ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:23:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"索引index\r分为聚集索引和非聚集索引， 聚集索：聚集索引就相当于使用字典的拼音查找，因为聚集索引存储记录是物理上连续，即拼音a过后一定是b. 非聚集索引，就相当于使用字典的首部查找，逻辑连续，物理不连续。 全表扫描：对数据进行检索（select）效率最差的是全表扫描，就是一条条的找。 如果没有目录，查汉语字典就要一页页的翻，而有了目录只要查询目录即可。为了提高检索的速度，可以为经常进行检索的列添加索引，相当于创建目录。 创建索引的方式，在表设计器中点击右键，选择“索引/键”→添加→在列中选择索引包含的列。不能为空 使用索引能提高查询效率，但是索引也是占据空间的，而且添加、更新、删除数据的时候也需要同步更新索引，因此会降低Insert、Update、Delete的速度。只在经常检索的字段上(Where)创建索引。 （*）即使创建了索引，仍然有可能全表扫描，比如like、函数、类型转换等。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:24:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"表连接\r有客户表（T_Customers）和订单表（T_Orders）两个表，客户表字段为：Id、Name、Age，订单表字段为：Id、BillNo、CustomerId，订单表通过CustomerId关联客户表。测试数据见备注。 SELECT o.BillNo,c.Name,c.Age from T_Orders as o\rJOIN T_Customers as c on o.CustomerId=c.Id join是和哪个表连接，on后是连接的关系是什么。(多表) 要求显示所有年龄大于15岁的顾客购买的订单号、客户姓名、客户年龄。 要求显示年龄大于平均年龄的顾客购买的订单 （*）Inner Join、Left Join、Right Join ：T_Orders ：T_Customers select o.BillNo,c.Name,c.Age\rfrom T_Orders as o\rjoin T_Customers as c on o.CustomerId=c.Id这个语句是以 T_Orders表为准，在其后添加join表的内容。 select o.BillNo,c.Name\rfrom T_Orders as o\rjoin T_Customers as c\ron o.CustomerId=c.Id\rwhere c.Age\u003e15 select o.BillNo,c.Name,c.Age\rfrom T_Orders as o\rjoin T_Customers as c on o.CustomerId=c.Id\rwhere c.Age\u003e(select AVG(Age) from T_Customers) ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:25:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"子查询\r将一个查询语句做为一个结果集供其他SQL语句使用，就像使用普通的表一样，被当作结果集的查询语句被称为子查询。所有可以使用表的地方几乎都可以使用子查询来代替。SELECT * FROM(SELECT * FROM T2 where FAge\u003c30) 单值做为子查询：SELECT 1 AS f1,2,(SELECT MIN(FYearPublished) FROM T_Book),(SELECT MAX(FYearPublished) FROM T_Book) AS f4 只有返回且仅返回一行、一列数据的子查询才能当成单值子查询。下面的是错误的：SELECT 1 AS f1,2,(SELECT FYearPublished FROM T_Book) SELECT * FROM T_ReaderFavorite WHERE FCategoryId=(SELECT FId FROM T_Category WHERE FName='Story') 如果子查询是多行单列的子查询，这样的子查询的结果集其实是一个集合。 SELECT * FROM T_Reader WHERE FYearOfJoin IN\r(\rselect FYearPublished FROM T_Book\r) 限制结果集。返回第3行到第5行的数据（ ROW_NUMBER 不能用在where子句中，所以将带行号的执行结果作为子查询，就可以将结果当成表一样用了）： SELECT * FROM ( SELECT ROW_NUMBER() OVER(ORDER BY FSalary DESC) AS rownum, FNumber,FName,FSalary,FAge FROM T_Employee ) AS a WHERE a.rownum\u003e=3 AND a.rownum\u003c=5 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:26:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"视图概述\r视图是一张虚拟表，它表示一张表的部分数据或多张表的综合数据，其结构和数据是建立在对表的查询基础上 视图在操作上和数据表没有什么区别，但两者的差异是其本质是不同:数据表是实际存储记录的地方，然而视图并不保存任何记录，它存储的实际上是查询语句 相同的数据表，根据不同用户的不同需求，可以创建不同的视图（不同的查询语句） 优点： 筛选表中的行 防止未经许可的用户访问敏感数据 降低数据库的复杂程度 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:27:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"局部变量\r声明局部变量 DECLARE @变量名 数据类型 DECLARE @bookName varchar(20) DECLARE @bId int 赋值 SET @变量名 =值 –set用于普通的赋值 SELECT @变量名 = 值 –用于从表中查询数据并赋值 例如： SET @ bookName =‘家宝’ SELECT @ bookName=b_title FROM Book WHERE b_id=2 declare @money money --声明变量 set @money = 2000 –赋值 select @money – 查询变量值 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:28:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"变量种类\r变量分为： 局部变量：局部变量必须以标记@作为前缀 ，如@Age int 局部变量：先声明，再赋值 全局变量（系统变量）： 全局变量必须以标记@@作为前缀，如@@version 全局变量由系统定义和维护，我们只能读取，不能修改全局变量的值 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:29:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"if else\rIF(条件表达式) BEGIN --相当于C#里的{ 语句1 …… END --相当于C#里的} ELSE BEGIN 语句1 …… END declare @money money select @money=AVG(b_money) from Book if @money \u003e50 begin select 'A' select top 2 * from Book order by b_money desc end else begin select 'B' select top 2 * from Book order by b_money asc end ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:30:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"while循环\rWHILE(条件表达式) BEGIN --相当于C#里的{ 语句 …… BREAK END --相当于C#里的} declare @a int set @a=1 while(@a\u003c50 ) begin print str(@a) set @a=@a+1 end DECLARE @num int WHILE(1=1) --条件永远成立 BEGIN SELECT @num=COUNT(*) FROM T_Book WHERE FYearPublished\u003c2000--统计不达标本数 IF (@num\u003e0) UPDATE T_Book --每本加2元 SET FYearPublished=FYearPublished+2 ELSE BREAK--退出循环(只有一行语句可省begin-end) END SELECT * FROM T_Book ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:31:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"事务\r借钱问题： 假定钱从A转到B，至少需要两步： A的资金减少 然后B的资金相应增加 UPDATE bank SET uMoney=uMoney-1000 WHERE uName='家宝‘ @@error UPDATE bank SET uMoney=uMoney+1000 WHERE uName='奥巴马‘ @@error 查看结果： SELECT * FROM bank 会出问题：不好回滚 指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)–也就是由多个sql语句组成，必须作为一个整体执行 这些sql语句作为一个整体一起向系统提交，要么都执行、要么都不执行 语法步骤： 开始事务：BEGIN TRANSACTION 事务提交：COMMIT TRANSACTION 事务回滚：ROLLBACK TRANSACTION 判断某条语句执行是否出错： 全局变量@@ERROR； @@ERROR只能判断当前一条T-SQL语句执行是否有错，为了判断事务中所有T-SQL语句是否有错，我们需要对错误进行累计； 例：SET @errorSum=@errorSum+@@error BEGIN TRANSACTION /*--定义变量，用于累计事务执行过程中的错误--*/ DECLARE @errorSum INT SET @errorSum=0 --初始化为0，即无错误 /*--转账：张三的账户少1000元，李四的账户多1000元*/ UPDATE bank SET currentMoney=currentMoney-1000 WHERE customerName='张三' SET @errorSum=@errorSum+@@error UPDATE bank SET currentMoney=currentMoney+1000 WHERE customerName='李四' SET @errorSum=@errorSum+@@error --累计是否有错误 If @errorSum\u003e0 Begin rollback transaction select ‘失败’ End Else Begin commit transaction select ‘成功’ End ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:32:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"存储过程\r存储过程—就像数据库中运行方法(函数) 和C#里的方法一样，由存储过程名/存储过程参数组成/可以有返回结果。 前面学的if else/while/变量 等，都可以在存储过程中使用 优点： 执行速度更快，在数据库中保存的语句是编译过的 允许模块化程序设计 ，方法的复用 提高系统安全性，防止SQL注入 减少网络流通量，只要传输存储过程的名称 系统存储过程 由系统定义，存放在master数据库中 名称以“sp_”开头或”xp_”开头 自定义存储过程 由用户在自己的数据库中创建的存储过程 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:33:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"系统存储过程\rEXEC sp_databases EXEC sp_renamedb 'Northwind','Northwind1' EXEC sp_tables EXEC sp_columns stuInfo EXEC sp_help stuInfo EXEC sp_helpconstraint stuInfo EXEC sp_helpindex stuMarks EXEC sp_helptext 'view_stuInfo_stuMarks' EXEC sp_stored_procedures ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:34:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"创建存储过程\r定义存储过程的语法 CREATE PROC[EDURE] 存储过程名 @参数1 数据类型 = 默认值 OUTPUT, @参数n 数据类型 = 默认值 OUTPUT AS SQL语句 参数说明： 参数可选 参数分为输入参数、输出参数 输入参数允许有默认值 EXEC 过程名 [参数] 例子–编写分页存储过程 create procedure proGetPageData @pageIndex int, @pageSize int as declare @sqlStr varchar(300) set @sqlStr='select top '+str(@pageSize)+' * from Category where c_id not in(select top '+str((@pageIndex-1)*@pageSize)+' c_id from Category order by c_addtime)order by c_addtime' print @sqlStr EXEC(@sqlStr) execute proGetPageData 3,3 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:35:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"调用带参数的存储过程\r无参数的存储过程调用： Exec pro_GetAge 有参数的存储过程两种调用法： EXEC proGetPageData 60,55 —按次序 EXEC proGetPageData @labPass=55,@writtenPass=60 –参数名 参数有默认值时： EXEC proGetPageData –都用默认值 EXEC proGetPageData 1 –页容量(@pageSize)默认值 EXEC proGetPageData 1,5 –不用默认值 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:36:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"存储过程中使用输出参数\rcreate procedure [dbo].[proGetPageData2] –带输出参数的存储过程 @pageIndex int=1, @pageSize int=3, @pageCount int output, --总页数 @rowCount int output -- 总行数 as declare @sqlStr nvarchar(300),@sqlCount nvarchar(300) SET @sqlCount = 'SELECT @rowCount=COUNT(b_id),@pageCount=CEILING((COUNT(b_id)+0.0)/'+ CAST(@pageSize AS VARCHAR)+') FROM Book' print @sqlCount EXEC SP_EXECUTESQL @sqlCount,N'@rowCount INT OUTPUT,@pageCount INT OUTPUT',@rowCount OUTPUT,@pageCount OUTPUT set @sqlStr='select top '+str(@pageSize)+' * from Category where c_id not in(select top '+str((@pageIndex-1)*@pageSize)+' c_id from Category order by c_addtime)order by c_addtime' print @sqlStr EXEC(@sqlStr) declare @pc int declare @rc int exec [proGetPageData2] 1,3,@pc output,@rc output select @pc,@rc ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:36:1","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"触发器\r触发器是一种特殊类型的存储过程，它不同于前面介绍过的一般的存储过程。 一般的存储过程通过存储过程名称被直接调用，而触发器主要是通过事件进行触发而被执行。 触发器是一个功能强大的工具，在表中数据发生变化时自动强制执行。触发器可以用于SQL Server约束、默认值和规则的完整性检查，还可以完成难以用普通约束实现的复杂功能。 那究竟何为触发器？在SQL Server里面也就是对某一个表的一定的操作，触发某种条件，从而执行的一段程序。 触发器是一个特殊的存储过程。 常见的触发器有三种： 分别应用于Insert , Update , Delete 事件 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:37:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"常用语法\rCREATE TRIGGER triggerName ON Table for UPDATE|INSERT|DELETE AS begin … end ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:37:1","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"更新\rCREATE TRIGGER testForFun ON dbo.T_Category for UPDATE AS begin select * from dbo.T_Book end update dbo.T_Category set FName = 'Android2' where FId=3 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:37:2","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"删除\rCREATE TRIGGER testForDel ON dbo.Category for delete AS begin select * from book end delete Category set c_name = 'Android2' where c_id=3 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:37:3","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"在触发器中获取值\rSELECT * FROM INSERTED 对于更新触发器，旧记录值在DELETED中可用，新记录值在INSERTED中 DECLARE @OldValue int，@ NewValue int SELECT @OldValue = Column1 FROM DELETED SELECT @NewValue = Column1 FROM INSERTED 通过保持旧值和新值，您可以比较它们的状态。 ADO.NET\r程序要和数据库交互要通过ADO.Net 进行 通过ADO.Net就能在程序中执行SQL了。 ADO.Net中提供了对各种不同数据库的统一操作接口。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:37:4","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"ADO.NET的组成\r如果要执行增删改和单个值查询的时候，可以直接让【车间工人】去【中央仓库】做。 如果要从【中央仓库】查询多行货物的时候，有两种方式： 可以选择叫一辆【货运卡车】去搬，卡车可以一次性的都搬过来，但【生产车间】一下子用不了，所以卡车就把货先放在【车间临时仓库】，这样车间需要的时候直接拿就可以了。 可以让【车间工人】把自己的【摩托车】拿来，骑【摩托车】去仓库拿货，但每次只能拿一行货物，所以需要往返的拿很多次才能拿完。但因为每次只拿一行货物过来，车间就直接使用了，不必存到【车间临时仓库】里。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:38:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"Connection 类\r和数据库交互，你必须连接它。连接帮助指明数据库服务器、数据库名字、用户名、密码，和连接数据库所需要的其它参数。Connection对象会被Command对象使用，这样就能够知道是在哪个数据源上面执行命令。 与数据库交互的过程意味着你必须指明想要执行的操作。这是依靠Command对象执行的。你使用Command对象来发送SQL语句给数据库。Command对象使用Connection对象来指出与哪个数据源进行连接。你能够单独使用Command对象来直接执行命令，或者将一个Command对象的引用传递给DataAdapter，它保存了一组能够操作下面描述的一组数据的命令。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:39:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"Command对象\r成功于数据建立连接后,就可以用Command对象来执行查询、修改、插入、删除等命令; Command对象常用的方法有ExecuteReader方法、ExecuteScalar()方法和ExecuteNonQuery()方法;插入数据可用ExecuteNonQuery()方法来执行插入命令。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:40:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"DataReader类\r许多数据操作要求你只是读取一串数据。DataReader对象允许你获得从Command对象的SELECT语句得到的结果。考虑性能的因素，从DataReader返回的数据都是快速的且只是“向前”的数据流。这意味着你只能按照一定的顺序从数据流中取出数据。这对于速度来说是有好处的，但是如果你需要操作数据，更好的办法是使用DataSet。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:41:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"DataSet对象\rDataSet对象是数据在内存中的表示形式。它包括多个DataTable对象，而DataTable包含列和行，就象一个普通的数据库中的表。你甚至能够定义表之间的关系来创建主从关系（parent-child relationships）。DataSet是在特定的场景下使用――帮助管理内存中的数据并支持对数据的断开操作的。DataSet是被所有Data Providers使用的对象，因此它并不像Data Provider一样需要特别的前缀。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:42:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"DataAdapter类\r某些时候你使用的数据主要是只读的，并且你很少需要将其改变至底层的数据源。同样一些情况要求在内存中缓存数据，以此来减少并不改变的数据被数据库调用的次数。DataAdapter通过断开模型来帮助你方便的完成对以上情况的处理。当在一单批次的对数据库的读写操作的持续的改变返回至数据库的时候，DataAdapter 填充（fill）DataSet对象。DataAadapter包含对连接对象以及当对数据库进行读取或者写入的时候自动的打开或者关闭连接的引用。另外，DataAdapter包含对数据的SELECT、INSERT、UPDATE和DELETE操作的Command对象引用。你将为DataSet中的每一个Table都定义DataAadapter，它将为你照顾所有与数据库的连接。所有你将做的工作是告诉DataAdapter什么时候装载或者写入到数据库。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:43:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"DataTable类\rDataTable 是一个数据网格控件,理解成一张表就可以了。 DataTable的实例化以及添加列： DataTable dt = new DataTable(); dt.Columns.Add(\"ID\"); dt.Columns.Add(\"Name\"); DataRow dr = dt.NewRow(); object[] objs = { 1, \"Name\" }; dr.ItemArray = objs; dt.Rows.Add(dr); this.dataGridView1.DataSource = dt; ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:44:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"ADO.Net基础\r直接在项目中内嵌mdf文件的方式使用SQLServer数据库（新建→数据→基于服务的数据库）。mdf文件随着项目走，用起来方便，和在数据库服务器上创建数据库没什么区别，运行的时候会自动附加（Attach） 双击mdf文件会在“服务器资源管理器”中打开，管理方式和在Management Studio没有什么本质不同。要拷贝mdf文件需要关闭所有指向mdf文件的连接。 正式生产运行的时候附加到SQLServer上、修改连接字符串即可，除此之外没有任何的区别，在“数据库”节点上点右键“附加”；在数据库节点上→任务→分离就可以得到可以拷来拷去mdf文件。 用的时候要在控制台、WinForm项目中在Main函数最开始的位置加入备注中的代码。ASP.Net项目中不需要。 连接字符串：程序通过连接字符串 指定要连哪台服务器上的、哪个实例的哪个数据库、用什么用户名密码等。 项目内嵌mdf文件形式的连接字符串\"DataSource=.\\SQLEXPRESS;AttachDBFilename=|DataDirectory|\\Database1.mdf;Integrated Security=True;User Instance=True\"。“.\\SQLEXPRESS”表示“本机上的SQLEXPRESS实例”，如果数据库实例名不是SQLEXPRESS，则需要修改。“Database1.mdf”为mdf的文件名。 ADO.Net中通过SqlConnection类创建到SQLServer的连接，SqlConnection代表一个数据库连接，ADO.Net中的连接等资源都实现了IDisposable接口，可以使用using进行资源管理。执行备注中的代码如果成功了就ok。 using (SqlConnection conn = new SqlConnection(@\"Data Source=.\\SQLEXPRESS;AttachDBFilename=|DataDirectory|\\Database1.mdf;Integrated Security=True;User Instance=True\")) { conn.Open(); Console.WriteLine(\"连接成功！\"); } 增删改查 SqlCommand表示向服务器提交的一个命令（SQL语句等） , CommandText属性为要执行的SQL语句，ExecuteNonQuery方法执行一个非查询语句（Update、Insert、Delete等） using (SqlCommand cmd = conn.CreateCommand()) { cmd.CommandText = \"Insert into T_Users(UserName,Password) values('admin','888888')\"; cmd.ExecuteNonQuery(); } ExecuteNonQuery返回值是执行的影响行数 常犯错： string username='test'; .... cmd.CommandText = \"Insert into T_Users(UserName,Password) values(username,'888888')\"; ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:45:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"查询单个值\rSqlCommand的ExecuteScalar方法用于执行查询，并返回查询所返回的结果集中第一行的第一列，因为不能确定返回值的类型，所以返回值是object类型。 cmd.CommandText = \"select count(*) from T_Users\"; int i = Convert.ToInt32(cmd.ExecuteScalar()) cmd.CommandText = \"select getdate()\"; DateTime dt = Convert.ToDateTime(cmd.ExecuteScalar()); 得到自动增长字段的主键值，用@@identity(目前工作阶段任何资料表中所产生的最后一个识别值 )，用ExecuteScalar执行最方便 cmd.CommandText = “Insert into T_Users(UserName,Password) values(‘admin’,‘888888’); select @@identity;\"; int i = Convert.ToInt32(cmd.ExecuteScalar()); ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:46:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"查询多行值\r执行有多行结果集的用ExecuteReader SqlDataReader reader = cmd.ExecuteReader(); while (reader.Read()) { Console.WriteLine(reader.GetString(1)); } reader的GetString、GetInt32等方法只接受整数参数，也就是序号，用GetOrdinal方法根据列名动态得到序号 为什么用using。Close：关闭以后还能打开。 Dispose：直接销毁，不能再次使用。 using在出了作用域以后调用Dispose， SqlConnection、FileStream等的Dispose内部都会做这样的判断：判断有没有close，如果没有Close就先Close再Dispose。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:47:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"注入漏洞攻击\r登录判断：select * from T_Users where UserName=... and Password=...，将参数拼到SQL语句中。 构造恶意的Password：' or '1'='1 if (reader.Read()) { Console.WriteLine(\"登录成功\"); } else { Console.WriteLine(\"登录失败\"); } 防范注入漏洞攻击的方法：不使用SQL语句拼接，通过参数赋值 using (SqlCommand cmd = conn.CreateCommand()) { string password = \"' or '1'='1\"; cmd.CommandText = \"select * from T_Users where UserName='admin' and Password='\" + password+\"'\"; using (SqlDataReader reader = cmd.ExecuteReader()) { if (reader.Read()) { Console.WriteLine(\"登录成功\"); } else { Console.WriteLine(\"登录失败\"); } } } ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:48:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"查询参数\rSQL语句使用@UserName表示“此处用参数代替”，向SqlCommand的Parameters中添加参数 cmd.CommandText = \"select * from T_Users where UserName=@UserName and Password=@Password\"; cmd.Parameters.Add(new SqlParameter(\"UserName\",\"admin\")); cmd.Parameters.Add(new SqlParameter(\"Password\",password)); 参数在SQLServer内部不是简单的字符串替换，SQLServer直接用添加的值进行数据比较，因此不会有注入漏洞攻击。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:49:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"案例\rComboBox的显示值：Items.Add的参数是Object类型，也就是可以放任意数据类型的数据，可以设置DisplayMember属性设定显示的属性，通过SelectedItem属性取得到就是选择的条目对应的对象。例子。疑问：取出来的是Object，怎么能转换为对应的类型？变量名只是“标签”。显示的值和实际的对象不一样，在ASP.Net中也有相同的东西 创建一个ProvinceItem类，将数据填充在这个对象中添加到ComboBox中。 将连接字符串写在代码中的缺点：多次重复，违反了DRY（Don’t Repeat Yourself）原则；如果要修改连接字符串就要修改代码。将连接字符串写在App.Config中： 添加App.config文件（文件名不能改）：添加→新建项→常规→应用程序配置文件。App.config是.Net的通用配置文件，在ASP.Net中也能同样使用。 在App.config中添加connectionStrings段，添加一个add项，用name属性起一个名字（比如DbConnStr），connectionString属性指定连接字符串。 在“引用”节点上点右键“添加引用”，找到System.configuration。不是所有.Net中的类都能直接调用，类所在的Assembly要被添加到项目的引用中才可以。 ConfigurationManager.ConnectionStrings[\" DbConnStr “].ConnectionString得到连接字符串。 如何在部署的程序中修改配置。 \u003c?xml version=\"1.0\" encoding=\"utf-8\" ?\u003e \u003cconfiguration\u003e \u003cconnectionStrings\u003e \u003cadd name=\"conStr\" connectionString =\"server=.;database=SimpleArticle;Integrated Security=True;\"/\u003e \u003c/connectionStrings\u003e \u003c/configuration\u003e ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:50:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"多行查询\rSqlDataReader是连接相关的， SqlDataReader中的查询结果并不是放到程序中的，而是放在数据库服务器中，SqlDataReader只是相当于放了一个指针（游标），只能读取当前游标指向的行，一旦连接断开就不能再读取。这样做的好处就是无论查询结果有多少条，对程序占用的内存都几乎没有影响。 SqlDataReader对于小数据量的数据来说带来的只有麻烦，优点可以忽略不计。ADO.Net中提供了数据集的机制，将查询结果填充到本地内存中，这样连接断开、服务器断开都不影响数据的读取。 DataSet dataset = new DataSet(); SqlDataAdapter adapter = new SqlDataAdapter(cmd); adapter.Fill(dataset); SqlDataAdapter是DataSet和数据库之间沟通的桥梁。数据集DataSet包含若干表DataTable，DataTable包含若干行DataRow。foreach (DataRow row in dataset.Tables[0].Rows) row[\"Name\"]。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:51:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"SQL Helper\r封装一个SQLHelper类方便使用，提供ExecuteDataTable(string sql,params SqlParameter[] parameters)、ExecuteNonQuery(string sql,params SqlParameter[] parameters)、ExecuteScalar(string sql,params SqlParameter[] parameters)等方法。 网上有微软提供的最全的SQLHelper类，是Enterprise Library中的一部分。 sqlconnection在程序中一直保持它open可以吗？对于数据库来说，连接是非常宝贵的资源，一定要用完了就close、dispose。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:52:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"DataSet\r可以更新行row[“Name”] = “yzk”、删除行datatable.Rows.Remove()、新增行datatable. NewRow()。这一切都是修改的内存中的DataSet，没有修改数据库。 可以调用SqlDataAdapter的Update方法将对DataSet的修改提交到数据库，Update方法有很多重载方法，可以提交整个DataSet、DataTable或者若干DataRow。但是需要为SqlDataAdapter提供DeleteCommand、UpdateCommand、InsertCommand它才知道如何将对DataSet的修改提交到数据库，由于这几个Command要求的格式非常苛刻，因此开发人员自己写非常困难，可以用SqlCommandBuilder自动生成这几个Command，用法很简单：new SqlCommandBuilder(adapter)。查看生成的Command（没有直接赋值给SqlDataAdapter ，看SqlCommandBuilder的）。SqlCommandBuilder要求表必须有主键。 (*)通过DataRow的RowState可以获得行的状态（删除、修改、新增等）；调用DataSet的GetChanges()方法得到变化的结果集，降低传递的资源占用。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:53:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"可空数据\rC#中值类型（int、Guid、bool等）是不可以为空的，int i=null是错误的，因此int、bool等这些类型不能表示数据库中的“Null” 。因此C#提供了“可空类型”这种语法，只要在类型后加?就构成了可空的数据类型，比如int?、bool?，这样int? i=null 就可以了。解决数据库中int可以为null，而C#中int不能为null的问题。 判断可空类型是否为空，i==null或者i.HasValue；得到可空变量的值，int i1=(int)i.Value或者int i1=i.Value。 类型转换：不可空类型赋值给可空类型无需显式转换（一定成功），可空类型赋值给不可空类型则需显式转换（不一定成功）。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:54:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"弱类型DataSet的缺点\r只能通过列名引用，dataset.Tables[0].Rows[0][“Age”]，如果写错了列名编译时不会发现错误，因此开发时必须要记着列名。 int age = Convert.ToInt32(dataset.Rows[0][“Age”])，取到的字段的值是object类型，必须小心翼翼的进行类型转换，不仅麻烦，而且容易出错。 将DataSet传递给其他使用者，使用者很难识别出有哪些列可以供使用 运行时才能知道所有列名，数据绑定麻烦，无法使用Winform、ASP.Net的快速开发功能。 自己动手写强类型DataSet(类型化DataSet，TypedDataSet)，创建继承自DataSet的PersonDataSet类，封装出int? Age等属性和bool IsAgeNull等方法，向PersonDataSet中填充。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:55:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"VS自动生成强类型DataSet\r添加→新建项→数据集 将表从服务器资源管理器拖放到DataSet中。注意拖放过程是自动根据表结构生成强类型DataSet等类，没有把数据也拖过来，程序还是连的那个数据库，自动将数据库连接字符串写在了App.Config中。 代码中使用DataSet示例：CC_RecordTableAdapter adapter = new CC_RecordTableAdapter(); 如何得知Adapter的类名？选中DataSet中下半部分的Adapter，Name属性就是类名。需要右键点击类名→解析 取得所有的数据：adapter.GetData()，例子程序：遍历显示所有数据，i\u003cadapter.GetData().Count;adapter.GetData()[i].Age。 常见问题：类名敲不对，表名+TableAdapter，表名+DataTable，表名+Row，然后用“解析”来填充类名，别照着我的代码敲。 常见问题：类的内部定义的类要通过包含namespace的全名来引用，不能省略。类的内部定义的类就能避免同一个namespace下类不能重名的问题。 强类型DataSet其实就是一种代码生成器的实现机制（DataSetPersons.Designer.cs）， 调用的 ***TableAdapter等类都是VS自动生成的，可以看到的，不要手动改生成的类代码，改xsd即可。 GetData和Fill的区别。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:56:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"强类型强在哪\r像使用类的属性一样使用列名，dsPerson[0].Age，可以使用VS的自动提示功能，绝对不会写错列名，写错了编译通不过。 将强类型DataSet传递给其他人，使用者可以轻松确定有哪些列 int age = dsPerson[0].Age，列名的类型是明确的，避免类型转换的麻烦。 编译时就可以确定 名词：强类型DataSet（类型化DataSet），英文：Typed DataSet。 DataSet包含DataTable、DataTable包含DataRow，强类型DataSet同样如此。查看源代码看看VS帮我们做了什么 GetData返回是什么类型？每一行是什么类型？看类型定义即可得知。一般规律：表类型名：表名+DataTable，行类型名：表名+row，忘了也没关系：“转到定义”。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:57:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"更新DataSet\r调用Adapter的Update方法就可以将DataSet的改变保存到数据库。adapter.Update(datatable) 要调用Update方法更新必须设置数据库主键，后面的Delete也是如此。 常见错误：“当传递具有已修改行的 DataRow 集合时，更新要求有效的 UpdateCommand”，要为表设置主键。“谁都变了，唯有主键不会变”，程序要通过主键来定位要更新的行。忘了设主键怎么办？先到数据库中设置主键，然后在DataSet的对应DataTable上点右键，选择“配置”，在对话框中点击【完成】。好习惯：所有表都要设置主键！！！看看为什么会自动帮我们GetData、Update、Delete。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:58:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"其他问题\r插入新行，调用Insert方法。 增加字段怎么办？DataSet设计器中点【配置】，对话框中点【查询生成器】，勾选新增加的字段即可。删除字段同样如此。如果是高手也可以直接手改SQL语句。 要修改字段就要重新配置生成，这就是强类型DataSet的弱点，因此强类型DataSet不一定真的就是“强”，还是叫“类型化DataSet”(Typed DataSet)吧 常见错误：报错：数据为空。判断列的值为空的方法：Is**Null 为什么Select方法会填充、Update方法会更新，Insert方法会插入？没有多么神奇，看看Adapter的SelectCommand等属性，是那些SQL语句在起作用，如果有需要完全可以手工调整 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:59:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"增加新的SQL语句\r设计器的Adapter中点右键，选择“添加查询”→“使用SQL语句”，就可以添加多种类型的SQL语句。如果是“SELECT（返回行）”则SQL语句的列必须是对应DataSet类的父集合，生成两个方法：FillBy和GetBy，方法名根据查询语句的意义定，比如FillByAge，FillBy是将结果填充到现有DataSet，GetBy是将结果以DataSet方式返回，建议两个都生成，方便以后用。看看默认生成的GetData就明白了 GetDataById、IncAge “SELECT（返回单个值）”就是ExecuteScalar 对于增加的SQL语句在代码中是以方法的形式使用的。方法的参数类型、顺序就是VS猜测的，如果不正确或者需要调整只要选中对应的语句，然后在【属性】窗口中修改Parameters属性即可 增加新的SQL语句本质论，探寻源码：不能并发调用。 像使用普通类的方法一样使用Adapter。SQL语句不用再写在界面代码中。这就是一种数据访问层（DAL：Data Access Layer） ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:60:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"强类型DataSet其他\r通过查看生成的源代码的值，生成的强类型TableAdapter默认每次调用方法都是打开连接、执行、关闭连接，而如果操作之前连接已经打开则不会自动帮我们连接、关闭，因此如果想批量操作提高效率可以操作之前先自己Open，操作完毕再Close。经测试：插入三千条数据，不优化用了45秒，优化后只用一两秒。回答面试问题：如何优化访问数据库的效率。 常见错误：DataSet ds = new DataSet()；ds = GetData();变量名和对象。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:61:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数据绑定\rDataGridView绑定。拖放TableAdapter、DataSet、bindingSource，将bindingSource的DataSource设定为DataSet，设定DataMember属性，然后DataGridView绑定到bindingSource。在Load的时候调用TableAdapter的Fill方法将数据填充到DataSet。绑定：双方能同步感知对方的变化。 DataGridView绑定到BindingSource， BindingSource绑定到DataSet，所以DataGridView显示的是DataSet中的数据。 修改列标题。 将保存提交到数据库，在DataGridView中修改会同步反应到DataSet中，这样只要将DataSet Update到数据库就是“保存修改”，Update，保存前要dataGridView1.EndEdit(); dataGridView1.CommitEdit(DataGridViewDataErrorContexts.Commit);bindingsource1.EndEdit()已提交正在编辑的修改。 删除当前选择行：cCRecordBindingSource.RemoveCurrent()，只是删除DataSet中的数据，需要Update才能提交到数据库。 绑定单独控件，在控件属性的DataBindings中将属性绑定到BindingSource 的指定字段，这样控件中的值就会显示这个字段的值了 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:62:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"补充\r拖过来的控件是什么？控件就是控件类的对象，Winform中从Component类继承的类都可以拖到窗口中以控件的形式出来，本质上和new出来的对象没区别。控件的id就是变量名。 新建的强类型DataSet只有“生成”以后才会在工具箱中出现 并不是控件的所有属性都能绑定，只有显示在DataBindings节点下的属性才能绑定（*）只有标记了[Bindable(true)]的属性才能绑定。 只有移开焦点才会同步，并不是实时同步。 刷新查询窗口中的数据“执行SQL” BindingSource是做什么的？维持当前项。这就是为什么详细控件和DataGridView会联动。试试控件绑定到不同的BindingSource。 Adapter的作用是负责DataSet和数据库之间的数据传递。 绑定到ComboBox。给Person增加一个TypeId字段（表示是黄种人、白种人、黑种人还是其他人种）。ComboBox的绑定分为显示数据项的绑定、选中值的绑定两个，DataSource属性设定要数据项绑定的数据源，DisplayMember属性为显示的属性、ValueMember为值（通过SelectedValue取得）的属性；然后绑定SelectedValue属性到表的字段。 DataGridView中的ComboBox列：设定列的ColumnType为DataGridViewComboBoxColumn为，然后其他绑定和普通ComboBox一样，由于BindingSource是维持当前项，所以记住“专BindingSource专用” ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:63:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"Web","content":"CSS（层叠样式表）是用来美化页面用的，可以对页面元素进行更精细的设置，样式主要描述元素的字体颜色、背景颜色、边框等。 CSS主要有元素内联、页面嵌入和外部引用三种使用方式。CSS是描述元素的皮肤！ 元素内联，直接将样式写入元素的style属性中，\u003cinput type=\"text\" readonly=\"readonly\" style=\"background-color: #FF00FF\" /\u003e，**style=“color:Red;background-color: #FF00FF”**为元素内联，适用于样式没有可复用性的场合。 页面嵌入：在head中加入 \u003cstyle type=\"text/css\"\u003e input{border-color:Yellow;color:Red;} \u003c/style\u003e 表示页面中所有input都是采用指定的样式。适合于样式复用，减小页面体积 \u003cstyle type=\"text/css\"\u003e P { color:Red; font-weight:bold; } \u003c/style\u003e 所有的P标签都变成红色字体，加粗。 外部引用，将css内容写入css后缀的文件 div{background:yellow} 然后在页面中引用，在head中加入 \u003clink type=\"text/css\" rel=\"Stylesheet\" href=\"s1.css\" /\u003e 适合于多个页面共享css。 更变原则：就近原则 ","date":"2018-10-22","objectID":"/2018/10/web2-css/:0:0","tags":["Web","css"],"title":"自学 CSS","uri":"/2018/10/web2-css/"},{"categories":"Web","content":"常见样式\rcss计量单位：css中表示宽度、距离时有多种计量单位：px（像素）、30%（百分比）、em（相对单位）等。width:20px。 background-color:Red;背景颜色；color：文本颜色 复合样式 background border border-style:solid;边框风格，实线solid（默认是没有），还有dotted(点)等值；border-color：边框颜色；border-width：边框宽度(默认是0)。例子：style=\"border-color:Red;border-width:1px;border-style:dotted;\" display：元素是否显示，可选值none（不显示,不占地儿）、block （显示为块级元素，此元素前后会带有换行符。）、inline（显示为内联元素，元素前后没有换行符 ）等。 cursor，鼠标在元素上时显示的光标图标，可选值：cursor（默认光标）、pointer（超链接上的手）、text（输入Bean）、wait（忙沙漏）、help（帮助）等。还可以通过cursor:url(dinosau2.ani)使用ani、cur格式的自定义光标图片。 LI不显示圆点：LIST-STYLE-TYPE: none;一般设在li或者ul上 应用：图片：不显示边框，见备注 图片：不显示边框 IMG { border:0px;BORDER-BOTTOM: medium none; BORDER-LEFT: medium none; BORDER-TOP: medium none; BORDER-RIGHT: medium none } ","date":"2018-10-22","objectID":"/2018/10/web2-css/:1:0","tags":["Web","css"],"title":"自学 CSS","uri":"/2018/10/web2-css/"},{"categories":"Web","content":"例子 外部引用\r* { /* 所有的元素 */ margin:0; padding:0; color:Red; } body { background:red url(/images/back_image.GIF); } span { /* block 块 display:block;*/ cursor:pointer; color:Blue; text-decoration:underline; } input { color:Green; } li { /* 去掉ul前面的黑点 */ list-style-type:none; } ","date":"2018-10-22","objectID":"/2018/10/web2-css/:1:1","tags":["Web","css"],"title":"自学 CSS","uri":"/2018/10/web2-css/"},{"categories":"Web","content":"样式选择器\r对于非元素内联的样式需要定义样式选择器，通俗的说就是这个样式适合于哪些元素，三种：标签选择器、class选择器和id选择器。 标签选择器 input{border-color:Yellow;color:Red;}，对于指定的标签采用统一的样式 class选择器，以定义一个命名的样式，然后在用到它的时候设定元素的class属性为样式的名称，还可以同时设定多个class，名称之间加空格 .d1 { color:Red; width:100px; } .d2 { color:Blue; width:200px; } .d3 { color:Green; width:300px; } \u003cdiv class=\"d1\"\u003e 123123123 \u003c/div\u003e \u003cdiv class=\"d2\"\u003e abc \u003c/div\u003e \u003cdiv class=\"d3\"\u003e 啊打发 \u003c/div\u003e 样式名称开头加“.” .warning{background:Yellow;} .highlight{font-size:xx-large;cursor:help;} \u003ctable\u003e \u003ctr\u003e \u003ctd class=\"highlight\"\u003eaaa\u003c/td\u003e \u003ctd class=\"warning\"\u003ebb\u003c/td\u003e \u003ctd class=\"highlight warning\"\u003eccc\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e 标签+类选择器:通过指定标签来确定不同的类适用范围 label.name { background-color:Gray; } input.name { color:Blue; } \u003clabel for=\"name\" class=\"name\"\u003e用户名：\u003c/label\u003e \u003cinput class=\"name\" id=\"name\" type=\"text\" value=\"\" /\u003e id选择器：与类选择器不同的地方就是.改成了#。 #wrap { border:solid 1px blue; width:300px; height:300px; } \u003cdiv id=\"wrap\"\u003e main \u003c/div\u003e 包含选择器：设置div中strong标签的格式，div中所有strong div strong { color:Red; } \u003cstrong\u003e测试\u003c/strong\u003e \u003cdiv\u003e \u003cstrong\u003e这是左边栏\u003c/strong\u003e left \u003c/div\u003e 后代选择器：直接属于div的strong才会属于这个样式。 div strong { color:Red; } \u003cdiv\u003e \u003cstrong\u003e这是左边栏\u003c/strong\u003e left \u003c/div\u003e 组合选择器 ：多个标签一个样式，组合选择器可以使用类选择器.h3,.p,.span {} h3,p,span { color:Yellow; } \u003ch3\u003e标题3\u003c/h3\u003e \u003cp\u003e这是段落\u003c/p\u003e \u003cspan\u003e这是span\u003c/span\u003e 伪选择器：超链接使用 A:visited：超链接点击过的样式；A:visited {TEXT-DECORATION: none}下划线 A:active：选中超链接时的样式；A:active {TEXT-DECORATION: none} A:link：超链接未被访问时的状态；A:link {TEXT-DECORATION: none} A:hover：鼠标移到超链接时的状态。A:hover {TEXT-DECORATION: underline} a:visited { color:Gray; } a:link { color:Red; } a:hover { color:Black; font-style:italic; } a:active { color:Yellow; } \u003ca href=\"http://www.itcast.cn\"\u003e传智播客\u003c/a\u003e \u003ca href=\"http://www.csdn.com\"\u003ecsdn\u003c/a\u003e \u003ca href=\"http://www.cnbeta.com\"\u003ecnbeta\u003c/a\u003e \u003ca href=\"http://www.123.com\"\u003e123\u003c/a\u003e ","date":"2018-10-22","objectID":"/2018/10/web2-css/:1:2","tags":["Web","css"],"title":"自学 CSS","uri":"/2018/10/web2-css/"},{"categories":"Web","content":"布局\r布局的分类：表格布局，框架布局，div+css布局 表格布局：表格套表格 ，代码多，table显示很慢，一块块的显示就比较麻烦，显示圆角就比较麻烦 框架布局：多个页面来显示： Frameset 框架页里不能有body \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003c/head\u003e \u003cframeset rows=\"30%,*\"\u003e \u003cframe name=\"top\" src=\"top.htm\" noresize=\"noresize\"/\u003e \u003cframeset cols=\"20%,*\"\u003e \u003cframe name=\"left\" src=\"left.htm\" noresize=\"noresize\"/\u003e \u003cframe name=\"main\" src=\"main.htm\" noresize=\"noresize\"/\u003e \u003c/frameset\u003e \u003c/frameset\u003e left.html \u003cbody\u003e \u003cul\u003e \u003cli\u003e\u003ca href=\"1-注册页面.htm\" target=\"main\"\u003e注册\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"5-选择器.htm\" target=\"if\"\u003e登陆\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/body\u003e iframe 嵌入页面 \u003ciframe src=\"iframe.htm\" name=\"0\" width=\"0\" height=\"0\"\u003e\u003c/iframe\u003e \u003cbody\u003e adsfasdf asdf \u003ciframe src=\"1-注册页面.htm\" width=\"0\" height=\"0\"\u003e\u003c/iframe\u003e adsf \u003c/body\u003e main.html iframe：在一个页面中嵌入一个页面 \u003cbody\u003e \u003ciframe src=\"1-注册页面.htm\" width=\"500px\" height=\"200px\" name=\"if\"\u003e\u003c/iframe\u003e adsf \u003c/body\u003e div+css布局： 网页布局就是“这块内容显示在左边，那两块内容并排显示，那块内容漂浮在页面上”。 不要使用\u003ctable\u003e进行布局，因为：table可能会在所有tr、td加载完成以后才显示，所以加载完成之前界面是一片空白；用table布局会将布局方式写在html中，违反了“语义性”原则；用table会影响搜索引擎的抓取，不利于SEO。因此Table用来表达真是表格状数据的东西，布局用Div(层)+Css来做,Div用来圈定元素，CSS用来定义元素的位置。 Div+CSS就是将要布局的内容用\u003cdiv\u003e切成块，然后使用css描述每个块的大小、位置等。 布局最重要的一个属性就是float， \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003clink href=\"css/style.css\" rel=\"stylesheet\" type=\"text/css\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"wrap\"\u003e \u003cdiv id=\"head\"\u003e \u003cdiv id=\"logo\"\u003e \u003cimg src=\"images/back_image.GIF\" width=\"100px\" height=\"50px\" /\u003e\u003c/div\u003e \u003cdiv id=\"menu\"\u003e \u003cul\u003e \u003cli\u003e首页\u003c/li\u003e \u003cli\u003e播客\u003c/li\u003e \u003cli\u003e相册\u003c/li\u003e \u003cli\u003e关于\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv id=\"body\"\u003e \u003cdiv id=\"nav\"\u003e \u003cul\u003e \u003cli\u003e好好学习\u003c/li\u003e \u003cli\u003e天天向上\u003c/li\u003e \u003cli\u003e不要睡觉\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cdiv id=\"content\"\u003e内容\u003c/div\u003e \u003c/div\u003e \u003cdiv id=\"footer\"\u003e版权\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e * { margin:0px; padding:0px; } body { background-color:Gray; } #wrap { width:98%; height:500px; margin:0px auto; } #head { height:150px; background-color:Red; } #head #menu { margin:80px auto 0px auto; padding-left:200px; } #head #menu ul { width:400px; } #head #menu li { float:left; width:100px; list-style-type:none; } #body { height:800px; background-color:White; } #body #nav { /* 强制英文换行 word-break:break-all; */ /* 溢出后显示滚动条 */ overflow:auto; background-color:Blue; width:200px; float:left; } #body #nav ul { padding-top:100px; } #body #nav li { list-style-type:none; height:30px; padding-left:30px; } #body #content { background-color:Green; } ","date":"2018-10-22","objectID":"/2018/10/web2-css/:2:0","tags":["Web","css"],"title":"自学 CSS","uri":"/2018/10/web2-css/"},{"categories":"Web","content":"HTML(HyperText Markup Language)：描述网页长什么样子、有什么内容的一个文本。查看网页的描述内容（HTML）的方式：使用IE浏览器的话，在网页上点击右键，选择“查看源文件”。 ","date":"2018-10-17","objectID":"/2018/10/web1-html/:0:0","tags":["Web","Html"],"title":"自学 HTML","uri":"/2018/10/web1-html/"},{"categories":"Web","content":"主要构架\r\u003chtml\u003e\r\u003chead\u003e\r\u003ctitle\u003e我的第一个网页\u003c/title\u003e\r\u003c/head\u003e\r\u003cbody bgcolor=\"red\" background=\"bg.jpg\"\u003e\rHello world\r\u003c/body\u003e\r\u003c/html\u003e\r所有内容都在\u003chtml\u003e\u003c/html\u003e标签之内； \u003chead\u003e\u003c/head\u003e内放的是头部信息，是对页面的描述，不会直接显示在页面中，\u003chead\u003e内的\u003ctitle\u003e中设置的是页面的标题，\u003ctitle\u003e只能放在\u003chead\u003e中； \u003cbody\u003e是页面的主体，大部分显示内容都定义在这里； \u003cmeta\u003e标签，\u003cmeta\u003e有指定name和指定http-equiv两种用法，\u003cmeta name=\"名字\" content=\"值\" /\u003e、\u003cmeta http-equiv=\"名字\" content=\"值\" /\u003e两种用法 \u003cmeta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\" /\u003e指定网页编码 \u003cmeta http-equiv=\"Refresh\" content=\"3\" /\u003e 三秒钟后刷新此网页 \u003cmeta http-equiv=\"Refresh\" content=\"3;url=http://www.rupeng.com\" /\u003e 三秒钟后重定向到新网页。发帖成功后提示“发帖成功，即将转向帖子查看页面” \u003cmeta http-equiv=\"Cache-Control\" content=\"no-cache\" /\u003e 禁止浏览器缓存页面 ","date":"2018-10-17","objectID":"/2018/10/web1-html/:1:0","tags":["Web","Html"],"title":"自学 HTML","uri":"/2018/10/web1-html/"},{"categories":"Web","content":"基本语法\r\u003ch\u003e：标签，HTML定义了\u003ch1\u003e\u003c/h1\u003e到\u003ch6\u003e\u003c/h6\u003e六个h标签，分别表示不同大小的字体。 \u003cbr\u003e：回车 \u003cp\u003e：分段。\u003cp\u003e前后会有比较大的空白，而\u003cbr\u003e则没有。 \u003ccenter\u003e这是居中\u003c/center\u003e居中显示 \u003cb\u003e粗体\u003c/b\u003e：粗体 \u003ci\u003e斜体\u003c/i\u003e：斜体 \u003cfont\u003e\u003c/font\u003e：字体标签，\u003cfont color=\"red\"\u003e红色\u003c/font\u003e \u003cfont size=\"30\" color=\"red\"\u003e红色\u003c/font\u003e 特殊字符：\u0026lt;（小于号，less than）；\u0026gt;（大于号，greater than）；\u0026nbsp;（空格，no-break space） \u003chr\u003e： 横线 color size width align=left,center,right \u003cpre\u003e：预格式化 保持本色 \u003cbody bgcolor=\"#006699\"\u003e背景颜色 \u003ca href=\"http://www.rupeng.com\"\u003e如鹏网\u003c/a\u003e超链接 \u003ca href=\"http://www.rupeng.com\"\u003e\u003cimg src=\"http://www.rupeng.com/forum/templates/uchome/images/logo.gif\"/\u003e\u003c/a\u003e镶嵌图片； “/”表示网站根目录，“../”表示父目录，“../../”表示父目录的父目录 将\u003ca\u003e的target属性设定为\"_blank\"就可以在新窗口中打开超链接。 锚记：用name属性为\u003ca\u003e 起名字：\u003ca name=\"Last\"\u003e这里是最后\u003c/a\u003e。这样可以通过\u003ca href=\"#Last\"\u003e转到平台\u003c/a\u003e来跳转到超链接的部分。去往评论、回到正文 \u003cimg src=\"a.jpg\"/\u003e注意图片是链接的，不是插入的，所以如果Src指向的文件不存在了，就看不了了。 alt： 图片无法显示时的显示文本，鼠标方式去也会有悬浮提示“点击查看大图” border属性指定边框，border=“0\"不显示边框 width、height属性指定图片的显示大小，如果不指定则是图片的原始大小 不要以为把bmp后缀改为jpg就是改文件格式了 如果网页上要显示小图（比如缩略图），不要仅仅是把大图设定一下width、height来缩小，因为仍然会下载大图，会使得加载速度很慢。 列表：\u003cul\u003e\u003cli\u003e灌水区\u003c/li\u003e\u003cli\u003e版务区\u003c/li\u003e\u003cli\u003e原创贴图\u003c/li\u003e\u003c/ul\u003e。无序列表。 有序的列表\u003col\u003e\u003c/ol\u003e 表格：\u003ctable\u003e\u003c/table\u003e为表格，在内部通过\u003ctr\u003e创建行，\u003ctr\u003e内部通过\u003ctd\u003e 创建单元格。可以将table的border属性设为0来隐藏表格线。 填充、间距Cellpadding内容和表格边线之间的距离 cellspacing单元格之间的间距s \u003ctr\u003e的属性：align，水平对齐，可选值left、right、center；valign，垂直对齐，可选值top、middle、bottom。 \u003ctd\u003e也有align和valign。\u003ctr align=\"right\"\u003e\u003ctd\u003etom\u003c/td\u003e\u003ctd align=\"left\"\u003e20\u003c/td\u003e\u003ctd\u003e男\u003c/td\u003e\u003c/tr\u003e：子标签默认继承父标签的属性，如果自己单独指定了属性，则会覆盖父标签的属性。 rowspan、colspan进行单元格的合并 表头的td可以用th代替，这样就会表头粗体、居中显示 表单：\u003cform\u003e标签为表单标签。如果要把数据提交到服务器，则需要将\u003cinput\u003e、\u003ctextarea\u003e、\u003cselect\u003e等表单元素放到form中 \u003cinput\u003e是主要的表单元素，type的可选值：submit（提交按钮）、button（普通按钮）、checkbox（复选框）、file（文件选择框）、hidden（隐藏字段）、image（图片按钮）、password（密码框）、radio（单选按钮）、reset（重置按钮）、text（文本框）。\u003cinput type=\"file\" /\u003e submit：点击submit按钮表单就会被提交给服务器，中文IE下默认按钮文本为“提交查询”，可以设置value属性修改按钮的显示文本 text：size属性为宽度，value为值，maxlength为可以输入的最大长度，readonly只读。\u003cinput type=\"text\" readonly/\u003e（只写属性名，不写属性值）或者\u003cinput type=\"text\" readonly=\"readonly\" /\u003e checkbox：checked属性表示是否被选中，\u003cinput type=\"checkbox\" checked /\u003e或者\u003cinput type=\"checkbox\" checked=\"checked\" /\u003e(推荐)checked、readonly等这种只有一个可选值的属性都可以省略属性值。 radio：相同name属性的为一组，不同radio设定不同的value值，这样通过取指定name的值就可以知道谁被选中了，不用单独的判断。 file：使用file，则form的enctype必须设置为multipart、form-data、form method属性为POST（*），get。get：少量数据，post：大量数据。\u003cform action=\"Default.aspx\" method=\"post\"\u003e\u003c/form\u003e image：使用src属性指定图片的地址，用来实现美化的“登录按钮”。 Reset:重置 \u003cselect\u003e:用来创建类似于WinForm中的ComboBox或者ListBox 如果size属性大于1就是ListBox（size的值为显示出来的列表数量），否则就是ComboBox。 \u003cselect multiple\u003e或者\u003cselect multiple=\"multiple\"\u003e（推荐），那么就是可以多选的ListBox。 select中的项是\u003coption\u003e，\u003coption\u003e北京\u003c/option\u003e还可以设定项的值\u003coption value=\"1\"\u003e北京\u003c/option\u003e。 将一个option设置为选中：\u003coption selected\u003e333\u003c/option\u003e或者\u003coption selected=\"selected\"\u003e333\u003c/option\u003e(推荐)就可以将这个项设定为选择项 如何实现“不选择”，添加一个\u003coption value=\"-1\"\u003e--不选择--\u003coption\u003e，然后编程判断select选中的值如果是-1就认为是不选择。 select分组选项，可以使用optgroup对数据进行分组，分组本身不会被选择，无论对于下拉列表还是列表框都适用。备注 \u003ctextarea\u003e多行文本（也是表单元素）：\u003ctextarea\u003e文本\u003c/textarea\u003e，cols、rows属性表示行数和列数。 \u003clabel\u003e：在\u003cinput type=\"text\"\u003e前可以写普通的文本来修饰，但是单击修饰文本的时候input并不会得到焦点，而用label则可以，for属性指定要修饰的控件的id，\u003clabel for=\"txt1\" \u003easdfad\u003c/label\u003e 为被修饰的控件设置一个唯一的id \u003clabel for=\"ma\"\u003e婚否\u003c/label\u003e \u003cinput id=\"ma\" type=\"checkbox\" /\u003e fieldset：GroupBox效果，将控件划分一个区域，看起来更规整 \u003cfieldset\u003e \u003clegend\u003e常用\u003c/legend\u003e \u003cinput type=\"text\" /\u003e \u003c/fieldset\u003e 滚动文字 \u003cmarquee\u003e scrolldelay控制速度 播放声音、显示flash， \u003cobject classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\" codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,29,0\" width=\"760\" height=\"700\"\r\u003cparam name=\"movie\" value=\"light-bot-2205.swf\" /\r\u003cparam name=\"quality\" value=\"high\" /\r\u003cembed src=\"light-bot-2205.swf\" quality=\"high\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" type=\"application/x-shockwave-flash\" width=\"760\" height=\"700\"\u003e\u003c/embed\r\u003c/object\u003e\r调用wmp的插件\u003cembed src=\"coder.mp3\" loop=true autostart=true name=bgss width=\"460\" height=\"68\"\u003e 只能播放wav和mid格式，只支持ie div：层\u003cdiv\u003e\u003c/div\u003e将内容放到层中，就以将这些内容当成一个整体进行处理，比如整体隐藏、整体移动等。div非常强大和常用。类似于WinForm的Panel。 span:div是将内容放到一个矩形的区块中，会影响布局，而span只是把一段内容定义成一个整体进行操作，但不影响布局、显示。 ","date":"2018-10-17","objectID":"/2018/10/web1-html/:2:0","tags":["Web","Html"],"title":"自学 HTML","uri":"/2018/10/web1-html/"},{"categories":"Web","content":"备注\rxml：描述存的什么数据 XHTML:可扩展超文本置标语言（eXtensible HyperText Markup Language，XHTML） DHTML：动态HTML； 格式标签：\u003cp\u003e\u003c/p\u003e创建段落；\u003cbr /\u003e回车，也可以写成\u003cbr\u003e，在HTML中有一些标签可以不关闭，\u003cbr\u003e就是一个，这是和XML不同的地方（常考），但是为了遵循XHTML规范，推荐像XML一样严格关闭。\u003cbr/\u003e\u003cimg src=\"1.gif\"/\u003e 属性值：HTML中属性值即可以用单引号括起来、也可以用双引号括起来、甚至不用引号都可以（不推荐），单双要配对。 注释：HTML使用和XML一样的来做注释。 ","date":"2018-10-17","objectID":"/2018/10/web1-html/:3:0","tags":["Web","Html"],"title":"自学 HTML","uri":"/2018/10/web1-html/"},{"categories":"设计模式","content":"上一章中对薪水支付案例的用例和类做了详细的阐述，在本篇会介绍薪水支付案例包的划分和数据库，UI的设计。 ","date":"2018-10-10","objectID":"/2018/10/designpattern3-case2/:0:0","tags":["敏捷软件开发原则模式与实践","薪水支付"],"title":"敏捷软件开发原则模式与实践 薪水支付","uri":"/2018/10/designpattern3-case2/"},{"categories":"设计模式","content":"包的划分\r一个错误包的划分 为什么这个包是错误的： 如果对classifications更改就要影响payrolldatabase更改，还会迫使transactions更改，tansactions重新发布和编译测试就是不负责的，transactions没有共享封闭性，每个类都有自己变化的敏感，所以发布的频率非常高，是不合理的。 调整一下： 将具体类和具体类打包，抽象类和抽象类打包，交互类单独打包。这已经是一个比较好打包设计了。 类的组件应该要符合共同重用原则，payrolldamain中的类没有形成最小的可重用单元，transaction类不必和组件中的其他类一起重用，可以把transaction迁移到transactionapplication类中 这样的划分太精细了，是否有这样的必要需要整体来看。 最终包的结构： ","date":"2018-10-10","objectID":"/2018/10/designpattern3-case2/:1:0","tags":["敏捷软件开发原则模式与实践","薪水支付"],"title":"敏捷软件开发原则模式与实践 薪水支付","uri":"/2018/10/designpattern3-case2/"},{"categories":"设计模式","content":"数据库的设计\remplogee是核心 完成这个设计需要进行重构： 提取出payrolldatabase接口， public interface PayrollDatabase { void AddEmployee(Employee employee); Employee GetEmployee(int id); void DeleteEmployee(int id); void AddUnionMember(int id, Employee e); Employee GetUnionMember(int id); void RemoveUnionMember(int memberId); ArrayList GetAllEmployeeIds(); IList GetAllEmployees(); } 内存表实例： public class InMemoryPayrollDatabase : PayrollDatabase { private static Hashtable employees = new Hashtable(); private static Hashtable unionMembers = new Hashtable(); public void AddEmployee(Employee employee) { employees[employee.EmpId] = employee; } // etc... public Employee GetEmployee(int id) { return employees[id] as Employee; } public void DeleteEmployee(int id) { employees.Remove(id); } public void AddUnionMember(int id, Employee e) { unionMembers[id] = e; } public Employee GetUnionMember(int id) { return unionMembers[id] as Employee; } public void RemoveUnionMember(int memberId) { unionMembers.Remove(memberId); } public ArrayList GetAllEmployeeIds() { return new ArrayList(employees.Keys); } public IList GetAllEmployees() { return new ArrayList(employees.Values); } public void Clear() { employees.Clear(); unionMembers.Clear(); } } 数据库 public class SqlPayrollDatabase : PayrollDatabase { private SqlConnection connection; public SqlPayrollDatabase() { connection = new SqlConnection(\"Initial Catalog=Payroll;Data Source=localhost;user id=sa;password=abc\"); connection.Open(); } ~SqlPayrollDatabase() { connection.Close(); } public void AddEmployee(Employee employee) { //增加员工策略 SaveEmployeeOperation operation = new SaveEmployeeOperation(employee, connection); operation.Execute(); } public Employee GetEmployee(int id) { //数据库事务 LoadEmployeeOperation loadOperation = new LoadEmployeeOperation(id, connection); loadOperation.Execute(); return loadOperation.Employee; } public void DeleteEmployee(int id) { throw new NotImplementedException(); } public void AddUnionMember(int id, Employee e) { throw new NotImplementedException(); } public Employee GetUnionMember(int id) { throw new NotImplementedException(); } public void RemoveUnionMember(int memberId) { throw new NotImplementedException(); } public ArrayList GetAllEmployeeIds() { throw new NotImplementedException(); } public IList GetAllEmployees() { throw new NotImplementedException(); } } 如果插入雇佣记录成功，但是支付记录失败，为了解决这个问题而使用事务的方式。 public class SaveEmployeeOperation { private readonly Employee employee; private readonly SqlConnection connection; private string methodCode; private string classificationCode; private SqlCommand insertPaymentMethodCommand; private SqlCommand insertEmployeeCommand; private SqlCommand insertClassificationCommand; public SaveEmployeeOperation(Employee employee, SqlConnection connection) { this.employee = employee; this.connection = connection; } public void Execute() { PrepareToSavePaymentMethod(employee); PrepareToSaveClassification(employee); PrepareToSaveEmployee(employee); SqlTransaction transaction = connection.BeginTransaction(\"Save Employee\"); try { ExecuteCommand(insertEmployeeCommand, transaction); ExecuteCommand(insertPaymentMethodCommand, transaction); ExecuteCommand(insertClassificationCommand, transaction); transaction.Commit(); } catch(Exception e) { transaction.Rollback(); throw e; } } private void ExecuteCommand(SqlCommand command, SqlTransaction transaction) { if(command != null) { command.Connection = connection; command.Transaction = transaction; command.ExecuteNonQuery(); } } private void PrepareToSaveEmployee(Employee employee) { string sql = \"insert into Employee values (\" + \"@EmpId, @Name, @Address, @ScheduleType, \" + \"@PaymentMethodType, @PaymentClassificationType)\"; insertEmployeeCommand = new SqlCommand(sql); this.insertEmployeeCommand.Parameters.Add(\"@EmpId\", employee.EmpId); this.insertEmployeeCommand.Parameters.Add(\"@Name\", employee.Name); this.insertEmployeeCommand.Parameters.Add(\"@Address\", employee.Address); this.insertEmployeeCommand.Parameters.Add(\"@ScheduleType\", Schedu","date":"2018-10-10","objectID":"/2018/10/designpattern3-case2/:2:0","tags":["敏捷软件开发原则模式与实践","薪水支付"],"title":"敏捷软件开发原则模式与实践 薪水支付","uri":"/2018/10/designpattern3-case2/"},{"categories":"设计模式","content":"界面设计\r界面设计时最好使得业务行为和UI分离，这里使用model view presenter模式（MVP） model：实体层和数据库交互 view：界面层 presenter：业务处理层 MVP的作用是解耦界面、业务和实体的关系 在presenter中主动使用view，界面的形态都是由presenter去控制，就是在presenter中去注册view事件，当用户触发事件时，这个事件会通过view传递到presenter中，并通过presenter调用model数据方法，最后presenter 调用引用的view实例去改变界面的形态。 public class AddEmployeePresenter { private TransactionContainer transactionContainer; private AddEmployeeView view; private PayrollDatabase database; private int empId; private string name; private string address; private bool isHourly; private double hourlyRate; private bool isSalary; private double salary; private bool isCommission; private double commissionSalary; private double commission; public AddEmployeePresenter(AddEmployeeView view, TransactionContainer container, PayrollDatabase database) { this.view = view; this.transactionContainer = container; this.database = database; } public int EmpId { get { return empId; } set { empId = value; UpdateView(); } } public string Name { get { return name; } set { name = value; UpdateView(); } } public string Address { get { return address; } set { address = value; UpdateView(); } } public bool IsHourly { get { return isHourly; } set { isHourly = value; UpdateView(); } } public double HourlyRate { get { return hourlyRate; } set { hourlyRate = value; UpdateView(); } } public bool IsSalary { get { return isSalary; } set { isSalary = value; UpdateView(); } } public double Salary { get { return salary; } set { salary = value; UpdateView(); } } public bool IsCommission { get { return isCommission; } set { isCommission = value; UpdateView(); } } public double CommissionSalary { get { return commissionSalary; } set { commissionSalary = value; UpdateView(); } } public double Commission { get { return commission; } set { commission = value; UpdateView(); } } private void UpdateView() { if(AllInformationIsCollected()) view.SubmitEnabled = true; else view.SubmitEnabled = false; } public bool AllInformationIsCollected() { bool result = true; result \u0026= empId \u003e 0; result \u0026= name != null \u0026\u0026 name.Length \u003e 0; result \u0026= address != null \u0026\u0026 address.Length \u003e 0; result \u0026= isHourly || isSalary || isCommission; if(isHourly) result \u0026= hourlyRate \u003e 0; else if(isSalary) result \u0026= salary \u003e 0; else if(isCommission) { result \u0026= commission \u003e 0; result \u0026= commissionSalary \u003e 0; } return result; } public TransactionContainer TransactionContainer { get { return transactionContainer; } } public virtual void AddEmployee() { transactionContainer.Add(CreateTransaction()); } public Transaction CreateTransaction() { if(isHourly) return new AddHourlyEmployee( empId, name, address, hourlyRate, database); else if(isSalary) return new AddSalariedEmployee( empId, name, address, salary, database); else return new AddCommissionedEmployee( empId, name, address, commissionSalary, commission, database); } } public interface ViewLoader { void LoadPayrollView(); void LoadAddEmployeeView( TransactionContainer transactionContainer); } public class WindowViewLoader : ViewLoader { private readonly PayrollDatabase database; private Form lastLoadedView; public WindowViewLoader(PayrollDatabase database) { this.database = database; } public void LoadPayrollView() { PayrollWindow view = new PayrollWindow(); PayrollPresenter presenter = new PayrollPresenter(database, this); view.Presenter = presenter; presenter.View = view; // 相互关联 LoadView(view); } public void LoadAddEmployeeView( TransactionContainer transactionContainer) { AddEmployeeWindow view = new AddEmployeeWindow(); AddEmployeePresenter presenter = new AddEmployeePresenter(view, transactionContainer, database); view.Presenter = presenter; LoadView(view); } private void LoadView(Form view) { view.Show(); lastLoadedView = view; } /// \u003csummary\u003e /// 最新的form /// \u003c/summary\u003e public Form LastLoadedView { get { return lastLoadedView; } } } public class PayrollMain { public static void Main(string[] args) { PayrollDatabase database = new InMemoryPayrollDatabase(); WindowViewLoader viewLoader = new WindowViewLoader(database);","date":"2018-10-10","objectID":"/2018/10/designpattern3-case2/:3:0","tags":["敏捷软件开发原则模式与实践","薪水支付"],"title":"敏捷软件开发原则模式与实践 薪水支付","uri":"/2018/10/designpattern3-case2/"},{"categories":"设计模式","content":"单一职责原则(single responsibilities principle,SRP)\r原理：一个类应该只有一个变化 分离职责：如果不耦合的职责那么很简单，如果两个职责耦合，将两个职责抽象为接口，通过继承两个接口将依赖关系抽离处理啊 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:1:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"开放封闭原则(open close principle,OCP)\r软件实体(类，模块，函数等)应该是可以扩展的，但是不可修改 对扩展开放：当需求改变时，对模块可以扩展。 对修改封闭：对模块进行扩展时，不必改动模块的源代码或则二进制代码， 仅仅抽象出容易变化的部分。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:2:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"里氏替换原则(liskov substitution principle,LSP)\r子类型必须能够替换掉它的基类型。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:3:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"依赖倒置原则(dependence inversion principle,DIP)\r高层模块不应该依赖于底层模块，二者都应该依赖抽象 抽象不应该依赖细节，细节应该依赖抽象 为什么叫倒置，在传统软件开发中，总倾向于创建一些高层模块依赖底层模块，策略依赖细节的软件结构。一个良好的面向对象程序，对传统设计结构而言就被倒置了。 其实就是都依赖接口编程，高层依赖接口，细节依赖接口，这样模块的改动不会影响其他模块。比较好的模块设计： 模块和模块间的依赖都是依赖接口。 倒置不仅仅是依赖关系的倒置，也是接口所有权的倒置，通常会认为工具库应该拥有自己的接口，但其实应该是客户拥有接口，而它们的服务者应该是接口的派生。著名的 holly wood原则：“Don’t call us, we’ll call you”不要调用我们，我们会调用你，低层模块实现在高层模块中声明并被高层模块调用的接口 程序所有的依赖关系都应该终止与抽象 任何变量都不应该持有一个指向具体类的引用 任何类都不应该从具体类派生 任何方法都不应该重写它的任何基类中已经实现的方法。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:4:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"接口隔离原则(interface segregation principle,ISP)\r","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:5:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"接口会被污染:\r当借口的职责不再单一时，接口就很容易受到污染。 一个常见的例子：一个门，可能是关着也可能是开着，而且门类知道只是是开着还是关着。 常见的接口设计，现在需要实现自动报警，当门开着超过一定的时间就进行报警。常见的方法是关联timer类，实现报警。 这种方案就造成了接口污染，所有的门都必须依赖timeclient，同时还会出现门检测到时间超时，还未报警时，门关闭了，然后又被打开了，门变成了错误的报警 通过增加一个报警id,来区别每一次报警和客户端。 接口隔离原则：不应该强迫客户程序依赖并未使用的方法。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:5:1","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"隔离接口\r通过适配器原则，实现timer类对door类的引用隔离doorclient.这样仅仅增加了一个类，而将引用关系倒置。 创建一个派生自timer的timerclient对象，并把该对象请求委托给timerdoor。 这样就实现了timer和door的隔离，即使对timer进行更改也不会影响到door。timerdoor也不需要和timerclient一样的接口， 另一种方法是使用timerdoor来多重继承，door和timerclient， 这种方案没有多余的开销，只有当doortimeradapter对象所做的转换是必须的时候或则不同的时候需要不同的转换的时候，才需要使用适配器方法。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:5:2","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"例子：\rAMT的一个例子，输出信息要转换成不同的语言，输出信息要显示在桌面上， 把不同的事务处理方法封装在transaction上，这样每个事务的修改都会造成UI的修改，如果把接口分解成不通的单独接口，就可以避免 打包原则\r大型系统的设计非常依赖于好的组件设计，这样每个团队只要关注于单个组件而不需要关注整个系统。 但类经常会和其他类发生依赖关系，这些依赖关系也会跨越组件的边界。 在向组件中分配类时应该依据什么原则 应该使用什么设计原则来管理组件之间的关系 组件的设计应该先于类（自顶而下），还是设计应该先于组件（自底而上） 组件的实体以什么方式存在 组件创建好后，用于何种目的 组件和组件间的依赖关系：不能依赖具体类。只能是具体依赖抽象，抽象依赖抽象。这样就可以将影响将至最低。 前三个原则来指导如何将类划分到包中，后三个原则来管理包之间的耦合(稳定)。组件之间的耦合越稳定就越好 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:5:3","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"重用发布等价原则(reuse release equivalence principle,REP)\r重用粒度就是发布粒度：一个组件的重用粒度和发布粒度一样大，重用的任何东西必须被同时发布和跟踪， 重用性必然是基于组件的，所以可重用的组件必须包含可重用的类，因至少某些组件应该由一组可重用的类组成 一个类中的组件要么都是可重用的，要么都是不可重用的。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:6:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"共同重用原则(common reuse principle , crp)\r一个组件中所有的类都应该是共同重用的，如果重用了组件中的一个类，那么就要重用组件中的所有类。 这个原则可以帮助我们确定哪些类应该在一个组件中，相互之间没有紧密联系的类不应该在同一个组件中。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:7:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"共同封闭原则(common closure principle,ccp)\r组件中所有的类对同一种性质的变化应该是共同封闭的，一个变化若对一个封闭的组件产生影响，则将对该组件中所有的类产生影响，而对其他组件不产生影响。类似于单一职责原则。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:8:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"无环依赖原则\r在组件的关系图中不允许存在环。 解除依赖环的方法：提取抽象接口，通过实现接口来替换关联。关联和实现的依赖关系相反。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:9:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"稳定依赖原则\r朝着稳定的方向进行依赖。 被依赖的越多，该组件就越不可能改动，则越稳定。 稳定性度量： ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:10:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"稳定抽象原则\r组件的抽象程度与其稳定性。 中间连接线称为主序列。 到主序列的距离： 越为0 越好 有了度量和标准就让我们划分组件吧！！！ ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:11:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"这本书的实例非常好，给了我非常多的启发。主要讲了两个实例，咖啡机和薪水支付实例，咖啡机实例比较简单并没有用什么设计模式，薪水支付实例用了很多设计模式，包括后面的打包等。 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:0:0","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"咖啡机实例\r做一个使用咖啡机的软件，驱动接口已经被写好。 咖啡机的硬件包括： 加热器加热棒（开关） 保温盘加热棒（开关） 保温盘传感器（保温盘空，杯子空，杯子不空） 加热器传感器（有水，没水） 冲煮按钮（开关） 指示灯（开关） 减压阀门（开关） 咖啡机的冲煮流程： 咖啡机一次煮12杯咖啡， 咖啡加入过滤器，过滤器加入支架，支架放到咖啡机。 倒入12杯水到滤水器，按下冲煮，水杯加热至沸腾，水蒸气碰洒到过滤器，形成水滴到咖啡壶，咖啡壶发现有水保温， 拿走水杯，停止工作。 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:1:0","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"方案一\r建立一个咖啡机超类，关联各个硬件类。这个方案是非常丑陋的，这不是根据行为划分的，有些类，比如light没有任何变量，仅仅调用了驱动接口，这种类叫水蒸气类。没有意义 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:1:1","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"方案二\r按照行为来划分，要确定一些类有没有意义，只需要确定谁使用他们，而且要到业务底层去看。把问题的本质和细节分离，忘掉一切，最根本的问题是如何煮咖啡。如何煮咖啡，将热水倒到咖啡上，把冲泡好的咖啡收集起来。水从哪来？咖啡放到哪里？那么就有两个类：热水类和支架类，大大多数人会考虑热水流到支架中，这是比较错误的，软件的行为应该按照软件的行为给出而不是基于一些物理关系。还需要考虑用户界面，这样就有三个类。 谁使用 最根本的问题 软件行为而不是物理行为 用例\r按下冲煮，启动水流，支架做好准备，都准备好就开始煮咖啡 接受器具准备好没有 冲煮完成 咖啡喝完 Containment Vessel:支架和保温壶 Resume:恢复 a，b，c，d表示四种逻辑： a 表示：用户按下冲煮，确保支架中有咖啡壶放在保温杯上，热水器中已经加满了水，然后才开始煮咖啡 b 表示：如果正在股咖啡的过程中咖啡壶被拿走，则必须中断咖啡流，停止送热水，再次放回咖啡壶继续煮咖啡 c 表示：热水器中传感器告诉我们水用完了就停止煮咖啡，同时告诉用户和支架（保温盘）已经停止煮咖啡 d 表示：冲煮结束时并且一个空的咖啡壶放在支架上（保温盘），热水器应该知道这个消息，同时用户也应该知道这个消息 这样整个咖啡机的抽象就完成了，按职责划分，各司其职。这三个抽象类不能知道任何关于咖啡机的任何信息。这就是依赖倒置原则。 系统的控制流如何检测传感器呢？是选择线程还是轮询。最好的总是假设消息都是可以异步发送的，就像存在有独立的线程一样，把使用轮询还是线程的决策推迟到最后一刻。 这样设置了一个接口，main()程序就待在一个循环中，不停地一遍遍调用这个方法实现轮询。 public static void Main(string[] args) { CoffeeMakerAPI api = new M4CoffeeMakerAPI(); M4UserInterface ui = new M4UserInterface(api); M4HotWaterSOurce hws = new M4HotWaterSOurce(api); M4ContainmentVessel cv = new M4ContainmentVessel(api); ui.Init(hws,cv); hws.Init(ui,cv); cv.Init(hws,ui); while(true) { ui.Poll(); hws.Poll(); cv.Poll(); } } 依赖倒置，不允许高层的咖啡制作中依赖底层实现。 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:1:2","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"薪水支付实例\r该案例主要有做一个薪水支付系统，主要有三类员工 临时工：基本时薪，超过8小时加班时间1.5倍工资，每天有考勤卡，每周5结算。 正式员工：月薪，每个月最后一天结算。 经理：月薪，每月最后一天结算，有项目提成，每隔一周的周五结算，加入公会扣会费。 公会会费分服务费和会费：会费每周都有从薪水中扣除，服务费从下个月薪水中扣除。 薪水支付方式：可以选择支票邮寄到家，支票保存自取，直接存入银行账号。 薪水支付每天运行一次，在当天为相应的雇员进行支付，上一次支付到本次支付应付的数额。 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:2:0","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"用例：\r新增雇员：雇员号，姓名，地址。（零时工，正式员工，经理） 删除雇员：雇员号 登记考勤卡：雇员号，日期，小时 登记销售凭条：雇员号，日期，销售记录 登记公会服务费：公会成员，服务费用 更改雇员细则：更改姓名，更改地址，更改每小时报酬，更改薪水，更改提成，更改支付方式，加入公会，离开公会 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:2:1","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"设计类和结构：\r通过迭代的方式进行实现。数据库是实现细节，应该尽推迟数据库的设计。通过用例来推导出应该有哪些类。 从用例的角度设计\r新增雇员 Hourly:小时工 Commissioned：正式员工 Balarid：经理 把每一项工作划分为自己的类中。这样有可能会创建三个雇员类，但是分析一下就会发现变化的东西太多了，正式由于雇员变化的东西引发雇员类型的改变，只需要将变化的东西抽象出来，在更改雇员细则时改变这些变化的东西就可以改变雇员类型。 登记考勤卡 考勤卡和雇员应该是聚合的关系 登记销售凭条 销售凭条和雇员也应该是聚合的关系 登机工会服务费 工会服务费维护着工会会员的编号，因此系统必须要把工会成员和雇员标识联系起俩，推迟这一行为。公会成员和服务费也是聚合的关系 更改雇员细则 这是由多个更改策略组合而成。 最后各个类之间的关系 从程序运行的角度补充细节\r运行薪水支付系统：找到所有进行支付的雇员，确定扣款额，根据他们的支付方式支付。 抽象出变化的东西：雇员的支付类别抽象，支付时间抽象 工会服务费抽象。Affillation:联系 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:2:2","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"实现\r事务 事务是使用命令模式。 增加雇员事务，雇员有三个类型，所以使用模板模式来实现增加雇员，此处模板模式的唯一任务就是创建对象 public abstract class AddEmployeeTransaction : Transaction { private readonly int empid; private readonly string name; private readonly string address; public AddEmployeeTransaction(int empid, string name, string address, PayrollDatabase database) : base (database) { this.empid = empid; this.name = name; this.address = address; } protected abstract PaymentClassification MakeClassification(); protected abstract PaymentSchedule MakeSchedule(); public override void Execute() { PaymentClassification pc = MakeClassification(); PaymentSchedule ps = MakeSchedule(); PaymentMethod pm = new HoldMethod(); Employee e = new Employee(empid, name, address); e.Classification = pc; e.Schedule = ps; e.Method = pm; database.AddEmployee(e); } public override string ToString() { return String.Format(\"{0} id:{1} name:{2} address:{3}\", GetType().Name, empid, name,address); } } public class AddSalariedEmployee : AddEmployeeTransaction { private readonly double salary; public AddSalariedEmployee(int id, string name, string address, double salary, PayrollDatabase database) : base(id, name, address, database) { this.salary = salary; } protected override PaymentClassification MakeClassification() { return new SalariedClassification(salary); } protected override PaymentSchedule MakeSchedule() { return new MonthlySchedule(); } } 删除雇员 提供雇员id，去数据库删除雇员，没啥好说的。 考勤卡、销售凭条、服务费 考勤卡：需要参数，雇员id,日期，工作时间 public class TimeCard { private readonly DateTime date; private readonly double hours; public TimeCard(DateTime date, double hours) { this.date = date; this.hours = hours; } public double Hours { get { return hours; } } public DateTime Date { get { return date; } } } public class TimeCardTransaction : Transaction { private readonly DateTime date; private readonly double hours; private readonly int empId; public TimeCardTransaction(DateTime date, double hours, int empId, PayrollDatabase database) : base(database) { this.date = date; this.hours = hours; this.empId = empId; } public override void Execute() { Employee e = database.GetEmployee(empId); if (e != null) { HourlyClassification hc = e.Classification as HourlyClassification; if (hc != null) hc.AddTimeCard(new TimeCard(date, hours)); else throw new ApplicationException( \"Tried to add timecard to\" + \"non-hourly employee\"); } else throw new ApplicationException( \"No such employee.\"); } } 其他两种与这类似 更改雇员属性 更改雇员属性由多个事务集合而成 改名字事务： public abstract class ChangeEmployeeTransaction : Transaction { private readonly int empId; public ChangeEmployeeTransaction(int empId, PayrollDatabase database) : base (database) { this.empId = empId; } public override void Execute() { Employee e = database.GetEmployee(empId); if(e != null) Change(e); else throw new ApplicationException( \"No such employee.\"); } protected abstract void Change(Employee e); } public class ChangeNameTransaction : ChangeEmployeeTransaction { private readonly string newName; public ChangeNameTransaction(int id, string newName, PayrollDatabase database) : base(id, database) { this.newName = newName; } protected override void Change(Employee e) { e.Name = newName; } } 更改雇员类别 public abstract class ChangeClassificationTransaction : ChangeEmployeeTransaction { public ChangeClassificationTransaction(int id, PayrollDatabase database) : base (id, database) {} protected override void Change(Employee e) { e.Classification = Classification; e.Schedule = Schedule; } protected abstract PaymentClassification Classification { get; } protected abstract PaymentSchedule Schedule { get; } } public class ChangeHourlyTransaction : ChangeClassificationTransaction { private readonly double hourlyRate; public ChangeHourlyTransaction(int id, double hourlyRate, PayrollDatabase database) : base(id, database) { this.hourlyRate = hourlyRate; } protected override PaymentClassification Classification { get { return new HourlyClassification(hourlyRate); } } protected override PaymentSchedule Schedule { get { return new WeeklySchedule(","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:2:3","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"总结\r到目前为止基本功能已经实现，仅仅只是用了模板，空值，命令等设计模式，下一篇将会进一步使用更多的设计模式进行打包处理。 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:3:0","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"所看书籍是：敏捷软件开发_原则、模式与实践_C#版（美）马丁著，这本书写的非常棒，感谢作者。该归纳总结的过程按照我读的顺序写。 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:0:0","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"UML\r在建造桥梁，零件，自动化设备之前需要建模分析可行性，软件在编写之前也需要建立模型，看看类和逻辑的设计是否合理，这样的建模过程就是UML。 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:0","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"类图\r类图就是来描述一个类本身或和其他类的调用关系。 +public -private #protected 实现/泛化\r集成 实现接口 组合\r部分可以离开整体 聚合\r部分不能离开整体 关联\r持有对其他对象引用的实例变量 依赖\r局部变量/方法的参数或则静态方法的调用 注意 关系的强弱：泛化/实现\u003e组合\u003e聚合\u003e关联\u003e依赖 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:1","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"对象图\r表示系统执行的某个特定时刻的一组对象和关系，可以看成是内存快照。 该图大部分是从相应的类图中推导而来没啥用。 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:2","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"顺序图\r描述算法的实现，重点在于消息的顺序。比较常绘制的动态模型。 例子\r对象下面画有横线，类没有，对象名：类 垂下来的线为生命线 中间矩形垂下来的矩形：激活，表示一个函数的执行时间 虚线表示返回参与者并传回返回值 箭头：消息。返回值：消息名称（参数） 带圆圈的箭头：消息的参数 注意\r循环：框起来 [for each id in idlist] 容易被勿用和滥用 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:3","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"协作图\r描述算法的实现，重点在于对象之间的关系 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:4","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"状态图\r其实就是有限状态机（FSM）。 例子:\r实心黑球：初始伪状态，从这个状态开始运转 圆矩形：状态。上层放状态的名字，下层放一些特定动作和事件，表示进入或则退出时要做什么， 箭头：迁移。上面有触发该迁移的事件名称和要执行的动作 注意 entry和exit：标准事件，不管写不写都会触发 超状态：几个状态迁移时间相同时，可以组成一个超状态。迁移时会出发超状态的entry和exit ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:5","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"如何使用UML\r在使用UML的过程中，需要先通过行为优先的方式写出状态图，先是局部状态再是整体状态，抽象出会改变的，将每一种改变的类型实例化，中间再通过各种设计模式隔离 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:2:0","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"行为优先\r从项目的功能入手，用户的交互入手写出每一种功能，大体的类有了后，再抽象出会改变的类，通过设计模式隔离 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:2:1","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"检查结构\r检查每一种功能实现是否合理 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:2:2","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"想象代码\r想想出代码的样子做微调 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:2:3","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":null,"content":"关于我\r92年，儿子、丈夫、父亲，新时代农民工。 从事上位机开发多年，熟悉制药(层析超滤)和IVD(生化免疫)设备软件。 喜欢研究和学习各类技术，保持好奇心，持续探索。 熟悉的编程语言：C#,C,C++,Vue。 可以通过邮件978089234@qq.com与我联系！ Blog\r小时候夏天很长，长大了一年很短。每天都感觉很忙碌，却不知道在忙些什么。 想要记录些东西，表明那些年真的存在过。 写的文章，分享的想法观点可能早就有人写过，分享过。 没有关系，这算是自我的一种成长和探索，走一下别人走过的路，站在巨人的肩膀上，能不能看到不一样的风景？ ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]