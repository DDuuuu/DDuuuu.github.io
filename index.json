[{"categories":"LeeCode","content":"题目\r题目链接 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。 示例 1： 输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2： 输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3： 输入：nums = [], target = 0 输出：[-1,-1] 提示： 0 \u003c= nums.length \u003c= 105 -109 \u003c= nums[i] \u003c= 109 nums 是一个非递减数组 -109 \u003c= target \u003c= 109 ","date":"2022-11-16","objectID":"/2022/11/leecode34/:0:1","tags":["LeeCode","34","数组","查找第一个和最后一个位置"],"title":"LeeCode-34-数组-查找第一个和最后一个位置","uri":"/2022/11/leecode34/"},{"categories":"LeeCode","content":"解题\r二分法类似题，解题方案和前面两个相似 存在的变化，有重复数据，需要返回两个位置 尝试使用二分，找到值的序号后，向左，向右定位到上下限。 public int[] Search(int[] nums, int target) { //[left，right] var left = 0; var right = nums.Length - 1; var result = new int[] {-1, -1}; var mid = 0; while (left \u003c= right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { var min = mid; while (--min\u003e=left)//确定下限，使用遍历 { if(nums[min] != target) break; } result[0] = min + 1; var max = mid; while (++max \u003c= right)//确定上限，使用遍历 { if (nums[max] != target) break; } result[1] = max-1; break; } else if (target\u003cnums[mid]) { right = mid - 1; } else { left = mid + 1; } } return result; } 如果数组中的重复项比较多，中间使用遍历可以优化为二分，同时判定目标值是否在数组中也改成递归进行统一。 public int[] SearchPlus(int[] nums, int target) { var result = new int[] { -1, -1 }; if (nums.Length == 0) return result; //[left，right] var left = 0; var right = nums.Length - 1; var mid = 0; //遍历定位左右限，type 0:返回下限序号，1返回上限序号 ,2找到即返回, //返回[left right,index] int[] InnterSearch(int[] nums, int target, int left, int right, int type) { if (left \u003c= right) { mid = (left + right) \u003e\u003e 1; if (type == 2 \u0026\u0026 target == nums[mid]) { return new[] {left, right, mid}; } else if ( target \u003c nums[mid]||(type == 0 \u0026\u0026 target == nums[mid])) { right = mid - 1; } else if (target \u003e nums[mid] || (type == 1 \u0026\u0026 target == nums[mid])) { left = mid + 1; } return InnterSearch(nums, target, left, right, type); } if (type == 2)//不在数组中 { return new[] {left, right, -1}; } var index = type==1 ? left-1 : right+1; return new[] {left, right, nums[index] == target ? index : -1}; } var indexarray = InnterSearch(nums, target, left, right, 2);//数组中存在 if (indexarray[2] == -1) return result; result[0]= InnterSearch(nums, target, indexarray[0], indexarray[2], 0)[2];//找到下限 [left,mid]中二分 result[1] = InnterSearch(nums, target, indexarray[2], indexarray[1], 1)[2];//找到上限 [mid,right]中二分 return result; } InnterSearch方法承担了三个职责，目标值是否在数组中，寻找上限，寻找下限。导致内部实现用了很多的判定，看上去有点乱，通过字典封装判断逻辑，一目了然，如果以后需求变化，改动字典即可，尽可能满足开放封闭原则。 public int[] SearchPlusPro(int[] nums, int target) { var result = new int[] { -1, -1 }; if (nums.Length == 0) return result; //[left，right] var left = 0; var right = nums.Length - 1; var mid = 0; //遍历定位左右限，type 0:返回下限序号，1返回上限序号 ,2找到即返回, //返回[left right,index] var searchtypes = new Dictionary\u003cint, Func\u003cint[], int, int, int,int, int[]\u003e\u003e() { {//下限 0, (_nums, _target, _left, _right,_mid) =\u003e { if (_target \u003c= _nums[_mid]) { _right = _mid - 1; } else //target\u003enums[mid] { _left = _mid + 1; } return new []{_left,_right,-1}; } }, {//上限 1, (_nums, _target, _left, _right,_mid) =\u003e { if (_target \u003c _nums[_mid]) { _right = _mid - 1; } else //target\u003e=nums[mid] { _left = _mid + 1; } return new []{_left,_right,-1}; } }, {//找到立即返回 2, (_nums, _target, _left, _right,_mid) =\u003e { if (_target == _nums[_mid]) { return new[] {_left, _right, _mid}; } else if ( _target \u003c _nums[_mid]) { _right = _mid - 1; } else { _left = _mid + 1; } return new []{_left,_right,-1}; } } }; int[] InnterSearch(int[] nums, int target, int left, int right, int type) { if (left \u003c= right) { mid = (left + right) \u003e\u003e 1; var temresult = searchtypes[type](nums, target, left, right, mid); if (temresult[2] != -1) return temresult; return InnterSearch(nums, target, temresult[0], temresult[1], type); } return new[] {left, right, -1}; } var indexarray = InnterSearch(nums, target, left, right, 2);//数组中存在 if (indexarray[2] == -1) return result; result[0] = InnterSearch(nums, target, indexarray[0], indexarray[2], 0)[0];//找到下限 [left,mid]中二分 result[1] = InnterSearch(nums, target, indexarray[2], indexarray[1], 1)[1];//找到上限 [mid,right]中二分 return result; } ","date":"2022-11-16","objectID":"/2022/11/leecode34/:0:2","tags":["LeeCode","34","数组","查找第一个和最后一个位置"],"title":"LeeCode-34-数组-查找第一个和最后一个位置","uri":"/2022/11/leecode34/"},{"categories":"LeeCode","content":"网络解析\r网络解析有以下几种方式： 对数组使用两次二分查找上限和下限。 先判断目标在数组中，再使用二分查找上下限 public class Solution { public int[] SearchRange(int[] nums, int target) { if (nums.Length == 0) return new int[] { -1, -1 }; int l = binarySearch(nums, target, true); int r = binarySearch(nums, target, false) - 1; if (l \u003c= r \u0026\u0026 r \u003c nums.Length \u0026\u0026 nums[l] == target \u0026\u0026 nums[r] == target) return new int[] { l, r }; return new int[] { -1, -1 }; } int binarySearch(int[] nums,int target,bool lower) { int n = nums.Length; int l = 0, r = n - 1; while (l \u003c= r) { int m = (l + r) / 2; if (nums[m] \u003e target || (lower \u0026\u0026 nums[m] \u003e= target)) { r = m - 1; n = m; } else l = m + 1; } return n; } } public class Solution { public int[] SearchRange(int[] nums, int target) { int[] res = new int[2]; int left=0; int right = nums.Length-1; while(left\u003c= right) { int mid = left+(right-left)/2; if(nums[mid] \u003ctarget) { left = mid+1; }else if(nums[mid] \u003etarget) { right = mid-1; }else if (nums[mid]==target) { right = mid-1; } } if(left==nums.Length) { res[0] = -1; }else { res[0] = nums[left]==target?left:-1; } left=0; right = nums.Length-1; while(left\u003c= right) { int mid = left+(right-left)/2; if(nums[mid] \u003ctarget) { left = mid+1; }else if(nums[mid] \u003etarget) { right = mid-1; }else if (nums[mid]==target) { left = mid+1; } } if(left-1 \u003c0) { res[1] = -1; }else { res[1] = nums[left-1]==target?left-1:-1; } return res; } } ","date":"2022-11-16","objectID":"/2022/11/leecode34/:0:3","tags":["LeeCode","34","数组","查找第一个和最后一个位置"],"title":"LeeCode-34-数组-查找第一个和最后一个位置","uri":"/2022/11/leecode34/"},{"categories":"LeeCode","content":"题目\r题目链接 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例 1: 输入: nums = [1,3,5,6], target = 5 输出: 2 示例 2: 输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3: 输入: nums = [1,3,5,6], target = 7 输出: 4 提示: 1 \u003c= nums.length \u003c= 104 -104 \u003c= nums[i] \u003c= 104 nums 为 无重复元素 的 升序 排列数组 -104 \u003c= target \u003c= 104 解题\r","date":"2022-11-15","objectID":"/2022/11/leecode35/:0:0","tags":["LeeCode","35","数组","搜索插入位置"],"title":"LeeCode-35-数组-搜索插入位置","uri":"/2022/11/leecode35/"},{"categories":"LeeCode","content":"二分\r思考，排序数组，无重复，升序，规定时间复杂度，好像只有二分了，递归是否可以，因为递归也是Logn public int Search(int[] nums, int target) { //[left,right] var left = 0; var right = nums.Length - 1; var mid = 0; while (left \u003c= right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { left = mid; break; } else if (target\u003cnums[mid]) { right = mid - 1; } else { left = mid + 1; } } return left; } public int SearchPlus(int[] nums, int target) { //[right,left) var left = 0; var right = nums.Length; var mid = 0; while (left != right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { left = mid; break; } else if (target \u003c nums[mid]) { right = mid; } else { left = mid + 1; } } return left; } ","date":"2022-11-15","objectID":"/2022/11/leecode35/:1:0","tags":["LeeCode","35","数组","搜索插入位置"],"title":"LeeCode-35-数组-搜索插入位置","uri":"/2022/11/leecode35/"},{"categories":"LeeCode","content":"递归\rpublic int SearchPro(int[] nums, int target) { //[right,left] var left = 0; var right = nums.Length - 1; var mid = 0; int InnerCore(int[] nums, int target, int left, int right) { if (left \u003c= right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { return mid; } else if (target \u003c nums[mid]) { return InnerCore(nums, target, left, mid-1); } else { return InnerCore(nums, target, mid + 1, right); } } return left; } return InnerCore(nums,target,left,right); } public int SearchProPlus(int[] nums, int target) { //[right,left) var left = 0; var right = nums.Length; var mid = 0; int InnerCore(int[] nums, int target, int left, int right) { if (left != right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { return mid; } else if (target \u003c nums[mid]) { return InnerCore(nums, target, left, mid); } else { return InnerCore(nums, target, mid + 1, right); } } return left; } return InnerCore(nums, target, left, right); } 网络解析\rpublic int SearchInsert(int[] nums, int target) { int searchIdx; int searchLower = 0, searchHigher = nums.Length - 1; int middle = 0; while (searchLower \u003c= searchHigher) { middle = searchLower + (searchHigher - searchLower) / 2; if (nums[middle] == target) { return middle; } if (nums[middle] \u003e target) { searchHigher = middle - 1; } else { searchLower = middle + 1; } } if (target \u003c= nums[middle]) return middle; if (target \u003e nums[middle]) return middle + 1; return -1; } public class Solution { public int SearchInsert(int[] nums, int target) { return Rank(nums,0,nums.Length - 1,target); } public int Rank(int[] arr,int left,int right,int target) { if(target \u003c arr[left]) return left; if(target \u003e arr[right]) return right + 1; int mid = (left + right)/2; if(target == arr[mid]) return mid; if(target\u003carr[mid]) return Rank(arr,left,mid-1,target); else return Rank(arr,mid+1,right,target); } } ","date":"2022-11-15","objectID":"/2022/11/leecode35/:2:0","tags":["LeeCode","35","数组","搜索插入位置"],"title":"LeeCode-35-数组-搜索插入位置","uri":"/2022/11/leecode35/"},{"categories":"LeeCode","content":"题目\r给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示: 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 解题\r如果使用遍历，最好情况O(1)，最坏情况O(n)。 使用二分法是O(logn)。 尝试使用二分，二分肯定有上下限和中间值，通过中间值和目标值比较，不断缩小上下限最后得到结果。 从中考虑While的判断是什么？ 上下限的范围怎么划定？ 初版： public int Search(int[] nums, int target) { var maxindex = nums.Length-1; var minindex = 0; var index = (maxindex + minindex) / 2; while (maxindex != minindex) { if (target == nums[index]) { break; } if (target \u003c nums[index]) { maxindex = index; } else { minindex = index+1; } index = (maxindex + minindex) / 2; } if (target == nums[index]) return index; return -1; } 测试用例通过了，但是有效率不高，有很多重复代码，改进一下 public int SearchPro(int[] nums, int target) { var maxindex = nums.Length - 1; var minindex = 0; var midindex=0; while (minindex\u003c=maxindex) { midindex = (maxindex + minindex) / 2; if (target == nums[midindex]) { return midindex; } if (target \u003c nums[midindex]) { maxindex = midindex - 1; } else { minindex = midindex + 1; } } return -1; } 最佳答案 public int StandardSearch(int[] nums, int target) { int left = 0, right = nums.Length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } if (nums[mid] \u003e target) { right = mid - 1; } else { left = mid + 1; } } return -1; } 对比： 想一下变量用left和right应该更简介一点。mid在循环体中声明，每次会在栈中创建新的临时变量。 网络解析\rtarget 是在一个在左闭右闭的区间里，也就是[left, right] ，这种就是上面的标准写法 while (left \u003c= right) 要使用 \u003c= ，因为left == right是有意义的，所以使用 \u003c= if (nums[middle] \u003e target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 target 是在一个在左闭右开的区间里，也就是[left, right) while (left \u003c right)，这里使用 \u003c ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] \u003e target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] public int SearchPlus(int[] nums, int target) { var maxindex = nums.Length; var minindex = 0; var midindex = 0; while (minindex \u003c maxindex) { midindex = (maxindex + minindex) / 2; if (target == nums[midindex]) { return midindex; } if (target \u003c nums[midindex]) { maxindex = midindex; } else { minindex = midindex+1; } } return -1; } ","date":"2022-11-14","objectID":"/2022/11/leecode704/:0:0","tags":["LeeCode","704","数组","二分查找"],"title":"LeeCode-704-数组-二分查找","uri":"/2022/11/leecode704/"},{"categories":"DotNet基础","content":"概述\r高性能的套接字编程围绕着两个方面：异步和复用。异步：高性能就是最大化计算机资源的利用，是不可能让线程有阻塞的，所以就有了各种异步模式。复用：计算机资源最好是能重复使用的，频繁的创建和销毁相同的对象也是对资源的浪费，所以就有了各种池和零拷贝；CPU在访问相邻资源的时候有特别的优势可以利用缓存区，所以池中对象尽量相邻创建。 Socket套接字编程历史悠久，发展出好几种方式，对应着DotNet异步编程的发展，分别：异步编程模式(Asynchronous Programming Model ,APM)、基于事件的异步模式(Event-based Asynchronous Pattern ,EAP)和基于任务的异步模式(Task-based Asynchronous Pattern,TAP)。 本文将简要介绍几种异步编程对应Socket的实现，每一种都写了一个简单的Socket服务端以供学习。 ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:1:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"面向连接的套接字\r套接字流程如下，在Accept，Read，Write，Connect和Disconnect方法均涉及到异步编程。为什么会异步，简单来说就是线程执行速度很快，网络传输的IO速度很慢，线程发出IO操作的指令后，不可能一直等待指令执行完。所以线程设置一个回调函数的入口地址，让IO执行完之后调用该入口地址，之后线程就去干其他事情了，等该IO调用该入口地址，线程再回来继续工作。 ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:2:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"阻塞式套接字\rSocket接口，下面是用阻塞方法创建的一个简单服务端。可以分析出该服务的性能是很差的，没有做任何的异步和复用。 //服务端 public static void Run(string m_ip, int m_port) { var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); var ip = IPAddress.Parse(m_ip); var endpoint = new IPEndPoint(ip, m_port); socket.Bind(endpoint); socket.Listen(0); socket.ReceiveTimeout = -1; //线程池中后台线程执行 Task.Run(() =\u003e { while (true) { var acceptSocket = socket.Accept();//线程阻塞等待连接请求队列 if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { //线程池中后台线程执行 Task.Run(() =\u003e { byte[] receiveBuffer = new byte[1024];//每一个连接都在重新创建缓冲区 int result = 0; do { if (acceptSocket.Connected) { result = acceptSocket.Receive(receiveBuffer, 0, receiveBuffer.Length, SocketFlags.None, out SocketError error);//线程阻塞等待缓冲区数据 if (error == SocketError.Success \u0026\u0026 result \u003e 0) { var recestr = Encoding.UTF8.GetString(receiveBuffer, 0, result); var Replaystr = $\"Server收到消息:{recestr};Server收到消息的时间:{DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss:fff\")}\"; var strbytes = Encoding.UTF8.GetBytes(Replaystr); acceptSocket.Send(strbytes, 0, strbytes.Length, SocketFlags.None);//线程阻塞等待发送完缓冲区数据 if (recestr.Contains(\"stop\")) { break; } } } else { break; } } while (result \u003e 0); }).ContinueWith((t) =\u003e { System.Threading.Thread.Sleep(1000); acceptSocket.Disconnect(false); acceptSocket.Dispose(); }); } } }).Wait(); } ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:3:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"异步编程模式(Asynchronous Programming Model ,APM)\rBeginXXX方法并不会阻塞线程，而EndXXX会，dotnet提供Task\u003cT\u003e.Factory.FromAsync可以将APM转成TAP模式异步模式以提高性能，下面提供一个示例，同时使用ArrayPool复用缓冲区，处理分包，粘包等问。 public static Socket Run(string m_ip, int m_port) { var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); var ip = IPAddress.Any; if (!string.IsNullOrEmpty(m_ip)) { ip = IPAddress.Parse(m_ip); } var endpoint = new IPEndPoint(ip, m_port); socket.Bind(endpoint); Console.WriteLine($\"[{DateTime.Now.GetFormString()}] Server Established localEndpoint:[{socket.LocalEndPoint.ToString()}]\"); socket.Listen(200); socket.ReceiveTimeout = -1; //后台线程执行 Task.Run(async () =\u003e { while (true) { var acceptSocket = await Task\u003cSocket\u003e.Factory.FromAsync( socket.BeginAccept(null,null) ,socket.EndAccept);//APM转TAP异步 if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { //后台线程来处理Receive逻辑 var task = Task.Run(async () =\u003e { byte[] buffer = ArrayPool\u003cbyte\u003e.Shared.Rent(1024);//从内存池中获取缓冲区 var bytesBuffered = 0; var bytesConsumed = 0; while (true) { if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { var temremaining = bytesBuffered - bytesConsumed; if (temremaining == 0)//缓存区全部解析完 { bytesBuffered = 0; bytesConsumed = 0; } else if (temremaining \u003c buffer.Length \u0026\u0026 temremaining \u003e 0)//最后一个包不完整，部分数据未解析 { var newbuffer = ArrayPool\u003cbyte\u003e.Shared.Rent(buffer.Length); Buffer.BlockCopy(buffer, bytesConsumed, newbuffer, 0, temremaining); ArrayPool\u003cbyte\u003e.Shared.Return(buffer); buffer = newbuffer; bytesBuffered = temremaining; bytesConsumed = 0; } else //包不够大，分包了 { var newbuffer = ArrayPool\u003cbyte\u003e.Shared.Rent(buffer.Length * 2); Buffer.BlockCopy(buffer, 0, newbuffer, 0, buffer.Length); ArrayPool\u003cbyte\u003e.Shared.Return(buffer); buffer = newbuffer; } var bytesRemaining = buffer.Length - bytesBuffered; try { var bytesread = await Task\u003cint\u003e.Factory.FromAsync( acceptSocket.BeginReceive(buffer, bytesBuffered, bytesRemaining, SocketFlags.None, null, null), acceptSocket.EndReceive);//APM转TAP异步 if (bytesread == 0) { break; } bytesbuffered += bytesread; var lineposition = -1; do { lineposition = array.indexof(buffer, (byte)0x23, bytesconsumed,bytesbuffered - bytesconsumed); if (lineposition \u003e= 0) { var lineLength = linePosition - bytesConsumed; ProcessLine(acceptSocket, buffer, bytesConsumed, bytesread); bytesConsumed += bytesread; } } while (linePosition \u003e= 0);//包解析 } catch (Exception e) { break; } } else { break; } } ArrayPool\u003cbyte\u003e.Shared.Return(buffer); }).ContinueWith((t) =\u003e { Console.WriteLine($\"[{DateTime.Now.GetFormString()}] ServerClient Disconnected localEndpoint:[{acceptSocket?.LocalEndPoint.ToString()}] remoteEndpoint:[{acceptSocket?.RemoteEndPoint.ToString()}]\"); acceptSocket?.Shutdown(SocketShutdown.Both); acceptSocket?.Close(); acceptSocket = null; }); } } }); return socket; } ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:4:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"基于事件异步的完成端口模型(Event-based Asynchronous Pattern ,EAP)\r目前应用最广的Socket模型，完成端口模型还是按照\"回调函数\"的方式进行来实现异步，其本质是线程池，该线程池的核心工作就是去调用IO操作完成时的回调函数。另外因为IO操作毕竟是慢速的操作，所以几个线程就已经足可以应付成千上万的输入输出完成操作的请求(前提就是你的回调函数做的工作要足够少)，所以这个模型的性能是非常高的。也是现在Windows平台上性能最好的输入输出模型。自定义构造了内存池，将一大块内存切分成一定数据量的连续小内存，分别分配给不同的SocketAsyncEventArgs对象以提高服务性能，非常巴适；目前看到的FastSocket,SuperSocket,TouchSocket,NewLife等网络框架均采用这种模式，最主要的原因是应用范围广。 框架 版本 .NET Core 1.0, Core 1.1, Core 2.0, Core 2.1, Core 2.2, Core 3.0, Core 3.1, 5, 6, 7 Preview 7 .NET Framework 2.0, 3.0, 3.5, 4.0, 4.5, 4.5.1, 4.5.2, 4.6, 4.6.1, 4.6.2, 4.7, 4.7.1, 4.7.2, 4.8 .NET Standard 1.3, 1.4, 1.6, 2.0, 2.1 UWP 10.0 Xamarin.iOS 10.8 Xamarin.Mac 3.0 public class MyIOCPSocket { private static int m_numConnections;//最大连接数 private static int m_receiveBufferSize;//接收缓存区数量 private static int m_sendBufferSize;//发送缓存区大小 private static byte[] m_receivebuffer;//接收缓存区 private static Stack\u003cint\u003e m_freeReceiveIndexPool;//可用的接收缓存索引栈 private static int m_currentReceiveIndex;//当前的接收缓存区索引 private static byte[] m_sendbuffer;//发送缓存区 private static Stack\u003cint\u003e m_freeSendIndexPool;//可用的发送缓存索引栈 private static int m_currentSendIndex;//当前的发送缓存区索引 private static Stack\u003cSocketAsyncEventArgs\u003e m_ReadPool;//接收SocketAsyncEventArgs池 private static Stack\u003cSocketAsyncEventArgs\u003e m_WritePool;//发送SocketAsyncEventArgs池 private static Semaphore m_maxNumberAcceptedClients;//最大连接锁 private static int m_numConnectedSockets;//连接的Socket数量 private static int m_totalBytesRead;//总的接收字节数 private static Socket listenSocket;//监听Socket public static void Run(string m_ip, int m_port, int numConnections, int m_receiveBuffer, int m_sentBuffer) { //初始化 m_numConnections = numConnections; m_receiveBufferSize = m_receiveBuffer; m_sendBufferSize = m_sentBuffer; m_receivebuffer = new byte[m_receiveBufferSize * m_numConnections]; m_freeReceiveIndexPool = new Stack\u003cint\u003e(); m_currentReceiveIndex = 0; m_sendbuffer = new byte[m_sendBufferSize * m_numConnections]; m_freeSendIndexPool = new Stack\u003cint\u003e(); m_currentSendIndex = 0; m_ReadPool = new Stack\u003cSocketAsyncEventArgs\u003e(m_numConnections); m_WritePool = new Stack\u003cSocketAsyncEventArgs\u003e(m_numConnections); m_maxNumberAcceptedClients = new Semaphore(m_numConnections, m_numConnections); m_numConnectedSockets = 0; m_totalBytesRead = 0; //接收缓存分配 for (int i = 0; i \u003c m_numConnections; i++) { var readEventArg = new SocketAsyncEventArgs(); readEventArg.Completed += new EventHandler\u003cSocketAsyncEventArgs\u003e(ReadWriteIOComleted); readEventArg.UserToken = new AsyncUserToken(); if (m_freeReceiveIndexPool.Count \u003e 0) { readEventArg.SetBuffer(m_receivebuffer, m_freeReceiveIndexPool.Pop(), m_receiveBufferSize); } else { if ((m_receiveBufferSize * m_numConnections - m_receiveBufferSize) \u003c m_currentReceiveIndex) { new ArgumentException(\"接收缓存设置异常\"); } readEventArg.SetBuffer(m_receivebuffer, m_currentReceiveIndex, m_receiveBufferSize); m_currentReceiveIndex += m_receiveBufferSize; } m_ReadPool.Push(readEventArg); //发送缓存分配 var writeEventArg = new SocketAsyncEventArgs(); writeEventArg.Completed += new EventHandler\u003cSocketAsyncEventArgs\u003e(ReadWriteIOComleted); writeEventArg.UserToken = new AsyncUserToken(); if (m_freeSendIndexPool.Count \u003e 0) { writeEventArg.SetBuffer(m_sendbuffer, m_freeSendIndexPool.Pop(), m_sendBufferSize); } else { if ((m_sendBufferSize * m_numConnections - m_sendBufferSize) \u003c m_currentSendIndex) { new ArgumentException(\"发送缓存设置异常\"); } writeEventArg.SetBuffer(m_sendbuffer, m_currentSendIndex, m_sendBufferSize); m_currentSendIndex += m_sendBufferSize; } m_WritePool.Push(writeEventArg); } //设置监听socket listenSocket = new Socket(new IPEndPoint(IPAddress.Parse(m_ip), m_port).AddressFamily, SocketType.Stream, ProtocolType.Tcp); //绑定端口 listenSocket.Bind(new IPEndPoint(IPAddress.Parse(m_ip), m_port)); listenSocket.Listen(100); StartAccept(null); Console.WriteLine(\"Press any key to terminate the server process....\"); Console.ReadKey(); } public static void ReadWriteIOComleted(object sender, SocketAsyncEventArgs e) { switch (e.LastOperation) { case SocketAsyncO","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:5:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"基于任务的异步模式(Task-based Asynchronous Pattern,TAP)\r相对于前几个模型，基于任务的网络模型是比较新的模型，但是性能是最好的，最主要的原因是微软提供了System.Net.Sockets.SocketTaskExtensions封装TAP的异步方法；System.IO.Pipelines管道模型，在 .NET 中执行高性能 I/O 更加容易。该管道可以实现流量控制和反压。PipeScheduler可以进行回调线程控制。PipeReader和PipeWriter封装了对内存数据的直接操作，实现零拷贝得以大大提供业务流的性能。可惜的是应用范围比较小，目前框架只支持2.1, 2.2, 3.0, 3.1, 5, 6, 7 Preview 7，Framework不支持。 private static Pipe pipe; public static Socket Run(string m_ip, int m_port) { //监听Socket var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); var ip = IPAddress.Parse(m_ip); var endpoint = new IPEndPoint(ip, m_port); socket.Bind(endpoint); //绑定端口和IP socket.Listen(200); //允许同时监听的队列 socket.ReceiveTimeout = -1; Task.Run(async () =\u003e { while (true) { var acceptSocket = await socket.AcceptAsync(); //TAP异步接收 if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { pipe = new Pipe(); var writer = pipe.Writer; var reader = pipe.Reader; var writetaskr = Task.Run(async () =\u003e { while (true) { var memory = writer.GetMemory(1024); try { //TAP 异步读取数据 int bytesRead = await acceptSocket.ReceiveAsync(memory, SocketFlags.None); if (bytesRead == 0) { break; } //告诉 PipeWriter 写入多少数据。 writer.Advance(bytesRead); } catch (Exception e) { break; } //刷新写入 FlushResult result = await writer.FlushAsync(); if (result.IsCompleted) { break; } } // 完成写入 await writer.CompleteAsync(); }).ContinueWith((t) =\u003e { acceptSocket?.Shutdown(SocketShutdown.Both); //acceptSocket?.Disconnect(true); acceptSocket?.Dispose(); acceptSocket = null; }); var readingtask= Task.Run(async() =\u003e { while (true) { try { //从管道中读取 ReadResult result = await reader.ReadAsync(); ReadOnlySequence\u003cbyte\u003e buffer = result.Buffer; while (TryReadLine(ref buffer, out ReadOnlySequence\u003cbyte\u003e line))//解析 { ProcessLine(acceptSocket, line); } //实际读了多少 reader.AdvanceTo(buffer.Start, buffer.End); //是否写已经结束 if (result.IsCompleted) { break; } } catch (Exception e) { break; } } await reader.CompleteAsync(); }).ContinueWith((t) =\u003e { acceptSocket?.Shutdown(SocketShutdown.Both); acceptSocket?.Dispose(); acceptSocket = null; } ); } } }); return socket; } ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:6:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"总结\r主要讲述在套接字编程中，如何实现异步和复用以提高性能。讲述了异步编程(APM)、基于事件的异步模型(EAP)和基于任务的异步模型(TAP)；复用方面从内存池(ArrayPool)，到自定义构建内存池(利用高速缓存)和完成端口池，再到最新的管道模型，实现零拷贝。 ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:7:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 TouchSocket提供插件方式的扩展，这种方式对原框架的耦合较小。用插件基类封装了底层框架中所有的插件扩展接口，插件子类重写对应的接口就可注入相关业务。框架插件的注入和调用通过PluginsManager进行管理。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:1:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"插件架构\r插件接口在框架中的位置可以在TouchSocket 封装和扩展查看，插件基类封装了所有接口。 下图为插件基类。 插件管理负责插件的注入和调用，通过一些扩展方法封装各种插件注入方式。 下图为插件管理： 插件的注入方式比较特别，通过反射方式找到类中所有插件接口并构造PluginMethod封装方法，该封装主要封装了异步方法，调用时会等待异步结果再进行返回。 ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:2:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"重连插件\r当客户端连接断开时，提供自动重连。 通过扩展方法提供注入接口: /// \u003csummary\u003e /// 使用断线重连。 /// \u003cpara\u003e该效果仅客户端在完成首次连接，且为被动断开时有效。\u003c/para\u003e /// \u003c/summary\u003e /// \u003cparam name=\"pluginsManager\"\u003e\u003c/param\u003e /// \u003cparam name=\"successCallback\"\u003e成功回调函数\u003c/param\u003e /// \u003cparam name=\"tryCount\"\u003e尝试重连次数，设为-1时则永远尝试连接\u003c/param\u003e /// \u003cparam name=\"printLog\"\u003e是否输出日志。\u003c/param\u003e /// \u003cparam name=\"sleepTime\"\u003e失败时，停留时间\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static IPluginsManager UseReconnection(this IPluginsManager pluginsManager, int tryCount = 10, bool printLog = false, int sleepTime = 1000, Action\u003cITcpClient\u003e successCallback = null) { var reconnectionPlugin = new ReconnectionPlugin\u003cITcpClient\u003e(client=\u003e { int tryT = tryCount; while (tryCount \u003c 0 || tryT-- \u003e 0) { try { if (client.Online) { return true; } else { client.Connect(); } successCallback?.Invoke(client); return true; } catch (Exception ex) { if (printLog) { client.Logger.Debug(LogType.Error, client, \"断线重连失败。\", ex); } Thread.Sleep(sleepTime); } } return true; }); pluginsManager.Add(reconnectionPlugin); return pluginsManager; } ReconnectionPlugin继承TcpPluginBase，并重写OnDisconnected方法。通过Task.Run异步执行。 /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"client\"\u003e\u003c/param\u003e /// \u003cparam name=\"e\"\u003e\u003c/param\u003e protected override void OnDisconnected(ITcpClientBase client, ClientDisconnectedEventArgs e) { base.OnDisconnected(client, e); if (client is ITcpClient tcpClient) { if (e.Manual) { return; } Task.Run(() =\u003e { while (true) { try { if (this.m_tryCon.Invoke((TClient)tcpClient)) { break; } } catch { } } }); } } 框架调用： 通过PluginsManager调用插件接口，注意如果e.Handled在重写的方法里置为true，将不会调用Client.DisConnected和Client.OnDisConnected。 private void PrivateOnDisconnected(ClientDisconnectedEventArgs e) { if (this.m_usePlugin) { this.PluginsManager.Raise\u003cITcpPlugin\u003e(\"OnDisconnected\", this, e); if (e.Handled) { return; } } this.OnDisconnected(e); } ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:3:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"扩展插件横切面接口\rHTTPPlugin插件扩展了HTTP协议的相关接口 在HttpSocketClient中重写HandleReceivedData方法调用插件横切面。 /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"byteBlock\"\u003e\u003c/param\u003e /// \u003cparam name=\"requestInfo\"\u003e\u003c/param\u003e protected override void HandleReceivedData(ByteBlock byteBlock, IRequestInfo requestInfo) { if (requestInfo is HttpRequest request) { this.OnReceivedHttpRequest(request); } } /// \u003csummary\u003e /// 当收到到Http请求时。覆盖父类方法将不会触发插件。 /// \u003c/summary\u003e protected virtual void OnReceivedHttpRequest(HttpRequest request) { HttpContextEventArgs args = new HttpContextEventArgs(new HttpContext(request)); switch (request.Method) { case TouchSocketHttpUtility.Get: { this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnGet\", this, args); break; } case TouchSocketHttpUtility.Post: { this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnPost\", this, args); break; } case TouchSocketHttpUtility.Put: { this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnPut\", this, args); break; } case TouchSocketHttpUtility.Delete: { this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnDelete\", this, args); break; } default: this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnReceivedOtherHttpRequest\", this, args); break; } } ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:4:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"总结\r介绍了TouchSocket插件扩展，包括插件架构，利用重写默认的TcpPluginBase的方法实现业务注入；扩展插件横切面接口，这需要重写ClientBase的相关方法实现。 ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:5:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 TouchSocket的底层使用完成端口模型，基于事件的异步模式。关于完成端口模型的基础知识可以看Socket基础 。结合上篇横切面扩展(TouchSocket 封装和扩展)可以实现各种业务需求。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:1:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"Accept\r在TcpServer类中BeginListen方法，一个监听者用一个SocketAsyncEventArgs foreach (var networkMonitor in this.m_monitors) { SocketAsyncEventArgs e = new SocketAsyncEventArgs(); e.UserToken = networkMonitor.Socket; e.Completed += this.Args_Completed; if (!networkMonitor.Socket.AcceptAsync(e)) { this.OnAccepted(e); } } ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:2:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"Receive\r在SocketClient的BeginReceive方法中，缓存区使用了内存池进行复用，该内存池的细节可以看TouchSocket 字节池和待处理池，注意在处理完缓冲区后再HandleBuffer的finally中调用byteBlock的Dispose方法，将缓存区返回内存池，如果m_holding被设置为true，则由GC自己回收。 internal void BeginReceive(ReceiveType receiveType) { if (receiveType == ReceiveType.Auto) { SocketAsyncEventArgs eventArgs = new SocketAsyncEventArgs(); eventArgs.Completed += this.EventArgs_Completed; ByteBlock byteBlock = BytePool.GetByteBlock(this.BufferLength);//内存池获取缓冲区 eventArgs.UserToken = byteBlock; eventArgs.SetBuffer(byteBlock.Buffer, 0, byteBlock.Capacity); if (!this.m_mainSocket.ReceiveAsync(eventArgs)) { this.ProcessReceived(eventArgs); } } } private void HandleBuffer(ByteBlock byteBlock) { try { if (this.ClearType.HasFlag(ClearType.Receive)) { this.m_lastTick = DateTime.Now.Ticks; } if (this.OnHandleRawBuffer?.Invoke(byteBlock) == false) { return; } if (this.UsePlugin \u0026\u0026 this.PluginsManager.Raise\u003cITcpPlugin\u003e(\"OnReceivingData\", this, new ByteBlockEventArgs(byteBlock))) { return; } if (this.m_disposedValue) { return; } if (this.m_adapter == null) { this.Logger.Debug(LogType.Error, this, ResType.NullDataAdapter.GetDescription()); return; } this.m_adapter.ReceivedInput(byteBlock); } catch (System.Exception ex) { this.Logger.Debug(LogType.Error, this, \"在处理数据时发生错误\", ex); } finally { byteBlock.Dispose();//内存池回收 } } ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:3:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"Send\rSocketClient的SocketSend方法中使用Send同步方法发送，如果异步使用异步编程模式的BeginSend方法。 protected void SocketSend(byte[] buffer, int offset, int length, bool isAsync) { if (!this.m_online) { throw new NotConnectedException(ResType.NotConnected.GetDescription()); } if (this.HandleSendingData(buffer, offset, length)) { lock (this.m_sendLocker) { if (this.UseSsl) { this.m_workStream.Write(buffer, offset, length); } else { if (isAsync) { this.m_mainSocket.BeginSend(buffer, offset, length, SocketFlags.None, null, null); } else { while (length \u003e 0) { int r = this.m_mainSocket.Send(buffer, offset, length, SocketFlags.None); if (r == 0 \u0026\u0026 length \u003e 0) { throw new Exception(\"发送数据不完全\"); } offset += r; length -= r; } } } } if (this.ClearType.HasFlag(ClearType.Send)) { this.m_lastTick = DateTime.Now.Ticks; } } } ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:4:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"Connect\r在TcpClient的Connect方法中，使用异步编程模式的BeginConnect和EndConnect方法 /// \u003csummary\u003e /// 请求连接到服务器。 /// \u003c/summary\u003e public virtual ITcpClient Connect(int timeout = 5000) { if (this.m_online) { return this; } if (this.m_disposedValue) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_config == null) { throw new ArgumentNullException(\"配置文件不能为空。\"); } IPHost iPHost = this.m_config.GetValue\u003cIPHost\u003e(TouchSocketConfigExtension.RemoteIPHostProperty); if (iPHost == null) { throw new ArgumentNullException(\"iPHost不能为空。\"); } if (this.m_mainSocket != null) { this.m_mainSocket.Dispose(); } this.m_mainSocket = this.CreateSocket(iPHost); ClientConnectingEventArgs args = new ClientConnectingEventArgs(this.m_mainSocket); this.PrivateOnConnecting(args); var result = this.m_mainSocket.BeginConnect(iPHost.EndPoint, null, null);//APM if (result.AsyncWaitHandle.WaitOne(timeout)) { if (this.m_mainSocket.Connected) { this.m_mainSocket.EndConnect(result);//APM this.LoadSocketAndReadIpPort(); if (this.m_separateThreadSend) { this.m_asyncSender.SafeDispose(); this.m_asyncSender = new AsyncSender(this.m_mainSocket, this.m_mainSocket.RemoteEndPoint, this.OnSeparateThreadSendError); } this.BeginReceive(); this.m_online = true; this.PrivateOnConnected(new MsgEventArgs(\"连接成功\")); return this; } } this.m_mainSocket.Dispose(); throw new TimeoutException(); } ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:5:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"总结\r本篇讲述底层Socket实现，使用完成端口模型和内存池提高Socket性能。 ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:6:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 Socket模型中需要考虑对各种方法的封装，需要考虑对各种业务场景的扩展，在实现业务流的同时，针对业务流的各个横切面做扩展，甚至业务流本身可以被替换。常用的扩展方式有下面几种，并按耦合从高到低的顺序：继承/泛型，接口/委托/事件，插件/扩展方法。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-15","objectID":"/2022/09/touchsocket5-encapsulationextension/:1:0","tags":["TouchSocket0.3.5","封装和扩展"],"title":"TouchSocket 封装和扩展","uri":"/2022/09/touchsocket5-encapsulationextension/"},{"categories":"TouchSocket0.3.5","content":"Socket\rSocket模型如下图： TouchSocket封装。客户端所有接口封装成TCPClient；服务端将通讯部分桥接给SocketClient，外部接口封装成TCPServer，并通过泛型将SocketClient的类型传入；数据包封装成XXHandlingAdapter；参数设置TouchSocketConfig 可扩展的横切面，横切面主要有：虚方法用于继承重写，事件委托用于订阅，插件扩展方法用于插件扩展。 服务端： 客户端： ","date":"2022-09-15","objectID":"/2022/09/touchsocket5-encapsulationextension/:2:0","tags":["TouchSocket0.3.5","封装和扩展"],"title":"TouchSocket 封装和扩展","uri":"/2022/09/touchsocket5-encapsulationextension/"},{"categories":"TouchSocket0.3.5","content":"总结\r服务端封装成TCPServer,SocketClient；客户端封装成TCPClient，将通讯包封装成XXHandlingAdapter，参数设置封装TouchSocketConfig。 通过扩展方法/插件，事件/委托，虚方法提供横切面的扩展。 ","date":"2022-09-15","objectID":"/2022/09/touchsocket5-encapsulationextension/:3:0","tags":["TouchSocket0.3.5","封装和扩展"],"title":"TouchSocket 封装和扩展","uri":"/2022/09/touchsocket5-encapsulationextension/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 读写文件是应用中必不可少的操作，也是比较经典的问题。该问题一般要求： 允许多个读者对文件执行读操作。 只允许一个写者往文件中写信息。 任一写者写完前不允许其他读者或写者工作。 写者执行写操作前应让已有读者和写者全部退出。 实现要求的逻辑代码: //声明 Semaphore rwlock=1;//读写锁 int rcount=0;//读者数量 Semaphore countlock=1;//读者数量锁 Semaphore firstwlock=1;//写优先锁 //写逻辑 Write() { while(1) { firstwlock.WaitOne(); rwlock.WaitOne(); //Todo:写文件 rwlock.Set(); firstwlock.Set(); } } //读逻辑 Reader() { while(1) { firstwlock.WaitOne(); countlock.WaitOne(); if(rcount==0) rwlock.WaitOne(); rcount++; countlock.Set(); firstwlock.Set(); //Todo:读文件 countlock.WaitOne(); rcount--; if(rcount==0) rwlock.Set(); countlock.Set(); } } 下面看一下TouchSocket文件池解析: 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-14","objectID":"/2022/09/touchsocket4-filepool/:1:0","tags":["TouchSocket0.3.5","文件池"],"title":"TouchSocket 文件池","uri":"/2022/09/touchsocket4-filepool/"},{"categories":"TouchSocket0.3.5","content":"文件池FilePool\r池的作用是复用文件池中对于大文件缓存了文件句柄，对于小文件缓存了文件内容。这样多次对文件的操作就不需要频繁创建和销毁文件句柄。提高文件操作性能。 对于缓存元数据的封装为FileStorage，也是真正对文件操作的实现类。FilePool保存其字典进行复用。 为了便于对FileStorage的操作，将读写操作封装成FileStorageReader和FileStorageWriter 在写入文件时为了保存的实时写入状态，封装了TouchRpcFileStream，并将状态信息封装成TouchRpcFileInfo。 FilePool和FileStorage类中相关操作全部加锁以保证线程安全，并通过原子操作保证FileStorage引用数量 相关类图： 读写模式的互斥通过状态保证: /// \u003csummary\u003e /// 加载文件为读取流 /// \u003c/summary\u003e /// \u003cparam name=\"path\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static void LoadFileForRead(string path) { lock (m_locker) { if (string.IsNullOrEmpty(path)) { throw new System.ArgumentException($\"“{nameof(path)}”不能为 null 或空。\", nameof(path)); } path = Path.GetFullPath(path); if (pathStream.TryGetValue(path, out FileStorage storage)) { if (storage.Access != FileAccess.Read) { throw new Exception(\"该路径的文件已经被加载为写入模式。\"); } return; } if (FileStorage.TryCreateFileStorage(path, FileAccess.Read, out FileStorage fileStorage, out string msg)) { pathStream.TryAdd(path, fileStorage); } else { throw new Exception(msg); } } } 读写操作： /// \u003csummary\u003e /// 从指定位置，读取数据到缓存区。线程安全。 /// \u003c/summary\u003e /// \u003cparam name=\"stratPos\"\u003e\u003c/param\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"length\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public int Read(long stratPos, byte[] buffer, int offset, int length) { using (WriteLock writeLock = new WriteLock(this.m_lockSlim)) { if (this.m_disposedValue) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_fileAccess != FileAccess.Read) { throw new Exception(\"该流不允许读取。\"); } if (this.m_cache) { int r = (int)Math.Min(this.m_fileData.Length - stratPos, length); Array.Copy(this.m_fileData, stratPos, buffer, offset, r); return r; } else { this.m_fileStream.Position = stratPos; return this.m_fileStream.Read(buffer, offset, length); } } } /// \u003csummary\u003e /// 从指定位置，写入数据到存储区。线程安全。 /// \u003c/summary\u003e /// \u003cparam name=\"stratPos\"\u003e\u003c/param\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"length\"\u003e\u003c/param\u003e public void Write(long stratPos, byte[] buffer, int offset, int length) { using (WriteLock writeLock = new WriteLock(this.m_lockSlim)) { if (this.m_disposedValue) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_fileAccess != FileAccess.Write) { throw new Exception(\"该流不允许写入。\"); } this.m_fileStream.Position = stratPos; this.m_fileStream.Write(buffer, offset, length); this.m_fileStream.Flush(); } } ","date":"2022-09-14","objectID":"/2022/09/touchsocket4-filepool/:2:0","tags":["TouchSocket0.3.5","文件池"],"title":"TouchSocket 文件池","uri":"/2022/09/touchsocket4-filepool/"},{"categories":"TouchSocket0.3.5","content":"总结\r讲述了经典的读写问题，介绍了TouchSocket中FilePool的封装，该封装并不复杂，但我觉得一个简单且功能强大的设计才是一个优秀的设计。 ","date":"2022-09-14","objectID":"/2022/09/touchsocket4-filepool/:3:0","tags":["TouchSocket0.3.5","文件池"],"title":"TouchSocket 文件池","uri":"/2022/09/touchsocket4-filepool/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 池是高性能组件中必不可少的东西，池最主要的功能是复用，在软件中创建和销毁对象是有成本的，消耗的资源也特别多。在需要大量使用相同或相似对象的场景下使用池，需要使用对象时去池中取，用完之后再放回到池中，避免创建和销毁对象，从而提高软件的性能。 池在设计时要注意以下几点： 池中对象的存储尽量利用高速缓冲区，这样可以更快速访问对象。 池中对象可以用原型模式加以改造。 池中对象的使用需要注意内存泄漏问题。因为对象使用完并没有销毁。 TouchSocket用到很多的池，字节池 (BytePool)、等待处理池(WaitHandlePool)、文件池(FilePool)、对象池(ObjectPool)，本文介绍字节池和等待处理池 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:1:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"字节池BytePool\r字节数组的复用是非常常见的做法，在高速IO中一定可以看见它的身影，微软对其也进行了各种封装。 TouchSocket字节池保存所有创建的字节数组，并根据数组的长度将其放在字典中等待复用，相同长度的数组通过队列进行缓存，最终字节此的样子 private static readonly ConcurrentDictionary\u003clong, BytesQueue\u003e bytesDictionary = new ConcurrentDictionary\u003clong, BytesQueue\u003e(); long:表示数组长度 BytesQueue:表示该长度数组队列。内部就是private readonly ConcurrentQueue\u003cbyte[]\u003e bytesQueue = new ConcurrentQueue\u003cbyte[]\u003e(); 字节池并没有直接对外暴露字节数组，而是将其封装成ByteBlock，字节数组的装饰对象：ByteBlock，内部使用字节数组实现功能，并装饰Stream的对象。 写入数据可以自动扩容，扩容基数1.5倍。 m_needDis控制Dispose时字节数组是否返回给池中 /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e /// \u003cparam name=\"byteSize\"\u003e默认64K\u003c/param\u003e /// \u003cparam name=\"equalSize\"\u003e默认false\u003c/param\u003e public ByteBlock(int byteSize = 1024 * 64, bool equalSize = false) { this.m_needDis = true; this.m_buffer = BytePool.GetByteCore(byteSize, equalSize); this.m_using = true; } /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e /// \u003cparam name=\"bytes\"\u003e\u003c/param\u003e public ByteBlock(byte[] bytes) { this.m_buffer = bytes ?? throw new ArgumentNullException(nameof(bytes)); this.m_length = bytes.Length; this.m_using = true; } /// \u003csummary\u003e /// 扩容增长比，默认为1.5， /// min：1.5 /// \u003c/summary\u003e public static float Ratio { get =\u003e m_ratio; set { if (value \u003c 1.5) { value = 1.5f; } m_ratio = value; } } /// \u003csummary\u003e /// 读取数据，然后递增Pos /// \u003c/summary\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"length\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e /// \u003cexception cref=\"ObjectDisposedException\"\u003e\u003c/exception\u003e public override int Read(byte[] buffer, int offset, int length) { if (!this.m_using) { throw new ObjectDisposedException(this.GetType().FullName); } int len = this.m_length - this.m_position \u003e length ? length : this.CanReadLen; Array.Copy(this.m_buffer, this.m_position, buffer, offset, len); this.m_position += len; return len; } /// \u003csummary\u003e /// 写入 /// \u003c/summary\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"count\"\u003e\u003c/param\u003e /// \u003cexception cref=\"ObjectDisposedException\"\u003e\u003c/exception\u003e public override void Write(byte[] buffer, int offset, int count) { if (count == 0) { return; } if (!this.m_using) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_buffer.Length - this.m_position \u003c count) { int need = this.m_buffer.Length + count - ((int)(this.m_buffer.Length - this.m_position)); int lend = this.m_buffer.Length; while (need \u003e lend) { lend = (int)(lend * m_ratio); } this.SetCapacity(lend, true); } Array.Copy(buffer, offset, this.m_buffer, this.m_position, count); this.m_position += count; this.m_length = Math.Max(this.m_position, this.m_length); } /// \u003csummary\u003e /// 重新设置容量 /// \u003c/summary\u003e /// \u003cparam name=\"size\"\u003e新尺寸\u003c/param\u003e /// \u003cparam name=\"retainedData\"\u003e是否保留元数据\u003c/param\u003e /// \u003cexception cref=\"ObjectDisposedException\"\u003e\u003c/exception\u003e public void SetCapacity(int size, bool retainedData = false) { if (!this.m_using) { throw new ObjectDisposedException(this.GetType().FullName); } byte[] bytes = new byte[size]; if (retainedData) { Array.Copy(this.m_buffer, 0, bytes, 0, this.m_buffer.Length); } BytePool.Recycle(this.m_buffer); this.m_buffer = bytes; } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"disposing\"\u003e\u003c/param\u003e protected sealed override void Dispose(bool disposing) { if (this.m_holding) { return; } if (this.m_needDis) { if (Interlocked.Decrement(ref this.m_dis) == 0) { GC.SuppressFinalize(this); BytePool.Recycle(this.m_buffer); this.Dis(); } } base.Dispose(disposing); } 该字节池具有如下特性 每隔1小时自动清理所有缓存的字节数组 最大缓存的不同字节数组的数量为100 回收的数组可以设置是否清零 缓存的最大字节数512M 缓存字节数组的范围1KB~20M 自动清理功能，每1个小时会自动清理池中所有的字节数组 static BytePool() { m_timer = new Timer((o) =\u003e { BytePool.Clear(); }, null, 1000 * 60 * 60, 1000 * 60 * 60);//1小时 m_keyCapacity = 100; m_autoZero = false; m_maxSize = 1024 * 1024 * 512;//512M SetBlockSize(1024, 1024 * 1024 * 20);//1KB~ 20M AddSizeKey(10240);//10KB } /// \u003csummary\u003e /// 清理 /// \u003c/summary\u003e public static void Clear() { bytesDictionary.Clear(); GC.Collect(); } /// \u003csummary\u003e /// 获取内存核心。获取的核心可以不用归还。 /// \u003c/summary\u003e /// \u003cparam name=\"byteSize\"\u003e\u003c/param\u003e /// \u003cparam na","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:2:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"等待处理池WaitHandlePool\u003cT\u003e\r该池的主要是为了复用WaitData\u003cT\u003e对象，该对象的功能是：交由外部系统处理对象并返回数据。当给外部系统发送命令，等待外部系统执行命令，并在规定时间内返回数据。 该功能的传统实现方式是： 创建命令队列，将所有已发送外部系统的命令装进命令队列中，同时记录命令的发送时间； 当外部系统返回数据时，去队列中找到对应的命令执行命令成功的方法；如果命令队列中没有对应的命令，调用未知数据处理方法； 设置定时器定期扫描命令队列，将超期没有接收到返回数据的命令移除，并调用对应命令异常执行方法； 该池的实现方式是构造WaitData\u003cT\u003e对象集合，发送命令前构建WaitData对象，发送完命令后该对象使用信号量阻塞发送命令的线程，当收到返回数据时，信号量置位继续执行，处理对应接收数据；信号量阻塞的时候可以设置阻塞时间，时间到则执行对应异常方法。 由于WaitData对象需要构建信号量，创建和销毁的代价比较大。WaitHandlePool构建 ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e waitQueue;队列保存空闲WaitData。 ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e waitQueue;保存所有已经使用WaitData。 /// \u003csummary\u003e /// 等待数据对象 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public class WaitData\u003cT\u003e : DisposableObject { private WaitDataStatus m_status; private readonly AutoResetEvent m_waitHandle; private T m_waitResult; /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e public WaitData() { this.m_waitHandle = new AutoResetEvent(false); } /// \u003csummary\u003e /// 状态 /// \u003c/summary\u003e public WaitDataStatus Status =\u003e this.m_status; /// \u003csummary\u003e /// 等待数据结果 /// \u003c/summary\u003e public T WaitResult =\u003e this.m_waitResult; /// \u003csummary\u003e /// 取消任务 /// \u003c/summary\u003e public void Cancel() { this.m_status = WaitDataStatus.Canceled; this.m_waitHandle.Set(); } /// \u003csummary\u003e /// 释放 /// \u003c/summary\u003e /// \u003cparam name=\"disposing\"\u003e\u003c/param\u003e protected override void Dispose(bool disposing) { this.m_status = WaitDataStatus.Disposed; this.m_waitResult = default; this.m_waitHandle.Dispose(); base.Dispose(disposing); } /// \u003csummary\u003e /// Reset。 /// 设置\u003csee cref=\"WaitResult\"/\u003e为null。然后重置状态为\u003csee cref=\"WaitDataStatus.Default\"/\u003e，waitHandle.Reset() /// \u003c/summary\u003e public bool Reset() { this.m_status = WaitDataStatus.Default; this.m_waitResult = default; return this.m_waitHandle.Reset(); } /// \u003csummary\u003e /// 使等待的线程继续执行 /// \u003c/summary\u003e public bool Set() { this.m_status = WaitDataStatus.SetRunning; return this.m_waitHandle.Set(); } /// \u003csummary\u003e /// 使等待的线程继续执行 /// \u003c/summary\u003e /// \u003cparam name=\"waitResult\"\u003e等待结果\u003c/param\u003e public bool Set(T waitResult) { this.m_waitResult = waitResult; this.m_status = WaitDataStatus.SetRunning; return this.m_waitHandle.Set(); } /// \u003csummary\u003e /// 加载取消令箭 /// \u003c/summary\u003e /// \u003cparam name=\"cancellationToken\"\u003e\u003c/param\u003e public void SetCancellationToken(CancellationToken cancellationToken) { if (cancellationToken.CanBeCanceled) { cancellationToken.Register(this.Cancel); } } /// \u003csummary\u003e /// 载入结果 /// \u003c/summary\u003e public void SetResult(T result) { this.m_waitResult = result; } /// \u003csummary\u003e /// 等待指定毫秒 /// \u003c/summary\u003e /// \u003cparam name=\"millisecond\"\u003e\u003c/param\u003e public WaitDataStatus Wait(int millisecond) { if (!this.m_waitHandle.WaitOne(millisecond)) { this.m_status = WaitDataStatus.Overtime; } return this.m_status; } } /// \u003csummary\u003e /// 等待处理数据 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public class WaitHandlePool\u003cT\u003e : IDisposable where T : IWaitResult { private readonly SnowflakeIDGenerator idGenerator; private readonly ConcurrentDictionary\u003clong, WaitData\u003cT\u003e\u003e waitDic; private readonly ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e waitQueue; /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e public WaitHandlePool() { this.waitDic = new ConcurrentDictionary\u003clong, WaitData\u003cT\u003e\u003e(); this.waitQueue = new ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e(); this.idGenerator = new SnowflakeIDGenerator(4); } /// \u003csummary\u003e /// 销毁 /// \u003c/summary\u003e /// \u003cparam name=\"waitData\"\u003e\u003c/param\u003e public void Destroy(WaitData\u003cT\u003e waitData) { if (waitData.DisposedValue) { throw new ObjectDisposedException(nameof(waitData)); } if (this.waitDic.TryRemove(waitData.WaitResult.Sign, out _)) { waitData.Reset(); this.waitQueue.Enqueue(waitData); } } /// \u003csummary\u003e /// 释放 /// \u003c/summary\u003e public void Dispose() { foreach (var item in this.waitDic.Values) { item.Dispose(); } foreach (var item in this.waitQueue) { item.Dispose(); } this.waitDic.Clear(); this.waitQueue.Clear(); } /// \u003csummary\u003e /// 获取一个可等待对象 /// \u003c/summary\u003e /// \u003cparam name=\"result\"\u003e\u003c/param\u003e /// \u003cparam name=\"autoSign\"\u003e设置为false时，不会生成sign\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public WaitData\u003cT\u003e GetWaitData(T result, bool autoSign = true) { WaitData\u003cT\u003e waitData; if (this.waitQ","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:3:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"总结\r主要介绍了字节池和等待处理池，详细介绍了相关特性和业务功能的实现。对于等待处理池我觉得还可以使用TaskCompletionSource\u003cTResult\u003e来实现，消耗比信号量更小，同时是异步执行，不会阻塞线程。 ","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:4:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 容器现在已经成为各种组件的标配了，为什么容器这么火，确实是太好用了。 表面上容器解决的是耦合问题，实际上容器实现了框架对流程的控制。 表面的耦合问题：没有容器，高层逻辑想要实现某个具体功能，只能依赖某个具体类或者具体工厂。当变化越来越多，改动越来越大，具体类之间依赖关系就像麻绳。里氏替换和依赖倒置根本无法实现。容器的出现将所有的具体类都保存在容器中，实现依赖倒置和里氏替换，系统高层和底层实现解耦。 框架对流程的控制问题：框架实现了整个应用流程的编排，流程中肯定需要具体的执行类。一旦依赖某个执行类就无法应对变化，具体类和流程严重耦合。整个框架就像被焊死，无法应对任何变化。容器就像是活页，连接着具体类和框架流程，当具体类发生变化，对框架没有任何影响，这也就使得框架的应用范围更广，实现的功能更多，框架中任何部件都是可以改变的。 唯一不变的就是改变，如果没有改变，也就不需要任何模式了。我们痛恨变化，同时也热爱变化，在痛苦中追求无限可能。 言归正传，TouchSocket框架实现了一个简易版的依赖注入容器。一起来看一下。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-09","objectID":"/2022/09/touchsocket2-dependencyinjection/:1:0","tags":["TouchSocket0.3.5","依赖注入容器"],"title":"TouchSocket 依赖注入容器","uri":"/2022/09/touchsocket2-dependencyinjection/"},{"categories":"TouchSocket0.3.5","content":"依赖注入\r简单点，容器其实就是一个字典，一个包含一个key和具体类的字典，将框架中所有依赖具体类的地方换成key，当执行到key的时候去字典中根据key取出具体类就可以了。 当然字典也需要生成，就是在应用开始的时候根据需求构建出字典。以后即使变化，也只变化开始构建的部分，最大程度减少修改。 真正的容器就是将字典改造一下，既然由容器管理，就应该负责到底，管理具体类的生命周期，什么时候创建，什么时候销毁，怎么创建。 首先字典中的具体类需要改造一下，变成描述类。 生命周期分为:单例，瞬态，域。 /// \u003csummary\u003e /// 注入依赖对象 /// \u003c/summary\u003e public class DependencyDescriptor { /// \u003csummary\u003e /// 初始化一个单例实例。 /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"instance\"\u003e\u003c/param\u003e public DependencyDescriptor(Type fromType, object instance) { this.FromType = fromType; this.ToInstance = instance; this.Lifetime = Lifetime.Singleton; this.ToType = instance.GetType(); } /// \u003csummary\u003e /// 初始化一个完整的服务注册 /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"toType\"\u003e\u003c/param\u003e /// \u003cparam name=\"lifetime\"\u003e\u003c/param\u003e public DependencyDescriptor(Type fromType, Type toType, Lifetime lifetime) { this.FromType = fromType; this.Lifetime = lifetime; this.ToType = toType; } /// \u003csummary\u003e /// 实例类型 /// \u003c/summary\u003e public Type ToType { get; } /// \u003csummary\u003e /// 实例 /// \u003c/summary\u003e public object ToInstance { get; set; } /// \u003csummary\u003e /// 生命周期 /// \u003c/summary\u003e public Lifetime Lifetime { get; } /// \u003csummary\u003e /// 注册类型 /// \u003c/summary\u003e public Type FromType { get; } } /// \u003csummary\u003e /// 注入项的生命周期。 /// \u003c/summary\u003e public enum Lifetime { /// \u003csummary\u003e /// 单例对象 /// \u003c/summary\u003e Singleton, /// \u003csummary\u003e /// 以\u003csee cref=\"IScopedContainer\"/\u003e接口为区域实例单例。 /// \u003c/summary\u003e Scoped, /// \u003csummary\u003e /// 瞬时对象 /// \u003c/summary\u003e Transient } 字典中的key改成FromType+Name。 最终字典变成了 private readonly ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e registrations = new ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e();这样。 看一下怎么实现注入和解析的。下面是原代码，Resolve方法根据生命周期实现解析逻辑；Create方法负责创建，同时各种注入方式；Register实现构建字典。 该容器有一些特点： 在注入容器时，提供了一个Name，key被构建成FromType+Name。这样的好处是可以根据Name来获取具体类。 同时对于多态的问题，同一个接口的多个实现没有实现注入，只能通过Name来区别了。 如果FromType不是抽象类，不需要注入，也可以Resolve出来。 Resolve会根据所有构造函数参数的个数最多的那个构造函数。 可以使用DependencyInject，DependencyParamterInject特性进行控制。 实现了构造函数注入，属性注入和方法注入 /// \u003csummary\u003e /// IOC容器 /// \u003c/summary\u003e public class Container : IContainer { private readonly ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e registrations = new ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e(); /// \u003csummary\u003e /// 初始化一个IOC容器 /// \u003c/summary\u003e public Container() { this.RegisterSingleton\u003cIContainer\u003e(this); } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public bool IsRegistered(Type fromType, string key = \"\") { return this.registrations.ContainsKey($\"{fromType.FullName}{key}\"); } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"descriptor\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e public void Register(DependencyDescriptor descriptor, string key = \"\") { string k = $\"{descriptor.FromType.FullName}{key}\"; this.registrations.AddOrUpdate(k, descriptor, (k, v) =\u003e { return descriptor; }); } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"ps\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public object Resolve(Type fromType, object[] ps = null, string key = \"\") { if (fromType == typeof(IScopedContainer)) { return this.GetScopedContainer(); } string k; DependencyDescriptor descriptor; if (fromType.IsGenericType) { Type type = fromType.GetGenericTypeDefinition(); k = $\"{type.FullName}{key}\"; if (this.registrations.TryGetValue(k, out descriptor)) { if (descriptor.Lifetime == Lifetime.Singleton) { if (descriptor.ToInstance != null) { return descriptor.ToInstance; } lock (descriptor) { if (descriptor.ToInstance != null) { return descriptor.ToInstance; } if (descriptor.ToType.IsGenericType) { return descriptor.ToInstance = this.Create(descriptor.ToType.MakeGenericType(fromType.GetGenericArguments()), ps); } else { return descriptor.ToInstance = this.Create(descriptor.ToType, ps); } } } if (descriptor.ToType.IsGenericType) { return this.Create(descriptor.ToType.MakeGenericType(fromType.GetGenericArguments()), ps); } el","date":"2022-09-09","objectID":"/2022/09/touchsocket2-dependencyinjection/:2:0","tags":["TouchSocket0.3.5","依赖注入容器"],"title":"TouchSocket 依赖注入容器","uri":"/2022/09/touchsocket2-dependencyinjection/"},{"categories":"TouchSocket0.3.5","content":"总结\r该容器虽然简单，但是足够使用，小巧紧致，非常值得学习。不需要注入直接解析对象的方式，虽然有点违反依赖倒置原则，但是在使用中确实是一个非常实用的功能。有一点缺陷是没有实现Dispose和瞬态对象的弱引用，当域生命周期结束的时候，Dispose容器同时销毁所有域创建出的瞬态对象。 ","date":"2022-09-09","objectID":"/2022/09/touchsocket2-dependencyinjection/:3:0","tags":["TouchSocket0.3.5","依赖注入容器"],"title":"TouchSocket 依赖注入容器","uri":"/2022/09/touchsocket2-dependencyinjection/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 该框架实现了广泛的Socket应用，NAT，各种RPC，文件传输，WebAPI，WebSocket，非常优秀的框架，学习一下，有问题可以相互探讨。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index 本章主要介绍TouchSocket的主要特性之一：依赖属性 ","date":"2022-09-07","objectID":"/2022/09/touchsocket1-dependencyproperties/:1:0","tags":["TouchSocket0.3.5","依赖属性"],"title":"TouchSocket 依赖属性","uri":"/2022/09/touchsocket1-dependencyproperties/"},{"categories":"TouchSocket0.3.5","content":"依赖属性\r用过WPF都知道依赖属性，其是绑定，动画，样式的基础，提供了属性值，更改通知等功能，该框架中的依赖属性相当于简易版本，提供了应用的思路。 依赖属性可以看成是Key和Value的封装。依赖属性类：名称，所属类型，值类型和值，还包含了一个工厂方法，用来创建依赖属性，创建时可以提供初始值。 /// \u003csummary\u003e /// 依赖项属性 /// \u003c/summary\u003e [DebuggerDisplay(\"Name={Name},Type={ValueType}\")] public class DependencyProperty { /// \u003csummary\u003e /// 属性名称 /// \u003c/summary\u003e protected string m_name; /// \u003csummary\u003e /// 所属类型 /// \u003c/summary\u003e protected Type m_owner; /// \u003csummary\u003e /// 值类型 /// \u003c/summary\u003e protected Type m_valueType; private object m_value; /// \u003csummary\u003e /// 依赖项属性 /// \u003c/summary\u003e private DependencyProperty() { } /// \u003csummary\u003e /// 默认值 /// \u003c/summary\u003e public object DefauleValue =\u003e this.m_value; /// \u003csummary\u003e /// 属性名 /// \u003c/summary\u003e public string Name =\u003e this.m_name; /// \u003csummary\u003e /// 所属类型 /// \u003c/summary\u003e public Type Owner =\u003e this.m_owner; /// \u003csummary\u003e /// 值类型 /// \u003c/summary\u003e public Type ValueType =\u003e this.m_valueType; internal void DataValidation(object value) { if (value == null) { if (typeof(ValueType).IsAssignableFrom(this.m_valueType)) { throw new Exception($\"属性“{this.m_name}”赋值类型不允许出现Null\"); } } else if (!this.m_valueType.IsAssignableFrom(value.GetType())) { throw new Exception($\"属性“{this.m_name}”赋值类型与注册类型不一致，应当注入“{this.m_valueType}”类型\"); } } internal void SetDefauleValue(object value) { this.DataValidation(value); this.m_value = value; } /// \u003csummary\u003e /// 注册依赖项属性。 /// \u003cpara\u003e依赖属性的默认值，可能会应用于所有的\u003csee cref=\"IDependencyObject\"/\u003e\u003c/para\u003e /// \u003c/summary\u003e /// \u003cparam name=\"propertyName\"\u003e\u003c/param\u003e /// \u003cparam name=\"valueType\"\u003e\u003c/param\u003e /// \u003cparam name=\"owner\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e依赖项属性值，一般该值应该是值类型，因为它可能会被用于多个依赖对象。\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static DependencyProperty Register(string propertyName, Type valueType, Type owner, object value) { DependencyProperty dp = new DependencyProperty { m_name = propertyName, m_valueType = valueType, m_owner = owner }; dp.SetDefauleValue(value); return dp; } } 如何管理依赖属性，类中创建依赖属性，并设置和获取依赖属性的值。首先实现接口，可以获取和设置依赖属性的值，实现一个基类，实现该接口，所有包含依赖属性的类继承该基类，就可以实现操作依赖属性了。 该框架做了进一步扩展，在基类中添加了一个依赖属性字典，可以添加外部依赖属性。 也就是在基类中保存了一个Key，Value的字典，通过特定的Key获取到Value，在配置的时候特别有用，配置类Option/Config怎么应对变化，写组件的时候发现配置项多需要添加属性怎么办，修改配置项，违反开放封闭原则；使用继承，显得太重；增加一个配置类，还不如使用继承。 把配置项修改成字典，所有信息通过key,value保存，可以应对开放封闭原则。显然该框架就说这样干的，key是依赖属性，vlaue是依赖属性的值。 /// \u003csummary\u003e /// 依赖对象接口 /// \u003c/summary\u003e public interface IDependencyObject : System.IDisposable { /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e object GetValue(DependencyProperty dp); /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public T GetValue\u003cT\u003e(DependencyProperty dp); /// \u003csummary\u003e /// 设置依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e\u003c/param\u003e public DependencyObject SetValue(DependencyProperty dp, object value); } /// \u003csummary\u003e /// 依赖项对象. /// 线程安全。 /// \u003c/summary\u003e public class DependencyObject : DisposableObject, IDependencyObject, System.IDisposable { /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e public DependencyObject() { this.m_dp = new ConcurrentDictionary\u003cDependencyProperty, object\u003e(); } [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)] private readonly ConcurrentDictionary\u003cDependencyProperty, object\u003e m_dp; /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public object GetValue(DependencyProperty dp) { if (this.m_dp.TryGetValue(dp, out object value)) { return value; } else { return dp.DefauleValue; } } /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public T GetValue\u003cT\u003e(DependencyProperty dp) { try { return (T)this.GetValue(dp); } catch { return default; } } /// \u003csummary\u003e /// 设置依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e\u003c/param\u003e public DependencyObject SetValue(DependencyProperty dp, object value) { dp.DataValidation(value); if (this.m_dp.ContainsKey(dp)) { this.m_dp[dp] = value; } els","date":"2022-09-07","objectID":"/2022/09/touchsocket1-dependencyproperties/:2:0","tags":["TouchSocket0.3.5","依赖属性"],"title":"TouchSocket 依赖属性","uri":"/2022/09/touchsocket1-dependencyproperties/"},{"categories":"TouchSocket0.3.5","content":"总结\r依赖属性这样的应用方式非常优秀，满足了扩展开放，单一职责。如果有其他的应用方式欢迎评论。 ","date":"2022-09-07","objectID":"/2022/09/touchsocket1-dependencyproperties/:3:0","tags":["TouchSocket0.3.5","依赖属性"],"title":"TouchSocket 依赖属性","uri":"/2022/09/touchsocket1-dependencyproperties/"},{"categories":"算法","content":"实现队列的一些思路\r数组的优劣： 读取：连续的地址空间，数组全部或者部分元素被连续存在CPU缓存里面，读取速度非常快。 插入/删除/扩容：插入和删除，需要修改该元素之前或之后所有元素的位置，扩容时需要重新找较大的内存块，将原数组中所有数据复制到新内存块中。这些操作都非常耗时。 链表的优劣： 读取：链表的节点分散在堆空间中，无法利用CPU缓存，读写速度比较慢，是数组的33倍 插入/删除/扩容：不需要改变原来元素的位置，仅仅修改节点信息即可。但是频繁的插入删除会导致堆中有大量碎片化内存。 链表每个节点不仅需要保存数据还需要保存下一个节点的位置。 较好的方式是结合数组和链表的优势，用链表节点将固定大小的数组连接起来组成大的内存块，即易于扩展又在一定范围内保持良好的访问速度。 在需要构建内存池，缓存队列等应用场景中均可使用此方法进行优化。 ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:1:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"队列接口\rpublic interface IQueue\u003cTItem\u003e : IEnumerable\u003cTItem\u003e, IDisposable { bool IsEmpty { get; } int Length { get; } void Enqueue(TItem item); TItem Dequeue(); } ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:2:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"基于数组的扩容队列\rpublic class SGResizingArrayQueue\u003cTItem\u003e : IQueue\u003cTItem\u003e { public SGResizingArrayQueue() { _first = 0; _last = 0; _items = new TItem[2]; } public IEnumerator\u003cTItem\u003e GetEnumerator() { if (!IsEmpty) { for (var i = _first; i \u003c _last; i++) { yield return _items[i]; } } } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } public void Dispose() { Dispose(true); } protected virtual void Dispose(bool disposing) { if (disposing) { if (!IsEmpty) { for (var i = _first; i \u003c _last; i++) { _items[i] = default; } _items = null; } } } private TItem[] _items; private int _first; private int _last; public bool IsEmpty =\u003e (_last - _first) == 0; public int Length =\u003e _last - _first; private void resize(int size) { var temitems = new TItem[size]; var temlength = Length; Array.Copy(_items, _first, temitems, 0, Length); _first = 0; _last = temlength; _items = temitems; } public void Enqueue(TItem item) { if (_last == _items.Length) resize(Length * 2); _items[_last++] = item; } public TItem Dequeue() { if (IsEmpty) return default; var item = _items[_first++]; if (Length \u003c _items.Length / 4) resize(_items.Length / 2); return item; } } ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:3:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"基于链表的扩容队列\rpublic class SGLinkedQueue\u003cTItem\u003e : IQueue\u003cTItem\u003e { private Node _first; private Node _last; private int _length; public SGLinkedQueue() { _length = 0; } private class Node { public TItem Item { set; get; } public Node Next { set; get; } } public IEnumerator\u003cTItem\u003e GetEnumerator() { if (!IsEmpty) { var temnode = _first; while (temnode != default) { var item = temnode.Item; temnode = temnode.Next; yield return item; } } } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } public void Dispose() { Dispose(true); } protected virtual void Dispose(bool disposing) { if (disposing) { if (!IsEmpty) { var temfirst = _first; while (temfirst != default) { temfirst.Item = default; temfirst = temfirst.Next; } _length = 0; } } } public bool IsEmpty =\u003e _length == 0; public int Length =\u003e _length; public void Enqueue(TItem item) { var temnode = _last; _last = new Node(); _last.Item = item; _last.Next = null; if (IsEmpty) _first = _last; else temnode.Next = _last; _length++; } public TItem Dequeue() { if (_length \u003e 0) { var temitem = _first.Item; _first = _first.Next; _length--; return temitem; } return default; } } ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:4:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"结合数组和链表的扩容队列\rclass SGArraySegment\u003cTItem\u003e { public TItem[] Array { get; private set; } public SGArraySegment\u003cTItem\u003e Next { get; set; } public int Offset { get; set; } public int End { get; set; } = -1; public SGArraySegment(TItem[] array) { Array = array; } public bool IsAvailable { get { return Array.Length \u003e (End + 1); } } public void Write(TItem value) { Array[++End] = value; } } class SGPipeQueue\u003cTItem\u003e : IValueTaskSource\u003cTItem\u003e, IDisposable { private const int _segmentSize = 5; private SGArraySegment\u003cTItem\u003e _first; private SGArraySegment\u003cTItem\u003e _current; private object _syncRoot = new object(); private static readonly ArrayPool\u003cTItem\u003e _pool = ArrayPool\u003cTItem\u003e.Shared; private ManualResetValueTaskSourceCore\u003cTItem\u003e _taskSourceCore; private bool _waiting = false; private bool _lastReadIsWait = false; private int _length; public SGPipeQueue() { SetBufferSegment(CreateSegment()); _taskSourceCore = new ManualResetValueTaskSourceCore\u003cTItem\u003e(); } SGArraySegment\u003cTItem\u003e CreateSegment() { return new SGArraySegment\u003cTItem\u003e(_pool.Rent(_segmentSize)); } void SetBufferSegment(SGArraySegment\u003cTItem\u003e segment) { if (_first == null) _first = segment; var current = _current; if (current != null) current.Next = segment; _current = segment; } public int Write(TItem target) { lock (_syncRoot) { if (_waiting) { _waiting = false; _taskSourceCore.SetResult(target); return _length; } var current = _current; if (!current.IsAvailable) { current = CreateSegment(); SetBufferSegment(current); } current.Write(target); _length++; return _length; } } public ValueTask\u003cTItem\u003e ReadAsync() { lock (_syncRoot) { if (TryRead(out TItem value)) { if (_lastReadIsWait) { _taskSourceCore.Reset(); _lastReadIsWait = false; } _length--; if (_length == 0) OnWaitTaskStart(); return new ValueTask\u003cTItem\u003e(value); } _waiting = true; _lastReadIsWait = true; _taskSourceCore.Reset(); OnWaitTaskStart(); return new ValueTask\u003cTItem\u003e(this, _taskSourceCore.Version); } } private bool TryRead(out TItem value) { var first = _first; if (first.Offset \u003c first.End) { value = first.Array[first.Offset]; first.Array[first.Offset] = default; first.Offset++; return true; } else if (first.Offset == first.End) { if (first == _current) { value = first.Array[first.Offset]; first.Array[first.Offset] = default; first.Offset = 0; first.End = -1; return true; } else { value = first.Array[first.Offset]; first.Array[first.Offset] = default; _first = first.Next; _pool.Return(first.Array); return true; } } value = default; return false; } protected virtual void OnWaitTaskStart() { } public virtual void Clear() { lock (_syncRoot) { if (_lastReadIsWait) { _taskSourceCore.Reset(); _lastReadIsWait = false; } var first = _first; if (first.Offset \u003c= first.End) { while (first != _current) { for (int i = first.Offset; i \u003c= first.End; i++) { first.Array[i] = default; } _first = first.Next; _pool.Return(first.Array); first = _first; } for (int i = first.Offset; i \u003c= first.End; i++) { first.Array[i] = default; } first.Offset = 0; first.End = -1; } } } public void Dispose() { lock (_syncRoot) { var segment = _first; while (segment != null) { _pool.Return(segment.Array); segment = segment.Next; } _first = null; _current = null; } } TItem IValueTaskSource\u003cTItem\u003e.GetResult(short token) { return _taskSourceCore.GetResult(token); } ValueTaskSourceStatus IValueTaskSource\u003cTItem\u003e.GetStatus(short token) { return _taskSourceCore.GetStatus(token); } void IValueTaskSource\u003cTItem\u003e.OnCompleted(Action\u003cobject?\u003e continuation, object? state, short token, ValueTaskSourceOnCompletedFlags flags) { _taskSourceCore.OnCompleted(continuation, state, token, flags); } } 该队列额外实现2个功能，以提高队列的性能： 异步出队列，当队列为空时，异步等待。 当压入队列时，如果发现有异步等待对象，则不进入队列，直接给等待对象。 ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:5:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":null,"content":"关于我\r92年，儿子、丈夫、父亲，新时代农民工。 从事上位机开发多年，熟悉制药(层析超滤)和IVD(生化免疫)设备软件。 喜欢研究和学习各类技术，保持好奇心，持续探索。 熟悉的编程语言：C#,C,C++,Vue。 可以通过邮件978089234@qq.com与我联系！ Blog\r小时候夏天很长，长大了一年很短。每天都感觉很忙碌，却不知道在忙些什么。 想要记录些东西，证明那些年真的存在过。 写的文章，分享的想法观点可能早就有人写过，分享过。但自我成长和探索，是贯穿一生的事情。而在这个过程中，记录显得尤为重要，因为没有记录就没有发生，没有记录就会被遗忘。整理自己学到的，记录自己有共鸣的，对世界输出一些什么，通过创造来学习更多。 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]