[{"categories":"LeeCode","content":"题目\r题目链接 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。 示例 1： 输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2： 输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3： 输入：nums = [], target = 0 输出：[-1,-1] 提示： 0 \u003c= nums.length \u003c= 105 -109 \u003c= nums[i] \u003c= 109 nums 是一个非递减数组 -109 \u003c= target \u003c= 109 ","date":"2022-11-16","objectID":"/2022/11/leecode34/:0:1","tags":["LeeCode","34","数组","查找第一个和最后一个位置"],"title":"LeeCode-34-数组-查找第一个和最后一个位置","uri":"/2022/11/leecode34/"},{"categories":"LeeCode","content":"解题\r二分法类似题，解题方案和前面两个相似 存在的变化，有重复数据，需要返回两个位置 尝试使用二分，找到值的序号后，向左，向右定位到上下限。 public int[] Search(int[] nums, int target) { //[left，right] var left = 0; var right = nums.Length - 1; var result = new int[] {-1, -1}; var mid = 0; while (left \u003c= right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { var min = mid; while (--min\u003e=left)//确定下限，使用遍历 { if(nums[min] != target) break; } result[0] = min + 1; var max = mid; while (++max \u003c= right)//确定上限，使用遍历 { if (nums[max] != target) break; } result[1] = max-1; break; } else if (target\u003cnums[mid]) { right = mid - 1; } else { left = mid + 1; } } return result; } 如果数组中的重复项比较多，中间使用遍历可以优化为二分，同时判定目标值是否在数组中也改成递归进行统一。 public int[] SearchPlus(int[] nums, int target) { var result = new int[] { -1, -1 }; if (nums.Length == 0) return result; //[left，right] var left = 0; var right = nums.Length - 1; var mid = 0; //遍历定位左右限，type 0:返回下限序号，1返回上限序号 ,2找到即返回, //返回[left right,index] int[] InnterSearch(int[] nums, int target, int left, int right, int type) { if (left \u003c= right) { mid = (left + right) \u003e\u003e 1; if (type == 2 \u0026\u0026 target == nums[mid]) { return new[] {left, right, mid}; } else if ( target \u003c nums[mid]||(type == 0 \u0026\u0026 target == nums[mid])) { right = mid - 1; } else if (target \u003e nums[mid] || (type == 1 \u0026\u0026 target == nums[mid])) { left = mid + 1; } return InnterSearch(nums, target, left, right, type); } if (type == 2)//不在数组中 { return new[] {left, right, -1}; } var index = type==1 ? left-1 : right+1; return new[] {left, right, nums[index] == target ? index : -1}; } var indexarray = InnterSearch(nums, target, left, right, 2);//数组中存在 if (indexarray[2] == -1) return result; result[0]= InnterSearch(nums, target, indexarray[0], indexarray[2], 0)[2];//找到下限 [left,mid]中二分 result[1] = InnterSearch(nums, target, indexarray[2], indexarray[1], 1)[2];//找到上限 [mid,right]中二分 return result; } InnterSearch方法承担了三个职责，目标值是否在数组中，寻找上限，寻找下限。导致内部实现用了很多的判定，看上去有点乱，通过字典封装判断逻辑，一目了然，如果以后需求变化，改动字典即可，尽可能满足开放封闭原则。 public int[] SearchPlusPro(int[] nums, int target) { var result = new int[] { -1, -1 }; if (nums.Length == 0) return result; //[left，right] var left = 0; var right = nums.Length - 1; var mid = 0; //遍历定位左右限，type 0:返回下限序号，1返回上限序号 ,2找到即返回, //返回[left right,index] var searchtypes = new Dictionary\u003cint, Func\u003cint[], int, int, int,int, int[]\u003e\u003e() { {//下限 0, (_nums, _target, _left, _right,_mid) =\u003e { if (_target \u003c= _nums[_mid]) { _right = _mid - 1; } else //target\u003enums[mid] { _left = _mid + 1; } return new []{_left,_right,-1}; } }, {//上限 1, (_nums, _target, _left, _right,_mid) =\u003e { if (_target \u003c _nums[_mid]) { _right = _mid - 1; } else //target\u003e=nums[mid] { _left = _mid + 1; } return new []{_left,_right,-1}; } }, {//找到立即返回 2, (_nums, _target, _left, _right,_mid) =\u003e { if (_target == _nums[_mid]) { return new[] {_left, _right, _mid}; } else if ( _target \u003c _nums[_mid]) { _right = _mid - 1; } else { _left = _mid + 1; } return new []{_left,_right,-1}; } } }; int[] InnterSearch(int[] nums, int target, int left, int right, int type) { if (left \u003c= right) { mid = (left + right) \u003e\u003e 1; var temresult = searchtypes[type](nums, target, left, right, mid); if (temresult[2] != -1) return temresult; return InnterSearch(nums, target, temresult[0], temresult[1], type); } return new[] {left, right, -1}; } var indexarray = InnterSearch(nums, target, left, right, 2);//数组中存在 if (indexarray[2] == -1) return result; result[0] = InnterSearch(nums, target, indexarray[0], indexarray[2], 0)[0];//找到下限 [left,mid]中二分 result[1] = InnterSearch(nums, target, indexarray[2], indexarray[1], 1)[1];//找到上限 [mid,right]中二分 return result; } ","date":"2022-11-16","objectID":"/2022/11/leecode34/:0:2","tags":["LeeCode","34","数组","查找第一个和最后一个位置"],"title":"LeeCode-34-数组-查找第一个和最后一个位置","uri":"/2022/11/leecode34/"},{"categories":"LeeCode","content":"网络解析\r网络解析有以下几种方式： 对数组使用两次二分查找上限和下限。 先判断目标在数组中，再使用二分查找上下限 public class Solution { public int[] SearchRange(int[] nums, int target) { if (nums.Length == 0) return new int[] { -1, -1 }; int l = binarySearch(nums, target, true); int r = binarySearch(nums, target, false) - 1; if (l \u003c= r \u0026\u0026 r \u003c nums.Length \u0026\u0026 nums[l] == target \u0026\u0026 nums[r] == target) return new int[] { l, r }; return new int[] { -1, -1 }; } int binarySearch(int[] nums,int target,bool lower) { int n = nums.Length; int l = 0, r = n - 1; while (l \u003c= r) { int m = (l + r) / 2; if (nums[m] \u003e target || (lower \u0026\u0026 nums[m] \u003e= target)) { r = m - 1; n = m; } else l = m + 1; } return n; } } public class Solution { public int[] SearchRange(int[] nums, int target) { int[] res = new int[2]; int left=0; int right = nums.Length-1; while(left\u003c= right) { int mid = left+(right-left)/2; if(nums[mid] \u003ctarget) { left = mid+1; }else if(nums[mid] \u003etarget) { right = mid-1; }else if (nums[mid]==target) { right = mid-1; } } if(left==nums.Length) { res[0] = -1; }else { res[0] = nums[left]==target?left:-1; } left=0; right = nums.Length-1; while(left\u003c= right) { int mid = left+(right-left)/2; if(nums[mid] \u003ctarget) { left = mid+1; }else if(nums[mid] \u003etarget) { right = mid-1; }else if (nums[mid]==target) { left = mid+1; } } if(left-1 \u003c0) { res[1] = -1; }else { res[1] = nums[left-1]==target?left-1:-1; } return res; } } ","date":"2022-11-16","objectID":"/2022/11/leecode34/:0:3","tags":["LeeCode","34","数组","查找第一个和最后一个位置"],"title":"LeeCode-34-数组-查找第一个和最后一个位置","uri":"/2022/11/leecode34/"},{"categories":"LeeCode","content":"题目\r题目链接 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例 1: 输入: nums = [1,3,5,6], target = 5 输出: 2 示例 2: 输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3: 输入: nums = [1,3,5,6], target = 7 输出: 4 提示: 1 \u003c= nums.length \u003c= 104 -104 \u003c= nums[i] \u003c= 104 nums 为 无重复元素 的 升序 排列数组 -104 \u003c= target \u003c= 104 解题\r","date":"2022-11-15","objectID":"/2022/11/leecode35/:0:0","tags":["LeeCode","35","数组","搜索插入位置"],"title":"LeeCode-35-数组-搜索插入位置","uri":"/2022/11/leecode35/"},{"categories":"LeeCode","content":"二分\r思考，排序数组，无重复，升序，规定时间复杂度，好像只有二分了，递归是否可以，因为递归也是Logn public int Search(int[] nums, int target) { //[left,right] var left = 0; var right = nums.Length - 1; var mid = 0; while (left \u003c= right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { left = mid; break; } else if (target\u003cnums[mid]) { right = mid - 1; } else { left = mid + 1; } } return left; } public int SearchPlus(int[] nums, int target) { //[right,left) var left = 0; var right = nums.Length; var mid = 0; while (left != right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { left = mid; break; } else if (target \u003c nums[mid]) { right = mid; } else { left = mid + 1; } } return left; } ","date":"2022-11-15","objectID":"/2022/11/leecode35/:1:0","tags":["LeeCode","35","数组","搜索插入位置"],"title":"LeeCode-35-数组-搜索插入位置","uri":"/2022/11/leecode35/"},{"categories":"LeeCode","content":"递归\rpublic int SearchPro(int[] nums, int target) { //[right,left] var left = 0; var right = nums.Length - 1; var mid = 0; int InnerCore(int[] nums, int target, int left, int right) { if (left \u003c= right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { return mid; } else if (target \u003c nums[mid]) { return InnerCore(nums, target, left, mid-1); } else { return InnerCore(nums, target, mid + 1, right); } } return left; } return InnerCore(nums,target,left,right); } public int SearchProPlus(int[] nums, int target) { //[right,left) var left = 0; var right = nums.Length; var mid = 0; int InnerCore(int[] nums, int target, int left, int right) { if (left != right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { return mid; } else if (target \u003c nums[mid]) { return InnerCore(nums, target, left, mid); } else { return InnerCore(nums, target, mid + 1, right); } } return left; } return InnerCore(nums, target, left, right); } 网络解析\rpublic int SearchInsert(int[] nums, int target) { int searchIdx; int searchLower = 0, searchHigher = nums.Length - 1; int middle = 0; while (searchLower \u003c= searchHigher) { middle = searchLower + (searchHigher - searchLower) / 2; if (nums[middle] == target) { return middle; } if (nums[middle] \u003e target) { searchHigher = middle - 1; } else { searchLower = middle + 1; } } if (target \u003c= nums[middle]) return middle; if (target \u003e nums[middle]) return middle + 1; return -1; } public class Solution { public int SearchInsert(int[] nums, int target) { return Rank(nums,0,nums.Length - 1,target); } public int Rank(int[] arr,int left,int right,int target) { if(target \u003c arr[left]) return left; if(target \u003e arr[right]) return right + 1; int mid = (left + right)/2; if(target == arr[mid]) return mid; if(target\u003carr[mid]) return Rank(arr,left,mid-1,target); else return Rank(arr,mid+1,right,target); } } ","date":"2022-11-15","objectID":"/2022/11/leecode35/:2:0","tags":["LeeCode","35","数组","搜索插入位置"],"title":"LeeCode-35-数组-搜索插入位置","uri":"/2022/11/leecode35/"},{"categories":"LeeCode","content":"题目\r给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示: 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 解题\r如果使用遍历，最好情况O(1)，最坏情况O(n)。 使用二分法是O(logn)。 尝试使用二分，二分肯定有上下限和中间值，通过中间值和目标值比较，不断缩小上下限最后得到结果。 从中考虑While的判断是什么？ 上下限的范围怎么划定？ 初版： public int Search(int[] nums, int target) { var maxindex = nums.Length-1; var minindex = 0; var index = (maxindex + minindex) / 2; while (maxindex != minindex) { if (target == nums[index]) { break; } if (target \u003c nums[index]) { maxindex = index; } else { minindex = index+1; } index = (maxindex + minindex) / 2; } if (target == nums[index]) return index; return -1; } 测试用例通过了，但是有效率不高，有很多重复代码，改进一下 public int SearchPro(int[] nums, int target) { var maxindex = nums.Length - 1; var minindex = 0; var midindex=0; while (minindex\u003c=maxindex) { midindex = (maxindex + minindex) / 2; if (target == nums[midindex]) { return midindex; } if (target \u003c nums[midindex]) { maxindex = midindex - 1; } else { minindex = midindex + 1; } } return -1; } 最佳答案 public int StandardSearch(int[] nums, int target) { int left = 0, right = nums.Length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } if (nums[mid] \u003e target) { right = mid - 1; } else { left = mid + 1; } } return -1; } 对比： 想一下变量用left和right应该更简介一点。mid在循环体中声明，每次会在栈中创建新的临时变量。 网络解析\rtarget 是在一个在左闭右闭的区间里，也就是[left, right] ，这种就是上面的标准写法 while (left \u003c= right) 要使用 \u003c= ，因为left == right是有意义的，所以使用 \u003c= if (nums[middle] \u003e target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 target 是在一个在左闭右开的区间里，也就是[left, right) while (left \u003c right)，这里使用 \u003c ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] \u003e target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] public int SearchPlus(int[] nums, int target) { var maxindex = nums.Length; var minindex = 0; var midindex = 0; while (minindex \u003c maxindex) { midindex = (maxindex + minindex) / 2; if (target == nums[midindex]) { return midindex; } if (target \u003c nums[midindex]) { maxindex = midindex; } else { minindex = midindex+1; } } return -1; } ","date":"2022-11-14","objectID":"/2022/11/leecode704/:0:0","tags":["LeeCode","704","数组","二分查找"],"title":"LeeCode-704-数组-二分查找","uri":"/2022/11/leecode704/"},{"categories":"DotNet基础","content":"概述\r高性能的套接字编程围绕着两个方面：异步和复用。异步：高性能就是最大化计算机资源的利用，是不可能让线程有阻塞的，所以就有了各种异步模式。复用：计算机资源最好是能重复使用的，频繁的创建和销毁相同的对象也是对资源的浪费，所以就有了各种池和零拷贝；CPU在访问相邻资源的时候有特别的优势可以利用缓存区，所以池中对象尽量相邻创建。 Socket套接字编程历史悠久，发展出好几种方式，对应着DotNet异步编程的发展，分别：异步编程模式(Asynchronous Programming Model ,APM)、基于事件的异步模式(Event-based Asynchronous Pattern ,EAP)和基于任务的异步模式(Task-based Asynchronous Pattern,TAP)。 本文将简要介绍几种异步编程对应Socket的实现，每一种都写了一个简单的Socket服务端以供学习。 ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:1:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"面向连接的套接字\r套接字流程如下，在Accept，Read，Write，Connect和Disconnect方法均涉及到异步编程。为什么会异步，简单来说就是线程执行速度很快，网络传输的IO速度很慢，线程发出IO操作的指令后，不可能一直等待指令执行完。所以线程设置一个回调函数的入口地址，让IO执行完之后调用该入口地址，之后线程就去干其他事情了，等该IO调用该入口地址，线程再回来继续工作。 ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:2:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"阻塞式套接字\rSocket接口，下面是用阻塞方法创建的一个简单服务端。可以分析出该服务的性能是很差的，没有做任何的异步和复用。 //服务端 public static void Run(string m_ip, int m_port) { var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); var ip = IPAddress.Parse(m_ip); var endpoint = new IPEndPoint(ip, m_port); socket.Bind(endpoint); socket.Listen(0); socket.ReceiveTimeout = -1; //线程池中后台线程执行 Task.Run(() =\u003e { while (true) { var acceptSocket = socket.Accept();//线程阻塞等待连接请求队列 if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { //线程池中后台线程执行 Task.Run(() =\u003e { byte[] receiveBuffer = new byte[1024];//每一个连接都在重新创建缓冲区 int result = 0; do { if (acceptSocket.Connected) { result = acceptSocket.Receive(receiveBuffer, 0, receiveBuffer.Length, SocketFlags.None, out SocketError error);//线程阻塞等待缓冲区数据 if (error == SocketError.Success \u0026\u0026 result \u003e 0) { var recestr = Encoding.UTF8.GetString(receiveBuffer, 0, result); var Replaystr = $\"Server收到消息:{recestr};Server收到消息的时间:{DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss:fff\")}\"; var strbytes = Encoding.UTF8.GetBytes(Replaystr); acceptSocket.Send(strbytes, 0, strbytes.Length, SocketFlags.None);//线程阻塞等待发送完缓冲区数据 if (recestr.Contains(\"stop\")) { break; } } } else { break; } } while (result \u003e 0); }).ContinueWith((t) =\u003e { System.Threading.Thread.Sleep(1000); acceptSocket.Disconnect(false); acceptSocket.Dispose(); }); } } }).Wait(); } ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:3:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"异步编程模式(Asynchronous Programming Model ,APM)\rBeginXXX方法并不会阻塞线程，而EndXXX会，dotnet提供Task\u003cT\u003e.Factory.FromAsync可以将APM转成TAP模式异步模式以提高性能，下面提供一个示例，同时使用ArrayPool复用缓冲区，处理分包，粘包等问。 public static Socket Run(string m_ip, int m_port) { var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); var ip = IPAddress.Any; if (!string.IsNullOrEmpty(m_ip)) { ip = IPAddress.Parse(m_ip); } var endpoint = new IPEndPoint(ip, m_port); socket.Bind(endpoint); Console.WriteLine($\"[{DateTime.Now.GetFormString()}] Server Established localEndpoint:[{socket.LocalEndPoint.ToString()}]\"); socket.Listen(200); socket.ReceiveTimeout = -1; //后台线程执行 Task.Run(async () =\u003e { while (true) { var acceptSocket = await Task\u003cSocket\u003e.Factory.FromAsync( socket.BeginAccept(null,null) ,socket.EndAccept);//APM转TAP异步 if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { //后台线程来处理Receive逻辑 var task = Task.Run(async () =\u003e { byte[] buffer = ArrayPool\u003cbyte\u003e.Shared.Rent(1024);//从内存池中获取缓冲区 var bytesBuffered = 0; var bytesConsumed = 0; while (true) { if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { var temremaining = bytesBuffered - bytesConsumed; if (temremaining == 0)//缓存区全部解析完 { bytesBuffered = 0; bytesConsumed = 0; } else if (temremaining \u003c buffer.Length \u0026\u0026 temremaining \u003e 0)//最后一个包不完整，部分数据未解析 { var newbuffer = ArrayPool\u003cbyte\u003e.Shared.Rent(buffer.Length); Buffer.BlockCopy(buffer, bytesConsumed, newbuffer, 0, temremaining); ArrayPool\u003cbyte\u003e.Shared.Return(buffer); buffer = newbuffer; bytesBuffered = temremaining; bytesConsumed = 0; } else //包不够大，分包了 { var newbuffer = ArrayPool\u003cbyte\u003e.Shared.Rent(buffer.Length * 2); Buffer.BlockCopy(buffer, 0, newbuffer, 0, buffer.Length); ArrayPool\u003cbyte\u003e.Shared.Return(buffer); buffer = newbuffer; } var bytesRemaining = buffer.Length - bytesBuffered; try { var bytesread = await Task\u003cint\u003e.Factory.FromAsync( acceptSocket.BeginReceive(buffer, bytesBuffered, bytesRemaining, SocketFlags.None, null, null), acceptSocket.EndReceive);//APM转TAP异步 if (bytesread == 0) { break; } bytesbuffered += bytesread; var lineposition = -1; do { lineposition = array.indexof(buffer, (byte)0x23, bytesconsumed,bytesbuffered - bytesconsumed); if (lineposition \u003e= 0) { var lineLength = linePosition - bytesConsumed; ProcessLine(acceptSocket, buffer, bytesConsumed, bytesread); bytesConsumed += bytesread; } } while (linePosition \u003e= 0);//包解析 } catch (Exception e) { break; } } else { break; } } ArrayPool\u003cbyte\u003e.Shared.Return(buffer); }).ContinueWith((t) =\u003e { Console.WriteLine($\"[{DateTime.Now.GetFormString()}] ServerClient Disconnected localEndpoint:[{acceptSocket?.LocalEndPoint.ToString()}] remoteEndpoint:[{acceptSocket?.RemoteEndPoint.ToString()}]\"); acceptSocket?.Shutdown(SocketShutdown.Both); acceptSocket?.Close(); acceptSocket = null; }); } } }); return socket; } ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:4:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"基于事件异步的完成端口模型(Event-based Asynchronous Pattern ,EAP)\r目前应用最广的Socket模型，完成端口模型还是按照\"回调函数\"的方式进行来实现异步，其本质是线程池，该线程池的核心工作就是去调用IO操作完成时的回调函数。另外因为IO操作毕竟是慢速的操作，所以几个线程就已经足可以应付成千上万的输入输出完成操作的请求(前提就是你的回调函数做的工作要足够少)，所以这个模型的性能是非常高的。也是现在Windows平台上性能最好的输入输出模型。自定义构造了内存池，将一大块内存切分成一定数据量的连续小内存，分别分配给不同的SocketAsyncEventArgs对象以提高服务性能，非常巴适；目前看到的FastSocket,SuperSocket,TouchSocket,NewLife等网络框架均采用这种模式，最主要的原因是应用范围广。 框架 版本 .NET Core 1.0, Core 1.1, Core 2.0, Core 2.1, Core 2.2, Core 3.0, Core 3.1, 5, 6, 7 Preview 7 .NET Framework 2.0, 3.0, 3.5, 4.0, 4.5, 4.5.1, 4.5.2, 4.6, 4.6.1, 4.6.2, 4.7, 4.7.1, 4.7.2, 4.8 .NET Standard 1.3, 1.4, 1.6, 2.0, 2.1 UWP 10.0 Xamarin.iOS 10.8 Xamarin.Mac 3.0 public class MyIOCPSocket { private static int m_numConnections;//最大连接数 private static int m_receiveBufferSize;//接收缓存区数量 private static int m_sendBufferSize;//发送缓存区大小 private static byte[] m_receivebuffer;//接收缓存区 private static Stack\u003cint\u003e m_freeReceiveIndexPool;//可用的接收缓存索引栈 private static int m_currentReceiveIndex;//当前的接收缓存区索引 private static byte[] m_sendbuffer;//发送缓存区 private static Stack\u003cint\u003e m_freeSendIndexPool;//可用的发送缓存索引栈 private static int m_currentSendIndex;//当前的发送缓存区索引 private static Stack\u003cSocketAsyncEventArgs\u003e m_ReadPool;//接收SocketAsyncEventArgs池 private static Stack\u003cSocketAsyncEventArgs\u003e m_WritePool;//发送SocketAsyncEventArgs池 private static Semaphore m_maxNumberAcceptedClients;//最大连接锁 private static int m_numConnectedSockets;//连接的Socket数量 private static int m_totalBytesRead;//总的接收字节数 private static Socket listenSocket;//监听Socket public static void Run(string m_ip, int m_port, int numConnections, int m_receiveBuffer, int m_sentBuffer) { //初始化 m_numConnections = numConnections; m_receiveBufferSize = m_receiveBuffer; m_sendBufferSize = m_sentBuffer; m_receivebuffer = new byte[m_receiveBufferSize * m_numConnections]; m_freeReceiveIndexPool = new Stack\u003cint\u003e(); m_currentReceiveIndex = 0; m_sendbuffer = new byte[m_sendBufferSize * m_numConnections]; m_freeSendIndexPool = new Stack\u003cint\u003e(); m_currentSendIndex = 0; m_ReadPool = new Stack\u003cSocketAsyncEventArgs\u003e(m_numConnections); m_WritePool = new Stack\u003cSocketAsyncEventArgs\u003e(m_numConnections); m_maxNumberAcceptedClients = new Semaphore(m_numConnections, m_numConnections); m_numConnectedSockets = 0; m_totalBytesRead = 0; //接收缓存分配 for (int i = 0; i \u003c m_numConnections; i++) { var readEventArg = new SocketAsyncEventArgs(); readEventArg.Completed += new EventHandler\u003cSocketAsyncEventArgs\u003e(ReadWriteIOComleted); readEventArg.UserToken = new AsyncUserToken(); if (m_freeReceiveIndexPool.Count \u003e 0) { readEventArg.SetBuffer(m_receivebuffer, m_freeReceiveIndexPool.Pop(), m_receiveBufferSize); } else { if ((m_receiveBufferSize * m_numConnections - m_receiveBufferSize) \u003c m_currentReceiveIndex) { new ArgumentException(\"接收缓存设置异常\"); } readEventArg.SetBuffer(m_receivebuffer, m_currentReceiveIndex, m_receiveBufferSize); m_currentReceiveIndex += m_receiveBufferSize; } m_ReadPool.Push(readEventArg); //发送缓存分配 var writeEventArg = new SocketAsyncEventArgs(); writeEventArg.Completed += new EventHandler\u003cSocketAsyncEventArgs\u003e(ReadWriteIOComleted); writeEventArg.UserToken = new AsyncUserToken(); if (m_freeSendIndexPool.Count \u003e 0) { writeEventArg.SetBuffer(m_sendbuffer, m_freeSendIndexPool.Pop(), m_sendBufferSize); } else { if ((m_sendBufferSize * m_numConnections - m_sendBufferSize) \u003c m_currentSendIndex) { new ArgumentException(\"发送缓存设置异常\"); } writeEventArg.SetBuffer(m_sendbuffer, m_currentSendIndex, m_sendBufferSize); m_currentSendIndex += m_sendBufferSize; } m_WritePool.Push(writeEventArg); } //设置监听socket listenSocket = new Socket(new IPEndPoint(IPAddress.Parse(m_ip), m_port).AddressFamily, SocketType.Stream, ProtocolType.Tcp); //绑定端口 listenSocket.Bind(new IPEndPoint(IPAddress.Parse(m_ip), m_port)); listenSocket.Listen(100); StartAccept(null); Console.WriteLine(\"Press any key to terminate the server process....\"); Console.ReadKey(); } public static void ReadWriteIOComleted(object sender, SocketAsyncEventArgs e) { switch (e.LastOperation) { case SocketAsyncO","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:5:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"基于任务的异步模式(Task-based Asynchronous Pattern,TAP)\r相对于前几个模型，基于任务的网络模型是比较新的模型，但是性能是最好的，最主要的原因是微软提供了System.Net.Sockets.SocketTaskExtensions封装TAP的异步方法；System.IO.Pipelines管道模型，在 .NET 中执行高性能 I/O 更加容易。该管道可以实现流量控制和反压。PipeScheduler可以进行回调线程控制。PipeReader和PipeWriter封装了对内存数据的直接操作，实现零拷贝得以大大提供业务流的性能。可惜的是应用范围比较小，目前框架只支持2.1, 2.2, 3.0, 3.1, 5, 6, 7 Preview 7，Framework不支持。 private static Pipe pipe; public static Socket Run(string m_ip, int m_port) { //监听Socket var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); var ip = IPAddress.Parse(m_ip); var endpoint = new IPEndPoint(ip, m_port); socket.Bind(endpoint); //绑定端口和IP socket.Listen(200); //允许同时监听的队列 socket.ReceiveTimeout = -1; Task.Run(async () =\u003e { while (true) { var acceptSocket = await socket.AcceptAsync(); //TAP异步接收 if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { pipe = new Pipe(); var writer = pipe.Writer; var reader = pipe.Reader; var writetaskr = Task.Run(async () =\u003e { while (true) { var memory = writer.GetMemory(1024); try { //TAP 异步读取数据 int bytesRead = await acceptSocket.ReceiveAsync(memory, SocketFlags.None); if (bytesRead == 0) { break; } //告诉 PipeWriter 写入多少数据。 writer.Advance(bytesRead); } catch (Exception e) { break; } //刷新写入 FlushResult result = await writer.FlushAsync(); if (result.IsCompleted) { break; } } // 完成写入 await writer.CompleteAsync(); }).ContinueWith((t) =\u003e { acceptSocket?.Shutdown(SocketShutdown.Both); //acceptSocket?.Disconnect(true); acceptSocket?.Dispose(); acceptSocket = null; }); var readingtask= Task.Run(async() =\u003e { while (true) { try { //从管道中读取 ReadResult result = await reader.ReadAsync(); ReadOnlySequence\u003cbyte\u003e buffer = result.Buffer; while (TryReadLine(ref buffer, out ReadOnlySequence\u003cbyte\u003e line))//解析 { ProcessLine(acceptSocket, line); } //实际读了多少 reader.AdvanceTo(buffer.Start, buffer.End); //是否写已经结束 if (result.IsCompleted) { break; } } catch (Exception e) { break; } } await reader.CompleteAsync(); }).ContinueWith((t) =\u003e { acceptSocket?.Shutdown(SocketShutdown.Both); acceptSocket?.Dispose(); acceptSocket = null; } ); } } }); return socket; } ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:6:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"总结\r主要讲述在套接字编程中，如何实现异步和复用以提高性能。讲述了异步编程(APM)、基于事件的异步模型(EAP)和基于任务的异步模型(TAP)；复用方面从内存池(ArrayPool)，到自定义构建内存池(利用高速缓存)和完成端口池，再到最新的管道模型，实现零拷贝。 ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:7:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 TouchSocket提供插件方式的扩展，这种方式对原框架的耦合较小。用插件基类封装了底层框架中所有的插件扩展接口，插件子类重写对应的接口就可注入相关业务。框架插件的注入和调用通过PluginsManager进行管理。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:1:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"插件架构\r插件接口在框架中的位置可以在TouchSocket 封装和扩展查看，插件基类封装了所有接口。 下图为插件基类。 插件管理负责插件的注入和调用，通过一些扩展方法封装各种插件注入方式。 下图为插件管理： 插件的注入方式比较特别，通过反射方式找到类中所有插件接口并构造PluginMethod封装方法，该封装主要封装了异步方法，调用时会等待异步结果再进行返回。 ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:2:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"重连插件\r当客户端连接断开时，提供自动重连。 通过扩展方法提供注入接口: /// \u003csummary\u003e /// 使用断线重连。 /// \u003cpara\u003e该效果仅客户端在完成首次连接，且为被动断开时有效。\u003c/para\u003e /// \u003c/summary\u003e /// \u003cparam name=\"pluginsManager\"\u003e\u003c/param\u003e /// \u003cparam name=\"successCallback\"\u003e成功回调函数\u003c/param\u003e /// \u003cparam name=\"tryCount\"\u003e尝试重连次数，设为-1时则永远尝试连接\u003c/param\u003e /// \u003cparam name=\"printLog\"\u003e是否输出日志。\u003c/param\u003e /// \u003cparam name=\"sleepTime\"\u003e失败时，停留时间\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static IPluginsManager UseReconnection(this IPluginsManager pluginsManager, int tryCount = 10, bool printLog = false, int sleepTime = 1000, Action\u003cITcpClient\u003e successCallback = null) { var reconnectionPlugin = new ReconnectionPlugin\u003cITcpClient\u003e(client=\u003e { int tryT = tryCount; while (tryCount \u003c 0 || tryT-- \u003e 0) { try { if (client.Online) { return true; } else { client.Connect(); } successCallback?.Invoke(client); return true; } catch (Exception ex) { if (printLog) { client.Logger.Debug(LogType.Error, client, \"断线重连失败。\", ex); } Thread.Sleep(sleepTime); } } return true; }); pluginsManager.Add(reconnectionPlugin); return pluginsManager; } ReconnectionPlugin继承TcpPluginBase，并重写OnDisconnected方法。通过Task.Run异步执行。 /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"client\"\u003e\u003c/param\u003e /// \u003cparam name=\"e\"\u003e\u003c/param\u003e protected override void OnDisconnected(ITcpClientBase client, ClientDisconnectedEventArgs e) { base.OnDisconnected(client, e); if (client is ITcpClient tcpClient) { if (e.Manual) { return; } Task.Run(() =\u003e { while (true) { try { if (this.m_tryCon.Invoke((TClient)tcpClient)) { break; } } catch { } } }); } } 框架调用： 通过PluginsManager调用插件接口，注意如果e.Handled在重写的方法里置为true，将不会调用Client.DisConnected和Client.OnDisConnected。 private void PrivateOnDisconnected(ClientDisconnectedEventArgs e) { if (this.m_usePlugin) { this.PluginsManager.Raise\u003cITcpPlugin\u003e(\"OnDisconnected\", this, e); if (e.Handled) { return; } } this.OnDisconnected(e); } ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:3:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"扩展插件横切面接口\rHTTPPlugin插件扩展了HTTP协议的相关接口 在HttpSocketClient中重写HandleReceivedData方法调用插件横切面。 /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"byteBlock\"\u003e\u003c/param\u003e /// \u003cparam name=\"requestInfo\"\u003e\u003c/param\u003e protected override void HandleReceivedData(ByteBlock byteBlock, IRequestInfo requestInfo) { if (requestInfo is HttpRequest request) { this.OnReceivedHttpRequest(request); } } /// \u003csummary\u003e /// 当收到到Http请求时。覆盖父类方法将不会触发插件。 /// \u003c/summary\u003e protected virtual void OnReceivedHttpRequest(HttpRequest request) { HttpContextEventArgs args = new HttpContextEventArgs(new HttpContext(request)); switch (request.Method) { case TouchSocketHttpUtility.Get: { this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnGet\", this, args); break; } case TouchSocketHttpUtility.Post: { this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnPost\", this, args); break; } case TouchSocketHttpUtility.Put: { this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnPut\", this, args); break; } case TouchSocketHttpUtility.Delete: { this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnDelete\", this, args); break; } default: this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnReceivedOtherHttpRequest\", this, args); break; } } ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:4:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"总结\r介绍了TouchSocket插件扩展，包括插件架构，利用重写默认的TcpPluginBase的方法实现业务注入；扩展插件横切面接口，这需要重写ClientBase的相关方法实现。 ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:5:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 TouchSocket的底层使用完成端口模型，基于事件的异步模式。关于完成端口模型的基础知识可以看Socket基础 。结合上篇横切面扩展(TouchSocket 封装和扩展)可以实现各种业务需求。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:1:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"Accept\r在TcpServer类中BeginListen方法，一个监听者用一个SocketAsyncEventArgs foreach (var networkMonitor in this.m_monitors) { SocketAsyncEventArgs e = new SocketAsyncEventArgs(); e.UserToken = networkMonitor.Socket; e.Completed += this.Args_Completed; if (!networkMonitor.Socket.AcceptAsync(e)) { this.OnAccepted(e); } } ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:2:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"Receive\r在SocketClient的BeginReceive方法中，缓存区使用了内存池进行复用，该内存池的细节可以看TouchSocket 字节池和待处理池，注意在处理完缓冲区后再HandleBuffer的finally中调用byteBlock的Dispose方法，将缓存区返回内存池，如果m_holding被设置为true，则由GC自己回收。 internal void BeginReceive(ReceiveType receiveType) { if (receiveType == ReceiveType.Auto) { SocketAsyncEventArgs eventArgs = new SocketAsyncEventArgs(); eventArgs.Completed += this.EventArgs_Completed; ByteBlock byteBlock = BytePool.GetByteBlock(this.BufferLength);//内存池获取缓冲区 eventArgs.UserToken = byteBlock; eventArgs.SetBuffer(byteBlock.Buffer, 0, byteBlock.Capacity); if (!this.m_mainSocket.ReceiveAsync(eventArgs)) { this.ProcessReceived(eventArgs); } } } private void HandleBuffer(ByteBlock byteBlock) { try { if (this.ClearType.HasFlag(ClearType.Receive)) { this.m_lastTick = DateTime.Now.Ticks; } if (this.OnHandleRawBuffer?.Invoke(byteBlock) == false) { return; } if (this.UsePlugin \u0026\u0026 this.PluginsManager.Raise\u003cITcpPlugin\u003e(\"OnReceivingData\", this, new ByteBlockEventArgs(byteBlock))) { return; } if (this.m_disposedValue) { return; } if (this.m_adapter == null) { this.Logger.Debug(LogType.Error, this, ResType.NullDataAdapter.GetDescription()); return; } this.m_adapter.ReceivedInput(byteBlock); } catch (System.Exception ex) { this.Logger.Debug(LogType.Error, this, \"在处理数据时发生错误\", ex); } finally { byteBlock.Dispose();//内存池回收 } } ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:3:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"Send\rSocketClient的SocketSend方法中使用Send同步方法发送，如果异步使用异步编程模式的BeginSend方法。 protected void SocketSend(byte[] buffer, int offset, int length, bool isAsync) { if (!this.m_online) { throw new NotConnectedException(ResType.NotConnected.GetDescription()); } if (this.HandleSendingData(buffer, offset, length)) { lock (this.m_sendLocker) { if (this.UseSsl) { this.m_workStream.Write(buffer, offset, length); } else { if (isAsync) { this.m_mainSocket.BeginSend(buffer, offset, length, SocketFlags.None, null, null); } else { while (length \u003e 0) { int r = this.m_mainSocket.Send(buffer, offset, length, SocketFlags.None); if (r == 0 \u0026\u0026 length \u003e 0) { throw new Exception(\"发送数据不完全\"); } offset += r; length -= r; } } } } if (this.ClearType.HasFlag(ClearType.Send)) { this.m_lastTick = DateTime.Now.Ticks; } } } ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:4:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"Connect\r在TcpClient的Connect方法中，使用异步编程模式的BeginConnect和EndConnect方法 /// \u003csummary\u003e /// 请求连接到服务器。 /// \u003c/summary\u003e public virtual ITcpClient Connect(int timeout = 5000) { if (this.m_online) { return this; } if (this.m_disposedValue) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_config == null) { throw new ArgumentNullException(\"配置文件不能为空。\"); } IPHost iPHost = this.m_config.GetValue\u003cIPHost\u003e(TouchSocketConfigExtension.RemoteIPHostProperty); if (iPHost == null) { throw new ArgumentNullException(\"iPHost不能为空。\"); } if (this.m_mainSocket != null) { this.m_mainSocket.Dispose(); } this.m_mainSocket = this.CreateSocket(iPHost); ClientConnectingEventArgs args = new ClientConnectingEventArgs(this.m_mainSocket); this.PrivateOnConnecting(args); var result = this.m_mainSocket.BeginConnect(iPHost.EndPoint, null, null);//APM if (result.AsyncWaitHandle.WaitOne(timeout)) { if (this.m_mainSocket.Connected) { this.m_mainSocket.EndConnect(result);//APM this.LoadSocketAndReadIpPort(); if (this.m_separateThreadSend) { this.m_asyncSender.SafeDispose(); this.m_asyncSender = new AsyncSender(this.m_mainSocket, this.m_mainSocket.RemoteEndPoint, this.OnSeparateThreadSendError); } this.BeginReceive(); this.m_online = true; this.PrivateOnConnected(new MsgEventArgs(\"连接成功\")); return this; } } this.m_mainSocket.Dispose(); throw new TimeoutException(); } ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:5:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"总结\r本篇讲述底层Socket实现，使用完成端口模型和内存池提高Socket性能。 ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:6:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 Socket模型中需要考虑对各种方法的封装，需要考虑对各种业务场景的扩展，在实现业务流的同时，针对业务流的各个横切面做扩展，甚至业务流本身可以被替换。常用的扩展方式有下面几种，并按耦合从高到低的顺序：继承/泛型，接口/委托/事件，插件/扩展方法。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-15","objectID":"/2022/09/touchsocket5-encapsulationextension/:1:0","tags":["TouchSocket0.3.5","封装和扩展"],"title":"TouchSocket 封装和扩展","uri":"/2022/09/touchsocket5-encapsulationextension/"},{"categories":"TouchSocket0.3.5","content":"Socket\rSocket模型如下图： TouchSocket封装。客户端所有接口封装成TCPClient；服务端将通讯部分桥接给SocketClient，外部接口封装成TCPServer，并通过泛型将SocketClient的类型传入；数据包封装成XXHandlingAdapter；参数设置TouchSocketConfig 可扩展的横切面，横切面主要有：虚方法用于继承重写，事件委托用于订阅，插件扩展方法用于插件扩展。 服务端： 客户端： ","date":"2022-09-15","objectID":"/2022/09/touchsocket5-encapsulationextension/:2:0","tags":["TouchSocket0.3.5","封装和扩展"],"title":"TouchSocket 封装和扩展","uri":"/2022/09/touchsocket5-encapsulationextension/"},{"categories":"TouchSocket0.3.5","content":"总结\r服务端封装成TCPServer,SocketClient；客户端封装成TCPClient，将通讯包封装成XXHandlingAdapter，参数设置封装TouchSocketConfig。 通过扩展方法/插件，事件/委托，虚方法提供横切面的扩展。 ","date":"2022-09-15","objectID":"/2022/09/touchsocket5-encapsulationextension/:3:0","tags":["TouchSocket0.3.5","封装和扩展"],"title":"TouchSocket 封装和扩展","uri":"/2022/09/touchsocket5-encapsulationextension/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 读写文件是应用中必不可少的操作，也是比较经典的问题。该问题一般要求： 允许多个读者对文件执行读操作。 只允许一个写者往文件中写信息。 任一写者写完前不允许其他读者或写者工作。 写者执行写操作前应让已有读者和写者全部退出。 实现要求的逻辑代码: //声明 Semaphore rwlock=1;//读写锁 int rcount=0;//读者数量 Semaphore countlock=1;//读者数量锁 Semaphore firstwlock=1;//写优先锁 //写逻辑 Write() { while(1) { firstwlock.WaitOne(); rwlock.WaitOne(); //Todo:写文件 rwlock.Set(); firstwlock.Set(); } } //读逻辑 Reader() { while(1) { firstwlock.WaitOne(); countlock.WaitOne(); if(rcount==0) rwlock.WaitOne(); rcount++; countlock.Set(); firstwlock.Set(); //Todo:读文件 countlock.WaitOne(); rcount--; if(rcount==0) rwlock.Set(); countlock.Set(); } } 下面看一下TouchSocket文件池解析: 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-14","objectID":"/2022/09/touchsocket4-filepool/:1:0","tags":["TouchSocket0.3.5","文件池"],"title":"TouchSocket 文件池","uri":"/2022/09/touchsocket4-filepool/"},{"categories":"TouchSocket0.3.5","content":"文件池FilePool\r池的作用是复用文件池中对于大文件缓存了文件句柄，对于小文件缓存了文件内容。这样多次对文件的操作就不需要频繁创建和销毁文件句柄。提高文件操作性能。 对于缓存元数据的封装为FileStorage，也是真正对文件操作的实现类。FilePool保存其字典进行复用。 为了便于对FileStorage的操作，将读写操作封装成FileStorageReader和FileStorageWriter 在写入文件时为了保存的实时写入状态，封装了TouchRpcFileStream，并将状态信息封装成TouchRpcFileInfo。 FilePool和FileStorage类中相关操作全部加锁以保证线程安全，并通过原子操作保证FileStorage引用数量 相关类图： 读写模式的互斥通过状态保证: /// \u003csummary\u003e /// 加载文件为读取流 /// \u003c/summary\u003e /// \u003cparam name=\"path\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static void LoadFileForRead(string path) { lock (m_locker) { if (string.IsNullOrEmpty(path)) { throw new System.ArgumentException($\"“{nameof(path)}”不能为 null 或空。\", nameof(path)); } path = Path.GetFullPath(path); if (pathStream.TryGetValue(path, out FileStorage storage)) { if (storage.Access != FileAccess.Read) { throw new Exception(\"该路径的文件已经被加载为写入模式。\"); } return; } if (FileStorage.TryCreateFileStorage(path, FileAccess.Read, out FileStorage fileStorage, out string msg)) { pathStream.TryAdd(path, fileStorage); } else { throw new Exception(msg); } } } 读写操作： /// \u003csummary\u003e /// 从指定位置，读取数据到缓存区。线程安全。 /// \u003c/summary\u003e /// \u003cparam name=\"stratPos\"\u003e\u003c/param\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"length\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public int Read(long stratPos, byte[] buffer, int offset, int length) { using (WriteLock writeLock = new WriteLock(this.m_lockSlim)) { if (this.m_disposedValue) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_fileAccess != FileAccess.Read) { throw new Exception(\"该流不允许读取。\"); } if (this.m_cache) { int r = (int)Math.Min(this.m_fileData.Length - stratPos, length); Array.Copy(this.m_fileData, stratPos, buffer, offset, r); return r; } else { this.m_fileStream.Position = stratPos; return this.m_fileStream.Read(buffer, offset, length); } } } /// \u003csummary\u003e /// 从指定位置，写入数据到存储区。线程安全。 /// \u003c/summary\u003e /// \u003cparam name=\"stratPos\"\u003e\u003c/param\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"length\"\u003e\u003c/param\u003e public void Write(long stratPos, byte[] buffer, int offset, int length) { using (WriteLock writeLock = new WriteLock(this.m_lockSlim)) { if (this.m_disposedValue) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_fileAccess != FileAccess.Write) { throw new Exception(\"该流不允许写入。\"); } this.m_fileStream.Position = stratPos; this.m_fileStream.Write(buffer, offset, length); this.m_fileStream.Flush(); } } ","date":"2022-09-14","objectID":"/2022/09/touchsocket4-filepool/:2:0","tags":["TouchSocket0.3.5","文件池"],"title":"TouchSocket 文件池","uri":"/2022/09/touchsocket4-filepool/"},{"categories":"TouchSocket0.3.5","content":"总结\r讲述了经典的读写问题，介绍了TouchSocket中FilePool的封装，该封装并不复杂，但我觉得一个简单且功能强大的设计才是一个优秀的设计。 ","date":"2022-09-14","objectID":"/2022/09/touchsocket4-filepool/:3:0","tags":["TouchSocket0.3.5","文件池"],"title":"TouchSocket 文件池","uri":"/2022/09/touchsocket4-filepool/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 池是高性能组件中必不可少的东西，池最主要的功能是复用，在软件中创建和销毁对象是有成本的，消耗的资源也特别多。在需要大量使用相同或相似对象的场景下使用池，需要使用对象时去池中取，用完之后再放回到池中，避免创建和销毁对象，从而提高软件的性能。 池在设计时要注意以下几点： 池中对象的存储尽量利用高速缓冲区，这样可以更快速访问对象。 池中对象可以用原型模式加以改造。 池中对象的使用需要注意内存泄漏问题。因为对象使用完并没有销毁。 TouchSocket用到很多的池，字节池 (BytePool)、等待处理池(WaitHandlePool)、文件池(FilePool)、对象池(ObjectPool)，本文介绍字节池和等待处理池 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:1:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"字节池BytePool\r字节数组的复用是非常常见的做法，在高速IO中一定可以看见它的身影，微软对其也进行了各种封装。 TouchSocket字节池保存所有创建的字节数组，并根据数组的长度将其放在字典中等待复用，相同长度的数组通过队列进行缓存，最终字节此的样子 private static readonly ConcurrentDictionary\u003clong, BytesQueue\u003e bytesDictionary = new ConcurrentDictionary\u003clong, BytesQueue\u003e(); long:表示数组长度 BytesQueue:表示该长度数组队列。内部就是private readonly ConcurrentQueue\u003cbyte[]\u003e bytesQueue = new ConcurrentQueue\u003cbyte[]\u003e(); 字节池并没有直接对外暴露字节数组，而是将其封装成ByteBlock，字节数组的装饰对象：ByteBlock，内部使用字节数组实现功能，并装饰Stream的对象。 写入数据可以自动扩容，扩容基数1.5倍。 m_needDis控制Dispose时字节数组是否返回给池中 /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e /// \u003cparam name=\"byteSize\"\u003e默认64K\u003c/param\u003e /// \u003cparam name=\"equalSize\"\u003e默认false\u003c/param\u003e public ByteBlock(int byteSize = 1024 * 64, bool equalSize = false) { this.m_needDis = true; this.m_buffer = BytePool.GetByteCore(byteSize, equalSize); this.m_using = true; } /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e /// \u003cparam name=\"bytes\"\u003e\u003c/param\u003e public ByteBlock(byte[] bytes) { this.m_buffer = bytes ?? throw new ArgumentNullException(nameof(bytes)); this.m_length = bytes.Length; this.m_using = true; } /// \u003csummary\u003e /// 扩容增长比，默认为1.5， /// min：1.5 /// \u003c/summary\u003e public static float Ratio { get =\u003e m_ratio; set { if (value \u003c 1.5) { value = 1.5f; } m_ratio = value; } } /// \u003csummary\u003e /// 读取数据，然后递增Pos /// \u003c/summary\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"length\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e /// \u003cexception cref=\"ObjectDisposedException\"\u003e\u003c/exception\u003e public override int Read(byte[] buffer, int offset, int length) { if (!this.m_using) { throw new ObjectDisposedException(this.GetType().FullName); } int len = this.m_length - this.m_position \u003e length ? length : this.CanReadLen; Array.Copy(this.m_buffer, this.m_position, buffer, offset, len); this.m_position += len; return len; } /// \u003csummary\u003e /// 写入 /// \u003c/summary\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"count\"\u003e\u003c/param\u003e /// \u003cexception cref=\"ObjectDisposedException\"\u003e\u003c/exception\u003e public override void Write(byte[] buffer, int offset, int count) { if (count == 0) { return; } if (!this.m_using) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_buffer.Length - this.m_position \u003c count) { int need = this.m_buffer.Length + count - ((int)(this.m_buffer.Length - this.m_position)); int lend = this.m_buffer.Length; while (need \u003e lend) { lend = (int)(lend * m_ratio); } this.SetCapacity(lend, true); } Array.Copy(buffer, offset, this.m_buffer, this.m_position, count); this.m_position += count; this.m_length = Math.Max(this.m_position, this.m_length); } /// \u003csummary\u003e /// 重新设置容量 /// \u003c/summary\u003e /// \u003cparam name=\"size\"\u003e新尺寸\u003c/param\u003e /// \u003cparam name=\"retainedData\"\u003e是否保留元数据\u003c/param\u003e /// \u003cexception cref=\"ObjectDisposedException\"\u003e\u003c/exception\u003e public void SetCapacity(int size, bool retainedData = false) { if (!this.m_using) { throw new ObjectDisposedException(this.GetType().FullName); } byte[] bytes = new byte[size]; if (retainedData) { Array.Copy(this.m_buffer, 0, bytes, 0, this.m_buffer.Length); } BytePool.Recycle(this.m_buffer); this.m_buffer = bytes; } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"disposing\"\u003e\u003c/param\u003e protected sealed override void Dispose(bool disposing) { if (this.m_holding) { return; } if (this.m_needDis) { if (Interlocked.Decrement(ref this.m_dis) == 0) { GC.SuppressFinalize(this); BytePool.Recycle(this.m_buffer); this.Dis(); } } base.Dispose(disposing); } 该字节池具有如下特性 每隔1小时自动清理所有缓存的字节数组 最大缓存的不同字节数组的数量为100 回收的数组可以设置是否清零 缓存的最大字节数512M 缓存字节数组的范围1KB~20M 自动清理功能，每1个小时会自动清理池中所有的字节数组 static BytePool() { m_timer = new Timer((o) =\u003e { BytePool.Clear(); }, null, 1000 * 60 * 60, 1000 * 60 * 60);//1小时 m_keyCapacity = 100; m_autoZero = false; m_maxSize = 1024 * 1024 * 512;//512M SetBlockSize(1024, 1024 * 1024 * 20);//1KB~ 20M AddSizeKey(10240);//10KB } /// \u003csummary\u003e /// 清理 /// \u003c/summary\u003e public static void Clear() { bytesDictionary.Clear(); GC.Collect(); } /// \u003csummary\u003e /// 获取内存核心。获取的核心可以不用归还。 /// \u003c/summary\u003e /// \u003cparam name=\"byteSize\"\u003e\u003c/param\u003e /// \u003cparam na","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:2:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"等待处理池WaitHandlePool\u003cT\u003e\r该池的主要是为了复用WaitData\u003cT\u003e对象，该对象的功能是：交由外部系统处理对象并返回数据。当给外部系统发送命令，等待外部系统执行命令，并在规定时间内返回数据。 该功能的传统实现方式是： 创建命令队列，将所有已发送外部系统的命令装进命令队列中，同时记录命令的发送时间； 当外部系统返回数据时，去队列中找到对应的命令执行命令成功的方法；如果命令队列中没有对应的命令，调用未知数据处理方法； 设置定时器定期扫描命令队列，将超期没有接收到返回数据的命令移除，并调用对应命令异常执行方法； 该池的实现方式是构造WaitData\u003cT\u003e对象集合，发送命令前构建WaitData对象，发送完命令后该对象使用信号量阻塞发送命令的线程，当收到返回数据时，信号量置位继续执行，处理对应接收数据；信号量阻塞的时候可以设置阻塞时间，时间到则执行对应异常方法。 由于WaitData对象需要构建信号量，创建和销毁的代价比较大。WaitHandlePool构建 ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e waitQueue;队列保存空闲WaitData。 ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e waitQueue;保存所有已经使用WaitData。 /// \u003csummary\u003e /// 等待数据对象 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public class WaitData\u003cT\u003e : DisposableObject { private WaitDataStatus m_status; private readonly AutoResetEvent m_waitHandle; private T m_waitResult; /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e public WaitData() { this.m_waitHandle = new AutoResetEvent(false); } /// \u003csummary\u003e /// 状态 /// \u003c/summary\u003e public WaitDataStatus Status =\u003e this.m_status; /// \u003csummary\u003e /// 等待数据结果 /// \u003c/summary\u003e public T WaitResult =\u003e this.m_waitResult; /// \u003csummary\u003e /// 取消任务 /// \u003c/summary\u003e public void Cancel() { this.m_status = WaitDataStatus.Canceled; this.m_waitHandle.Set(); } /// \u003csummary\u003e /// 释放 /// \u003c/summary\u003e /// \u003cparam name=\"disposing\"\u003e\u003c/param\u003e protected override void Dispose(bool disposing) { this.m_status = WaitDataStatus.Disposed; this.m_waitResult = default; this.m_waitHandle.Dispose(); base.Dispose(disposing); } /// \u003csummary\u003e /// Reset。 /// 设置\u003csee cref=\"WaitResult\"/\u003e为null。然后重置状态为\u003csee cref=\"WaitDataStatus.Default\"/\u003e，waitHandle.Reset() /// \u003c/summary\u003e public bool Reset() { this.m_status = WaitDataStatus.Default; this.m_waitResult = default; return this.m_waitHandle.Reset(); } /// \u003csummary\u003e /// 使等待的线程继续执行 /// \u003c/summary\u003e public bool Set() { this.m_status = WaitDataStatus.SetRunning; return this.m_waitHandle.Set(); } /// \u003csummary\u003e /// 使等待的线程继续执行 /// \u003c/summary\u003e /// \u003cparam name=\"waitResult\"\u003e等待结果\u003c/param\u003e public bool Set(T waitResult) { this.m_waitResult = waitResult; this.m_status = WaitDataStatus.SetRunning; return this.m_waitHandle.Set(); } /// \u003csummary\u003e /// 加载取消令箭 /// \u003c/summary\u003e /// \u003cparam name=\"cancellationToken\"\u003e\u003c/param\u003e public void SetCancellationToken(CancellationToken cancellationToken) { if (cancellationToken.CanBeCanceled) { cancellationToken.Register(this.Cancel); } } /// \u003csummary\u003e /// 载入结果 /// \u003c/summary\u003e public void SetResult(T result) { this.m_waitResult = result; } /// \u003csummary\u003e /// 等待指定毫秒 /// \u003c/summary\u003e /// \u003cparam name=\"millisecond\"\u003e\u003c/param\u003e public WaitDataStatus Wait(int millisecond) { if (!this.m_waitHandle.WaitOne(millisecond)) { this.m_status = WaitDataStatus.Overtime; } return this.m_status; } } /// \u003csummary\u003e /// 等待处理数据 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public class WaitHandlePool\u003cT\u003e : IDisposable where T : IWaitResult { private readonly SnowflakeIDGenerator idGenerator; private readonly ConcurrentDictionary\u003clong, WaitData\u003cT\u003e\u003e waitDic; private readonly ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e waitQueue; /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e public WaitHandlePool() { this.waitDic = new ConcurrentDictionary\u003clong, WaitData\u003cT\u003e\u003e(); this.waitQueue = new ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e(); this.idGenerator = new SnowflakeIDGenerator(4); } /// \u003csummary\u003e /// 销毁 /// \u003c/summary\u003e /// \u003cparam name=\"waitData\"\u003e\u003c/param\u003e public void Destroy(WaitData\u003cT\u003e waitData) { if (waitData.DisposedValue) { throw new ObjectDisposedException(nameof(waitData)); } if (this.waitDic.TryRemove(waitData.WaitResult.Sign, out _)) { waitData.Reset(); this.waitQueue.Enqueue(waitData); } } /// \u003csummary\u003e /// 释放 /// \u003c/summary\u003e public void Dispose() { foreach (var item in this.waitDic.Values) { item.Dispose(); } foreach (var item in this.waitQueue) { item.Dispose(); } this.waitDic.Clear(); this.waitQueue.Clear(); } /// \u003csummary\u003e /// 获取一个可等待对象 /// \u003c/summary\u003e /// \u003cparam name=\"result\"\u003e\u003c/param\u003e /// \u003cparam name=\"autoSign\"\u003e设置为false时，不会生成sign\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public WaitData\u003cT\u003e GetWaitData(T result, bool autoSign = true) { WaitData\u003cT\u003e waitData; if (this.waitQ","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:3:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"总结\r主要介绍了字节池和等待处理池，详细介绍了相关特性和业务功能的实现。对于等待处理池我觉得还可以使用TaskCompletionSource\u003cTResult\u003e来实现，消耗比信号量更小，同时是异步执行，不会阻塞线程。 ","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:4:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 容器现在已经成为各种组件的标配了，为什么容器这么火，确实是太好用了。 表面上容器解决的是耦合问题，实际上容器实现了框架对流程的控制。 表面的耦合问题：没有容器，高层逻辑想要实现某个具体功能，只能依赖某个具体类或者具体工厂。当变化越来越多，改动越来越大，具体类之间依赖关系就像麻绳。里氏替换和依赖倒置根本无法实现。容器的出现将所有的具体类都保存在容器中，实现依赖倒置和里氏替换，系统高层和底层实现解耦。 框架对流程的控制问题：框架实现了整个应用流程的编排，流程中肯定需要具体的执行类。一旦依赖某个执行类就无法应对变化，具体类和流程严重耦合。整个框架就像被焊死，无法应对任何变化。容器就像是活页，连接着具体类和框架流程，当具体类发生变化，对框架没有任何影响，这也就使得框架的应用范围更广，实现的功能更多，框架中任何部件都是可以改变的。 唯一不变的就是改变，如果没有改变，也就不需要任何模式了。我们痛恨变化，同时也热爱变化，在痛苦中追求无限可能。 言归正传，TouchSocket框架实现了一个简易版的依赖注入容器。一起来看一下。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-09","objectID":"/2022/09/touchsocket2-dependencyinjection/:1:0","tags":["TouchSocket0.3.5","依赖注入容器"],"title":"TouchSocket 依赖注入容器","uri":"/2022/09/touchsocket2-dependencyinjection/"},{"categories":"TouchSocket0.3.5","content":"依赖注入\r简单点，容器其实就是一个字典，一个包含一个key和具体类的字典，将框架中所有依赖具体类的地方换成key，当执行到key的时候去字典中根据key取出具体类就可以了。 当然字典也需要生成，就是在应用开始的时候根据需求构建出字典。以后即使变化，也只变化开始构建的部分，最大程度减少修改。 真正的容器就是将字典改造一下，既然由容器管理，就应该负责到底，管理具体类的生命周期，什么时候创建，什么时候销毁，怎么创建。 首先字典中的具体类需要改造一下，变成描述类。 生命周期分为:单例，瞬态，域。 /// \u003csummary\u003e /// 注入依赖对象 /// \u003c/summary\u003e public class DependencyDescriptor { /// \u003csummary\u003e /// 初始化一个单例实例。 /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"instance\"\u003e\u003c/param\u003e public DependencyDescriptor(Type fromType, object instance) { this.FromType = fromType; this.ToInstance = instance; this.Lifetime = Lifetime.Singleton; this.ToType = instance.GetType(); } /// \u003csummary\u003e /// 初始化一个完整的服务注册 /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"toType\"\u003e\u003c/param\u003e /// \u003cparam name=\"lifetime\"\u003e\u003c/param\u003e public DependencyDescriptor(Type fromType, Type toType, Lifetime lifetime) { this.FromType = fromType; this.Lifetime = lifetime; this.ToType = toType; } /// \u003csummary\u003e /// 实例类型 /// \u003c/summary\u003e public Type ToType { get; } /// \u003csummary\u003e /// 实例 /// \u003c/summary\u003e public object ToInstance { get; set; } /// \u003csummary\u003e /// 生命周期 /// \u003c/summary\u003e public Lifetime Lifetime { get; } /// \u003csummary\u003e /// 注册类型 /// \u003c/summary\u003e public Type FromType { get; } } /// \u003csummary\u003e /// 注入项的生命周期。 /// \u003c/summary\u003e public enum Lifetime { /// \u003csummary\u003e /// 单例对象 /// \u003c/summary\u003e Singleton, /// \u003csummary\u003e /// 以\u003csee cref=\"IScopedContainer\"/\u003e接口为区域实例单例。 /// \u003c/summary\u003e Scoped, /// \u003csummary\u003e /// 瞬时对象 /// \u003c/summary\u003e Transient } 字典中的key改成FromType+Name。 最终字典变成了 private readonly ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e registrations = new ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e();这样。 看一下怎么实现注入和解析的。下面是原代码，Resolve方法根据生命周期实现解析逻辑；Create方法负责创建，同时各种注入方式；Register实现构建字典。 该容器有一些特点： 在注入容器时，提供了一个Name，key被构建成FromType+Name。这样的好处是可以根据Name来获取具体类。 同时对于多态的问题，同一个接口的多个实现没有实现注入，只能通过Name来区别了。 如果FromType不是抽象类，不需要注入，也可以Resolve出来。 Resolve会根据所有构造函数参数的个数最多的那个构造函数。 可以使用DependencyInject，DependencyParamterInject特性进行控制。 实现了构造函数注入，属性注入和方法注入 /// \u003csummary\u003e /// IOC容器 /// \u003c/summary\u003e public class Container : IContainer { private readonly ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e registrations = new ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e(); /// \u003csummary\u003e /// 初始化一个IOC容器 /// \u003c/summary\u003e public Container() { this.RegisterSingleton\u003cIContainer\u003e(this); } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public bool IsRegistered(Type fromType, string key = \"\") { return this.registrations.ContainsKey($\"{fromType.FullName}{key}\"); } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"descriptor\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e public void Register(DependencyDescriptor descriptor, string key = \"\") { string k = $\"{descriptor.FromType.FullName}{key}\"; this.registrations.AddOrUpdate(k, descriptor, (k, v) =\u003e { return descriptor; }); } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"ps\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public object Resolve(Type fromType, object[] ps = null, string key = \"\") { if (fromType == typeof(IScopedContainer)) { return this.GetScopedContainer(); } string k; DependencyDescriptor descriptor; if (fromType.IsGenericType) { Type type = fromType.GetGenericTypeDefinition(); k = $\"{type.FullName}{key}\"; if (this.registrations.TryGetValue(k, out descriptor)) { if (descriptor.Lifetime == Lifetime.Singleton) { if (descriptor.ToInstance != null) { return descriptor.ToInstance; } lock (descriptor) { if (descriptor.ToInstance != null) { return descriptor.ToInstance; } if (descriptor.ToType.IsGenericType) { return descriptor.ToInstance = this.Create(descriptor.ToType.MakeGenericType(fromType.GetGenericArguments()), ps); } else { return descriptor.ToInstance = this.Create(descriptor.ToType, ps); } } } if (descriptor.ToType.IsGenericType) { return this.Create(descriptor.ToType.MakeGenericType(fromType.GetGenericArguments()), ps); } el","date":"2022-09-09","objectID":"/2022/09/touchsocket2-dependencyinjection/:2:0","tags":["TouchSocket0.3.5","依赖注入容器"],"title":"TouchSocket 依赖注入容器","uri":"/2022/09/touchsocket2-dependencyinjection/"},{"categories":"TouchSocket0.3.5","content":"总结\r该容器虽然简单，但是足够使用，小巧紧致，非常值得学习。不需要注入直接解析对象的方式，虽然有点违反依赖倒置原则，但是在使用中确实是一个非常实用的功能。有一点缺陷是没有实现Dispose和瞬态对象的弱引用，当域生命周期结束的时候，Dispose容器同时销毁所有域创建出的瞬态对象。 ","date":"2022-09-09","objectID":"/2022/09/touchsocket2-dependencyinjection/:3:0","tags":["TouchSocket0.3.5","依赖注入容器"],"title":"TouchSocket 依赖注入容器","uri":"/2022/09/touchsocket2-dependencyinjection/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 该框架实现了广泛的Socket应用，NAT，各种RPC，文件传输，WebAPI，WebSocket，非常优秀的框架，学习一下，有问题可以相互探讨。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index 本章主要介绍TouchSocket的主要特性之一：依赖属性 ","date":"2022-09-07","objectID":"/2022/09/touchsocket1-dependencyproperties/:1:0","tags":["TouchSocket0.3.5","依赖属性"],"title":"TouchSocket 依赖属性","uri":"/2022/09/touchsocket1-dependencyproperties/"},{"categories":"TouchSocket0.3.5","content":"依赖属性\r用过WPF都知道依赖属性，其是绑定，动画，样式的基础，提供了属性值，更改通知等功能，该框架中的依赖属性相当于简易版本，提供了应用的思路。 依赖属性可以看成是Key和Value的封装。依赖属性类：名称，所属类型，值类型和值，还包含了一个工厂方法，用来创建依赖属性，创建时可以提供初始值。 /// \u003csummary\u003e /// 依赖项属性 /// \u003c/summary\u003e [DebuggerDisplay(\"Name={Name},Type={ValueType}\")] public class DependencyProperty { /// \u003csummary\u003e /// 属性名称 /// \u003c/summary\u003e protected string m_name; /// \u003csummary\u003e /// 所属类型 /// \u003c/summary\u003e protected Type m_owner; /// \u003csummary\u003e /// 值类型 /// \u003c/summary\u003e protected Type m_valueType; private object m_value; /// \u003csummary\u003e /// 依赖项属性 /// \u003c/summary\u003e private DependencyProperty() { } /// \u003csummary\u003e /// 默认值 /// \u003c/summary\u003e public object DefauleValue =\u003e this.m_value; /// \u003csummary\u003e /// 属性名 /// \u003c/summary\u003e public string Name =\u003e this.m_name; /// \u003csummary\u003e /// 所属类型 /// \u003c/summary\u003e public Type Owner =\u003e this.m_owner; /// \u003csummary\u003e /// 值类型 /// \u003c/summary\u003e public Type ValueType =\u003e this.m_valueType; internal void DataValidation(object value) { if (value == null) { if (typeof(ValueType).IsAssignableFrom(this.m_valueType)) { throw new Exception($\"属性“{this.m_name}”赋值类型不允许出现Null\"); } } else if (!this.m_valueType.IsAssignableFrom(value.GetType())) { throw new Exception($\"属性“{this.m_name}”赋值类型与注册类型不一致，应当注入“{this.m_valueType}”类型\"); } } internal void SetDefauleValue(object value) { this.DataValidation(value); this.m_value = value; } /// \u003csummary\u003e /// 注册依赖项属性。 /// \u003cpara\u003e依赖属性的默认值，可能会应用于所有的\u003csee cref=\"IDependencyObject\"/\u003e\u003c/para\u003e /// \u003c/summary\u003e /// \u003cparam name=\"propertyName\"\u003e\u003c/param\u003e /// \u003cparam name=\"valueType\"\u003e\u003c/param\u003e /// \u003cparam name=\"owner\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e依赖项属性值，一般该值应该是值类型，因为它可能会被用于多个依赖对象。\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static DependencyProperty Register(string propertyName, Type valueType, Type owner, object value) { DependencyProperty dp = new DependencyProperty { m_name = propertyName, m_valueType = valueType, m_owner = owner }; dp.SetDefauleValue(value); return dp; } } 如何管理依赖属性，类中创建依赖属性，并设置和获取依赖属性的值。首先实现接口，可以获取和设置依赖属性的值，实现一个基类，实现该接口，所有包含依赖属性的类继承该基类，就可以实现操作依赖属性了。 该框架做了进一步扩展，在基类中添加了一个依赖属性字典，可以添加外部依赖属性。 也就是在基类中保存了一个Key，Value的字典，通过特定的Key获取到Value，在配置的时候特别有用，配置类Option/Config怎么应对变化，写组件的时候发现配置项多需要添加属性怎么办，修改配置项，违反开放封闭原则；使用继承，显得太重；增加一个配置类，还不如使用继承。 把配置项修改成字典，所有信息通过key,value保存，可以应对开放封闭原则。显然该框架就说这样干的，key是依赖属性，vlaue是依赖属性的值。 /// \u003csummary\u003e /// 依赖对象接口 /// \u003c/summary\u003e public interface IDependencyObject : System.IDisposable { /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e object GetValue(DependencyProperty dp); /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public T GetValue\u003cT\u003e(DependencyProperty dp); /// \u003csummary\u003e /// 设置依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e\u003c/param\u003e public DependencyObject SetValue(DependencyProperty dp, object value); } /// \u003csummary\u003e /// 依赖项对象. /// 线程安全。 /// \u003c/summary\u003e public class DependencyObject : DisposableObject, IDependencyObject, System.IDisposable { /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e public DependencyObject() { this.m_dp = new ConcurrentDictionary\u003cDependencyProperty, object\u003e(); } [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)] private readonly ConcurrentDictionary\u003cDependencyProperty, object\u003e m_dp; /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public object GetValue(DependencyProperty dp) { if (this.m_dp.TryGetValue(dp, out object value)) { return value; } else { return dp.DefauleValue; } } /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public T GetValue\u003cT\u003e(DependencyProperty dp) { try { return (T)this.GetValue(dp); } catch { return default; } } /// \u003csummary\u003e /// 设置依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e\u003c/param\u003e public DependencyObject SetValue(DependencyProperty dp, object value) { dp.DataValidation(value); if (this.m_dp.ContainsKey(dp)) { this.m_dp[dp] = value; } els","date":"2022-09-07","objectID":"/2022/09/touchsocket1-dependencyproperties/:2:0","tags":["TouchSocket0.3.5","依赖属性"],"title":"TouchSocket 依赖属性","uri":"/2022/09/touchsocket1-dependencyproperties/"},{"categories":"TouchSocket0.3.5","content":"总结\r依赖属性这样的应用方式非常优秀，满足了扩展开放，单一职责。如果有其他的应用方式欢迎评论。 ","date":"2022-09-07","objectID":"/2022/09/touchsocket1-dependencyproperties/:3:0","tags":["TouchSocket0.3.5","依赖属性"],"title":"TouchSocket 依赖属性","uri":"/2022/09/touchsocket1-dependencyproperties/"},{"categories":"算法","content":"实现队列的一些思路\r数组的优劣： 读取：连续的地址空间，数组全部或者部分元素被连续存在CPU缓存里面，读取速度非常快。 插入/删除/扩容：插入和删除，需要修改该元素之前或之后所有元素的位置，扩容时需要重新找较大的内存块，将原数组中所有数据复制到新内存块中。这些操作都非常耗时。 链表的优劣： 读取：链表的节点分散在堆空间中，无法利用CPU缓存，读写速度比较慢，是数组的33倍 插入/删除/扩容：不需要改变原来元素的位置，仅仅修改节点信息即可。但是频繁的插入删除会导致堆中有大量碎片化内存。 链表每个节点不仅需要保存数据还需要保存下一个节点的位置。 较好的方式是结合数组和链表的优势，用链表节点将固定大小的数组连接起来组成大的内存块，即易于扩展又在一定范围内保持良好的访问速度。 在需要构建内存池，缓存队列等应用场景中均可使用此方法进行优化。 ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:1:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"队列接口\rpublic interface IQueue\u003cTItem\u003e : IEnumerable\u003cTItem\u003e, IDisposable { bool IsEmpty { get; } int Length { get; } void Enqueue(TItem item); TItem Dequeue(); } ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:2:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"基于数组的扩容队列\rpublic class SGResizingArrayQueue\u003cTItem\u003e : IQueue\u003cTItem\u003e { public SGResizingArrayQueue() { _first = 0; _last = 0; _items = new TItem[2]; } public IEnumerator\u003cTItem\u003e GetEnumerator() { if (!IsEmpty) { for (var i = _first; i \u003c _last; i++) { yield return _items[i]; } } } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } public void Dispose() { Dispose(true); } protected virtual void Dispose(bool disposing) { if (disposing) { if (!IsEmpty) { for (var i = _first; i \u003c _last; i++) { _items[i] = default; } _items = null; } } } private TItem[] _items; private int _first; private int _last; public bool IsEmpty =\u003e (_last - _first) == 0; public int Length =\u003e _last - _first; private void resize(int size) { var temitems = new TItem[size]; var temlength = Length; Array.Copy(_items, _first, temitems, 0, Length); _first = 0; _last = temlength; _items = temitems; } public void Enqueue(TItem item) { if (_last == _items.Length) resize(Length * 2); _items[_last++] = item; } public TItem Dequeue() { if (IsEmpty) return default; var item = _items[_first++]; if (Length \u003c _items.Length / 4) resize(_items.Length / 2); return item; } } ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:3:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"基于链表的扩容队列\rpublic class SGLinkedQueue\u003cTItem\u003e : IQueue\u003cTItem\u003e { private Node _first; private Node _last; private int _length; public SGLinkedQueue() { _length = 0; } private class Node { public TItem Item { set; get; } public Node Next { set; get; } } public IEnumerator\u003cTItem\u003e GetEnumerator() { if (!IsEmpty) { var temnode = _first; while (temnode != default) { var item = temnode.Item; temnode = temnode.Next; yield return item; } } } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } public void Dispose() { Dispose(true); } protected virtual void Dispose(bool disposing) { if (disposing) { if (!IsEmpty) { var temfirst = _first; while (temfirst != default) { temfirst.Item = default; temfirst = temfirst.Next; } _length = 0; } } } public bool IsEmpty =\u003e _length == 0; public int Length =\u003e _length; public void Enqueue(TItem item) { var temnode = _last; _last = new Node(); _last.Item = item; _last.Next = null; if (IsEmpty) _first = _last; else temnode.Next = _last; _length++; } public TItem Dequeue() { if (_length \u003e 0) { var temitem = _first.Item; _first = _first.Next; _length--; return temitem; } return default; } } ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:4:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"结合数组和链表的扩容队列\rclass SGArraySegment\u003cTItem\u003e { public TItem[] Array { get; private set; } public SGArraySegment\u003cTItem\u003e Next { get; set; } public int Offset { get; set; } public int End { get; set; } = -1; public SGArraySegment(TItem[] array) { Array = array; } public bool IsAvailable { get { return Array.Length \u003e (End + 1); } } public void Write(TItem value) { Array[++End] = value; } } class SGPipeQueue\u003cTItem\u003e : IValueTaskSource\u003cTItem\u003e, IDisposable { private const int _segmentSize = 5; private SGArraySegment\u003cTItem\u003e _first; private SGArraySegment\u003cTItem\u003e _current; private object _syncRoot = new object(); private static readonly ArrayPool\u003cTItem\u003e _pool = ArrayPool\u003cTItem\u003e.Shared; private ManualResetValueTaskSourceCore\u003cTItem\u003e _taskSourceCore; private bool _waiting = false; private bool _lastReadIsWait = false; private int _length; public SGPipeQueue() { SetBufferSegment(CreateSegment()); _taskSourceCore = new ManualResetValueTaskSourceCore\u003cTItem\u003e(); } SGArraySegment\u003cTItem\u003e CreateSegment() { return new SGArraySegment\u003cTItem\u003e(_pool.Rent(_segmentSize)); } void SetBufferSegment(SGArraySegment\u003cTItem\u003e segment) { if (_first == null) _first = segment; var current = _current; if (current != null) current.Next = segment; _current = segment; } public int Write(TItem target) { lock (_syncRoot) { if (_waiting) { _waiting = false; _taskSourceCore.SetResult(target); return _length; } var current = _current; if (!current.IsAvailable) { current = CreateSegment(); SetBufferSegment(current); } current.Write(target); _length++; return _length; } } public ValueTask\u003cTItem\u003e ReadAsync() { lock (_syncRoot) { if (TryRead(out TItem value)) { if (_lastReadIsWait) { _taskSourceCore.Reset(); _lastReadIsWait = false; } _length--; if (_length == 0) OnWaitTaskStart(); return new ValueTask\u003cTItem\u003e(value); } _waiting = true; _lastReadIsWait = true; _taskSourceCore.Reset(); OnWaitTaskStart(); return new ValueTask\u003cTItem\u003e(this, _taskSourceCore.Version); } } private bool TryRead(out TItem value) { var first = _first; if (first.Offset \u003c first.End) { value = first.Array[first.Offset]; first.Array[first.Offset] = default; first.Offset++; return true; } else if (first.Offset == first.End) { if (first == _current) { value = first.Array[first.Offset]; first.Array[first.Offset] = default; first.Offset = 0; first.End = -1; return true; } else { value = first.Array[first.Offset]; first.Array[first.Offset] = default; _first = first.Next; _pool.Return(first.Array); return true; } } value = default; return false; } protected virtual void OnWaitTaskStart() { } public virtual void Clear() { lock (_syncRoot) { if (_lastReadIsWait) { _taskSourceCore.Reset(); _lastReadIsWait = false; } var first = _first; if (first.Offset \u003c= first.End) { while (first != _current) { for (int i = first.Offset; i \u003c= first.End; i++) { first.Array[i] = default; } _first = first.Next; _pool.Return(first.Array); first = _first; } for (int i = first.Offset; i \u003c= first.End; i++) { first.Array[i] = default; } first.Offset = 0; first.End = -1; } } } public void Dispose() { lock (_syncRoot) { var segment = _first; while (segment != null) { _pool.Return(segment.Array); segment = segment.Next; } _first = null; _current = null; } } TItem IValueTaskSource\u003cTItem\u003e.GetResult(short token) { return _taskSourceCore.GetResult(token); } ValueTaskSourceStatus IValueTaskSource\u003cTItem\u003e.GetStatus(short token) { return _taskSourceCore.GetStatus(token); } void IValueTaskSource\u003cTItem\u003e.OnCompleted(Action\u003cobject?\u003e continuation, object? state, short token, ValueTaskSourceOnCompletedFlags flags) { _taskSourceCore.OnCompleted(continuation, state, token, flags); } } 该队列额外实现2个功能，以提高队列的性能： 异步出队列，当队列为空时，异步等待。 当压入队列时，如果发现有异步等待对象，则不进入队列，直接给等待对象。 ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:5:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"Web","content":"DOM(document object medol)文档对象模型。 DOM就是HTML页面的模型，将每个标签都做为一个对象，JavaScript通过调用DOM中的属性、方法就可以对网页中的文本框、层等元素进行编程控制。比如通过操作文本框的DOM对象，就可以读取文本框中的值、设置文本框中的值。 JavaScript→Dom就是C#→.Net Framwork。没有.net，C#只能for、while，连WriteLine、MessageBox都不行。Dom就是一些让JavaScript能操作HTML页面控件的类、函数。 DOM也像WinForm一样，通过事件、属性、方法进行编程。 CSS+JavaScript+DOM=DHTML 学习阶段只考虑IE。用IE Collection安装IE所有版本，学习使用IE6（要调试必须使用本机安装的版本）。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:0:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"事件\r事件：\u003cbody onmousedown=\"alert('哈哈')\"\u003e当点击鼠标的时候执行onmousedown中的代码。有时间事件响应的代码太多，就放到单独的函数中： \u003cscript type=\"text/javascript\"\u003e function bodymousedown() { alert(\"网页被点坏了，赔吧！\"); alert(\"逗你玩的！\"); } \u003c/script\u003e \u003cbody onmousedown=\"bodymousedown()\"\u003e bodymousedown后的括号不能丢（ onmousedown=“bodymousedown” ），因为表示onmousedown事件发生时调用bodymousedown函数，而不是onmousedown事件的响应函数是bodymousedown。 \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function setTxt() { t1.value = \"1234\"; } \u003c/script\u003e \u003c/head\u003e \u003cbody onload=\"setTxt();\" onunload=\"alert('欢迎下次光临！')\" onbeforeunload=\"window.event.returnValue='确定关闭？'\"\u003e \u003cinput id=\"t1\" type=\"text\" value=\"\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:1:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"动态设置事件\r可以在代码中动态设置事件响应函数，就像.Net中btn.Click+=一样 function f1() { alert(\"1\"); } function f2(){ alert(\"2\"); } \u003cinput type=\"button\" onclick=\"document.ondblclick=f1\" value=\"关联事件1\" /\u003e//注意f1不要加括号。如果加上括号就变成了执行f1函数，并且将函数的返回值复制给document.ondblclick \u003cinput type=\"button\" onclick=\"document.ondblclick=f2\" value=\"关联事件2\" /\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function load() { alert('地球日'); alert('2012不远了'); } function f1() { alert(\"f1\"); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"按钮\" onclick=\"document.onclick=f1\" /\u003e \u003cinput type=\"button\" value=\"关闭\" onclick=\"window.close()\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:2:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"window对象\rwindow对象代表当前浏览器窗口，使用window对象的属性、方法的时候可以省略window，比如window.alert(‘a’)可以省略成alert(‘aa’)。 alert方法，弹出消息对话框 confirm方法，显示“确定”、“取消”对话框，如果按了【确定】按钮，就返回true，否则就false if (confirm(\"是否继续？\")) { alert(\"确定\"); } else { alert(\"取消\"); } + 重新导航到指定的地址：navigate(\"http://www.rupeng.com\");\r+ setInterval每隔一段时间执行指定的代码，第一个参数为代码的字符串，第二个参数为间隔时间（单位毫秒），返回值为定时器的标识\r`setInterval(\"alert('hello')\", 5000);`\r+ clearInterval取消setInterval的定时执行，相当于Timer中的Enabled=False。因为setInterval可以设定多个定时，所以clearInterval要指定清除那个定时器的标识，即setInterval的返回值。\rvar intervalId = setInterval(\"alert('hello')\", 5000);\rclearInterval(intervalId); + setTimeout也是定时执行，但是不像setInterval那样是重复的定时执行，只执行一次，clearTimeout也是清除定时。很好区分：Interval：间隔；timeout：超时。 var timeoutId = setTimeout(\"alert('hello')\", 2000); + showModalDialog弹出模态对话框，注意showModalDialog必须在onClick等用户手动触发的事件中才会执行，否则可能会被最新版本的浏览器当成广告弹窗而拦截。\r+ 第一个参数为弹出模态窗口的页面地址。\r+ 在弹出的页面中调用window.close()（不能省略window.close()中的window.）关闭窗口，只有在对话框中调用window.close()才会自动关闭窗口，否则浏览器会提示用户进行确认。\r+ 除了有特有的属性之外，当然还有通用的HTML元素的事件：onclick（单击）、ondblclick（双击）、onkeydown（按键按下）、onkeypress（点击按键）、onkeyup（按键释放）、onmousedown（鼠标按下）、onmousemove（鼠标移动）、onmouseout（鼠标离开元素范围）、onmouseover（鼠标移动到元素范围）、onmouseup（鼠标按键释放）等。\r\u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e1234567890\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e var tid; function setTimeoutDemo() { tid = setTimeout(\"alert('下课了')\", 3000); } function clearTimeoutDemo() { //判断tid是否初始化 if (tid) { clearTimeout(tid); } } var dir = \"left\"; function scroll() { var title = window.document.title; if (dir == \"left\") { var first = title.charAt(0); var last = title.substring(1, title.length); //start 从0数 end从1数 } else if (dir == \"right\") { var last = title.charAt(title.length - 1); var first = title.substring(0, title.length - 1); } window.document.title = last + first; } setInterval(\"scroll()\", 500); function setDir(str) { dir = str; } function scrollRight() { var title = window.document.title; var last = title.charAt(title.length - 1); var first = title.substring(0, title.length - 1); title = last + first; window.document.title = title; } window.showModalDialog(\"1-.htm\"); function showDialog() { window.showModalDialog(\"1-.htm\"); } function show() { window.showModelessDialog(\"1-.htm\"); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"启动\" onclick=\"setTimeoutDemo();\" /\u003e \u003cinput type=\"button\" value=\"取消\" onclick=\"clearTimeoutDemo();\" /\u003e \u003cinput type=\"button\" value=\"向左\" onclick=\"setDir('left')\" /\u003e \u003cinput type=\"button\" value=\"向右\" onclick=\"setDir('right')\" /\u003e \u003cbr /\u003e \u003cinput type=\"button\" value=\"模式窗口\" onclick=\"showDialog()\" /\u003e \u003cinput type=\"button\" value=\"非模式窗口\" onclick=\"show()\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e var times = 10; function count() { var btn = document.getElementById(\"btn\"); if (times \u003e 0) { btn.value = \"同意(倒计时\" + times + \")\"; times--; } else { btn.value = \"同意\"; btn.disabled = false; clearInterval(tid); } } var tid = setInterval(\"count()\", 1000); \u003c/script\u003e \u003c/head\u003e \u003cbody onload=\"count()\"\u003e 注册协议 \u003cbr /\u003e \u003cinput id=\"btn\" type=\"button\" value=\"同意\" disabled=\"disabled\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:3:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"window对象属性\rwindow.location.href='http://www.itcast.cn'，重新导向新的地址，和navigate方法效果一样。window.location.reload() 刷新页面 window.event是非常重要的属性，用来获得发生事件时的信息，事件不局限于window对象的事件，所有元素的事件都可以通过event属性取到相关信息。类似于winForm中的e(EventArg). altKey属性，bool类型，表示发生事件时alt键是否被按下，类似的还有ctrlKey、shiftKey属性，例子 \u003cinput type=\"button\" value=\"点击\" onclick=\"if(event.altKey){alert('Alt点击')}else{alert('普通点击')}\" /\u003e ； clientX、clientY 发生事件时鼠标在客户区的坐标；screenX、screenY 发生事件时鼠标在屏幕上的坐标；offsetX、offsetY 发生事件时鼠标相对于事件源（比如点击按钮时触发onclick）的坐标。 returnValue属性，如果将returnValue设置为false，就会取消默认事件的处理。在超链接的onclick里面禁止访问href的页面。在表单校验的时候禁止提交表单到服务器，防止错误数据提交给服务器、防止页面刷新。 srcElement，获得事件源对象。几个事件共享一个事件响应函数用。 keyCode，发生事件时的按键值。 button，发生事件时鼠标按键，1为左键，2为右键，3为左右键同时按。\u003cbody onmousedown=\"if(event.button==2){alert('禁止复制');}\"\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:4:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"（*）screen对象，屏幕的信息\ralert(\"分辨率：\" + screen.width + \"*\" + screen.height); if (screen.width \u003c 1024 || screen.height \u003c 768){ alert(\"分辨率太低！\"); } ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:5:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"clipboardData对象\r对粘贴板的操作。clearData(“Text”)清空粘贴板；getData(“Text”)读取粘贴板的值，返回值为粘贴板中的内容；setData(“Text”,val)，设置粘贴板中的值。 案例：复制地址给友好。见备注。 当复制的时候body的oncopy方法被触发，直接return false就是禁止复制。\u003cbody oncopy=“alert(‘禁止复制！’);return false;” 很多元素也有oncopy、onpaste事件： 案例：禁止粘贴帐号。见备注。 在网站中复制文章的时候，为了防止那些拷贝党不添加文章来源，自动在复制的内容后添加版权声明。 function modifyClipboard() { clipboardData.setData('Text', clipboardData.getData('Text') + '本文来自传智播客技术专区，转载请注明来源。' + location.href); } + `oncopy=\"setTimeout('modifyClipboard()',100)\"`。用户复制动作发生0.1秒以后再去改粘贴板中的内容。100ms只是一个经常取值，写1000、10、50、200……都行。不能直接在oncopy里修改粘贴板。\r+ 不能直接在oncopy中执行对粘贴板的操作，因此设定定时器，0.1秒以后执行，这样就不再oncopy的执行调用栈上了。\rhistory操作历史记录 window.history.back()后退；window.history.forward()前进。也可以用window.history.go(-1)、window.history.go(1)前进 \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function getXY() { document.title = window.event.clientX + \" \" + window.event.clientY; } function turnInto(right) { if (right) { alert(\"欢迎进入\"); } else { alert(\"非法入侵\"); window.event.returnValue = false; alert(\"123123\"); } } function btnClick() { return false; alert(\"abc\"); } function txtKeyDown() { var txt = window.event.srcElement; if (txt.id == \"txtNums\") { if (window.event.keyCode \u003e= 48 \u0026\u0026 window.event.keyCode \u003c= 57) { } else { return false; } } else if (txt.id = \"txt\") { } } \u003c/script\u003e \u003c/head\u003e \u003cbody onmousemove=\"getXY()\" onmousedown=\"if(window.event.button==2){alert('禁止复制')}\"\u003e \u003cinput type=\"button\" value=\"url\" onclick=\"alert(window.location.href);\" /\u003e \u003cinput type=\"button\" value=\"转向\" onclick=\"window.location.href='2-window对象.htm'\" /\u003e \u003cinput type=\"button\" value=\"reload\" onclick=\"window.location.reload()\" /\u003e \u003cinput type=\"button\" value=\"ctrlKey\" onclick=\"if(window.event.ctrlKey){alert('按下ctrl')}else{alert('没有按下')}\" /\u003e \u003cbr /\u003e \u003ca href=\"1-.htm\" onclick=\"turnInto(0)\"\u003e超链接\u003c/a\u003e \u003cinput type=\"button\" value=\"returnValue\" onclick=\"btnClick();\" /\u003e \u003cform action=\"http://www.baidu.com\"\u003e \u003cinput type=\"submit\" onclick=\"alert('请输入用户名密码');window.event.returnValue=false\"/\u003e \u003c/form\u003e \u003cinput id=\"txtNums\" type=\"text\" value=\"\" onkeydown=\"return txtKeyDown()\" /\u003e \u003cinput id=\"txt\" type=\"text\" value=\"\" onkeydown=\"txtKeyDown()\" /\u003e \u003cinput type=\"button\" value=\"screen\" onclick=\"alert(window.screen.width + ' ' + window.screen.height)\" /\u003e \u003chr /\u003e 手机号：\u003cinput type=\"text\" value=\"\" oncopy=\"alert('禁止复制');return false\" /\u003e\u003cbr /\u003e 重复手机号：\u003cinput type=\"text\" value=\"\" onpaste=\"alert('请输入');return false\" /\u003e \u003chr /\u003e \u003cinput id=\"tabc\" type=\"text\" value=\"213123123\" /\u003e\u003cinput type=\"button\" value=\"copy\" onclick=\"window.clipboardData.setData('text',tabc.value);alert('复制成功');\" /\u003e\u003cbr /\u003e \u003cinput id=\"t123\" type=\"text\" value=\"\" /\u003e\u003cinput type=\"button\" value=\"paste\" onclick=\"t123.value=clipboardData.getData('text')\" /\u003e\u003cbr /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function setClip() { var text = window.clipboardData.getData(\"text\"); text = text + \"转载请注明：\" + window.location.href; window.clipboardData.setData(\"text\",text); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003ctextarea id=\"t1\" oncopy=\"setTimeout('setClip()',50)\"\u003e asdfasdfasdf asdfasdfasdf \u003c/textarea\u003e \u003ca href=\"6-history.htm\"\u003e链接\u003c/a\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"后退\" onclick=\"window.history.back()\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:6:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"document属性。\r是最复杂的属性之一。后面讲解详细使用。 document是window对象的一个属性，因为使用window对象成员的时候可以省略window.，所以一般直接写document document的方法： write：向文档中写入内容。writeln，和write差不多，只不过最后添加一个回车 \u003cinput type=\"button\" value=\"点击\" onclick=\"document.write('\u003cfont color=red\u003e你好\u003c/font\u003e')\" /\u003e + 在onclick等事件中写的代码会冲掉页面中的内容，只有在页面加载过程中write才会与原有内容融合在一起\r\u003cscript type=\"text/javascript\"\u003e document.write('\u003cfont color=red\u003e你好\u003c/font\u003e'); \u003c/script\u003e + write经常在广告代码、整合资源代码中被使用。见备注\r内容联盟、广告代码、cnzz，不需要被主页面的站长去维护内容，只要被嵌入的js内容提供商修改内容，显示的内容就变了。 getElementById方法（非常常用），根据元素的Id获得对象，网页中id不能重复。也可以直接通过元素的id来引用元素，但是有有效范围、form1.textbox1之类的问题，因此不建议直接通过id操作元素，而是通过getElementById （*）getElementsByName，根据元素的name获得对象，由于页面中元素的name可以重复，比如多个RadioButton的name一样，因此getElementsByName返回值是对象数组。 （*）getElementsByTagName，获得指定标签名称的元素数组，比如getElementsByTagName(“p”)可以获得所有的标签。 案例：实现checkbox的全选，反选 案例：点击一个按钮，被点击的按钮显示“呜呜”，其他按钮显示“哈哈”。 案例：十秒钟后协议文本框下的注册按钮才能点击，时钟倒数。(btn.disabled = true ) \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function writeDemo() { document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); } document.writeln(\"123\u003cbr/\u003e\"); document.writeln(\"123\u003cbr/\u003e\"); document.writeln(\"\u003ca href='123.htm'\u003e123\u003c/a\u003e\"); document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); document.write(\"\u003cul\u003e\u003cli\u003e开始\u003c/li\u003e\u003cli\u003e运行\u003c/li\u003e\u003cli\u003e结束\u003c/li\u003e\u003c/ul\u003e\"); //document.write(\"\u003cscript type='text/javascript'\u003ealert('hello world');\u003c\\/script\u003e\"); \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv\u003eabc \u003cscript type=\"text/javascript\"\u003e document.writeln(\"123\u003cbr/\u003e\"); document.writeln(\"123\u003cbr/\u003e\"); \u003c/script\u003eabc \u003c/div\u003e \u003cdiv\u003e sdfsd \u003c/div\u003e \u003cinput type=\"button\" value=\"按钮\" onclick=\"writeDemo()\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function setText() { var txt = document.getElementById(\"t1\"); txt.value = \"123\"; //t1.value = \"123\"; } function setText2() { var txt = document.getElementById(\"t2\"); txt.value = \"abc\"; //form1.t2.value = \"abc\"; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput id=\"t1\" type=\"text\" value=\"\" /\u003e \u003cform id=\"form1\"\u003e \u003cinput id=\"t2\" type=\"text\" value=\"\" /\u003e \u003c/form\u003e \u003cinput type=\"button\" value=\"按钮\" onclick=\"setText()\" /\u003e \u003cinput type=\"button\" value=\"按钮2\" onclick=\"setText2()\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function btnClick() { var chks = document.getElementsByName(\"hobby\"); //错误 // for (var c in chks) { // alert(c); // } for (var i = 0; i \u003c chks.length; i++) { //alert(chks[i].value); chks[i].checked = \"checked\"; } } function checkAll() { var chkAll = document.getElementById(\"chkAll\"); var chks = document.getElementsByName(\"hobby\"); for (var i = 0; i \u003c chks.length; i++) { chks[i].checked = chkAll.checked; } } function reverseCheck() { var chks = document.getElementsByName(\"hobby\"); for (var i = 0; i \u003c chks.length; i++) { chks[i].checked = !chks[i].checked; } } function checkSingle() { var b = true; //假设全被选中 var chkAll = document.getElementById(\"chkAll\"); var chks = document.getElementsByName(\"hobby\"); for (var i = 0; i \u003c chks.length; i++) { //查找所有子的checkbox，判断是否被选中 //如果有一个checkbox没有被选中，则退出循环，最终全选的checkbox为false if (!chks[i].checked) { b = false; break; } } chkAll.checked = b; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"checkbox\" value=\"cf\" onclick=\"checkSingle()\" name=\"hobby\"/\u003e吃饭\u003cbr /\u003e \u003cinput type=\"checkbox\" value=\"sj\" onclick=\"checkSingle()\" name=\"hobby\"/\u003e睡觉\u003cbr /\u003e \u003cinput type=\"checkbox\" value=\"ddd\" onclick=\"checkSingle()\" name=\"hobby\"/\u003e打豆豆\u003cbr /\u003e \u003cbr /\u003e\u003cbr /\u003e \u003cinput id=\"chkAll\" type=\"checkbox\" onclick=\"checkAll()\"/\u003e全选 \u003cinput type=\"button\" value=\"反选\" onclick=\"reverseCheck()\" /\u003e \u003cinput type=\"button\" value=\"全选\" onclick=\"btnClick()\" /\u003e \u003cbr /\u003e \u003cinput type=\"checkbox\" value=\"ctl\" /\u003e春天里\u003cbr /\u003e \u003cinput type=\"checkbox\" value=\"xtl\" /\u003e夏天里\u003cbr /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"htt","date":"2019-04-04","objectID":"/2019/04/web4-dom/:6:1","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"dom动态创建\rdocument.write只能在页面加载过程中才能动态创建。 可以调用document的createElement方法来创建具有指定标签的DOM对象，然后通过调用某个元素的appendChild方法将新创建元素添加到相应的元素下 function showit() { var divMain = document.getElementById(\"divMain\"); var btn = document.createElement(\"input\"); btn.type = \"button\"; btn.value = \"我是动态的！\"; divMain.appendChild(btn); } \u003cdiv id=\"divMain\"\u003e\u003c/div\u003e \u003cinput type=\"button\" value=\"ok\" onclick=\"showit()\" /\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function createBtn() { var btn = document.createElement(\"input\"); btn.type = \"button\"; btn.value = \"新按钮\"; btn.onclick = function() { alert(\"我是新来的\"); } var d = document.getElementById(\"d1\"); d.appendChild(btn); } function createLink() { var link = document.createElement(\"a\"); link.href = \"http://www.baidu.com\"; link.innerText = \"百度\"; link.target = \"_blank\"; var d = document.getElementById(\"d1\"); d.appendChild(link); } function btnClick(){ alert(\"我是新来的\"); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"创建按钮\" onclick=\"createBtn()\" /\u003e \u003cinput type=\"button\" value=\"创建超链接\" onclick=\"createLink()\" /\u003e \u003cdiv id=\"d1\"\u003eabc\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e Value 获取表单元素 几乎所有DOM元素都有innerText、innerHTML属性（注意大小写），分别是元素标签内内容的文本表示形式和HTML源代码，这两个属性是可读可写的。 \u003ca href=\"http://www.itcast.cn\" id=\"link1\"\u003e传\u003cfont color=\"Red\"\u003e智\u003c/font\u003e播客\u003c/a\u003e \u003cinput type=\"button\" value=\"inner*\" onclick=\"alert(document.getElementById('link1').innerText);alert(document.getElementById('link1').innerHTML);\" /\u003e 用innerHTML也可以替代createElement，属于简单、粗放型、后果自负的创建 function createlink() { var divMain = document.getElementById(\"divMain\"); divMain.innerHTML = \"\u003ca href='http://www.rupeng.com'\u003e如鹏网\u003c/a\u003e\"; } \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function getLinkText() { var link = document.getElementById(\"link1\"); alert(link.innerText); alert(link.innerHTML); } function setDiv() { var div = document.getElementById(\"d1\"); //div.innerText = \"\u003cfont color='red'\u003e123123\u003c/font\u003e\"; //div.innerHTML = \"\u003cfont color='red'\u003e123123\u003c/font\u003e\"; //div.innerHTML = \"\u003cul\u003e\u003cli\u003e春天里\u003c/li\u003e\u003cli\u003e怒放\u003c/li\u003e\u003c/ul\u003e\"; //div.innerHTML = \"\u003cinput type='text' value='1234' /\u003e\"; //div.innerText = div.innerText + \"123123\"; //Node节点 Element元素的区别 //html文档里所有的内容都是节点 标签 属性 文本 //元素 一个完整的标签 //var txtNode = document.createTextNode(\"123123\"); // div.appendChild(txtNode); div.innerHTML = \"\u003cscript type='text/javascript'\u003efunction test(){alert('hello');}\u003c\\/script\u003e\"; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003ca id=\"link1\" href=\"http://www.itcast.cn\"\u003e传智\u003cfont color=\"red\"\u003e播客\u003c/font\u003e\u003c/a\u003e \u003cinput type=\"button\" value=\"按钮\" onclick=\"getLinkText()\" /\u003e \u003cdiv id=\"d1\"\u003eabcd\u003c/div\u003e \u003cinput type=\"button\" value=\"set div\" onclick=\"setDiv() \" /\u003e \u003cinput type=\"button\" value=\"test\" onclick=\"test()\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function createTable() { var div = document.getElementById(\"d1\"); var dic = { \"baidu\": \"http://www.baidu.com\", \"传智播客\": \"http://www.itcast.cn\", \"cnbeta\": \"http://www.cnbeta.com\" }; var table = document.createElement(\"table\"); table.border = 1; for (var key in dic) { var tr = document.createElement(\"tr\"); var td0 = document.createElement(\"td\"); td0.innerText = key; //把td0加到tr中 tr.appendChild(td0); var td1 = document.createElement(\"td\"); td1.innerHTML = \"\u003ca href='\" + dic[key] + \"'\u003e\" + dic[key] + \"\u003c/a\u003e\"; tr.appendChild(td1); //把tr添加到table中 table.appendChild(tr); } //把table添加到div中 div.appendChild(table); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"d1\"\u003e\u003c/div\u003e \u003cinput type=\"button\" value=\"load。。。\" onclick=\"createTable()\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:7:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"浏览器兼容性的例子\rie6，ie7对table.appendChild(“tr”)的支持和IE8不一样，用insertRow、insertCell来代替或者为表格添加tbody，然后向tbody中添加tr。FF不支持InnerText。 所以动态加载网站列表的程序修改为： var tr = tableLinks.insertRow(-1);//FF必须加-1这个参数 var td1 = tr.insertCell(-1); td1.innerText = key; var td2 = tr.insertCell(-1); td2.innerHTML = \"\u003ca href='\" + value + \"'\u003e\" + value + \"\u003c/a\u003e\"; 或者： \u003ctable id=\"tableLinks\"\u003e \u003ctbody\u003e\u003c/tbody\u003e \u003c/table\u003e，然后tableLinks. tBodies[0].appendChild(tr); \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function add() { var name = document.getElementById(\"txtName\").value; var content = document.getElementById(\"txtContent\").value; var tr = document.createElement(\"tr\"); var td0 = document.createElement(\"td\"); td0.innerText = name; tr.appendChild(td0); var td1 = document.createElement(\"td\"); td1.innerText = content; tr.appendChild(td1); var table = document.getElementById(\"re\"); table.appendChild(tr); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003e 最新新闻 \u003c/p\u003e \u003ctable id=\"re\"\u003e\u003c/table\u003e \u003chr /\u003e 评论： \u003cinput id=\"txtName\" type=\"text\" value=\"\" /\u003e\u003cbr /\u003e \u003ctextarea id=\"txtContent\" cols=\"50\" rows=\"10\"\u003e\u003c/textarea\u003e \u003cbr /\u003e \u003cinput type=\"button\" value=\"评论\" onclick=\"add()\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function add() { var name = document.getElementById(\"txtName\").value; var content = document.getElementById(\"txtContent\").value; var table = document.getElementById(\"re\"); var tr = table.insertRow(-1); var td = tr.insertCell(-1); td.innerHTML = name; var td1 = tr.insertCell(-1); td1.innerHTML = content; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003e 最新新闻 \u003c/p\u003e \u003ctable id=\"re\"\u003e\u003c/table\u003e \u003chr /\u003e 评论： \u003cinput id=\"txtName\" type=\"text\" value=\"\" /\u003e\u003cbr /\u003e \u003ctextarea id=\"txtContent\" cols=\"50\" rows=\"10\"\u003e\u003c/textarea\u003e \u003cbr /\u003e \u003cinput type=\"button\" value=\"评论\" onclick=\"add()\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:8:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"事件冒泡\r事件冒泡：如果元素A嵌套在元素B中，那么A被点击不仅A的onclick事件会被触发，B的onclick也会被触发。触发的顺序是“由内而外” 。验证：在页面上添加一个table、table里有tr、tr里有td，td里放一个p，在p、td、tr、table中添加onclick事件响应，见备注。 \u003ctable onclick=\"alert('table onclick');\"\u003e \u003ctr onclick=\"alert('tr onclick');\"\u003e \u003ctd onclick=\"alert('td onclick');\"\u003e\u003cp onclick=\"alert('p onclick');\"\u003eaaaa\u003c/p\u003e\u003c/td\u003e \u003ctd\u003ebbb\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function btn3() { alert(event.srcElement.value); } //事件响应函数的调用函数 function btn4() { alert(this.value); } function initBtn5() { var btn = document.getElementById(\"btn5\"); //事件响应函数 btn.onclick = btn4; } \u003c/script\u003e \u003c/head\u003e \u003cbody onload=\"initBtn5()\"\u003e \u003ctable onclick=\"alert('table')\"\u003e \u003ctr onclick=\"alert('tr')\"\u003e \u003ctd onclick=\"alert('td')\"\u003e \u003cdiv onclick=\"alert('div')\"\u003easd\u003c/div\u003e\u003c/td\u003e \u003ctd\u003e2\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003cinput type=\"button\" value=\"click1\" onclick=\"alert(event.srcElement.value)\" /\u003e\u003cbr /\u003e \u003c!-- 事件响应函数--\u003e \u003cinput type=\"button\" value=\"click2\" onclick=\"alert(this.value)\" /\u003e \u003cinput type=\"button\" value=\"click3\" onclick=\"btn3()\" /\u003e \u003cinput type=\"button\" value=\"click4\" onclick=\"btn4()\" /\u003e \u003cinput id=\"btn5\" type=\"button\" value=\"click5\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:8:1","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"this\r事件中的this。 除了可以使用event.srcElement在事件响应函数中 this表示发生事件的控件。 只有在事件响应函数才能使用this获得发生事件的控件，在事件响应函数调用的函数中不能使用，如果要使用则要将this传递给函数或者使用event.srcElement。 (*)this和event.srcElement的语义是不一样的，this就是表示当前监听事件的这个对象，event.srcElement是引发事件的对象：事件冒泡。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:9:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"修改样式\r易错：修改元素的样式不是设置class属性，而是className属性。案例：网页开关灯的效果。 修改元素的样式不能this.style=\"background-color:Red\"。 易错：单独修改样式的属性使用“style.属性名”。注意在css中属性名在JavaScript中操作的时候属性名可能不一样，主要集中在那些属性名中含有-的属性，因为JavaScript中-是不能做属性、类名的。所以CSS中背景颜色是background-color，而JavaScript则是style.backgroundColor；元素样式名是class，在JavaScript中是className属性；font-size→style.fontSize；margin-top→style.marginTop 单独修改控件的样式\u003cinput type=\"button\" value=\"AAA\" onclick=\"this.style.color='red'\" /\u003e。技巧，没有文档的情况下的值属性名，随便给一个元素设定id，然后在js中就能id.style.出来能用的属性。 \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e .light{ background-color:White; } .dark { background-color:Black; } \u003c/style\u003e \u003cscript type=\"text/javascript\"\u003e function open1() { document.body.className = \"light\"; } function close1() { document.body.className = \"dark\"; } function change() { var txt = document.getElementById(\"txt1\"); //错误 不能这样用。可以把style看成一个只读属性 //txt.style = \"background-color:Green\"; txt.style.backgroundColor = \"Green\"; txt.style.color = \"red\"; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"开灯\" onclick=\"open1()\" /\u003e \u003cinput type=\"button\" value=\"关灯\" onclick=\"close1()\" /\u003e \u003cinput id=\"txt1\" type=\"text\" value=\"123\" /\u003e \u003cinput type=\"button\" value=\"click\" onclick=\" change() \" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function initTxt() { var txts = document.getElementsByTagName(\"input\"); for (var i = 0; i \u003c txts.length; i++) { if (txts[i].type == \"text\") { //事件响应函数 txts[i].onblur = iBlur; } } } function iBlur() { if (this.value.length \u003c= 0) { this.style.backgroundColor = \"red\"; } else { this.style.backgroundColor = \"white\"; } } function iFocus(txt) { txt.value = \"\"; } \u003c/script\u003e \u003c/head\u003e \u003cbody onload=\"initTxt()\"\u003e \u003cinput type=\"text\" value=\"\"/\u003e \u003cinput type=\"text\" value=\"\" /\u003e \u003cinput type=\"text\" value=\"\" /\u003e \u003cinput type=\"button\" value=\"click\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function iBlur(txt) { var t2 = document.getElementById(\"t2\"); t2.style.backgroundColor = txt.style.backgroundColor; t2.style.color = txt.style.color; t2.style.width = txt.style.width; t2.value = txt.value; } function iFocus(txt) { var t1 = document.getElementById(\"t1\"); txt.style.backgroundColor = t1.style.backgroundColor; txt.style.color = t1.style.color; txt.style.width = t1.style.width; txt.value = t1.value; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput id=\"t1\" type=\"text\" value=\"\" style=\"background-color:Green; color:Red; width:300px\" /\u003e \u003cinput type=\"text\" onfocus=\"iFocus(this)\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function init() { var table = document.getElementById(\"rating\"); var tds = table.getElementsByTagName(\"td\"); for (var i = 0; i \u003c tds.length; i++) { //事件响应函数 tds[i].onmouseover = change; tds[i].onclick = stop; tds[i].style.cursor = \"pointer\"; } } //记录是否点鼠标，默认没点 var isClick = false; function stop() { isClick = true; } function indexOf(arr,element){ var j = -1; for(var i=0;i\u003carr.length;i++){ if(arr[i] == element) { j = i; break; } } return j; } function change() { //当没点鼠标的时候去执行 if (!isClick) { var table = document.getElementById(\"rating\"); var tds = table.getElementsByTagName(\"td\"); var n = indexOf(tds, this); for (var i = 0; i \u003c= n; i++) { //tds[i].style.backgroundColor = \"red\"; tds[i].innerText = \"★\"; } for (var i = n + 1; i \u003c tds.length; i++) { //tds[i].style.backgroundColor = \"white\"; tds[i].innerText = \"☆\"; } } } \u003c/script\u003e \u003c/head\u003e \u003cbody onload=\"init()\"\u003e \u003ctable id=\"rating\"\u003e \u003ctr\u003e \u003ctd\u003e☆\u003c/td\u003e\u003ctd\u003e☆\u003c/td\u003e\u003ctd\u003e☆\u003c/td\u003e\u003ctd\u003e☆\u003c/td\u003e\u003ctd\u003e☆\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function init() { var d1 = document.getElementById(\"d1\"); var links = d1.getElementsByTagName(\"a\"); for (var i = 0; i \u003c links.length; i++) { links[i].onclick = linkClick; } } function linkClick() { var d1 = document.getElementById(\"d1\"); var links = d1.getElementsByTagName(\"a\")","date":"2019-04-04","objectID":"/2019/04/web4-dom/:10:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"控制层显示\r修改style.display，例子：切换层的显示 function togglediv() { var div1 = document.getElementById('div1'); if (div1.style.display == '') { div1.style.display = 'none';//不显示 } else { div1.style.display = '';//显示 } } 案例：注册页面，点击“高级”CheckBox，则显示高级选项，否则隐藏 案例：鼠标放到一个超链接的时候，在鼠标的位置显示一个黄色背景，带图片的悬浮提示，鼠标离开就消失。提示：鼠标进入控件的事件是onmouseover，离开的事件是onmouseout。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:11:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"Body事件的范围\rIE中如果在body上添加onclick、onmousemove等事件响应，那么如果页面没有满，则 “body 中最后一个元素以下（横向不限制）” 的部分是无法响应事件的，必须使用代码在document上监听那些事件，比如document.onmousemove = MovePic FF中也差不多。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:12:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"元素的位置、大小单位\r通过dom读取元素的top、left、width、height等取到的值不是数字，而是“10px”这样的字符串；为这些属性设值的时候IE可以是80、90这样的数字，FF必须是“80px”、“90%”等这样的字符串形式，为了兼容统一用字符串形式。 易错：不要写成div1.style.width=80px，而是div1.style.width=‘80px’ 如果要修改元素的大小（宽度加10），则首先要取出元素的宽度，然后用parseInt将宽度转换为数字（parseInt可以将\"20px\"这样数字开头的包含其他内容的字符串解析为20，）；然后加上一个值，再加上px赋值回去。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:13:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"层的操作\r元素的position 样式值：static（无定位，显示在默认位置）、absolute（绝对定位）、fixed（相对于窗口的固定定位，位置不会随着浏览器的滚动而变化，IE6不支持）、relative（相对元素默认位置的定位）。如果要通过代码修改元素的坐标则一般使用absolute，然后修改元素的top（上边缘距离）、left（左边缘距离）两个样式值。left、top都是指的层的左上角的坐标 案例：跟着鼠标飞的图片。提示：鼠标移动的事件是onmousemove（一边移动事件一边触发，而不是移动开始或者移动完成才触发），通过window.event的clientX、clientY属性获得鼠标的位置。 案例：放三个超链接，鼠标放上时候动态生成一个层，层显示在鼠标的位置，鼠标离开的时候移除该层removeChild 案例：点击按钮层动态变大。提示：英文字母连续单词不会在中间自动换行的陷阱 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:14:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"易错\r易错：不要写成div1.style.width=80px，而是div1.style.width=‘80px’ 修改元素的样式不能this.style=“background-color:Red”，哪怕可以的话也是把以前所有样式都冲掉了。单独修改控件的样式this.style. background=‘red’，只修改要修改的样式。技巧，没有文档的情况下的值属性名，随便给一个元素设定id，然后在js中就能id.style.出来能用的属性。 createElement的两种用法，注意innerText的问题 var input = document.createElement(\"\")快速创建元素，并且赋值，但是注意设置的inner部分不会被设置var link = document.createElement(\"百度\") label.setAttribute(“for”, “username”); //设定一些Dom元素属性名特殊的属性,label.for = “username\"会有问题。label.setAttribute(“xuehao”,“33333”) ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:15:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"form对象\rdocument.getElementById(‘btn1’).click() form对象是表单的Dom对象。 方法：submit()提交表单，但是不会触发onsubmit事件。 实现autopost，也就是焦点离开控件以后页面立即提交，而不是只有提交submit按钮以后才提交，当光标离开的时候触发onblur事件，在onblur中调用form的submit方法。代码见备注。 在点击submit后form的onsubmit事件被触发，在onsubmit中可以进行数据校验，数据数据有问题，返回false即可取消提交 \u003cform name=\"form1\" action=\"a.aspx\" method=\"get\" onsubmit=\"if(document.getElementById('txtname').value.length\u003c=0){alert('姓名必填');return false;}\"\u003e 自动提交 \u003cform name=\"form1\" action=\"a.aspx\" method=\"get\"\u003e \u003cinput type=\"text\" onblur=\"form1.submit()\" /\u003e \u003cinput type=\"text\" /\u003e \u003c/form\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:16:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"不同浏览器差异\r面试题：说说开发项目的时候不同浏览器的不同点，你是怎么解决的？Button,appendChild,insertCell,px 不同浏览器中对DOM支持的方法不一样 获取网页中那个元素触发了事件：在IE里使用srcElement ；在FireFox里使用target 使用Dom获取和更改网页标签元素内文本：在IE里使用innerText ；在FireFox里使用textContent 动态为网页或元素绑定事件：在IE中绑定事件的方法是attachEvent ；在FireFox中绑定事件的方法是addEventListener 更多http://www.360doc.com/content/09/0319/12/16915_2855107.shtml。 不同浏览器中对CSS的支持不一样，所以出现在IE中显示正常的网页，在FF下全部乱掉了。哀悼网页使用的CSS只有IE支持，FF都不支持。 JQuery之类的框架进行了封装，将不同浏览器的差异帮开发人员处理了，开发人员只要调用JQuery的方法，JQuery会帮助在不同浏览器中进行翻译。用JQuery就可以解决不同浏览器上Dom的不同。对于CSS的不同是美工的事，IETester、FF、Chrome。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:17:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"弹出对话框处理\r复习，使用window.showModalDialog(‘dialog.htm’)弹出模态对话框 给对话框传递参数，使用showModalDialog的第二个参数传递参数，在对话框中用window.dialogArguments获得传递的参数值；对话框中给window.parent.returnValue设定返回值，这样在父窗口中就可以通过showModalDialog返回值读取设置的返回值了。例子：弹出对话框询问用户姓名，向用户问好；弹出含有“是”、“否”、“取消”三个按钮的模态窗口，点击按钮的时候窗口关闭，然后主窗口显示用户点击的按钮。 传递多个参数，将参数包装到数组中，然后仍然是通过第二个参数传递，返回多个返回值也可以返回数组：var arr = new Array();arr[0]=30;arr[1]=“tom”; 练习（面试题），弹出一个含有确定、取消、重试三个按钮的对话框，并且得知用户的选择。 给对话框传递参数，使用showModalDialog的第二个参数传递参数，在对话框中用window.dialogArguments获得传递的参数值；对话框中给window.parent.returnValue设定返回值，这样在父窗口中就可以通过showModalDialog返回值读取设置的返回值了： dialog.htm： function getData() { return document.getElementById('mytext1').value; } \u003cbody onLoad=\"javascript:document.getElementById('mytext1').value=window.dialogArguments;\"\u003e \u003cinput type=\"text\" id=\"mytext1\"/\u003e \u003cinput type=\"button\" value=\"确定\" onclick=\"javascript:window.parent.returnValue=getData();window.close();\"\u003e \u003c/body\u003e 主页面： var result=window.showModalDialog('dialog2.htm',777); alert(result); 传递多个参数，将参数包装到数组中即可：var arr = new Array();arr[0]=30;arr[1]=“tom”; ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:18:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"JS正则表达式\rJavaScript中创建正则表达式类的方法： var regex = new RegExp(”\\d{5}\") 或者 var regex = /\\d{5}/ /表达式/是JavaScript中专门为简化正则表达式编写而提供的语法，写在//中的正则表达式就不用管转义符了。 RegExp对象的方法： （1）test(str)判断字符串str是否匹配正则表达式，相当于IsMatch var regex = /.+@.+/; alert(regex.test(\"a@b.com\")); alert(regex.test(\"ab.com\")); （2）exec(str)进行搜索匹配，返回值为匹配结果，没找到返回null() （3）compile编译表达式，提高运行速度。 () ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:19:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"string 的正则表达\rReplace match String对象中提供了一些与正则表达式相关的方法，相当于对于RegExp类的包装，简化调用： match(regexp)，相当于调用exec var s = \"aaa@163.com\"; var regex = /(.+)@(.+)/; var match = s.match(regex); alert(RegExp.$1 + \"，服务器：\" + RegExp.$2); 练习：光标离开Email地址框的时候用正则表达式校验是否是合法的Email地址，如果不是的话Email地址框变红，并且注册按钮禁用，否则Email地址框颜色为白色，启用注册按钮。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:20:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"HTML JS压缩\rHTML、JavaScript的压缩和混淆。去掉空格、缩短变量名，让js、html尺寸更小，提高下载速度。 HTML、JS压缩、混淆有动态和静态两种方案。HTML压缩器，比如HTML Compress，JavaScript压缩工具：Google Closure Compiler、YUI Compressor 等。 很多js库都提供了.min.js、compress.js的压缩版本。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:21:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"什么是JAVASCRIPT\rHTML只是描述网页长相的标记语言，没有计算、判断能力，如果所有计算、判断（比如判断文本框是否为空、判断两次密码是否输入一致）都放到服务器端执行的话网页的话页面会非常慢、用起来也很难用，对服务器的压力也很大，因此要求能在浏览器中执行一些简单的运算、判断。JavaScript就是一种在浏览器端执行的语言。HTML内容，css衣服，修饰，js控制 JavaScript的Java没直接的关系，唯一的关系就是JavaScript原名LiveScript，后来吸收了Java的一些特性，升级为JavaScript。JavaScript有时被简称为JS。 JavaScript是解释型语言，无需编译就可以随时运行，这样哪怕语法有错误，没有语法错误的部分还是能正确运行。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:1:0","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"JAVASCRIPT开发环境\rVS中JavaScript、JQuery的自动完成功能：在VS2010中直接有，VS2008需要安装VisualStudio 2008SP1（http://www.microsoft.com/downloads/details.aspx?displaylang=zh-cn\u0026familyid=27673c47-b3b5-4c67-bd99-84e525b5ce61）和VS90SP1-KB958502-x86（http://code.msdn.microsoft.com/KB958502/Release/ProjectReleases.aspx?ReleaseId=1736）补丁会更强更好用。如果实在“.” 不出来也没关系，不影响运行。注意：先安装2008SP1，再安装VS90SP1-KB958502-x86。 JS是非常灵活的动态语言，不像C#等静态语言那样严谨，开发工具中的JS完成功能只是一个辅助、建议，“.”出来的成员调用可能不能用，“.”不出来的成员也许也能调用，因此不要因为“点儿不出来”而担心代码有问题。 VS2008的HTML编辑器中触发JavaScript自动完成：Ctrl+J。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:2:0","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"入门\r\u003cscript type=\"text/javascript\"\u003e alert(new Date().toLocaleDateString()); \u003c/script\u003e \u003cscript language=\"....\u003e已经不推荐使用。 JavaScript代码放到\u003cscript\u003e标签中，script可以放到\u003chead\u003e、\u003cbody\u003e等任意位置，而且可以有不止一个\u003cscript\u003e标签。alert函数是弹出消息窗口，new Date()是创建一个Date类的对象，默认值就是当前时间。 JS是大小写敏感的。 放到\u003chead\u003e中的\u003cscript\u003e在body加载之前就已经运行了。写在body中的\u003cscript\u003e是随着页面的加载而一个个执行的。 除了可以在页面中声明JavaScript以外，还可以将JavaScript写到单独的js文件中，然后在页面中引入：\u003cscript src=\"test.js\" type=\"text/javascript\"\u003e\u003c/script\u003e。声明到单独的js文件的好处是多页面也可以共享、减小网络流量。js文件的CDN(*)内容分发布网络(CDN),将别的服务器上的库 注意：不要写成\u003cscript src=\"test.js\" type=\"text/javascript\"/\u003e否则会有问题，这是一个比较特殊的地方。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:0","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"事件\r在超链接的点击里执行JavaScript：\u003ca href=\"javascript:alert(88)\"\u003e发发\u003c/a\u003e JavaScript中也有事件的概念，当按钮被点击的时候也可以执行JavaScript： \u003cinput type=\"button\" onclick=\"alert(99)\" value=\"久久\"/\u003e 只有超链接的href中的JavaScript中才需要加““javascript:”，因为它不是事件，而是把““javascript:”看成像“http:”、“ftp:”、“thunder://”、“ed2k://”、“mailto:”一样的网络协议，交由js解析引擎处理。只有href中这是这是一个特例。 \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e var sum = 0; for(int i = 0;i\u003c=100;i++){ sum += i; } alert(sum); function test() { var sum = 0; for(int i = 0;i\u003c=100;i++){ sum += i; } alert(sum); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003ca href=\"javascript:test()\"\u003eClick me\u003c/a\u003e \u003ca href=\"win.htm\" onclick=\"alert('123')\"\u003eClick me\u003c/a\u003e \u003cinput type=\"button\" value=\"按钮\" ondblclick=\"test()\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:1","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"变量\rJavaScript中即可以使用双引号声明字符串，也可以使用单引号声明字符串。主要是为了方便和html集成，避免转义符的麻烦。只有一种类型var JavaScript中有null、undefined两种，null表示变量的值为空，undefined则表示变量还没有指向任何的对象，未初始化。两者的区别参考资料。 JavaScript是弱类型，声明变量的时候无法：int i=0；只能通过var i=0;声明变量，和C#中的var不一样，不是C#中那样的类型推断。 JavaScript中也可以不用var声明变量，直接用，这样的变量是“全局变量”，因此除非确实想用全局变量，否则使用的时候最好加上var。 JS是动态类型的，因此var i=0;i=“abc”;是合法的。并且可以把方法放到var中， \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e var x = \"abc\"; if (!null) { alert(\"null\"); } if (!undefined) { alert(\"undefined\"); } if (x == null) { alert(\"null\"); } if (typeof(x) == \"undefined\") { alert(\"undefined\"); } if (!x) { alert(\"未初始化 0\"); } if (x) { alert(x); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:2","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"除错和调试\r如果JavaScript中的代码有语法错误，浏览器会弹出报错信息，查看报错信息就能帮助排查错误。 JavaScript的调试，使用VS可以很方便的进行JavaScript的调试，调试时需要注意几点： IE6的调试选项要打开，Internet选项→高级，去掉“禁用脚本调试”前的勾选。 以调试方式运行网页。 设置断点、监视变量等操作和C#一样。 案例：用循环语句的方法计算1到100之间整数的和 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:3","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"判断变量初始化\rJavaScript中判断变量、参数是否初始化 的三种方法： var x; if (x == null) { alert(\"null\"); } if (typeof (x) == \"undefined\") { alert('undefined'); } if (!x) {alert('不x');} if(x){}//变量被初始化了或者变量不为空或者变量不为0. 推荐用最后一种方法。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:4","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"函数声明\rJavaScript中声明函数的方式： function add(i1, i2) { return i1 + i2; } int add(int i1,int i2)//C#写法 不需要声明返回值类型、参数类型。函数定义以function开头。 var r = add(1, 2); alert(r); r = add(\"你好\", \"tom\"); alert(r); JavaScript中不像C#中那样要求所有路径都有返回值，没有返回值就是undefined。 易错：自定义函数名不要和js内置、dom内置方法重名，比如selectall、focus等函数名不要用。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:5","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"匿名函数\rvar f1 = function(i1, i2) { return i1 + i2; } alert(f1(1,2)); 类似于C#中的匿名函数。 这种匿名函数的用法在JQuery中的非常多 alert(function(i1, i2) { return i1 + i2; }(10,10));//直接声明一个匿名函数，立即使用。用匿名函数省得定义一个用一次就不用的函数，而且免了命名冲突的问题，js中没有命名空间的概念，因此很容易函数名字冲突。通过例子发现一旦命名冲突以最后声明的为准 必须\u003cscript src=\"my1.js\" type=\"text/javascript\"\u003e\u003c/script\u003e不能：\u003cscript src=\"my1.js\" type=\"text/javascript\"/\u003e ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:6","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"面向对象基础\rJavaScript中没有类的语法，是用函数闭包（closure）模拟出来的，下面讲解的时候还是用C#中的类、构造函数的概念，JavaScript中String、Date等“类”都被叫做“对象”，挺怪，方便初学者理解，不严谨。JavaScript中声明类（类不是类，是对象）： function Person(name,age) { this.name = name; this.age =age; this.sayHello=function(){ alert(\"你好，我是\"+this.name+\"，我\"+this.age+\"岁了\"); } } var p1 = new Person(\"tom\",20); p1.sayHello(); 必须要声明类名，function Person(name,age)可以看做是声明构造函数，Name、Age这些属性也是使用者动态添加了。var p1 = new Person(“tom”, 30);//不要丢了new，否则就变成调用函数了，p1为undefined。new 相当于创建了函数的一个实例 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:7","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"string 对象\rlength属性； charAt方法；取第几个字符 indexOf lastIndexOf Substr(start,length)、substring(start,end) split match、replace(只会替换一个，替换多个要用正则表达式)、search方法，正则表达式相关 var str = \"我爱北京天安门,北京天安门爱我\"; var reg = /我/g; alert(str.replace(\"我\", \"你\")); //replace()当第一个参数是字符串，只替换源字符串中的第一个匹配到的字符 如果是reg，就可以全部替换成功alert(str.replace(reg, \"你\")); 是正则表达式，是一个object ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:8","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"ARRAY对象\rJavaScript中的Array对象就是数组，首先是一个动态数组，而且是一个像C#中数组、ArrayList、Hashtable等的超强综合体。 var names = new Array(); names[0] = \"tom\"; names[1] = \"jerry\"; names[2] = \"lily\"; for (var i = 0; i \u003c names.length; i++) { alert(names[i]); } 无需预先制定大小，动态。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:9","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"dictionary\rJS中的Array是一个宝贝，不仅是一个数组，还是一个Dictionary，还是一个Stack。 var pinyins = new Array(); pinyins[\"人\"] = \"ren\"; pinyins[\"口\"] = \"kou\"; pinyins[\"手\"] = \"shou\"; alert(pinyins[\"人\"]); alert(pinyins.人); 像Hashtable、Dictionary那样用，而且像它们一样效率高。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:10","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"array简化\rArray还可以有简化的创建方式 var arr = [3, 5, 6, 8, 9]; 普通数组初始化 这种数组可以看做是pinyins[“人”] = “ren”;的特例，也就是key为0、1、2…… 字典风格的简化创建方式： var arr = {\"tom\":30,\"jim\":20}; ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:11","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"数组，for其他\r对于数组风格的Array来说，可以使用join方法拼接为字符串 var arr = [\"tom\",\"jim\",\"lily\"];\ralert(arr.join(\",\"));//JS中join是array的方法，不像.Net中是string的方法 for循环可以像C#中的foreach一样用 for循环还可以获得一个对象所有的成员，类似于.Net中的反射 for (var e in document) { alert(e); } 有了它没有文档也可以进行开发。 var p1 = new Object();//创建一个Object对象，动态增加属性、方法s p1.Name = \"tom\"; p1.Age = 30; p1.SayHello = function() { alert(\"hello\"); }; p1.SayHello(); for(var e in p1) {//对象的成员都是对象的key alert(e); } ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:12","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"扩展方法\r通过类对象的prototype设置扩展方法，下面为String对象增加quote（两边加字符）方法 String.prototype.quote = function(quotestr) { if (!quotestr) { quotestr = \"\\\"\"; } return quotestr + this + quotestr; }; alert(\"abc\".quote());alert(\"abc\".quote(\"|\")); 扩展方法的声明要在使用扩展方法之前执行。JS的函数没有专门的函数默认值的语法，但是可以不给参数传值，不传值的参数值就是undefined，自己做判断来给默认值。 一门新的语言学：数据类型，程序接口，类库 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:13","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"CSS（层叠样式表）是用来美化页面用的，可以对页面元素进行更精细的设置，样式主要描述元素的字体颜色、背景颜色、边框等。 CSS主要有元素内联、页面嵌入和外部引用三种使用方式。CSS是描述元素的皮肤！ 元素内联，直接将样式写入元素的style属性中，\u003cinput type=\"text\" readonly=\"readonly\" style=\"background-color: #FF00FF\" /\u003e，**style=“color:Red;background-color: #FF00FF”**为元素内联，适用于样式没有可复用性的场合。 页面嵌入：在head中加入 \u003cstyle type=\"text/css\"\u003e input{border-color:Yellow;color:Red;} \u003c/style\u003e 表示页面中所有input都是采用指定的样式。适合于样式复用，减小页面体积 \u003cstyle type=\"text/css\"\u003e P { color:Red; font-weight:bold; } \u003c/style\u003e 所有的P标签都变成红色字体，加粗。 外部引用，将css内容写入css后缀的文件 div{background:yellow} 然后在页面中引用，在head中加入 \u003clink type=\"text/css\" rel=\"Stylesheet\" href=\"s1.css\" /\u003e 适合于多个页面共享css。 更变原则：就近原则 ","date":"2018-10-22","objectID":"/2018/10/web2-css/:0:0","tags":["Web","css"],"title":"自学 CSS","uri":"/2018/10/web2-css/"},{"categories":"Web","content":"常见样式\rcss计量单位：css中表示宽度、距离时有多种计量单位：px（像素）、30%（百分比）、em（相对单位）等。width:20px。 background-color:Red;背景颜色；color：文本颜色 复合样式 background border border-style:solid;边框风格，实线solid（默认是没有），还有dotted(点)等值；border-color：边框颜色；border-width：边框宽度(默认是0)。例子：style=\"border-color:Red;border-width:1px;border-style:dotted;\" display：元素是否显示，可选值none（不显示,不占地儿）、block （显示为块级元素，此元素前后会带有换行符。）、inline（显示为内联元素，元素前后没有换行符 ）等。 cursor，鼠标在元素上时显示的光标图标，可选值：cursor（默认光标）、pointer（超链接上的手）、text（输入Bean）、wait（忙沙漏）、help（帮助）等。还可以通过cursor:url(dinosau2.ani)使用ani、cur格式的自定义光标图片。 LI不显示圆点：LIST-STYLE-TYPE: none;一般设在li或者ul上 应用：图片：不显示边框，见备注 图片：不显示边框 IMG { border:0px;BORDER-BOTTOM: medium none; BORDER-LEFT: medium none; BORDER-TOP: medium none; BORDER-RIGHT: medium none } ","date":"2018-10-22","objectID":"/2018/10/web2-css/:1:0","tags":["Web","css"],"title":"自学 CSS","uri":"/2018/10/web2-css/"},{"categories":"Web","content":"例子 外部引用\r* { /* 所有的元素 */ margin:0; padding:0; color:Red; } body { background:red url(/images/back_image.GIF); } span { /* block 块 display:block;*/ cursor:pointer; color:Blue; text-decoration:underline; } input { color:Green; } li { /* 去掉ul前面的黑点 */ list-style-type:none; } ","date":"2018-10-22","objectID":"/2018/10/web2-css/:1:1","tags":["Web","css"],"title":"自学 CSS","uri":"/2018/10/web2-css/"},{"categories":"Web","content":"样式选择器\r对于非元素内联的样式需要定义样式选择器，通俗的说就是这个样式适合于哪些元素，三种：标签选择器、class选择器和id选择器。 标签选择器 input{border-color:Yellow;color:Red;}，对于指定的标签采用统一的样式 class选择器，以定义一个命名的样式，然后在用到它的时候设定元素的class属性为样式的名称，还可以同时设定多个class，名称之间加空格 .d1 { color:Red; width:100px; } .d2 { color:Blue; width:200px; } .d3 { color:Green; width:300px; } \u003cdiv class=\"d1\"\u003e 123123123 \u003c/div\u003e \u003cdiv class=\"d2\"\u003e abc \u003c/div\u003e \u003cdiv class=\"d3\"\u003e 啊打发 \u003c/div\u003e 样式名称开头加“.” .warning{background:Yellow;} .highlight{font-size:xx-large;cursor:help;} \u003ctable\u003e \u003ctr\u003e \u003ctd class=\"highlight\"\u003eaaa\u003c/td\u003e \u003ctd class=\"warning\"\u003ebb\u003c/td\u003e \u003ctd class=\"highlight warning\"\u003eccc\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e 标签+类选择器:通过指定标签来确定不同的类适用范围 label.name { background-color:Gray; } input.name { color:Blue; } \u003clabel for=\"name\" class=\"name\"\u003e用户名：\u003c/label\u003e \u003cinput class=\"name\" id=\"name\" type=\"text\" value=\"\" /\u003e id选择器：与类选择器不同的地方就是.改成了#。 #wrap { border:solid 1px blue; width:300px; height:300px; } \u003cdiv id=\"wrap\"\u003e main \u003c/div\u003e 包含选择器：设置div中strong标签的格式，div中所有strong div strong { color:Red; } \u003cstrong\u003e测试\u003c/strong\u003e \u003cdiv\u003e \u003cstrong\u003e这是左边栏\u003c/strong\u003e left \u003c/div\u003e 后代选择器：直接属于div的strong才会属于这个样式。 div strong { color:Red; } \u003cdiv\u003e \u003cstrong\u003e这是左边栏\u003c/strong\u003e left \u003c/div\u003e 组合选择器 ：多个标签一个样式，组合选择器可以使用类选择器.h3,.p,.span {} h3,p,span { color:Yellow; } \u003ch3\u003e标题3\u003c/h3\u003e \u003cp\u003e这是段落\u003c/p\u003e \u003cspan\u003e这是span\u003c/span\u003e 伪选择器：超链接使用 A:visited：超链接点击过的样式；A:visited {TEXT-DECORATION: none}下划线 A:active：选中超链接时的样式；A:active {TEXT-DECORATION: none} A:link：超链接未被访问时的状态；A:link {TEXT-DECORATION: none} A:hover：鼠标移到超链接时的状态。A:hover {TEXT-DECORATION: underline} a:visited { color:Gray; } a:link { color:Red; } a:hover { color:Black; font-style:italic; } a:active { color:Yellow; } \u003ca href=\"http://www.itcast.cn\"\u003e传智播客\u003c/a\u003e \u003ca href=\"http://www.csdn.com\"\u003ecsdn\u003c/a\u003e \u003ca href=\"http://www.cnbeta.com\"\u003ecnbeta\u003c/a\u003e \u003ca href=\"http://www.123.com\"\u003e123\u003c/a\u003e ","date":"2018-10-22","objectID":"/2018/10/web2-css/:1:2","tags":["Web","css"],"title":"自学 CSS","uri":"/2018/10/web2-css/"},{"categories":"Web","content":"布局\r布局的分类：表格布局，框架布局，div+css布局 表格布局：表格套表格 ，代码多，table显示很慢，一块块的显示就比较麻烦，显示圆角就比较麻烦 框架布局：多个页面来显示： Frameset 框架页里不能有body \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003c/head\u003e \u003cframeset rows=\"30%,*\"\u003e \u003cframe name=\"top\" src=\"top.htm\" noresize=\"noresize\"/\u003e \u003cframeset cols=\"20%,*\"\u003e \u003cframe name=\"left\" src=\"left.htm\" noresize=\"noresize\"/\u003e \u003cframe name=\"main\" src=\"main.htm\" noresize=\"noresize\"/\u003e \u003c/frameset\u003e \u003c/frameset\u003e left.html \u003cbody\u003e \u003cul\u003e \u003cli\u003e\u003ca href=\"1-注册页面.htm\" target=\"main\"\u003e注册\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"5-选择器.htm\" target=\"if\"\u003e登陆\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/body\u003e iframe 嵌入页面 \u003ciframe src=\"iframe.htm\" name=\"0\" width=\"0\" height=\"0\"\u003e\u003c/iframe\u003e \u003cbody\u003e adsfasdf asdf \u003ciframe src=\"1-注册页面.htm\" width=\"0\" height=\"0\"\u003e\u003c/iframe\u003e adsf \u003c/body\u003e main.html iframe：在一个页面中嵌入一个页面 \u003cbody\u003e \u003ciframe src=\"1-注册页面.htm\" width=\"500px\" height=\"200px\" name=\"if\"\u003e\u003c/iframe\u003e adsf \u003c/body\u003e div+css布局： 网页布局就是“这块内容显示在左边，那两块内容并排显示，那块内容漂浮在页面上”。 不要使用\u003ctable\u003e进行布局，因为：table可能会在所有tr、td加载完成以后才显示，所以加载完成之前界面是一片空白；用table布局会将布局方式写在html中，违反了“语义性”原则；用table会影响搜索引擎的抓取，不利于SEO。因此Table用来表达真是表格状数据的东西，布局用Div(层)+Css来做,Div用来圈定元素，CSS用来定义元素的位置。 Div+CSS就是将要布局的内容用\u003cdiv\u003e切成块，然后使用css描述每个块的大小、位置等。 布局最重要的一个属性就是float， \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003clink href=\"css/style.css\" rel=\"stylesheet\" type=\"text/css\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"wrap\"\u003e \u003cdiv id=\"head\"\u003e \u003cdiv id=\"logo\"\u003e \u003cimg src=\"images/back_image.GIF\" width=\"100px\" height=\"50px\" /\u003e\u003c/div\u003e \u003cdiv id=\"menu\"\u003e \u003cul\u003e \u003cli\u003e首页\u003c/li\u003e \u003cli\u003e播客\u003c/li\u003e \u003cli\u003e相册\u003c/li\u003e \u003cli\u003e关于\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv id=\"body\"\u003e \u003cdiv id=\"nav\"\u003e \u003cul\u003e \u003cli\u003e好好学习\u003c/li\u003e \u003cli\u003e天天向上\u003c/li\u003e \u003cli\u003e不要睡觉\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cdiv id=\"content\"\u003e内容\u003c/div\u003e \u003c/div\u003e \u003cdiv id=\"footer\"\u003e版权\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e * { margin:0px; padding:0px; } body { background-color:Gray; } #wrap { width:98%; height:500px; margin:0px auto; } #head { height:150px; background-color:Red; } #head #menu { margin:80px auto 0px auto; padding-left:200px; } #head #menu ul { width:400px; } #head #menu li { float:left; width:100px; list-style-type:none; } #body { height:800px; background-color:White; } #body #nav { /* 强制英文换行 word-break:break-all; */ /* 溢出后显示滚动条 */ overflow:auto; background-color:Blue; width:200px; float:left; } #body #nav ul { padding-top:100px; } #body #nav li { list-style-type:none; height:30px; padding-left:30px; } #body #content { background-color:Green; } ","date":"2018-10-22","objectID":"/2018/10/web2-css/:2:0","tags":["Web","css"],"title":"自学 CSS","uri":"/2018/10/web2-css/"},{"categories":"Web","content":"HTML(HyperText Markup Language)：描述网页长什么样子、有什么内容的一个文本。查看网页的描述内容（HTML）的方式：使用IE浏览器的话，在网页上点击右键，选择“查看源文件”。 ","date":"2018-10-17","objectID":"/2018/10/web1-html/:0:0","tags":["Web","Html"],"title":"自学 HTML","uri":"/2018/10/web1-html/"},{"categories":"Web","content":"主要构架\r\u003chtml\u003e\r\u003chead\u003e\r\u003ctitle\u003e我的第一个网页\u003c/title\u003e\r\u003c/head\u003e\r\u003cbody bgcolor=\"red\" background=\"bg.jpg\"\u003e\rHello world\r\u003c/body\u003e\r\u003c/html\u003e\r所有内容都在\u003chtml\u003e\u003c/html\u003e标签之内； \u003chead\u003e\u003c/head\u003e内放的是头部信息，是对页面的描述，不会直接显示在页面中，\u003chead\u003e内的\u003ctitle\u003e中设置的是页面的标题，\u003ctitle\u003e只能放在\u003chead\u003e中； \u003cbody\u003e是页面的主体，大部分显示内容都定义在这里； \u003cmeta\u003e标签，\u003cmeta\u003e有指定name和指定http-equiv两种用法，\u003cmeta name=\"名字\" content=\"值\" /\u003e、\u003cmeta http-equiv=\"名字\" content=\"值\" /\u003e两种用法 \u003cmeta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\" /\u003e指定网页编码 \u003cmeta http-equiv=\"Refresh\" content=\"3\" /\u003e 三秒钟后刷新此网页 \u003cmeta http-equiv=\"Refresh\" content=\"3;url=http://www.rupeng.com\" /\u003e 三秒钟后重定向到新网页。发帖成功后提示“发帖成功，即将转向帖子查看页面” \u003cmeta http-equiv=\"Cache-Control\" content=\"no-cache\" /\u003e 禁止浏览器缓存页面 ","date":"2018-10-17","objectID":"/2018/10/web1-html/:1:0","tags":["Web","Html"],"title":"自学 HTML","uri":"/2018/10/web1-html/"},{"categories":"Web","content":"基本语法\r\u003ch\u003e：标签，HTML定义了\u003ch1\u003e\u003c/h1\u003e到\u003ch6\u003e\u003c/h6\u003e六个h标签，分别表示不同大小的字体。 \u003cbr\u003e：回车 \u003cp\u003e：分段。\u003cp\u003e前后会有比较大的空白，而\u003cbr\u003e则没有。 \u003ccenter\u003e这是居中\u003c/center\u003e居中显示 \u003cb\u003e粗体\u003c/b\u003e：粗体 \u003ci\u003e斜体\u003c/i\u003e：斜体 \u003cfont\u003e\u003c/font\u003e：字体标签，\u003cfont color=\"red\"\u003e红色\u003c/font\u003e \u003cfont size=\"30\" color=\"red\"\u003e红色\u003c/font\u003e 特殊字符：\u0026lt;（小于号，less than）；\u0026gt;（大于号，greater than）；\u0026nbsp;（空格，no-break space） \u003chr\u003e： 横线 color size width align=left,center,right \u003cpre\u003e：预格式化 保持本色 \u003cbody bgcolor=\"#006699\"\u003e背景颜色 \u003ca href=\"http://www.rupeng.com\"\u003e如鹏网\u003c/a\u003e超链接 \u003ca href=\"http://www.rupeng.com\"\u003e\u003cimg src=\"http://www.rupeng.com/forum/templates/uchome/images/logo.gif\"/\u003e\u003c/a\u003e镶嵌图片； “/”表示网站根目录，“../”表示父目录，“../../”表示父目录的父目录 将\u003ca\u003e的target属性设定为\"_blank\"就可以在新窗口中打开超链接。 锚记：用name属性为\u003ca\u003e 起名字：\u003ca name=\"Last\"\u003e这里是最后\u003c/a\u003e。这样可以通过\u003ca href=\"#Last\"\u003e转到平台\u003c/a\u003e来跳转到超链接的部分。去往评论、回到正文 \u003cimg src=\"a.jpg\"/\u003e注意图片是链接的，不是插入的，所以如果Src指向的文件不存在了，就看不了了。 alt： 图片无法显示时的显示文本，鼠标方式去也会有悬浮提示“点击查看大图” border属性指定边框，border=“0\"不显示边框 width、height属性指定图片的显示大小，如果不指定则是图片的原始大小 不要以为把bmp后缀改为jpg就是改文件格式了 如果网页上要显示小图（比如缩略图），不要仅仅是把大图设定一下width、height来缩小，因为仍然会下载大图，会使得加载速度很慢。 列表：\u003cul\u003e\u003cli\u003e灌水区\u003c/li\u003e\u003cli\u003e版务区\u003c/li\u003e\u003cli\u003e原创贴图\u003c/li\u003e\u003c/ul\u003e。无序列表。 有序的列表\u003col\u003e\u003c/ol\u003e 表格：\u003ctable\u003e\u003c/table\u003e为表格，在内部通过\u003ctr\u003e创建行，\u003ctr\u003e内部通过\u003ctd\u003e 创建单元格。可以将table的border属性设为0来隐藏表格线。 填充、间距Cellpadding内容和表格边线之间的距离 cellspacing单元格之间的间距s \u003ctr\u003e的属性：align，水平对齐，可选值left、right、center；valign，垂直对齐，可选值top、middle、bottom。 \u003ctd\u003e也有align和valign。\u003ctr align=\"right\"\u003e\u003ctd\u003etom\u003c/td\u003e\u003ctd align=\"left\"\u003e20\u003c/td\u003e\u003ctd\u003e男\u003c/td\u003e\u003c/tr\u003e：子标签默认继承父标签的属性，如果自己单独指定了属性，则会覆盖父标签的属性。 rowspan、colspan进行单元格的合并 表头的td可以用th代替，这样就会表头粗体、居中显示 表单：\u003cform\u003e标签为表单标签。如果要把数据提交到服务器，则需要将\u003cinput\u003e、\u003ctextarea\u003e、\u003cselect\u003e等表单元素放到form中 \u003cinput\u003e是主要的表单元素，type的可选值：submit（提交按钮）、button（普通按钮）、checkbox（复选框）、file（文件选择框）、hidden（隐藏字段）、image（图片按钮）、password（密码框）、radio（单选按钮）、reset（重置按钮）、text（文本框）。\u003cinput type=\"file\" /\u003e submit：点击submit按钮表单就会被提交给服务器，中文IE下默认按钮文本为“提交查询”，可以设置value属性修改按钮的显示文本 text：size属性为宽度，value为值，maxlength为可以输入的最大长度，readonly只读。\u003cinput type=\"text\" readonly/\u003e（只写属性名，不写属性值）或者\u003cinput type=\"text\" readonly=\"readonly\" /\u003e checkbox：checked属性表示是否被选中，\u003cinput type=\"checkbox\" checked /\u003e或者\u003cinput type=\"checkbox\" checked=\"checked\" /\u003e(推荐)checked、readonly等这种只有一个可选值的属性都可以省略属性值。 radio：相同name属性的为一组，不同radio设定不同的value值，这样通过取指定name的值就可以知道谁被选中了，不用单独的判断。 file：使用file，则form的enctype必须设置为multipart、form-data、form method属性为POST（*），get。get：少量数据，post：大量数据。\u003cform action=\"Default.aspx\" method=\"post\"\u003e\u003c/form\u003e image：使用src属性指定图片的地址，用来实现美化的“登录按钮”。 Reset:重置 \u003cselect\u003e:用来创建类似于WinForm中的ComboBox或者ListBox 如果size属性大于1就是ListBox（size的值为显示出来的列表数量），否则就是ComboBox。 \u003cselect multiple\u003e或者\u003cselect multiple=\"multiple\"\u003e（推荐），那么就是可以多选的ListBox。 select中的项是\u003coption\u003e，\u003coption\u003e北京\u003c/option\u003e还可以设定项的值\u003coption value=\"1\"\u003e北京\u003c/option\u003e。 将一个option设置为选中：\u003coption selected\u003e333\u003c/option\u003e或者\u003coption selected=\"selected\"\u003e333\u003c/option\u003e(推荐)就可以将这个项设定为选择项 如何实现“不选择”，添加一个\u003coption value=\"-1\"\u003e--不选择--\u003coption\u003e，然后编程判断select选中的值如果是-1就认为是不选择。 select分组选项，可以使用optgroup对数据进行分组，分组本身不会被选择，无论对于下拉列表还是列表框都适用。备注 \u003ctextarea\u003e多行文本（也是表单元素）：\u003ctextarea\u003e文本\u003c/textarea\u003e，cols、rows属性表示行数和列数。 \u003clabel\u003e：在\u003cinput type=\"text\"\u003e前可以写普通的文本来修饰，但是单击修饰文本的时候input并不会得到焦点，而用label则可以，for属性指定要修饰的控件的id，\u003clabel for=\"txt1\" \u003easdfad\u003c/label\u003e 为被修饰的控件设置一个唯一的id \u003clabel for=\"ma\"\u003e婚否\u003c/label\u003e \u003cinput id=\"ma\" type=\"checkbox\" /\u003e fieldset：GroupBox效果，将控件划分一个区域，看起来更规整 \u003cfieldset\u003e \u003clegend\u003e常用\u003c/legend\u003e \u003cinput type=\"text\" /\u003e \u003c/fieldset\u003e 滚动文字 \u003cmarquee\u003e scrolldelay控制速度 播放声音、显示flash， \u003cobject classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\" codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,29,0\" width=\"760\" height=\"700\"\r\u003cparam name=\"movie\" value=\"light-bot-2205.swf\" /\r\u003cparam name=\"quality\" value=\"high\" /\r\u003cembed src=\"light-bot-2205.swf\" quality=\"high\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" type=\"application/x-shockwave-flash\" width=\"760\" height=\"700\"\u003e\u003c/embed\r\u003c/object\u003e\r调用wmp的插件\u003cembed src=\"coder.mp3\" loop=true autostart=true name=bgss width=\"460\" height=\"68\"\u003e 只能播放wav和mid格式，只支持ie div：层\u003cdiv\u003e\u003c/div\u003e将内容放到层中，就以将这些内容当成一个整体进行处理，比如整体隐藏、整体移动等。div非常强大和常用。类似于WinForm的Panel。 span:div是将内容放到一个矩形的区块中，会影响布局，而span只是把一段内容定义成一个整体进行操作，但不影响布局、显示。 ","date":"2018-10-17","objectID":"/2018/10/web1-html/:2:0","tags":["Web","Html"],"title":"自学 HTML","uri":"/2018/10/web1-html/"},{"categories":"Web","content":"备注\rxml：描述存的什么数据 XHTML:可扩展超文本置标语言（eXtensible HyperText Markup Language，XHTML） DHTML：动态HTML； 格式标签：\u003cp\u003e\u003c/p\u003e创建段落；\u003cbr /\u003e回车，也可以写成\u003cbr\u003e，在HTML中有一些标签可以不关闭，\u003cbr\u003e就是一个，这是和XML不同的地方（常考），但是为了遵循XHTML规范，推荐像XML一样严格关闭。\u003cbr/\u003e\u003cimg src=\"1.gif\"/\u003e 属性值：HTML中属性值即可以用单引号括起来、也可以用双引号括起来、甚至不用引号都可以（不推荐），单双要配对。 注释：HTML使用和XML一样的来做注释。 ","date":"2018-10-17","objectID":"/2018/10/web1-html/:3:0","tags":["Web","Html"],"title":"自学 HTML","uri":"/2018/10/web1-html/"},{"categories":"设计模式","content":"上一章中对薪水支付案例的用例和类做了详细的阐述，在本篇会介绍薪水支付案例包的划分和数据库，UI的设计。 ","date":"2018-10-10","objectID":"/2018/10/designpattern3-case2/:0:0","tags":["敏捷软件开发原则模式与实践","薪水支付"],"title":"敏捷软件开发原则模式与实践 薪水支付","uri":"/2018/10/designpattern3-case2/"},{"categories":"设计模式","content":"包的划分\r一个错误包的划分 为什么这个包是错误的： 如果对classifications更改就要影响payrolldatabase更改，还会迫使transactions更改，tansactions重新发布和编译测试就是不负责的，transactions没有共享封闭性，每个类都有自己变化的敏感，所以发布的频率非常高，是不合理的。 调整一下： 将具体类和具体类打包，抽象类和抽象类打包，交互类单独打包。这已经是一个比较好打包设计了。 类的组件应该要符合共同重用原则，payrolldamain中的类没有形成最小的可重用单元，transaction类不必和组件中的其他类一起重用，可以把transaction迁移到transactionapplication类中 这样的划分太精细了，是否有这样的必要需要整体来看。 最终包的结构： ","date":"2018-10-10","objectID":"/2018/10/designpattern3-case2/:1:0","tags":["敏捷软件开发原则模式与实践","薪水支付"],"title":"敏捷软件开发原则模式与实践 薪水支付","uri":"/2018/10/designpattern3-case2/"},{"categories":"设计模式","content":"数据库的设计\remplogee是核心 完成这个设计需要进行重构： 提取出payrolldatabase接口， public interface PayrollDatabase { void AddEmployee(Employee employee); Employee GetEmployee(int id); void DeleteEmployee(int id); void AddUnionMember(int id, Employee e); Employee GetUnionMember(int id); void RemoveUnionMember(int memberId); ArrayList GetAllEmployeeIds(); IList GetAllEmployees(); } 内存表实例： public class InMemoryPayrollDatabase : PayrollDatabase { private static Hashtable employees = new Hashtable(); private static Hashtable unionMembers = new Hashtable(); public void AddEmployee(Employee employee) { employees[employee.EmpId] = employee; } // etc... public Employee GetEmployee(int id) { return employees[id] as Employee; } public void DeleteEmployee(int id) { employees.Remove(id); } public void AddUnionMember(int id, Employee e) { unionMembers[id] = e; } public Employee GetUnionMember(int id) { return unionMembers[id] as Employee; } public void RemoveUnionMember(int memberId) { unionMembers.Remove(memberId); } public ArrayList GetAllEmployeeIds() { return new ArrayList(employees.Keys); } public IList GetAllEmployees() { return new ArrayList(employees.Values); } public void Clear() { employees.Clear(); unionMembers.Clear(); } } 数据库 public class SqlPayrollDatabase : PayrollDatabase { private SqlConnection connection; public SqlPayrollDatabase() { connection = new SqlConnection(\"Initial Catalog=Payroll;Data Source=localhost;user id=sa;password=abc\"); connection.Open(); } ~SqlPayrollDatabase() { connection.Close(); } public void AddEmployee(Employee employee) { //增加员工策略 SaveEmployeeOperation operation = new SaveEmployeeOperation(employee, connection); operation.Execute(); } public Employee GetEmployee(int id) { //数据库事务 LoadEmployeeOperation loadOperation = new LoadEmployeeOperation(id, connection); loadOperation.Execute(); return loadOperation.Employee; } public void DeleteEmployee(int id) { throw new NotImplementedException(); } public void AddUnionMember(int id, Employee e) { throw new NotImplementedException(); } public Employee GetUnionMember(int id) { throw new NotImplementedException(); } public void RemoveUnionMember(int memberId) { throw new NotImplementedException(); } public ArrayList GetAllEmployeeIds() { throw new NotImplementedException(); } public IList GetAllEmployees() { throw new NotImplementedException(); } } 如果插入雇佣记录成功，但是支付记录失败，为了解决这个问题而使用事务的方式。 public class SaveEmployeeOperation { private readonly Employee employee; private readonly SqlConnection connection; private string methodCode; private string classificationCode; private SqlCommand insertPaymentMethodCommand; private SqlCommand insertEmployeeCommand; private SqlCommand insertClassificationCommand; public SaveEmployeeOperation(Employee employee, SqlConnection connection) { this.employee = employee; this.connection = connection; } public void Execute() { PrepareToSavePaymentMethod(employee); PrepareToSaveClassification(employee); PrepareToSaveEmployee(employee); SqlTransaction transaction = connection.BeginTransaction(\"Save Employee\"); try { ExecuteCommand(insertEmployeeCommand, transaction); ExecuteCommand(insertPaymentMethodCommand, transaction); ExecuteCommand(insertClassificationCommand, transaction); transaction.Commit(); } catch(Exception e) { transaction.Rollback(); throw e; } } private void ExecuteCommand(SqlCommand command, SqlTransaction transaction) { if(command != null) { command.Connection = connection; command.Transaction = transaction; command.ExecuteNonQuery(); } } private void PrepareToSaveEmployee(Employee employee) { string sql = \"insert into Employee values (\" + \"@EmpId, @Name, @Address, @ScheduleType, \" + \"@PaymentMethodType, @PaymentClassificationType)\"; insertEmployeeCommand = new SqlCommand(sql); this.insertEmployeeCommand.Parameters.Add(\"@EmpId\", employee.EmpId); this.insertEmployeeCommand.Parameters.Add(\"@Name\", employee.Name); this.insertEmployeeCommand.Parameters.Add(\"@Address\", employee.Address); this.insertEmployeeCommand.Parameters.Add(\"@ScheduleType\", Schedu","date":"2018-10-10","objectID":"/2018/10/designpattern3-case2/:2:0","tags":["敏捷软件开发原则模式与实践","薪水支付"],"title":"敏捷软件开发原则模式与实践 薪水支付","uri":"/2018/10/designpattern3-case2/"},{"categories":"设计模式","content":"界面设计\r界面设计时最好使得业务行为和UI分离，这里使用model view presenter模式（MVP） model：实体层和数据库交互 view：界面层 presenter：业务处理层 MVP的作用是解耦界面、业务和实体的关系 在presenter中主动使用view，界面的形态都是由presenter去控制，就是在presenter中去注册view事件，当用户触发事件时，这个事件会通过view传递到presenter中，并通过presenter调用model数据方法，最后presenter 调用引用的view实例去改变界面的形态。 public class AddEmployeePresenter { private TransactionContainer transactionContainer; private AddEmployeeView view; private PayrollDatabase database; private int empId; private string name; private string address; private bool isHourly; private double hourlyRate; private bool isSalary; private double salary; private bool isCommission; private double commissionSalary; private double commission; public AddEmployeePresenter(AddEmployeeView view, TransactionContainer container, PayrollDatabase database) { this.view = view; this.transactionContainer = container; this.database = database; } public int EmpId { get { return empId; } set { empId = value; UpdateView(); } } public string Name { get { return name; } set { name = value; UpdateView(); } } public string Address { get { return address; } set { address = value; UpdateView(); } } public bool IsHourly { get { return isHourly; } set { isHourly = value; UpdateView(); } } public double HourlyRate { get { return hourlyRate; } set { hourlyRate = value; UpdateView(); } } public bool IsSalary { get { return isSalary; } set { isSalary = value; UpdateView(); } } public double Salary { get { return salary; } set { salary = value; UpdateView(); } } public bool IsCommission { get { return isCommission; } set { isCommission = value; UpdateView(); } } public double CommissionSalary { get { return commissionSalary; } set { commissionSalary = value; UpdateView(); } } public double Commission { get { return commission; } set { commission = value; UpdateView(); } } private void UpdateView() { if(AllInformationIsCollected()) view.SubmitEnabled = true; else view.SubmitEnabled = false; } public bool AllInformationIsCollected() { bool result = true; result \u0026= empId \u003e 0; result \u0026= name != null \u0026\u0026 name.Length \u003e 0; result \u0026= address != null \u0026\u0026 address.Length \u003e 0; result \u0026= isHourly || isSalary || isCommission; if(isHourly) result \u0026= hourlyRate \u003e 0; else if(isSalary) result \u0026= salary \u003e 0; else if(isCommission) { result \u0026= commission \u003e 0; result \u0026= commissionSalary \u003e 0; } return result; } public TransactionContainer TransactionContainer { get { return transactionContainer; } } public virtual void AddEmployee() { transactionContainer.Add(CreateTransaction()); } public Transaction CreateTransaction() { if(isHourly) return new AddHourlyEmployee( empId, name, address, hourlyRate, database); else if(isSalary) return new AddSalariedEmployee( empId, name, address, salary, database); else return new AddCommissionedEmployee( empId, name, address, commissionSalary, commission, database); } } public interface ViewLoader { void LoadPayrollView(); void LoadAddEmployeeView( TransactionContainer transactionContainer); } public class WindowViewLoader : ViewLoader { private readonly PayrollDatabase database; private Form lastLoadedView; public WindowViewLoader(PayrollDatabase database) { this.database = database; } public void LoadPayrollView() { PayrollWindow view = new PayrollWindow(); PayrollPresenter presenter = new PayrollPresenter(database, this); view.Presenter = presenter; presenter.View = view; // 相互关联 LoadView(view); } public void LoadAddEmployeeView( TransactionContainer transactionContainer) { AddEmployeeWindow view = new AddEmployeeWindow(); AddEmployeePresenter presenter = new AddEmployeePresenter(view, transactionContainer, database); view.Presenter = presenter; LoadView(view); } private void LoadView(Form view) { view.Show(); lastLoadedView = view; } /// \u003csummary\u003e /// 最新的form /// \u003c/summary\u003e public Form LastLoadedView { get { return lastLoadedView; } } } public class PayrollMain { public static void Main(string[] args) { PayrollDatabase database = new InMemoryPayrollDatabase(); WindowViewLoader viewLoader = new WindowViewLoader(database);","date":"2018-10-10","objectID":"/2018/10/designpattern3-case2/:3:0","tags":["敏捷软件开发原则模式与实践","薪水支付"],"title":"敏捷软件开发原则模式与实践 薪水支付","uri":"/2018/10/designpattern3-case2/"},{"categories":"设计模式","content":"单一职责原则(single responsibilities principle,SRP)\r原理：一个类应该只有一个变化 分离职责：如果不耦合的职责那么很简单，如果两个职责耦合，将两个职责抽象为接口，通过继承两个接口将依赖关系抽离处理啊 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:1:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"开放封闭原则(open close principle,OCP)\r软件实体(类，模块，函数等)应该是可以扩展的，但是不可修改 对扩展开放：当需求改变时，对模块可以扩展。 对修改封闭：对模块进行扩展时，不必改动模块的源代码或则二进制代码， 仅仅抽象出容易变化的部分。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:2:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"里氏替换原则(liskov substitution principle,LSP)\r子类型必须能够替换掉它的基类型。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:3:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"依赖倒置原则(dependence inversion principle,DIP)\r高层模块不应该依赖于底层模块，二者都应该依赖抽象 抽象不应该依赖细节，细节应该依赖抽象 为什么叫倒置，在传统软件开发中，总倾向于创建一些高层模块依赖底层模块，策略依赖细节的软件结构。一个良好的面向对象程序，对传统设计结构而言就被倒置了。 其实就是都依赖接口编程，高层依赖接口，细节依赖接口，这样模块的改动不会影响其他模块。比较好的模块设计： 模块和模块间的依赖都是依赖接口。 倒置不仅仅是依赖关系的倒置，也是接口所有权的倒置，通常会认为工具库应该拥有自己的接口，但其实应该是客户拥有接口，而它们的服务者应该是接口的派生。著名的 holly wood原则：“Don’t call us, we’ll call you”不要调用我们，我们会调用你，低层模块实现在高层模块中声明并被高层模块调用的接口 程序所有的依赖关系都应该终止与抽象 任何变量都不应该持有一个指向具体类的引用 任何类都不应该从具体类派生 任何方法都不应该重写它的任何基类中已经实现的方法。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:4:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"接口隔离原则(interface segregation principle,ISP)\r","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:5:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"接口会被污染:\r当借口的职责不再单一时，接口就很容易受到污染。 一个常见的例子：一个门，可能是关着也可能是开着，而且门类知道只是是开着还是关着。 常见的接口设计，现在需要实现自动报警，当门开着超过一定的时间就进行报警。常见的方法是关联timer类，实现报警。 这种方案就造成了接口污染，所有的门都必须依赖timeclient，同时还会出现门检测到时间超时，还未报警时，门关闭了，然后又被打开了，门变成了错误的报警 通过增加一个报警id,来区别每一次报警和客户端。 接口隔离原则：不应该强迫客户程序依赖并未使用的方法。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:5:1","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"隔离接口\r通过适配器原则，实现timer类对door类的引用隔离doorclient.这样仅仅增加了一个类，而将引用关系倒置。 创建一个派生自timer的timerclient对象，并把该对象请求委托给timerdoor。 这样就实现了timer和door的隔离，即使对timer进行更改也不会影响到door。timerdoor也不需要和timerclient一样的接口， 另一种方法是使用timerdoor来多重继承，door和timerclient， 这种方案没有多余的开销，只有当doortimeradapter对象所做的转换是必须的时候或则不同的时候需要不同的转换的时候，才需要使用适配器方法。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:5:2","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"例子：\rAMT的一个例子，输出信息要转换成不同的语言，输出信息要显示在桌面上， 把不同的事务处理方法封装在transaction上，这样每个事务的修改都会造成UI的修改，如果把接口分解成不通的单独接口，就可以避免 打包原则\r大型系统的设计非常依赖于好的组件设计，这样每个团队只要关注于单个组件而不需要关注整个系统。 但类经常会和其他类发生依赖关系，这些依赖关系也会跨越组件的边界。 在向组件中分配类时应该依据什么原则 应该使用什么设计原则来管理组件之间的关系 组件的设计应该先于类（自顶而下），还是设计应该先于组件（自底而上） 组件的实体以什么方式存在 组件创建好后，用于何种目的 组件和组件间的依赖关系：不能依赖具体类。只能是具体依赖抽象，抽象依赖抽象。这样就可以将影响将至最低。 前三个原则来指导如何将类划分到包中，后三个原则来管理包之间的耦合(稳定)。组件之间的耦合越稳定就越好 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:5:3","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"重用发布等价原则(reuse release equivalence principle,REP)\r重用粒度就是发布粒度：一个组件的重用粒度和发布粒度一样大，重用的任何东西必须被同时发布和跟踪， 重用性必然是基于组件的，所以可重用的组件必须包含可重用的类，因至少某些组件应该由一组可重用的类组成 一个类中的组件要么都是可重用的，要么都是不可重用的。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:6:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"共同重用原则(common reuse principle , crp)\r一个组件中所有的类都应该是共同重用的，如果重用了组件中的一个类，那么就要重用组件中的所有类。 这个原则可以帮助我们确定哪些类应该在一个组件中，相互之间没有紧密联系的类不应该在同一个组件中。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:7:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"共同封闭原则(common closure principle,ccp)\r组件中所有的类对同一种性质的变化应该是共同封闭的，一个变化若对一个封闭的组件产生影响，则将对该组件中所有的类产生影响，而对其他组件不产生影响。类似于单一职责原则。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:8:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"无环依赖原则\r在组件的关系图中不允许存在环。 解除依赖环的方法：提取抽象接口，通过实现接口来替换关联。关联和实现的依赖关系相反。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:9:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"稳定依赖原则\r朝着稳定的方向进行依赖。 被依赖的越多，该组件就越不可能改动，则越稳定。 稳定性度量： ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:10:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"稳定抽象原则\r组件的抽象程度与其稳定性。 中间连接线称为主序列。 到主序列的距离： 越为0 越好 有了度量和标准就让我们划分组件吧！！！ ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:11:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"这本书的实例非常好，给了我非常多的启发。主要讲了两个实例，咖啡机和薪水支付实例，咖啡机实例比较简单并没有用什么设计模式，薪水支付实例用了很多设计模式，包括后面的打包等。 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:0:0","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"咖啡机实例\r做一个使用咖啡机的软件，驱动接口已经被写好。 咖啡机的硬件包括： 加热器加热棒（开关） 保温盘加热棒（开关） 保温盘传感器（保温盘空，杯子空，杯子不空） 加热器传感器（有水，没水） 冲煮按钮（开关） 指示灯（开关） 减压阀门（开关） 咖啡机的冲煮流程： 咖啡机一次煮12杯咖啡， 咖啡加入过滤器，过滤器加入支架，支架放到咖啡机。 倒入12杯水到滤水器，按下冲煮，水杯加热至沸腾，水蒸气碰洒到过滤器，形成水滴到咖啡壶，咖啡壶发现有水保温， 拿走水杯，停止工作。 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:1:0","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"方案一\r建立一个咖啡机超类，关联各个硬件类。这个方案是非常丑陋的，这不是根据行为划分的，有些类，比如light没有任何变量，仅仅调用了驱动接口，这种类叫水蒸气类。没有意义 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:1:1","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"方案二\r按照行为来划分，要确定一些类有没有意义，只需要确定谁使用他们，而且要到业务底层去看。把问题的本质和细节分离，忘掉一切，最根本的问题是如何煮咖啡。如何煮咖啡，将热水倒到咖啡上，把冲泡好的咖啡收集起来。水从哪来？咖啡放到哪里？那么就有两个类：热水类和支架类，大大多数人会考虑热水流到支架中，这是比较错误的，软件的行为应该按照软件的行为给出而不是基于一些物理关系。还需要考虑用户界面，这样就有三个类。 谁使用 最根本的问题 软件行为而不是物理行为 用例\r按下冲煮，启动水流，支架做好准备，都准备好就开始煮咖啡 接受器具准备好没有 冲煮完成 咖啡喝完 Containment Vessel:支架和保温壶 Resume:恢复 a，b，c，d表示四种逻辑： a 表示：用户按下冲煮，确保支架中有咖啡壶放在保温杯上，热水器中已经加满了水，然后才开始煮咖啡 b 表示：如果正在股咖啡的过程中咖啡壶被拿走，则必须中断咖啡流，停止送热水，再次放回咖啡壶继续煮咖啡 c 表示：热水器中传感器告诉我们水用完了就停止煮咖啡，同时告诉用户和支架（保温盘）已经停止煮咖啡 d 表示：冲煮结束时并且一个空的咖啡壶放在支架上（保温盘），热水器应该知道这个消息，同时用户也应该知道这个消息 这样整个咖啡机的抽象就完成了，按职责划分，各司其职。这三个抽象类不能知道任何关于咖啡机的任何信息。这就是依赖倒置原则。 系统的控制流如何检测传感器呢？是选择线程还是轮询。最好的总是假设消息都是可以异步发送的，就像存在有独立的线程一样，把使用轮询还是线程的决策推迟到最后一刻。 这样设置了一个接口，main()程序就待在一个循环中，不停地一遍遍调用这个方法实现轮询。 public static void Main(string[] args) { CoffeeMakerAPI api = new M4CoffeeMakerAPI(); M4UserInterface ui = new M4UserInterface(api); M4HotWaterSOurce hws = new M4HotWaterSOurce(api); M4ContainmentVessel cv = new M4ContainmentVessel(api); ui.Init(hws,cv); hws.Init(ui,cv); cv.Init(hws,ui); while(true) { ui.Poll(); hws.Poll(); cv.Poll(); } } 依赖倒置，不允许高层的咖啡制作中依赖底层实现。 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:1:2","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"薪水支付实例\r该案例主要有做一个薪水支付系统，主要有三类员工 临时工：基本时薪，超过8小时加班时间1.5倍工资，每天有考勤卡，每周5结算。 正式员工：月薪，每个月最后一天结算。 经理：月薪，每月最后一天结算，有项目提成，每隔一周的周五结算，加入公会扣会费。 公会会费分服务费和会费：会费每周都有从薪水中扣除，服务费从下个月薪水中扣除。 薪水支付方式：可以选择支票邮寄到家，支票保存自取，直接存入银行账号。 薪水支付每天运行一次，在当天为相应的雇员进行支付，上一次支付到本次支付应付的数额。 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:2:0","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"用例：\r新增雇员：雇员号，姓名，地址。（零时工，正式员工，经理） 删除雇员：雇员号 登记考勤卡：雇员号，日期，小时 登记销售凭条：雇员号，日期，销售记录 登记公会服务费：公会成员，服务费用 更改雇员细则：更改姓名，更改地址，更改每小时报酬，更改薪水，更改提成，更改支付方式，加入公会，离开公会 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:2:1","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"设计类和结构：\r通过迭代的方式进行实现。数据库是实现细节，应该尽推迟数据库的设计。通过用例来推导出应该有哪些类。 从用例的角度设计\r新增雇员 Hourly:小时工 Commissioned：正式员工 Balarid：经理 把每一项工作划分为自己的类中。这样有可能会创建三个雇员类，但是分析一下就会发现变化的东西太多了，正式由于雇员变化的东西引发雇员类型的改变，只需要将变化的东西抽象出来，在更改雇员细则时改变这些变化的东西就可以改变雇员类型。 登记考勤卡 考勤卡和雇员应该是聚合的关系 登记销售凭条 销售凭条和雇员也应该是聚合的关系 登机工会服务费 工会服务费维护着工会会员的编号，因此系统必须要把工会成员和雇员标识联系起俩，推迟这一行为。公会成员和服务费也是聚合的关系 更改雇员细则 这是由多个更改策略组合而成。 最后各个类之间的关系 从程序运行的角度补充细节\r运行薪水支付系统：找到所有进行支付的雇员，确定扣款额，根据他们的支付方式支付。 抽象出变化的东西：雇员的支付类别抽象，支付时间抽象 工会服务费抽象。Affillation:联系 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:2:2","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"实现\r事务 事务是使用命令模式。 增加雇员事务，雇员有三个类型，所以使用模板模式来实现增加雇员，此处模板模式的唯一任务就是创建对象 public abstract class AddEmployeeTransaction : Transaction { private readonly int empid; private readonly string name; private readonly string address; public AddEmployeeTransaction(int empid, string name, string address, PayrollDatabase database) : base (database) { this.empid = empid; this.name = name; this.address = address; } protected abstract PaymentClassification MakeClassification(); protected abstract PaymentSchedule MakeSchedule(); public override void Execute() { PaymentClassification pc = MakeClassification(); PaymentSchedule ps = MakeSchedule(); PaymentMethod pm = new HoldMethod(); Employee e = new Employee(empid, name, address); e.Classification = pc; e.Schedule = ps; e.Method = pm; database.AddEmployee(e); } public override string ToString() { return String.Format(\"{0} id:{1} name:{2} address:{3}\", GetType().Name, empid, name,address); } } public class AddSalariedEmployee : AddEmployeeTransaction { private readonly double salary; public AddSalariedEmployee(int id, string name, string address, double salary, PayrollDatabase database) : base(id, name, address, database) { this.salary = salary; } protected override PaymentClassification MakeClassification() { return new SalariedClassification(salary); } protected override PaymentSchedule MakeSchedule() { return new MonthlySchedule(); } } 删除雇员 提供雇员id，去数据库删除雇员，没啥好说的。 考勤卡、销售凭条、服务费 考勤卡：需要参数，雇员id,日期，工作时间 public class TimeCard { private readonly DateTime date; private readonly double hours; public TimeCard(DateTime date, double hours) { this.date = date; this.hours = hours; } public double Hours { get { return hours; } } public DateTime Date { get { return date; } } } public class TimeCardTransaction : Transaction { private readonly DateTime date; private readonly double hours; private readonly int empId; public TimeCardTransaction(DateTime date, double hours, int empId, PayrollDatabase database) : base(database) { this.date = date; this.hours = hours; this.empId = empId; } public override void Execute() { Employee e = database.GetEmployee(empId); if (e != null) { HourlyClassification hc = e.Classification as HourlyClassification; if (hc != null) hc.AddTimeCard(new TimeCard(date, hours)); else throw new ApplicationException( \"Tried to add timecard to\" + \"non-hourly employee\"); } else throw new ApplicationException( \"No such employee.\"); } } 其他两种与这类似 更改雇员属性 更改雇员属性由多个事务集合而成 改名字事务： public abstract class ChangeEmployeeTransaction : Transaction { private readonly int empId; public ChangeEmployeeTransaction(int empId, PayrollDatabase database) : base (database) { this.empId = empId; } public override void Execute() { Employee e = database.GetEmployee(empId); if(e != null) Change(e); else throw new ApplicationException( \"No such employee.\"); } protected abstract void Change(Employee e); } public class ChangeNameTransaction : ChangeEmployeeTransaction { private readonly string newName; public ChangeNameTransaction(int id, string newName, PayrollDatabase database) : base(id, database) { this.newName = newName; } protected override void Change(Employee e) { e.Name = newName; } } 更改雇员类别 public abstract class ChangeClassificationTransaction : ChangeEmployeeTransaction { public ChangeClassificationTransaction(int id, PayrollDatabase database) : base (id, database) {} protected override void Change(Employee e) { e.Classification = Classification; e.Schedule = Schedule; } protected abstract PaymentClassification Classification { get; } protected abstract PaymentSchedule Schedule { get; } } public class ChangeHourlyTransaction : ChangeClassificationTransaction { private readonly double hourlyRate; public ChangeHourlyTransaction(int id, double hourlyRate, PayrollDatabase database) : base(id, database) { this.hourlyRate = hourlyRate; } protected override PaymentClassification Classification { get { return new HourlyClassification(hourlyRate); } } protected override PaymentSchedule Schedule { get { return new WeeklySchedule(","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:2:3","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"总结\r到目前为止基本功能已经实现，仅仅只是用了模板，空值，命令等设计模式，下一篇将会进一步使用更多的设计模式进行打包处理。 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:3:0","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"所看书籍是：敏捷软件开发_原则、模式与实践_C#版（美）马丁著，这本书写的非常棒，感谢作者。该归纳总结的过程按照我读的顺序写。 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:0:0","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"UML\r在建造桥梁，零件，自动化设备之前需要建模分析可行性，软件在编写之前也需要建立模型，看看类和逻辑的设计是否合理，这样的建模过程就是UML。 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:0","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"类图\r类图就是来描述一个类本身或和其他类的调用关系。 +public -private #protected 实现/泛化\r集成 实现接口 组合\r部分可以离开整体 聚合\r部分不能离开整体 关联\r持有对其他对象引用的实例变量 依赖\r局部变量/方法的参数或则静态方法的调用 注意 关系的强弱：泛化/实现\u003e组合\u003e聚合\u003e关联\u003e依赖 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:1","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"对象图\r表示系统执行的某个特定时刻的一组对象和关系，可以看成是内存快照。 该图大部分是从相应的类图中推导而来没啥用。 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:2","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"顺序图\r描述算法的实现，重点在于消息的顺序。比较常绘制的动态模型。 例子\r对象下面画有横线，类没有，对象名：类 垂下来的线为生命线 中间矩形垂下来的矩形：激活，表示一个函数的执行时间 虚线表示返回参与者并传回返回值 箭头：消息。返回值：消息名称（参数） 带圆圈的箭头：消息的参数 注意\r循环：框起来 [for each id in idlist] 容易被勿用和滥用 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:3","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"协作图\r描述算法的实现，重点在于对象之间的关系 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:4","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"状态图\r其实就是有限状态机（FSM）。 例子:\r实心黑球：初始伪状态，从这个状态开始运转 圆矩形：状态。上层放状态的名字，下层放一些特定动作和事件，表示进入或则退出时要做什么， 箭头：迁移。上面有触发该迁移的事件名称和要执行的动作 注意 entry和exit：标准事件，不管写不写都会触发 超状态：几个状态迁移时间相同时，可以组成一个超状态。迁移时会出发超状态的entry和exit ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:5","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"如何使用UML\r在使用UML的过程中，需要先通过行为优先的方式写出状态图，先是局部状态再是整体状态，抽象出会改变的，将每一种改变的类型实例化，中间再通过各种设计模式隔离 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:2:0","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"行为优先\r从项目的功能入手，用户的交互入手写出每一种功能，大体的类有了后，再抽象出会改变的类，通过设计模式隔离 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:2:1","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"检查结构\r检查每一种功能实现是否合理 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:2:2","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"想象代码\r想想出代码的样子做微调 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:2:3","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":null,"content":"关于我\r92年，儿子、丈夫、父亲，新时代农民工。 从事上位机开发多年，熟悉制药(层析超滤)和IVD(生化免疫)设备软件。 喜欢研究和学习各类技术，保持好奇心，持续探索。 熟悉的编程语言：C#,C,C++,Vue。 可以通过邮件978089234@qq.com与我联系！ Blog\r小时候夏天很长，长大了一年很短。每天都感觉很忙碌，却不知道在忙些什么。 想要记录些东西，表明那些年真的存在过。 写的文章，分享的想法观点可能早就有人写过，分享过。 没有关系，这算是自我的一种成长和探索，走一下别人走过的路，站在巨人的肩膀上，能不能看到不一样的风景？ ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]