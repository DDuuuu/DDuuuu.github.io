[{"categories":"LeeCode","content":"题目\r题目链接 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。 示例 1： 输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2： 输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3： 输入：nums = [], target = 0 输出：[-1,-1] 提示： 0 \u003c= nums.length \u003c= 105 -109 \u003c= nums[i] \u003c= 109 nums 是一个非递减数组 -109 \u003c= target \u003c= 109 ","date":"2022-11-16","objectID":"/2022/11/leecode34/:0:1","tags":["LeeCode","34","数组","查找第一个和最后一个位置"],"title":"LeeCode-34-数组-查找第一个和最后一个位置","uri":"/2022/11/leecode34/"},{"categories":"LeeCode","content":"解题\r二分法类似题，解题方案和前面两个相似 存在的变化，有重复数据，需要返回两个位置 尝试使用二分，找到值的序号后，向左，向右定位到上下限。 public int[] Search(int[] nums, int target) { //[left，right] var left = 0; var right = nums.Length - 1; var result = new int[] {-1, -1}; var mid = 0; while (left \u003c= right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { var min = mid; while (--min\u003e=left)//确定下限，使用遍历 { if(nums[min] != target) break; } result[0] = min + 1; var max = mid; while (++max \u003c= right)//确定上限，使用遍历 { if (nums[max] != target) break; } result[1] = max-1; break; } else if (target\u003cnums[mid]) { right = mid - 1; } else { left = mid + 1; } } return result; } 如果数组中的重复项比较多，中间使用遍历可以优化为二分，同时判定目标值是否在数组中也改成递归进行统一。 public int[] SearchPlus(int[] nums, int target) { var result = new int[] { -1, -1 }; if (nums.Length == 0) return result; //[left，right] var left = 0; var right = nums.Length - 1; var mid = 0; //遍历定位左右限，type 0:返回下限序号，1返回上限序号 ,2找到即返回, //返回[left right,index] int[] InnterSearch(int[] nums, int target, int left, int right, int type) { if (left \u003c= right) { mid = (left + right) \u003e\u003e 1; if (type == 2 \u0026\u0026 target == nums[mid]) { return new[] {left, right, mid}; } else if ( target \u003c nums[mid]||(type == 0 \u0026\u0026 target == nums[mid])) { right = mid - 1; } else if (target \u003e nums[mid] || (type == 1 \u0026\u0026 target == nums[mid])) { left = mid + 1; } return InnterSearch(nums, target, left, right, type); } if (type == 2)//不在数组中 { return new[] {left, right, -1}; } var index = type==1 ? left-1 : right+1; return new[] {left, right, nums[index] == target ? index : -1}; } var indexarray = InnterSearch(nums, target, left, right, 2);//数组中存在 if (indexarray[2] == -1) return result; result[0]= InnterSearch(nums, target, indexarray[0], indexarray[2], 0)[2];//找到下限 [left,mid]中二分 result[1] = InnterSearch(nums, target, indexarray[2], indexarray[1], 1)[2];//找到上限 [mid,right]中二分 return result; } InnterSearch方法承担了三个职责，目标值是否在数组中，寻找上限，寻找下限。导致内部实现用了很多的判定，看上去有点乱，通过字典封装判断逻辑，一目了然，如果以后需求变化，改动字典即可，尽可能满足开放封闭原则。 public int[] SearchPlusPro(int[] nums, int target) { var result = new int[] { -1, -1 }; if (nums.Length == 0) return result; //[left，right] var left = 0; var right = nums.Length - 1; var mid = 0; //遍历定位左右限，type 0:返回下限序号，1返回上限序号 ,2找到即返回, //返回[left right,index] var searchtypes = new Dictionary\u003cint, Func\u003cint[], int, int, int,int, int[]\u003e\u003e() { {//下限 0, (_nums, _target, _left, _right,_mid) =\u003e { if (_target \u003c= _nums[_mid]) { _right = _mid - 1; } else //target\u003enums[mid] { _left = _mid + 1; } return new []{_left,_right,-1}; } }, {//上限 1, (_nums, _target, _left, _right,_mid) =\u003e { if (_target \u003c _nums[_mid]) { _right = _mid - 1; } else //target\u003e=nums[mid] { _left = _mid + 1; } return new []{_left,_right,-1}; } }, {//找到立即返回 2, (_nums, _target, _left, _right,_mid) =\u003e { if (_target == _nums[_mid]) { return new[] {_left, _right, _mid}; } else if ( _target \u003c _nums[_mid]) { _right = _mid - 1; } else { _left = _mid + 1; } return new []{_left,_right,-1}; } } }; int[] InnterSearch(int[] nums, int target, int left, int right, int type) { if (left \u003c= right) { mid = (left + right) \u003e\u003e 1; var temresult = searchtypes[type](nums, target, left, right, mid); if (temresult[2] != -1) return temresult; return InnterSearch(nums, target, temresult[0], temresult[1], type); } return new[] {left, right, -1}; } var indexarray = InnterSearch(nums, target, left, right, 2);//数组中存在 if (indexarray[2] == -1) return result; result[0] = InnterSearch(nums, target, indexarray[0], indexarray[2], 0)[0];//找到下限 [left,mid]中二分 result[1] = InnterSearch(nums, target, indexarray[2], indexarray[1], 1)[1];//找到上限 [mid,right]中二分 return result; } ","date":"2022-11-16","objectID":"/2022/11/leecode34/:0:2","tags":["LeeCode","34","数组","查找第一个和最后一个位置"],"title":"LeeCode-34-数组-查找第一个和最后一个位置","uri":"/2022/11/leecode34/"},{"categories":"LeeCode","content":"网络解析\r网络解析有以下几种方式： 对数组使用两次二分查找上限和下限。 先判断目标在数组中，再使用二分查找上下限 public class Solution { public int[] SearchRange(int[] nums, int target) { if (nums.Length == 0) return new int[] { -1, -1 }; int l = binarySearch(nums, target, true); int r = binarySearch(nums, target, false) - 1; if (l \u003c= r \u0026\u0026 r \u003c nums.Length \u0026\u0026 nums[l] == target \u0026\u0026 nums[r] == target) return new int[] { l, r }; return new int[] { -1, -1 }; } int binarySearch(int[] nums,int target,bool lower) { int n = nums.Length; int l = 0, r = n - 1; while (l \u003c= r) { int m = (l + r) / 2; if (nums[m] \u003e target || (lower \u0026\u0026 nums[m] \u003e= target)) { r = m - 1; n = m; } else l = m + 1; } return n; } } public class Solution { public int[] SearchRange(int[] nums, int target) { int[] res = new int[2]; int left=0; int right = nums.Length-1; while(left\u003c= right) { int mid = left+(right-left)/2; if(nums[mid] \u003ctarget) { left = mid+1; }else if(nums[mid] \u003etarget) { right = mid-1; }else if (nums[mid]==target) { right = mid-1; } } if(left==nums.Length) { res[0] = -1; }else { res[0] = nums[left]==target?left:-1; } left=0; right = nums.Length-1; while(left\u003c= right) { int mid = left+(right-left)/2; if(nums[mid] \u003ctarget) { left = mid+1; }else if(nums[mid] \u003etarget) { right = mid-1; }else if (nums[mid]==target) { left = mid+1; } } if(left-1 \u003c0) { res[1] = -1; }else { res[1] = nums[left-1]==target?left-1:-1; } return res; } } ","date":"2022-11-16","objectID":"/2022/11/leecode34/:0:3","tags":["LeeCode","34","数组","查找第一个和最后一个位置"],"title":"LeeCode-34-数组-查找第一个和最后一个位置","uri":"/2022/11/leecode34/"},{"categories":"LeeCode","content":"题目\r题目链接 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例 1: 输入: nums = [1,3,5,6], target = 5 输出: 2 示例 2: 输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3: 输入: nums = [1,3,5,6], target = 7 输出: 4 提示: 1 \u003c= nums.length \u003c= 104 -104 \u003c= nums[i] \u003c= 104 nums 为 无重复元素 的 升序 排列数组 -104 \u003c= target \u003c= 104 解题\r","date":"2022-11-15","objectID":"/2022/11/leecode35/:0:0","tags":["LeeCode","35","数组","搜索插入位置"],"title":"LeeCode-35-数组-搜索插入位置","uri":"/2022/11/leecode35/"},{"categories":"LeeCode","content":"二分\r思考，排序数组，无重复，升序，规定时间复杂度，好像只有二分了，递归是否可以，因为递归也是Logn public int Search(int[] nums, int target) { //[left,right] var left = 0; var right = nums.Length - 1; var mid = 0; while (left \u003c= right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { left = mid; break; } else if (target\u003cnums[mid]) { right = mid - 1; } else { left = mid + 1; } } return left; } public int SearchPlus(int[] nums, int target) { //[right,left) var left = 0; var right = nums.Length; var mid = 0; while (left != right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { left = mid; break; } else if (target \u003c nums[mid]) { right = mid; } else { left = mid + 1; } } return left; } ","date":"2022-11-15","objectID":"/2022/11/leecode35/:1:0","tags":["LeeCode","35","数组","搜索插入位置"],"title":"LeeCode-35-数组-搜索插入位置","uri":"/2022/11/leecode35/"},{"categories":"LeeCode","content":"递归\rpublic int SearchPro(int[] nums, int target) { //[right,left] var left = 0; var right = nums.Length - 1; var mid = 0; int InnerCore(int[] nums, int target, int left, int right) { if (left \u003c= right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { return mid; } else if (target \u003c nums[mid]) { return InnerCore(nums, target, left, mid-1); } else { return InnerCore(nums, target, mid + 1, right); } } return left; } return InnerCore(nums,target,left,right); } public int SearchProPlus(int[] nums, int target) { //[right,left) var left = 0; var right = nums.Length; var mid = 0; int InnerCore(int[] nums, int target, int left, int right) { if (left != right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { return mid; } else if (target \u003c nums[mid]) { return InnerCore(nums, target, left, mid); } else { return InnerCore(nums, target, mid + 1, right); } } return left; } return InnerCore(nums, target, left, right); } 网络解析\rpublic int SearchInsert(int[] nums, int target) { int searchIdx; int searchLower = 0, searchHigher = nums.Length - 1; int middle = 0; while (searchLower \u003c= searchHigher) { middle = searchLower + (searchHigher - searchLower) / 2; if (nums[middle] == target) { return middle; } if (nums[middle] \u003e target) { searchHigher = middle - 1; } else { searchLower = middle + 1; } } if (target \u003c= nums[middle]) return middle; if (target \u003e nums[middle]) return middle + 1; return -1; } public class Solution { public int SearchInsert(int[] nums, int target) { return Rank(nums,0,nums.Length - 1,target); } public int Rank(int[] arr,int left,int right,int target) { if(target \u003c arr[left]) return left; if(target \u003e arr[right]) return right + 1; int mid = (left + right)/2; if(target == arr[mid]) return mid; if(target\u003carr[mid]) return Rank(arr,left,mid-1,target); else return Rank(arr,mid+1,right,target); } } ","date":"2022-11-15","objectID":"/2022/11/leecode35/:2:0","tags":["LeeCode","35","数组","搜索插入位置"],"title":"LeeCode-35-数组-搜索插入位置","uri":"/2022/11/leecode35/"},{"categories":"LeeCode","content":"题目\r给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示: 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 解题\r如果使用遍历，最好情况O(1)，最坏情况O(n)。 使用二分法是O(logn)。 尝试使用二分，二分肯定有上下限和中间值，通过中间值和目标值比较，不断缩小上下限最后得到结果。 从中考虑While的判断是什么？ 上下限的范围怎么划定？ 初版： public int Search(int[] nums, int target) { var maxindex = nums.Length-1; var minindex = 0; var index = (maxindex + minindex) / 2; while (maxindex != minindex) { if (target == nums[index]) { break; } if (target \u003c nums[index]) { maxindex = index; } else { minindex = index+1; } index = (maxindex + minindex) / 2; } if (target == nums[index]) return index; return -1; } 测试用例通过了，但是有效率不高，有很多重复代码，改进一下 public int SearchPro(int[] nums, int target) { var maxindex = nums.Length - 1; var minindex = 0; var midindex=0; while (minindex\u003c=maxindex) { midindex = (maxindex + minindex) / 2; if (target == nums[midindex]) { return midindex; } if (target \u003c nums[midindex]) { maxindex = midindex - 1; } else { minindex = midindex + 1; } } return -1; } 最佳答案 public int StandardSearch(int[] nums, int target) { int left = 0, right = nums.Length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } if (nums[mid] \u003e target) { right = mid - 1; } else { left = mid + 1; } } return -1; } 对比： 想一下变量用left和right应该更简介一点。mid在循环体中声明，每次会在栈中创建新的临时变量。 网络解析\rtarget 是在一个在左闭右闭的区间里，也就是[left, right] ，这种就是上面的标准写法 while (left \u003c= right) 要使用 \u003c= ，因为left == right是有意义的，所以使用 \u003c= if (nums[middle] \u003e target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 target 是在一个在左闭右开的区间里，也就是[left, right) while (left \u003c right)，这里使用 \u003c ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] \u003e target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] public int SearchPlus(int[] nums, int target) { var maxindex = nums.Length; var minindex = 0; var midindex = 0; while (minindex \u003c maxindex) { midindex = (maxindex + minindex) / 2; if (target == nums[midindex]) { return midindex; } if (target \u003c nums[midindex]) { maxindex = midindex; } else { minindex = midindex+1; } } return -1; } ","date":"2022-11-14","objectID":"/2022/11/leecode704/:0:0","tags":["LeeCode","704","数组","二分查找"],"title":"LeeCode-704-数组-二分查找","uri":"/2022/11/leecode704/"},{"categories":"DotNet基础","content":"概述\r高性能的套接字编程围绕着两个方面：异步和复用。异步：高性能就是最大化计算机资源的利用，是不可能让线程有阻塞的，所以就有了各种异步模式。复用：计算机资源最好是能重复使用的，频繁的创建和销毁相同的对象也是对资源的浪费，所以就有了各种池和零拷贝；CPU在访问相邻资源的时候有特别的优势可以利用缓存区，所以池中对象尽量相邻创建。 Socket套接字编程历史悠久，发展出好几种方式，对应着DotNet异步编程的发展，分别：异步编程模式(Asynchronous Programming Model ,APM)、基于事件的异步模式(Event-based Asynchronous Pattern ,EAP)和基于任务的异步模式(Task-based Asynchronous Pattern,TAP)。 本文将简要介绍几种异步编程对应Socket的实现，每一种都写了一个简单的Socket服务端以供学习。 ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:1:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"面向连接的套接字\r套接字流程如下，在Accept，Read，Write，Connect和Disconnect方法均涉及到异步编程。为什么会异步，简单来说就是线程执行速度很快，网络传输的IO速度很慢，线程发出IO操作的指令后，不可能一直等待指令执行完。所以线程设置一个回调函数的入口地址，让IO执行完之后调用该入口地址，之后线程就去干其他事情了，等该IO调用该入口地址，线程再回来继续工作。 ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:2:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"阻塞式套接字\rSocket接口，下面是用阻塞方法创建的一个简单服务端。可以分析出该服务的性能是很差的，没有做任何的异步和复用。 //服务端 public static void Run(string m_ip, int m_port) { var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); var ip = IPAddress.Parse(m_ip); var endpoint = new IPEndPoint(ip, m_port); socket.Bind(endpoint); socket.Listen(0); socket.ReceiveTimeout = -1; //线程池中后台线程执行 Task.Run(() =\u003e { while (true) { var acceptSocket = socket.Accept();//线程阻塞等待连接请求队列 if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { //线程池中后台线程执行 Task.Run(() =\u003e { byte[] receiveBuffer = new byte[1024];//每一个连接都在重新创建缓冲区 int result = 0; do { if (acceptSocket.Connected) { result = acceptSocket.Receive(receiveBuffer, 0, receiveBuffer.Length, SocketFlags.None, out SocketError error);//线程阻塞等待缓冲区数据 if (error == SocketError.Success \u0026\u0026 result \u003e 0) { var recestr = Encoding.UTF8.GetString(receiveBuffer, 0, result); var Replaystr = $\"Server收到消息:{recestr};Server收到消息的时间:{DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss:fff\")}\"; var strbytes = Encoding.UTF8.GetBytes(Replaystr); acceptSocket.Send(strbytes, 0, strbytes.Length, SocketFlags.None);//线程阻塞等待发送完缓冲区数据 if (recestr.Contains(\"stop\")) { break; } } } else { break; } } while (result \u003e 0); }).ContinueWith((t) =\u003e { System.Threading.Thread.Sleep(1000); acceptSocket.Disconnect(false); acceptSocket.Dispose(); }); } } }).Wait(); } ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:3:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"异步编程模式(Asynchronous Programming Model ,APM)\rBeginXXX方法并不会阻塞线程，而EndXXX会，dotnet提供Task\u003cT\u003e.Factory.FromAsync可以将APM转成TAP模式异步模式以提高性能，下面提供一个示例，同时使用ArrayPool复用缓冲区，处理分包，粘包等问。 public static Socket Run(string m_ip, int m_port) { var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); var ip = IPAddress.Any; if (!string.IsNullOrEmpty(m_ip)) { ip = IPAddress.Parse(m_ip); } var endpoint = new IPEndPoint(ip, m_port); socket.Bind(endpoint); Console.WriteLine($\"[{DateTime.Now.GetFormString()}] Server Established localEndpoint:[{socket.LocalEndPoint.ToString()}]\"); socket.Listen(200); socket.ReceiveTimeout = -1; //后台线程执行 Task.Run(async () =\u003e { while (true) { var acceptSocket = await Task\u003cSocket\u003e.Factory.FromAsync( socket.BeginAccept(null,null) ,socket.EndAccept);//APM转TAP异步 if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { //后台线程来处理Receive逻辑 var task = Task.Run(async () =\u003e { byte[] buffer = ArrayPool\u003cbyte\u003e.Shared.Rent(1024);//从内存池中获取缓冲区 var bytesBuffered = 0; var bytesConsumed = 0; while (true) { if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { var temremaining = bytesBuffered - bytesConsumed; if (temremaining == 0)//缓存区全部解析完 { bytesBuffered = 0; bytesConsumed = 0; } else if (temremaining \u003c buffer.Length \u0026\u0026 temremaining \u003e 0)//最后一个包不完整，部分数据未解析 { var newbuffer = ArrayPool\u003cbyte\u003e.Shared.Rent(buffer.Length); Buffer.BlockCopy(buffer, bytesConsumed, newbuffer, 0, temremaining); ArrayPool\u003cbyte\u003e.Shared.Return(buffer); buffer = newbuffer; bytesBuffered = temremaining; bytesConsumed = 0; } else //包不够大，分包了 { var newbuffer = ArrayPool\u003cbyte\u003e.Shared.Rent(buffer.Length * 2); Buffer.BlockCopy(buffer, 0, newbuffer, 0, buffer.Length); ArrayPool\u003cbyte\u003e.Shared.Return(buffer); buffer = newbuffer; } var bytesRemaining = buffer.Length - bytesBuffered; try { var bytesread = await Task\u003cint\u003e.Factory.FromAsync( acceptSocket.BeginReceive(buffer, bytesBuffered, bytesRemaining, SocketFlags.None, null, null), acceptSocket.EndReceive);//APM转TAP异步 if (bytesread == 0) { break; } bytesbuffered += bytesread; var lineposition = -1; do { lineposition = array.indexof(buffer, (byte)0x23, bytesconsumed,bytesbuffered - bytesconsumed); if (lineposition \u003e= 0) { var lineLength = linePosition - bytesConsumed; ProcessLine(acceptSocket, buffer, bytesConsumed, bytesread); bytesConsumed += bytesread; } } while (linePosition \u003e= 0);//包解析 } catch (Exception e) { break; } } else { break; } } ArrayPool\u003cbyte\u003e.Shared.Return(buffer); }).ContinueWith((t) =\u003e { Console.WriteLine($\"[{DateTime.Now.GetFormString()}] ServerClient Disconnected localEndpoint:[{acceptSocket?.LocalEndPoint.ToString()}] remoteEndpoint:[{acceptSocket?.RemoteEndPoint.ToString()}]\"); acceptSocket?.Shutdown(SocketShutdown.Both); acceptSocket?.Close(); acceptSocket = null; }); } } }); return socket; } ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:4:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"基于事件异步的完成端口模型(Event-based Asynchronous Pattern ,EAP)\r目前应用最广的Socket模型，完成端口模型还是按照\"回调函数\"的方式进行来实现异步，其本质是线程池，该线程池的核心工作就是去调用IO操作完成时的回调函数。另外因为IO操作毕竟是慢速的操作，所以几个线程就已经足可以应付成千上万的输入输出完成操作的请求(前提就是你的回调函数做的工作要足够少)，所以这个模型的性能是非常高的。也是现在Windows平台上性能最好的输入输出模型。自定义构造了内存池，将一大块内存切分成一定数据量的连续小内存，分别分配给不同的SocketAsyncEventArgs对象以提高服务性能，非常巴适；目前看到的FastSocket,SuperSocket,TouchSocket,NewLife等网络框架均采用这种模式，最主要的原因是应用范围广。 框架 版本 .NET Core 1.0, Core 1.1, Core 2.0, Core 2.1, Core 2.2, Core 3.0, Core 3.1, 5, 6, 7 Preview 7 .NET Framework 2.0, 3.0, 3.5, 4.0, 4.5, 4.5.1, 4.5.2, 4.6, 4.6.1, 4.6.2, 4.7, 4.7.1, 4.7.2, 4.8 .NET Standard 1.3, 1.4, 1.6, 2.0, 2.1 UWP 10.0 Xamarin.iOS 10.8 Xamarin.Mac 3.0 public class MyIOCPSocket { private static int m_numConnections;//最大连接数 private static int m_receiveBufferSize;//接收缓存区数量 private static int m_sendBufferSize;//发送缓存区大小 private static byte[] m_receivebuffer;//接收缓存区 private static Stack\u003cint\u003e m_freeReceiveIndexPool;//可用的接收缓存索引栈 private static int m_currentReceiveIndex;//当前的接收缓存区索引 private static byte[] m_sendbuffer;//发送缓存区 private static Stack\u003cint\u003e m_freeSendIndexPool;//可用的发送缓存索引栈 private static int m_currentSendIndex;//当前的发送缓存区索引 private static Stack\u003cSocketAsyncEventArgs\u003e m_ReadPool;//接收SocketAsyncEventArgs池 private static Stack\u003cSocketAsyncEventArgs\u003e m_WritePool;//发送SocketAsyncEventArgs池 private static Semaphore m_maxNumberAcceptedClients;//最大连接锁 private static int m_numConnectedSockets;//连接的Socket数量 private static int m_totalBytesRead;//总的接收字节数 private static Socket listenSocket;//监听Socket public static void Run(string m_ip, int m_port, int numConnections, int m_receiveBuffer, int m_sentBuffer) { //初始化 m_numConnections = numConnections; m_receiveBufferSize = m_receiveBuffer; m_sendBufferSize = m_sentBuffer; m_receivebuffer = new byte[m_receiveBufferSize * m_numConnections]; m_freeReceiveIndexPool = new Stack\u003cint\u003e(); m_currentReceiveIndex = 0; m_sendbuffer = new byte[m_sendBufferSize * m_numConnections]; m_freeSendIndexPool = new Stack\u003cint\u003e(); m_currentSendIndex = 0; m_ReadPool = new Stack\u003cSocketAsyncEventArgs\u003e(m_numConnections); m_WritePool = new Stack\u003cSocketAsyncEventArgs\u003e(m_numConnections); m_maxNumberAcceptedClients = new Semaphore(m_numConnections, m_numConnections); m_numConnectedSockets = 0; m_totalBytesRead = 0; //接收缓存分配 for (int i = 0; i \u003c m_numConnections; i++) { var readEventArg = new SocketAsyncEventArgs(); readEventArg.Completed += new EventHandler\u003cSocketAsyncEventArgs\u003e(ReadWriteIOComleted); readEventArg.UserToken = new AsyncUserToken(); if (m_freeReceiveIndexPool.Count \u003e 0) { readEventArg.SetBuffer(m_receivebuffer, m_freeReceiveIndexPool.Pop(), m_receiveBufferSize); } else { if ((m_receiveBufferSize * m_numConnections - m_receiveBufferSize) \u003c m_currentReceiveIndex) { new ArgumentException(\"接收缓存设置异常\"); } readEventArg.SetBuffer(m_receivebuffer, m_currentReceiveIndex, m_receiveBufferSize); m_currentReceiveIndex += m_receiveBufferSize; } m_ReadPool.Push(readEventArg); //发送缓存分配 var writeEventArg = new SocketAsyncEventArgs(); writeEventArg.Completed += new EventHandler\u003cSocketAsyncEventArgs\u003e(ReadWriteIOComleted); writeEventArg.UserToken = new AsyncUserToken(); if (m_freeSendIndexPool.Count \u003e 0) { writeEventArg.SetBuffer(m_sendbuffer, m_freeSendIndexPool.Pop(), m_sendBufferSize); } else { if ((m_sendBufferSize * m_numConnections - m_sendBufferSize) \u003c m_currentSendIndex) { new ArgumentException(\"发送缓存设置异常\"); } writeEventArg.SetBuffer(m_sendbuffer, m_currentSendIndex, m_sendBufferSize); m_currentSendIndex += m_sendBufferSize; } m_WritePool.Push(writeEventArg); } //设置监听socket listenSocket = new Socket(new IPEndPoint(IPAddress.Parse(m_ip), m_port).AddressFamily, SocketType.Stream, ProtocolType.Tcp); //绑定端口 listenSocket.Bind(new IPEndPoint(IPAddress.Parse(m_ip), m_port)); listenSocket.Listen(100); StartAccept(null); Console.WriteLine(\"Press any key to terminate the server process....\"); Console.ReadKey(); } public static void ReadWriteIOComleted(object sender, SocketAsyncEventArgs e) { switch (e.LastOperation) { case SocketAsyncO","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:5:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"基于任务的异步模式(Task-based Asynchronous Pattern,TAP)\r相对于前几个模型，基于任务的网络模型是比较新的模型，但是性能是最好的，最主要的原因是微软提供了System.Net.Sockets.SocketTaskExtensions封装TAP的异步方法；System.IO.Pipelines管道模型，在 .NET 中执行高性能 I/O 更加容易。该管道可以实现流量控制和反压。PipeScheduler可以进行回调线程控制。PipeReader和PipeWriter封装了对内存数据的直接操作，实现零拷贝得以大大提供业务流的性能。可惜的是应用范围比较小，目前框架只支持2.1, 2.2, 3.0, 3.1, 5, 6, 7 Preview 7，Framework不支持。 private static Pipe pipe; public static Socket Run(string m_ip, int m_port) { //监听Socket var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); var ip = IPAddress.Parse(m_ip); var endpoint = new IPEndPoint(ip, m_port); socket.Bind(endpoint); //绑定端口和IP socket.Listen(200); //允许同时监听的队列 socket.ReceiveTimeout = -1; Task.Run(async () =\u003e { while (true) { var acceptSocket = await socket.AcceptAsync(); //TAP异步接收 if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { pipe = new Pipe(); var writer = pipe.Writer; var reader = pipe.Reader; var writetaskr = Task.Run(async () =\u003e { while (true) { var memory = writer.GetMemory(1024); try { //TAP 异步读取数据 int bytesRead = await acceptSocket.ReceiveAsync(memory, SocketFlags.None); if (bytesRead == 0) { break; } //告诉 PipeWriter 写入多少数据。 writer.Advance(bytesRead); } catch (Exception e) { break; } //刷新写入 FlushResult result = await writer.FlushAsync(); if (result.IsCompleted) { break; } } // 完成写入 await writer.CompleteAsync(); }).ContinueWith((t) =\u003e { acceptSocket?.Shutdown(SocketShutdown.Both); //acceptSocket?.Disconnect(true); acceptSocket?.Dispose(); acceptSocket = null; }); var readingtask= Task.Run(async() =\u003e { while (true) { try { //从管道中读取 ReadResult result = await reader.ReadAsync(); ReadOnlySequence\u003cbyte\u003e buffer = result.Buffer; while (TryReadLine(ref buffer, out ReadOnlySequence\u003cbyte\u003e line))//解析 { ProcessLine(acceptSocket, line); } //实际读了多少 reader.AdvanceTo(buffer.Start, buffer.End); //是否写已经结束 if (result.IsCompleted) { break; } } catch (Exception e) { break; } } await reader.CompleteAsync(); }).ContinueWith((t) =\u003e { acceptSocket?.Shutdown(SocketShutdown.Both); acceptSocket?.Dispose(); acceptSocket = null; } ); } } }); return socket; } ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:6:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"总结\r主要讲述在套接字编程中，如何实现异步和复用以提高性能。讲述了异步编程(APM)、基于事件的异步模型(EAP)和基于任务的异步模型(TAP)；复用方面从内存池(ArrayPool)，到自定义构建内存池(利用高速缓存)和完成端口池，再到最新的管道模型，实现零拷贝。 ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:7:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 TouchSocket提供插件方式的扩展，这种方式对原框架的耦合较小。用插件基类封装了底层框架中所有的插件扩展接口，插件子类重写对应的接口就可注入相关业务。框架插件的注入和调用通过PluginsManager进行管理。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:1:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"插件架构\r插件接口在框架中的位置可以在TouchSocket 封装和扩展查看，插件基类封装了所有接口。 下图为插件基类。 插件管理负责插件的注入和调用，通过一些扩展方法封装各种插件注入方式。 下图为插件管理： 插件的注入方式比较特别，通过反射方式找到类中所有插件接口并构造PluginMethod封装方法，该封装主要封装了异步方法，调用时会等待异步结果再进行返回。 ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:2:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"重连插件\r当客户端连接断开时，提供自动重连。 通过扩展方法提供注入接口: /// \u003csummary\u003e /// 使用断线重连。 /// \u003cpara\u003e该效果仅客户端在完成首次连接，且为被动断开时有效。\u003c/para\u003e /// \u003c/summary\u003e /// \u003cparam name=\"pluginsManager\"\u003e\u003c/param\u003e /// \u003cparam name=\"successCallback\"\u003e成功回调函数\u003c/param\u003e /// \u003cparam name=\"tryCount\"\u003e尝试重连次数，设为-1时则永远尝试连接\u003c/param\u003e /// \u003cparam name=\"printLog\"\u003e是否输出日志。\u003c/param\u003e /// \u003cparam name=\"sleepTime\"\u003e失败时，停留时间\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static IPluginsManager UseReconnection(this IPluginsManager pluginsManager, int tryCount = 10, bool printLog = false, int sleepTime = 1000, Action\u003cITcpClient\u003e successCallback = null) { var reconnectionPlugin = new ReconnectionPlugin\u003cITcpClient\u003e(client=\u003e { int tryT = tryCount; while (tryCount \u003c 0 || tryT-- \u003e 0) { try { if (client.Online) { return true; } else { client.Connect(); } successCallback?.Invoke(client); return true; } catch (Exception ex) { if (printLog) { client.Logger.Debug(LogType.Error, client, \"断线重连失败。\", ex); } Thread.Sleep(sleepTime); } } return true; }); pluginsManager.Add(reconnectionPlugin); return pluginsManager; } ReconnectionPlugin继承TcpPluginBase，并重写OnDisconnected方法。通过Task.Run异步执行。 /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"client\"\u003e\u003c/param\u003e /// \u003cparam name=\"e\"\u003e\u003c/param\u003e protected override void OnDisconnected(ITcpClientBase client, ClientDisconnectedEventArgs e) { base.OnDisconnected(client, e); if (client is ITcpClient tcpClient) { if (e.Manual) { return; } Task.Run(() =\u003e { while (true) { try { if (this.m_tryCon.Invoke((TClient)tcpClient)) { break; } } catch { } } }); } } 框架调用： 通过PluginsManager调用插件接口，注意如果e.Handled在重写的方法里置为true，将不会调用Client.DisConnected和Client.OnDisConnected。 private void PrivateOnDisconnected(ClientDisconnectedEventArgs e) { if (this.m_usePlugin) { this.PluginsManager.Raise\u003cITcpPlugin\u003e(\"OnDisconnected\", this, e); if (e.Handled) { return; } } this.OnDisconnected(e); } ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:3:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"扩展插件横切面接口\rHTTPPlugin插件扩展了HTTP协议的相关接口 在HttpSocketClient中重写HandleReceivedData方法调用插件横切面。 /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"byteBlock\"\u003e\u003c/param\u003e /// \u003cparam name=\"requestInfo\"\u003e\u003c/param\u003e protected override void HandleReceivedData(ByteBlock byteBlock, IRequestInfo requestInfo) { if (requestInfo is HttpRequest request) { this.OnReceivedHttpRequest(request); } } /// \u003csummary\u003e /// 当收到到Http请求时。覆盖父类方法将不会触发插件。 /// \u003c/summary\u003e protected virtual void OnReceivedHttpRequest(HttpRequest request) { HttpContextEventArgs args = new HttpContextEventArgs(new HttpContext(request)); switch (request.Method) { case TouchSocketHttpUtility.Get: { this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnGet\", this, args); break; } case TouchSocketHttpUtility.Post: { this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnPost\", this, args); break; } case TouchSocketHttpUtility.Put: { this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnPut\", this, args); break; } case TouchSocketHttpUtility.Delete: { this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnDelete\", this, args); break; } default: this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnReceivedOtherHttpRequest\", this, args); break; } } ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:4:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"总结\r介绍了TouchSocket插件扩展，包括插件架构，利用重写默认的TcpPluginBase的方法实现业务注入；扩展插件横切面接口，这需要重写ClientBase的相关方法实现。 ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:5:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 TouchSocket的底层使用完成端口模型，基于事件的异步模式。关于完成端口模型的基础知识可以看Socket基础 。结合上篇横切面扩展(TouchSocket 封装和扩展)可以实现各种业务需求。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:1:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"Accept\r在TcpServer类中BeginListen方法，一个监听者用一个SocketAsyncEventArgs foreach (var networkMonitor in this.m_monitors) { SocketAsyncEventArgs e = new SocketAsyncEventArgs(); e.UserToken = networkMonitor.Socket; e.Completed += this.Args_Completed; if (!networkMonitor.Socket.AcceptAsync(e)) { this.OnAccepted(e); } } ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:2:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"Receive\r在SocketClient的BeginReceive方法中，缓存区使用了内存池进行复用，该内存池的细节可以看TouchSocket 字节池和待处理池，注意在处理完缓冲区后再HandleBuffer的finally中调用byteBlock的Dispose方法，将缓存区返回内存池，如果m_holding被设置为true，则由GC自己回收。 internal void BeginReceive(ReceiveType receiveType) { if (receiveType == ReceiveType.Auto) { SocketAsyncEventArgs eventArgs = new SocketAsyncEventArgs(); eventArgs.Completed += this.EventArgs_Completed; ByteBlock byteBlock = BytePool.GetByteBlock(this.BufferLength);//内存池获取缓冲区 eventArgs.UserToken = byteBlock; eventArgs.SetBuffer(byteBlock.Buffer, 0, byteBlock.Capacity); if (!this.m_mainSocket.ReceiveAsync(eventArgs)) { this.ProcessReceived(eventArgs); } } } private void HandleBuffer(ByteBlock byteBlock) { try { if (this.ClearType.HasFlag(ClearType.Receive)) { this.m_lastTick = DateTime.Now.Ticks; } if (this.OnHandleRawBuffer?.Invoke(byteBlock) == false) { return; } if (this.UsePlugin \u0026\u0026 this.PluginsManager.Raise\u003cITcpPlugin\u003e(\"OnReceivingData\", this, new ByteBlockEventArgs(byteBlock))) { return; } if (this.m_disposedValue) { return; } if (this.m_adapter == null) { this.Logger.Debug(LogType.Error, this, ResType.NullDataAdapter.GetDescription()); return; } this.m_adapter.ReceivedInput(byteBlock); } catch (System.Exception ex) { this.Logger.Debug(LogType.Error, this, \"在处理数据时发生错误\", ex); } finally { byteBlock.Dispose();//内存池回收 } } ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:3:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"Send\rSocketClient的SocketSend方法中使用Send同步方法发送，如果异步使用异步编程模式的BeginSend方法。 protected void SocketSend(byte[] buffer, int offset, int length, bool isAsync) { if (!this.m_online) { throw new NotConnectedException(ResType.NotConnected.GetDescription()); } if (this.HandleSendingData(buffer, offset, length)) { lock (this.m_sendLocker) { if (this.UseSsl) { this.m_workStream.Write(buffer, offset, length); } else { if (isAsync) { this.m_mainSocket.BeginSend(buffer, offset, length, SocketFlags.None, null, null); } else { while (length \u003e 0) { int r = this.m_mainSocket.Send(buffer, offset, length, SocketFlags.None); if (r == 0 \u0026\u0026 length \u003e 0) { throw new Exception(\"发送数据不完全\"); } offset += r; length -= r; } } } } if (this.ClearType.HasFlag(ClearType.Send)) { this.m_lastTick = DateTime.Now.Ticks; } } } ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:4:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"Connect\r在TcpClient的Connect方法中，使用异步编程模式的BeginConnect和EndConnect方法 /// \u003csummary\u003e /// 请求连接到服务器。 /// \u003c/summary\u003e public virtual ITcpClient Connect(int timeout = 5000) { if (this.m_online) { return this; } if (this.m_disposedValue) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_config == null) { throw new ArgumentNullException(\"配置文件不能为空。\"); } IPHost iPHost = this.m_config.GetValue\u003cIPHost\u003e(TouchSocketConfigExtension.RemoteIPHostProperty); if (iPHost == null) { throw new ArgumentNullException(\"iPHost不能为空。\"); } if (this.m_mainSocket != null) { this.m_mainSocket.Dispose(); } this.m_mainSocket = this.CreateSocket(iPHost); ClientConnectingEventArgs args = new ClientConnectingEventArgs(this.m_mainSocket); this.PrivateOnConnecting(args); var result = this.m_mainSocket.BeginConnect(iPHost.EndPoint, null, null);//APM if (result.AsyncWaitHandle.WaitOne(timeout)) { if (this.m_mainSocket.Connected) { this.m_mainSocket.EndConnect(result);//APM this.LoadSocketAndReadIpPort(); if (this.m_separateThreadSend) { this.m_asyncSender.SafeDispose(); this.m_asyncSender = new AsyncSender(this.m_mainSocket, this.m_mainSocket.RemoteEndPoint, this.OnSeparateThreadSendError); } this.BeginReceive(); this.m_online = true; this.PrivateOnConnected(new MsgEventArgs(\"连接成功\")); return this; } } this.m_mainSocket.Dispose(); throw new TimeoutException(); } ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:5:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"总结\r本篇讲述底层Socket实现，使用完成端口模型和内存池提高Socket性能。 ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:6:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 Socket模型中需要考虑对各种方法的封装，需要考虑对各种业务场景的扩展，在实现业务流的同时，针对业务流的各个横切面做扩展，甚至业务流本身可以被替换。常用的扩展方式有下面几种，并按耦合从高到低的顺序：继承/泛型，接口/委托/事件，插件/扩展方法。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-15","objectID":"/2022/09/touchsocket5-encapsulationextension/:1:0","tags":["TouchSocket0.3.5","封装和扩展"],"title":"TouchSocket 封装和扩展","uri":"/2022/09/touchsocket5-encapsulationextension/"},{"categories":"TouchSocket0.3.5","content":"Socket\rSocket模型如下图： TouchSocket封装。客户端所有接口封装成TCPClient；服务端将通讯部分桥接给SocketClient，外部接口封装成TCPServer，并通过泛型将SocketClient的类型传入；数据包封装成XXHandlingAdapter；参数设置TouchSocketConfig 可扩展的横切面，横切面主要有：虚方法用于继承重写，事件委托用于订阅，插件扩展方法用于插件扩展。 服务端： 客户端： ","date":"2022-09-15","objectID":"/2022/09/touchsocket5-encapsulationextension/:2:0","tags":["TouchSocket0.3.5","封装和扩展"],"title":"TouchSocket 封装和扩展","uri":"/2022/09/touchsocket5-encapsulationextension/"},{"categories":"TouchSocket0.3.5","content":"总结\r服务端封装成TCPServer,SocketClient；客户端封装成TCPClient，将通讯包封装成XXHandlingAdapter，参数设置封装TouchSocketConfig。 通过扩展方法/插件，事件/委托，虚方法提供横切面的扩展。 ","date":"2022-09-15","objectID":"/2022/09/touchsocket5-encapsulationextension/:3:0","tags":["TouchSocket0.3.5","封装和扩展"],"title":"TouchSocket 封装和扩展","uri":"/2022/09/touchsocket5-encapsulationextension/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 读写文件是应用中必不可少的操作，也是比较经典的问题。该问题一般要求： 允许多个读者对文件执行读操作。 只允许一个写者往文件中写信息。 任一写者写完前不允许其他读者或写者工作。 写者执行写操作前应让已有读者和写者全部退出。 实现要求的逻辑代码: //声明 Semaphore rwlock=1;//读写锁 int rcount=0;//读者数量 Semaphore countlock=1;//读者数量锁 Semaphore firstwlock=1;//写优先锁 //写逻辑 Write() { while(1) { firstwlock.WaitOne(); rwlock.WaitOne(); //Todo:写文件 rwlock.Set(); firstwlock.Set(); } } //读逻辑 Reader() { while(1) { firstwlock.WaitOne(); countlock.WaitOne(); if(rcount==0) rwlock.WaitOne(); rcount++; countlock.Set(); firstwlock.Set(); //Todo:读文件 countlock.WaitOne(); rcount--; if(rcount==0) rwlock.Set(); countlock.Set(); } } 下面看一下TouchSocket文件池解析: 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-14","objectID":"/2022/09/touchsocket4-filepool/:1:0","tags":["TouchSocket0.3.5","文件池"],"title":"TouchSocket 文件池","uri":"/2022/09/touchsocket4-filepool/"},{"categories":"TouchSocket0.3.5","content":"文件池FilePool\r池的作用是复用文件池中对于大文件缓存了文件句柄，对于小文件缓存了文件内容。这样多次对文件的操作就不需要频繁创建和销毁文件句柄。提高文件操作性能。 对于缓存元数据的封装为FileStorage，也是真正对文件操作的实现类。FilePool保存其字典进行复用。 为了便于对FileStorage的操作，将读写操作封装成FileStorageReader和FileStorageWriter 在写入文件时为了保存的实时写入状态，封装了TouchRpcFileStream，并将状态信息封装成TouchRpcFileInfo。 FilePool和FileStorage类中相关操作全部加锁以保证线程安全，并通过原子操作保证FileStorage引用数量 相关类图： 读写模式的互斥通过状态保证: /// \u003csummary\u003e /// 加载文件为读取流 /// \u003c/summary\u003e /// \u003cparam name=\"path\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static void LoadFileForRead(string path) { lock (m_locker) { if (string.IsNullOrEmpty(path)) { throw new System.ArgumentException($\"“{nameof(path)}”不能为 null 或空。\", nameof(path)); } path = Path.GetFullPath(path); if (pathStream.TryGetValue(path, out FileStorage storage)) { if (storage.Access != FileAccess.Read) { throw new Exception(\"该路径的文件已经被加载为写入模式。\"); } return; } if (FileStorage.TryCreateFileStorage(path, FileAccess.Read, out FileStorage fileStorage, out string msg)) { pathStream.TryAdd(path, fileStorage); } else { throw new Exception(msg); } } } 读写操作： /// \u003csummary\u003e /// 从指定位置，读取数据到缓存区。线程安全。 /// \u003c/summary\u003e /// \u003cparam name=\"stratPos\"\u003e\u003c/param\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"length\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public int Read(long stratPos, byte[] buffer, int offset, int length) { using (WriteLock writeLock = new WriteLock(this.m_lockSlim)) { if (this.m_disposedValue) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_fileAccess != FileAccess.Read) { throw new Exception(\"该流不允许读取。\"); } if (this.m_cache) { int r = (int)Math.Min(this.m_fileData.Length - stratPos, length); Array.Copy(this.m_fileData, stratPos, buffer, offset, r); return r; } else { this.m_fileStream.Position = stratPos; return this.m_fileStream.Read(buffer, offset, length); } } } /// \u003csummary\u003e /// 从指定位置，写入数据到存储区。线程安全。 /// \u003c/summary\u003e /// \u003cparam name=\"stratPos\"\u003e\u003c/param\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"length\"\u003e\u003c/param\u003e public void Write(long stratPos, byte[] buffer, int offset, int length) { using (WriteLock writeLock = new WriteLock(this.m_lockSlim)) { if (this.m_disposedValue) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_fileAccess != FileAccess.Write) { throw new Exception(\"该流不允许写入。\"); } this.m_fileStream.Position = stratPos; this.m_fileStream.Write(buffer, offset, length); this.m_fileStream.Flush(); } } ","date":"2022-09-14","objectID":"/2022/09/touchsocket4-filepool/:2:0","tags":["TouchSocket0.3.5","文件池"],"title":"TouchSocket 文件池","uri":"/2022/09/touchsocket4-filepool/"},{"categories":"TouchSocket0.3.5","content":"总结\r讲述了经典的读写问题，介绍了TouchSocket中FilePool的封装，该封装并不复杂，但我觉得一个简单且功能强大的设计才是一个优秀的设计。 ","date":"2022-09-14","objectID":"/2022/09/touchsocket4-filepool/:3:0","tags":["TouchSocket0.3.5","文件池"],"title":"TouchSocket 文件池","uri":"/2022/09/touchsocket4-filepool/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 池是高性能组件中必不可少的东西，池最主要的功能是复用，在软件中创建和销毁对象是有成本的，消耗的资源也特别多。在需要大量使用相同或相似对象的场景下使用池，需要使用对象时去池中取，用完之后再放回到池中，避免创建和销毁对象，从而提高软件的性能。 池在设计时要注意以下几点： 池中对象的存储尽量利用高速缓冲区，这样可以更快速访问对象。 池中对象可以用原型模式加以改造。 池中对象的使用需要注意内存泄漏问题。因为对象使用完并没有销毁。 TouchSocket用到很多的池，字节池 (BytePool)、等待处理池(WaitHandlePool)、文件池(FilePool)、对象池(ObjectPool)，本文介绍字节池和等待处理池 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:1:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"字节池BytePool\r字节数组的复用是非常常见的做法，在高速IO中一定可以看见它的身影，微软对其也进行了各种封装。 TouchSocket字节池保存所有创建的字节数组，并根据数组的长度将其放在字典中等待复用，相同长度的数组通过队列进行缓存，最终字节此的样子 private static readonly ConcurrentDictionary\u003clong, BytesQueue\u003e bytesDictionary = new ConcurrentDictionary\u003clong, BytesQueue\u003e(); long:表示数组长度 BytesQueue:表示该长度数组队列。内部就是private readonly ConcurrentQueue\u003cbyte[]\u003e bytesQueue = new ConcurrentQueue\u003cbyte[]\u003e(); 字节池并没有直接对外暴露字节数组，而是将其封装成ByteBlock，字节数组的装饰对象：ByteBlock，内部使用字节数组实现功能，并装饰Stream的对象。 写入数据可以自动扩容，扩容基数1.5倍。 m_needDis控制Dispose时字节数组是否返回给池中 /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e /// \u003cparam name=\"byteSize\"\u003e默认64K\u003c/param\u003e /// \u003cparam name=\"equalSize\"\u003e默认false\u003c/param\u003e public ByteBlock(int byteSize = 1024 * 64, bool equalSize = false) { this.m_needDis = true; this.m_buffer = BytePool.GetByteCore(byteSize, equalSize); this.m_using = true; } /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e /// \u003cparam name=\"bytes\"\u003e\u003c/param\u003e public ByteBlock(byte[] bytes) { this.m_buffer = bytes ?? throw new ArgumentNullException(nameof(bytes)); this.m_length = bytes.Length; this.m_using = true; } /// \u003csummary\u003e /// 扩容增长比，默认为1.5， /// min：1.5 /// \u003c/summary\u003e public static float Ratio { get =\u003e m_ratio; set { if (value \u003c 1.5) { value = 1.5f; } m_ratio = value; } } /// \u003csummary\u003e /// 读取数据，然后递增Pos /// \u003c/summary\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"length\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e /// \u003cexception cref=\"ObjectDisposedException\"\u003e\u003c/exception\u003e public override int Read(byte[] buffer, int offset, int length) { if (!this.m_using) { throw new ObjectDisposedException(this.GetType().FullName); } int len = this.m_length - this.m_position \u003e length ? length : this.CanReadLen; Array.Copy(this.m_buffer, this.m_position, buffer, offset, len); this.m_position += len; return len; } /// \u003csummary\u003e /// 写入 /// \u003c/summary\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"count\"\u003e\u003c/param\u003e /// \u003cexception cref=\"ObjectDisposedException\"\u003e\u003c/exception\u003e public override void Write(byte[] buffer, int offset, int count) { if (count == 0) { return; } if (!this.m_using) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_buffer.Length - this.m_position \u003c count) { int need = this.m_buffer.Length + count - ((int)(this.m_buffer.Length - this.m_position)); int lend = this.m_buffer.Length; while (need \u003e lend) { lend = (int)(lend * m_ratio); } this.SetCapacity(lend, true); } Array.Copy(buffer, offset, this.m_buffer, this.m_position, count); this.m_position += count; this.m_length = Math.Max(this.m_position, this.m_length); } /// \u003csummary\u003e /// 重新设置容量 /// \u003c/summary\u003e /// \u003cparam name=\"size\"\u003e新尺寸\u003c/param\u003e /// \u003cparam name=\"retainedData\"\u003e是否保留元数据\u003c/param\u003e /// \u003cexception cref=\"ObjectDisposedException\"\u003e\u003c/exception\u003e public void SetCapacity(int size, bool retainedData = false) { if (!this.m_using) { throw new ObjectDisposedException(this.GetType().FullName); } byte[] bytes = new byte[size]; if (retainedData) { Array.Copy(this.m_buffer, 0, bytes, 0, this.m_buffer.Length); } BytePool.Recycle(this.m_buffer); this.m_buffer = bytes; } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"disposing\"\u003e\u003c/param\u003e protected sealed override void Dispose(bool disposing) { if (this.m_holding) { return; } if (this.m_needDis) { if (Interlocked.Decrement(ref this.m_dis) == 0) { GC.SuppressFinalize(this); BytePool.Recycle(this.m_buffer); this.Dis(); } } base.Dispose(disposing); } 该字节池具有如下特性 每隔1小时自动清理所有缓存的字节数组 最大缓存的不同字节数组的数量为100 回收的数组可以设置是否清零 缓存的最大字节数512M 缓存字节数组的范围1KB~20M 自动清理功能，每1个小时会自动清理池中所有的字节数组 static BytePool() { m_timer = new Timer((o) =\u003e { BytePool.Clear(); }, null, 1000 * 60 * 60, 1000 * 60 * 60);//1小时 m_keyCapacity = 100; m_autoZero = false; m_maxSize = 1024 * 1024 * 512;//512M SetBlockSize(1024, 1024 * 1024 * 20);//1KB~ 20M AddSizeKey(10240);//10KB } /// \u003csummary\u003e /// 清理 /// \u003c/summary\u003e public static void Clear() { bytesDictionary.Clear(); GC.Collect(); } /// \u003csummary\u003e /// 获取内存核心。获取的核心可以不用归还。 /// \u003c/summary\u003e /// \u003cparam name=\"byteSize\"\u003e\u003c/param\u003e /// \u003cparam na","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:2:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"等待处理池WaitHandlePool\u003cT\u003e\r该池的主要是为了复用WaitData\u003cT\u003e对象，该对象的功能是：交由外部系统处理对象并返回数据。当给外部系统发送命令，等待外部系统执行命令，并在规定时间内返回数据。 该功能的传统实现方式是： 创建命令队列，将所有已发送外部系统的命令装进命令队列中，同时记录命令的发送时间； 当外部系统返回数据时，去队列中找到对应的命令执行命令成功的方法；如果命令队列中没有对应的命令，调用未知数据处理方法； 设置定时器定期扫描命令队列，将超期没有接收到返回数据的命令移除，并调用对应命令异常执行方法； 该池的实现方式是构造WaitData\u003cT\u003e对象集合，发送命令前构建WaitData对象，发送完命令后该对象使用信号量阻塞发送命令的线程，当收到返回数据时，信号量置位继续执行，处理对应接收数据；信号量阻塞的时候可以设置阻塞时间，时间到则执行对应异常方法。 由于WaitData对象需要构建信号量，创建和销毁的代价比较大。WaitHandlePool构建 ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e waitQueue;队列保存空闲WaitData。 ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e waitQueue;保存所有已经使用WaitData。 /// \u003csummary\u003e /// 等待数据对象 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public class WaitData\u003cT\u003e : DisposableObject { private WaitDataStatus m_status; private readonly AutoResetEvent m_waitHandle; private T m_waitResult; /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e public WaitData() { this.m_waitHandle = new AutoResetEvent(false); } /// \u003csummary\u003e /// 状态 /// \u003c/summary\u003e public WaitDataStatus Status =\u003e this.m_status; /// \u003csummary\u003e /// 等待数据结果 /// \u003c/summary\u003e public T WaitResult =\u003e this.m_waitResult; /// \u003csummary\u003e /// 取消任务 /// \u003c/summary\u003e public void Cancel() { this.m_status = WaitDataStatus.Canceled; this.m_waitHandle.Set(); } /// \u003csummary\u003e /// 释放 /// \u003c/summary\u003e /// \u003cparam name=\"disposing\"\u003e\u003c/param\u003e protected override void Dispose(bool disposing) { this.m_status = WaitDataStatus.Disposed; this.m_waitResult = default; this.m_waitHandle.Dispose(); base.Dispose(disposing); } /// \u003csummary\u003e /// Reset。 /// 设置\u003csee cref=\"WaitResult\"/\u003e为null。然后重置状态为\u003csee cref=\"WaitDataStatus.Default\"/\u003e，waitHandle.Reset() /// \u003c/summary\u003e public bool Reset() { this.m_status = WaitDataStatus.Default; this.m_waitResult = default; return this.m_waitHandle.Reset(); } /// \u003csummary\u003e /// 使等待的线程继续执行 /// \u003c/summary\u003e public bool Set() { this.m_status = WaitDataStatus.SetRunning; return this.m_waitHandle.Set(); } /// \u003csummary\u003e /// 使等待的线程继续执行 /// \u003c/summary\u003e /// \u003cparam name=\"waitResult\"\u003e等待结果\u003c/param\u003e public bool Set(T waitResult) { this.m_waitResult = waitResult; this.m_status = WaitDataStatus.SetRunning; return this.m_waitHandle.Set(); } /// \u003csummary\u003e /// 加载取消令箭 /// \u003c/summary\u003e /// \u003cparam name=\"cancellationToken\"\u003e\u003c/param\u003e public void SetCancellationToken(CancellationToken cancellationToken) { if (cancellationToken.CanBeCanceled) { cancellationToken.Register(this.Cancel); } } /// \u003csummary\u003e /// 载入结果 /// \u003c/summary\u003e public void SetResult(T result) { this.m_waitResult = result; } /// \u003csummary\u003e /// 等待指定毫秒 /// \u003c/summary\u003e /// \u003cparam name=\"millisecond\"\u003e\u003c/param\u003e public WaitDataStatus Wait(int millisecond) { if (!this.m_waitHandle.WaitOne(millisecond)) { this.m_status = WaitDataStatus.Overtime; } return this.m_status; } } /// \u003csummary\u003e /// 等待处理数据 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public class WaitHandlePool\u003cT\u003e : IDisposable where T : IWaitResult { private readonly SnowflakeIDGenerator idGenerator; private readonly ConcurrentDictionary\u003clong, WaitData\u003cT\u003e\u003e waitDic; private readonly ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e waitQueue; /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e public WaitHandlePool() { this.waitDic = new ConcurrentDictionary\u003clong, WaitData\u003cT\u003e\u003e(); this.waitQueue = new ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e(); this.idGenerator = new SnowflakeIDGenerator(4); } /// \u003csummary\u003e /// 销毁 /// \u003c/summary\u003e /// \u003cparam name=\"waitData\"\u003e\u003c/param\u003e public void Destroy(WaitData\u003cT\u003e waitData) { if (waitData.DisposedValue) { throw new ObjectDisposedException(nameof(waitData)); } if (this.waitDic.TryRemove(waitData.WaitResult.Sign, out _)) { waitData.Reset(); this.waitQueue.Enqueue(waitData); } } /// \u003csummary\u003e /// 释放 /// \u003c/summary\u003e public void Dispose() { foreach (var item in this.waitDic.Values) { item.Dispose(); } foreach (var item in this.waitQueue) { item.Dispose(); } this.waitDic.Clear(); this.waitQueue.Clear(); } /// \u003csummary\u003e /// 获取一个可等待对象 /// \u003c/summary\u003e /// \u003cparam name=\"result\"\u003e\u003c/param\u003e /// \u003cparam name=\"autoSign\"\u003e设置为false时，不会生成sign\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public WaitData\u003cT\u003e GetWaitData(T result, bool autoSign = true) { WaitData\u003cT\u003e waitData; if (this.waitQ","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:3:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"总结\r主要介绍了字节池和等待处理池，详细介绍了相关特性和业务功能的实现。对于等待处理池我觉得还可以使用TaskCompletionSource\u003cTResult\u003e来实现，消耗比信号量更小，同时是异步执行，不会阻塞线程。 ","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:4:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 容器现在已经成为各种组件的标配了，为什么容器这么火，确实是太好用了。 表面上容器解决的是耦合问题，实际上容器实现了框架对流程的控制。 表面的耦合问题：没有容器，高层逻辑想要实现某个具体功能，只能依赖某个具体类或者具体工厂。当变化越来越多，改动越来越大，具体类之间依赖关系就像麻绳。里氏替换和依赖倒置根本无法实现。容器的出现将所有的具体类都保存在容器中，实现依赖倒置和里氏替换，系统高层和底层实现解耦。 框架对流程的控制问题：框架实现了整个应用流程的编排，流程中肯定需要具体的执行类。一旦依赖某个执行类就无法应对变化，具体类和流程严重耦合。整个框架就像被焊死，无法应对任何变化。容器就像是活页，连接着具体类和框架流程，当具体类发生变化，对框架没有任何影响，这也就使得框架的应用范围更广，实现的功能更多，框架中任何部件都是可以改变的。 唯一不变的就是改变，如果没有改变，也就不需要任何模式了。我们痛恨变化，同时也热爱变化，在痛苦中追求无限可能。 言归正传，TouchSocket框架实现了一个简易版的依赖注入容器。一起来看一下。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-09","objectID":"/2022/09/touchsocket2-dependencyinjection/:1:0","tags":["TouchSocket0.3.5","依赖注入容器"],"title":"TouchSocket 依赖注入容器","uri":"/2022/09/touchsocket2-dependencyinjection/"},{"categories":"TouchSocket0.3.5","content":"依赖注入\r简单点，容器其实就是一个字典，一个包含一个key和具体类的字典，将框架中所有依赖具体类的地方换成key，当执行到key的时候去字典中根据key取出具体类就可以了。 当然字典也需要生成，就是在应用开始的时候根据需求构建出字典。以后即使变化，也只变化开始构建的部分，最大程度减少修改。 真正的容器就是将字典改造一下，既然由容器管理，就应该负责到底，管理具体类的生命周期，什么时候创建，什么时候销毁，怎么创建。 首先字典中的具体类需要改造一下，变成描述类。 生命周期分为:单例，瞬态，域。 /// \u003csummary\u003e /// 注入依赖对象 /// \u003c/summary\u003e public class DependencyDescriptor { /// \u003csummary\u003e /// 初始化一个单例实例。 /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"instance\"\u003e\u003c/param\u003e public DependencyDescriptor(Type fromType, object instance) { this.FromType = fromType; this.ToInstance = instance; this.Lifetime = Lifetime.Singleton; this.ToType = instance.GetType(); } /// \u003csummary\u003e /// 初始化一个完整的服务注册 /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"toType\"\u003e\u003c/param\u003e /// \u003cparam name=\"lifetime\"\u003e\u003c/param\u003e public DependencyDescriptor(Type fromType, Type toType, Lifetime lifetime) { this.FromType = fromType; this.Lifetime = lifetime; this.ToType = toType; } /// \u003csummary\u003e /// 实例类型 /// \u003c/summary\u003e public Type ToType { get; } /// \u003csummary\u003e /// 实例 /// \u003c/summary\u003e public object ToInstance { get; set; } /// \u003csummary\u003e /// 生命周期 /// \u003c/summary\u003e public Lifetime Lifetime { get; } /// \u003csummary\u003e /// 注册类型 /// \u003c/summary\u003e public Type FromType { get; } } /// \u003csummary\u003e /// 注入项的生命周期。 /// \u003c/summary\u003e public enum Lifetime { /// \u003csummary\u003e /// 单例对象 /// \u003c/summary\u003e Singleton, /// \u003csummary\u003e /// 以\u003csee cref=\"IScopedContainer\"/\u003e接口为区域实例单例。 /// \u003c/summary\u003e Scoped, /// \u003csummary\u003e /// 瞬时对象 /// \u003c/summary\u003e Transient } 字典中的key改成FromType+Name。 最终字典变成了 private readonly ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e registrations = new ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e();这样。 看一下怎么实现注入和解析的。下面是原代码，Resolve方法根据生命周期实现解析逻辑；Create方法负责创建，同时各种注入方式；Register实现构建字典。 该容器有一些特点： 在注入容器时，提供了一个Name，key被构建成FromType+Name。这样的好处是可以根据Name来获取具体类。 同时对于多态的问题，同一个接口的多个实现没有实现注入，只能通过Name来区别了。 如果FromType不是抽象类，不需要注入，也可以Resolve出来。 Resolve会根据所有构造函数参数的个数最多的那个构造函数。 可以使用DependencyInject，DependencyParamterInject特性进行控制。 实现了构造函数注入，属性注入和方法注入 /// \u003csummary\u003e /// IOC容器 /// \u003c/summary\u003e public class Container : IContainer { private readonly ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e registrations = new ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e(); /// \u003csummary\u003e /// 初始化一个IOC容器 /// \u003c/summary\u003e public Container() { this.RegisterSingleton\u003cIContainer\u003e(this); } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public bool IsRegistered(Type fromType, string key = \"\") { return this.registrations.ContainsKey($\"{fromType.FullName}{key}\"); } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"descriptor\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e public void Register(DependencyDescriptor descriptor, string key = \"\") { string k = $\"{descriptor.FromType.FullName}{key}\"; this.registrations.AddOrUpdate(k, descriptor, (k, v) =\u003e { return descriptor; }); } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"ps\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public object Resolve(Type fromType, object[] ps = null, string key = \"\") { if (fromType == typeof(IScopedContainer)) { return this.GetScopedContainer(); } string k; DependencyDescriptor descriptor; if (fromType.IsGenericType) { Type type = fromType.GetGenericTypeDefinition(); k = $\"{type.FullName}{key}\"; if (this.registrations.TryGetValue(k, out descriptor)) { if (descriptor.Lifetime == Lifetime.Singleton) { if (descriptor.ToInstance != null) { return descriptor.ToInstance; } lock (descriptor) { if (descriptor.ToInstance != null) { return descriptor.ToInstance; } if (descriptor.ToType.IsGenericType) { return descriptor.ToInstance = this.Create(descriptor.ToType.MakeGenericType(fromType.GetGenericArguments()), ps); } else { return descriptor.ToInstance = this.Create(descriptor.ToType, ps); } } } if (descriptor.ToType.IsGenericType) { return this.Create(descriptor.ToType.MakeGenericType(fromType.GetGenericArguments()), ps); } el","date":"2022-09-09","objectID":"/2022/09/touchsocket2-dependencyinjection/:2:0","tags":["TouchSocket0.3.5","依赖注入容器"],"title":"TouchSocket 依赖注入容器","uri":"/2022/09/touchsocket2-dependencyinjection/"},{"categories":"TouchSocket0.3.5","content":"总结\r该容器虽然简单，但是足够使用，小巧紧致，非常值得学习。不需要注入直接解析对象的方式，虽然有点违反依赖倒置原则，但是在使用中确实是一个非常实用的功能。有一点缺陷是没有实现Dispose和瞬态对象的弱引用，当域生命周期结束的时候，Dispose容器同时销毁所有域创建出的瞬态对象。 ","date":"2022-09-09","objectID":"/2022/09/touchsocket2-dependencyinjection/:3:0","tags":["TouchSocket0.3.5","依赖注入容器"],"title":"TouchSocket 依赖注入容器","uri":"/2022/09/touchsocket2-dependencyinjection/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 该框架实现了广泛的Socket应用，NAT，各种RPC，文件传输，WebAPI，WebSocket，非常优秀的框架，学习一下，有问题可以相互探讨。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index 本章主要介绍TouchSocket的主要特性之一：依赖属性 ","date":"2022-09-07","objectID":"/2022/09/touchsocket1-dependencyproperties/:1:0","tags":["TouchSocket0.3.5","依赖属性"],"title":"TouchSocket 依赖属性","uri":"/2022/09/touchsocket1-dependencyproperties/"},{"categories":"TouchSocket0.3.5","content":"依赖属性\r用过WPF都知道依赖属性，其是绑定，动画，样式的基础，提供了属性值，更改通知等功能，该框架中的依赖属性相当于简易版本，提供了应用的思路。 依赖属性可以看成是Key和Value的封装。依赖属性类：名称，所属类型，值类型和值，还包含了一个工厂方法，用来创建依赖属性，创建时可以提供初始值。 /// \u003csummary\u003e /// 依赖项属性 /// \u003c/summary\u003e [DebuggerDisplay(\"Name={Name},Type={ValueType}\")] public class DependencyProperty { /// \u003csummary\u003e /// 属性名称 /// \u003c/summary\u003e protected string m_name; /// \u003csummary\u003e /// 所属类型 /// \u003c/summary\u003e protected Type m_owner; /// \u003csummary\u003e /// 值类型 /// \u003c/summary\u003e protected Type m_valueType; private object m_value; /// \u003csummary\u003e /// 依赖项属性 /// \u003c/summary\u003e private DependencyProperty() { } /// \u003csummary\u003e /// 默认值 /// \u003c/summary\u003e public object DefauleValue =\u003e this.m_value; /// \u003csummary\u003e /// 属性名 /// \u003c/summary\u003e public string Name =\u003e this.m_name; /// \u003csummary\u003e /// 所属类型 /// \u003c/summary\u003e public Type Owner =\u003e this.m_owner; /// \u003csummary\u003e /// 值类型 /// \u003c/summary\u003e public Type ValueType =\u003e this.m_valueType; internal void DataValidation(object value) { if (value == null) { if (typeof(ValueType).IsAssignableFrom(this.m_valueType)) { throw new Exception($\"属性“{this.m_name}”赋值类型不允许出现Null\"); } } else if (!this.m_valueType.IsAssignableFrom(value.GetType())) { throw new Exception($\"属性“{this.m_name}”赋值类型与注册类型不一致，应当注入“{this.m_valueType}”类型\"); } } internal void SetDefauleValue(object value) { this.DataValidation(value); this.m_value = value; } /// \u003csummary\u003e /// 注册依赖项属性。 /// \u003cpara\u003e依赖属性的默认值，可能会应用于所有的\u003csee cref=\"IDependencyObject\"/\u003e\u003c/para\u003e /// \u003c/summary\u003e /// \u003cparam name=\"propertyName\"\u003e\u003c/param\u003e /// \u003cparam name=\"valueType\"\u003e\u003c/param\u003e /// \u003cparam name=\"owner\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e依赖项属性值，一般该值应该是值类型，因为它可能会被用于多个依赖对象。\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static DependencyProperty Register(string propertyName, Type valueType, Type owner, object value) { DependencyProperty dp = new DependencyProperty { m_name = propertyName, m_valueType = valueType, m_owner = owner }; dp.SetDefauleValue(value); return dp; } } 如何管理依赖属性，类中创建依赖属性，并设置和获取依赖属性的值。首先实现接口，可以获取和设置依赖属性的值，实现一个基类，实现该接口，所有包含依赖属性的类继承该基类，就可以实现操作依赖属性了。 该框架做了进一步扩展，在基类中添加了一个依赖属性字典，可以添加外部依赖属性。 也就是在基类中保存了一个Key，Value的字典，通过特定的Key获取到Value，在配置的时候特别有用，配置类Option/Config怎么应对变化，写组件的时候发现配置项多需要添加属性怎么办，修改配置项，违反开放封闭原则；使用继承，显得太重；增加一个配置类，还不如使用继承。 把配置项修改成字典，所有信息通过key,value保存，可以应对开放封闭原则。显然该框架就说这样干的，key是依赖属性，vlaue是依赖属性的值。 /// \u003csummary\u003e /// 依赖对象接口 /// \u003c/summary\u003e public interface IDependencyObject : System.IDisposable { /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e object GetValue(DependencyProperty dp); /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public T GetValue\u003cT\u003e(DependencyProperty dp); /// \u003csummary\u003e /// 设置依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e\u003c/param\u003e public DependencyObject SetValue(DependencyProperty dp, object value); } /// \u003csummary\u003e /// 依赖项对象. /// 线程安全。 /// \u003c/summary\u003e public class DependencyObject : DisposableObject, IDependencyObject, System.IDisposable { /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e public DependencyObject() { this.m_dp = new ConcurrentDictionary\u003cDependencyProperty, object\u003e(); } [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)] private readonly ConcurrentDictionary\u003cDependencyProperty, object\u003e m_dp; /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public object GetValue(DependencyProperty dp) { if (this.m_dp.TryGetValue(dp, out object value)) { return value; } else { return dp.DefauleValue; } } /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public T GetValue\u003cT\u003e(DependencyProperty dp) { try { return (T)this.GetValue(dp); } catch { return default; } } /// \u003csummary\u003e /// 设置依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e\u003c/param\u003e public DependencyObject SetValue(DependencyProperty dp, object value) { dp.DataValidation(value); if (this.m_dp.ContainsKey(dp)) { this.m_dp[dp] = value; } els","date":"2022-09-07","objectID":"/2022/09/touchsocket1-dependencyproperties/:2:0","tags":["TouchSocket0.3.5","依赖属性"],"title":"TouchSocket 依赖属性","uri":"/2022/09/touchsocket1-dependencyproperties/"},{"categories":"TouchSocket0.3.5","content":"总结\r依赖属性这样的应用方式非常优秀，满足了扩展开放，单一职责。如果有其他的应用方式欢迎评论。 ","date":"2022-09-07","objectID":"/2022/09/touchsocket1-dependencyproperties/:3:0","tags":["TouchSocket0.3.5","依赖属性"],"title":"TouchSocket 依赖属性","uri":"/2022/09/touchsocket1-dependencyproperties/"},{"categories":"算法","content":"实现队列的一些思路\r数组的优劣： 读取：连续的地址空间，数组全部或者部分元素被连续存在CPU缓存里面，读取速度非常快。 插入/删除/扩容：插入和删除，需要修改该元素之前或之后所有元素的位置，扩容时需要重新找较大的内存块，将原数组中所有数据复制到新内存块中。这些操作都非常耗时。 链表的优劣： 读取：链表的节点分散在堆空间中，无法利用CPU缓存，读写速度比较慢，是数组的33倍 插入/删除/扩容：不需要改变原来元素的位置，仅仅修改节点信息即可。但是频繁的插入删除会导致堆中有大量碎片化内存。 链表每个节点不仅需要保存数据还需要保存下一个节点的位置。 较好的方式是结合数组和链表的优势，用链表节点将固定大小的数组连接起来组成大的内存块，即易于扩展又在一定范围内保持良好的访问速度。 在需要构建内存池，缓存队列等应用场景中均可使用此方法进行优化。 ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:1:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"队列接口\rpublic interface IQueue\u003cTItem\u003e : IEnumerable\u003cTItem\u003e, IDisposable { bool IsEmpty { get; } int Length { get; } void Enqueue(TItem item); TItem Dequeue(); } ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:2:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"基于数组的扩容队列\rpublic class SGResizingArrayQueue\u003cTItem\u003e : IQueue\u003cTItem\u003e { public SGResizingArrayQueue() { _first = 0; _last = 0; _items = new TItem[2]; } public IEnumerator\u003cTItem\u003e GetEnumerator() { if (!IsEmpty) { for (var i = _first; i \u003c _last; i++) { yield return _items[i]; } } } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } public void Dispose() { Dispose(true); } protected virtual void Dispose(bool disposing) { if (disposing) { if (!IsEmpty) { for (var i = _first; i \u003c _last; i++) { _items[i] = default; } _items = null; } } } private TItem[] _items; private int _first; private int _last; public bool IsEmpty =\u003e (_last - _first) == 0; public int Length =\u003e _last - _first; private void resize(int size) { var temitems = new TItem[size]; var temlength = Length; Array.Copy(_items, _first, temitems, 0, Length); _first = 0; _last = temlength; _items = temitems; } public void Enqueue(TItem item) { if (_last == _items.Length) resize(Length * 2); _items[_last++] = item; } public TItem Dequeue() { if (IsEmpty) return default; var item = _items[_first++]; if (Length \u003c _items.Length / 4) resize(_items.Length / 2); return item; } } ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:3:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"基于链表的扩容队列\rpublic class SGLinkedQueue\u003cTItem\u003e : IQueue\u003cTItem\u003e { private Node _first; private Node _last; private int _length; public SGLinkedQueue() { _length = 0; } private class Node { public TItem Item { set; get; } public Node Next { set; get; } } public IEnumerator\u003cTItem\u003e GetEnumerator() { if (!IsEmpty) { var temnode = _first; while (temnode != default) { var item = temnode.Item; temnode = temnode.Next; yield return item; } } } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } public void Dispose() { Dispose(true); } protected virtual void Dispose(bool disposing) { if (disposing) { if (!IsEmpty) { var temfirst = _first; while (temfirst != default) { temfirst.Item = default; temfirst = temfirst.Next; } _length = 0; } } } public bool IsEmpty =\u003e _length == 0; public int Length =\u003e _length; public void Enqueue(TItem item) { var temnode = _last; _last = new Node(); _last.Item = item; _last.Next = null; if (IsEmpty) _first = _last; else temnode.Next = _last; _length++; } public TItem Dequeue() { if (_length \u003e 0) { var temitem = _first.Item; _first = _first.Next; _length--; return temitem; } return default; } } ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:4:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"结合数组和链表的扩容队列\rclass SGArraySegment\u003cTItem\u003e { public TItem[] Array { get; private set; } public SGArraySegment\u003cTItem\u003e Next { get; set; } public int Offset { get; set; } public int End { get; set; } = -1; public SGArraySegment(TItem[] array) { Array = array; } public bool IsAvailable { get { return Array.Length \u003e (End + 1); } } public void Write(TItem value) { Array[++End] = value; } } class SGPipeQueue\u003cTItem\u003e : IValueTaskSource\u003cTItem\u003e, IDisposable { private const int _segmentSize = 5; private SGArraySegment\u003cTItem\u003e _first; private SGArraySegment\u003cTItem\u003e _current; private object _syncRoot = new object(); private static readonly ArrayPool\u003cTItem\u003e _pool = ArrayPool\u003cTItem\u003e.Shared; private ManualResetValueTaskSourceCore\u003cTItem\u003e _taskSourceCore; private bool _waiting = false; private bool _lastReadIsWait = false; private int _length; public SGPipeQueue() { SetBufferSegment(CreateSegment()); _taskSourceCore = new ManualResetValueTaskSourceCore\u003cTItem\u003e(); } SGArraySegment\u003cTItem\u003e CreateSegment() { return new SGArraySegment\u003cTItem\u003e(_pool.Rent(_segmentSize)); } void SetBufferSegment(SGArraySegment\u003cTItem\u003e segment) { if (_first == null) _first = segment; var current = _current; if (current != null) current.Next = segment; _current = segment; } public int Write(TItem target) { lock (_syncRoot) { if (_waiting) { _waiting = false; _taskSourceCore.SetResult(target); return _length; } var current = _current; if (!current.IsAvailable) { current = CreateSegment(); SetBufferSegment(current); } current.Write(target); _length++; return _length; } } public ValueTask\u003cTItem\u003e ReadAsync() { lock (_syncRoot) { if (TryRead(out TItem value)) { if (_lastReadIsWait) { _taskSourceCore.Reset(); _lastReadIsWait = false; } _length--; if (_length == 0) OnWaitTaskStart(); return new ValueTask\u003cTItem\u003e(value); } _waiting = true; _lastReadIsWait = true; _taskSourceCore.Reset(); OnWaitTaskStart(); return new ValueTask\u003cTItem\u003e(this, _taskSourceCore.Version); } } private bool TryRead(out TItem value) { var first = _first; if (first.Offset \u003c first.End) { value = first.Array[first.Offset]; first.Array[first.Offset] = default; first.Offset++; return true; } else if (first.Offset == first.End) { if (first == _current) { value = first.Array[first.Offset]; first.Array[first.Offset] = default; first.Offset = 0; first.End = -1; return true; } else { value = first.Array[first.Offset]; first.Array[first.Offset] = default; _first = first.Next; _pool.Return(first.Array); return true; } } value = default; return false; } protected virtual void OnWaitTaskStart() { } public virtual void Clear() { lock (_syncRoot) { if (_lastReadIsWait) { _taskSourceCore.Reset(); _lastReadIsWait = false; } var first = _first; if (first.Offset \u003c= first.End) { while (first != _current) { for (int i = first.Offset; i \u003c= first.End; i++) { first.Array[i] = default; } _first = first.Next; _pool.Return(first.Array); first = _first; } for (int i = first.Offset; i \u003c= first.End; i++) { first.Array[i] = default; } first.Offset = 0; first.End = -1; } } } public void Dispose() { lock (_syncRoot) { var segment = _first; while (segment != null) { _pool.Return(segment.Array); segment = segment.Next; } _first = null; _current = null; } } TItem IValueTaskSource\u003cTItem\u003e.GetResult(short token) { return _taskSourceCore.GetResult(token); } ValueTaskSourceStatus IValueTaskSource\u003cTItem\u003e.GetStatus(short token) { return _taskSourceCore.GetStatus(token); } void IValueTaskSource\u003cTItem\u003e.OnCompleted(Action\u003cobject?\u003e continuation, object? state, short token, ValueTaskSourceOnCompletedFlags flags) { _taskSourceCore.OnCompleted(continuation, state, token, flags); } } 该队列额外实现2个功能，以提高队列的性能： 异步出队列，当队列为空时，异步等待。 当压入队列时，如果发现有异步等待对象，则不进入队列，直接给等待对象。 ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:5:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"数据压缩\r基础模型 压缩盒，能够将一个比特流B 转化为压缩后的版本C(B); 展开盒，能够将C(B) 转化回B 。 这种模型叫做无损压缩模型一保证不丢失任何信息，即压缩和展开之后的比特流必须和原始的比特流完全相同。许多种类型的文件都会用到无损压缩，例如数值数据或者可执行的代码。对于某些类型的文件（例如图像、视频和音乐），有损的压缩方法也是可以接受的，此时解码器所产生的输出只是与原输入文件近似。 ","date":"2021-05-20","objectID":"/2021/05/algorithm12/:1:0","tags":["算法","字符串压缩"],"title":"算法 字符串压缩","uri":"/2021/05/algorithm12/"},{"categories":"算法","content":"读写二进制数据\rpublic class BinaryStdIn { private static int EOF = -1; // end of file private static TextReader input; // input stream private static int buffer; // one character buffer private static int n; // number of bits left in buffer private static bool isInitialized; // has BinaryStdIn been called for first time? // don't instantiate private BinaryStdIn() { } // fill buffer private static void Initialize() { input = Console.In; buffer = 0; n = 0; FillBuffer(); isInitialized = true; } private static void FillBuffer() { try { buffer = input.Read();//文本读取器中的下一个字符 n = 8; } catch (IOException e) { Console.WriteLine(\"EOF\"); buffer = EOF; n = -1; } } public static void Close() { if (!isInitialized) Initialize(); try { input.Close(); isInitialized = false; } catch (IOException ioe) { throw new ArgumentException(\"Could not close BinaryStdIn\", ioe); } } public static bool IsEmpty() { if (!isInitialized) Initialize(); return buffer == EOF; } public static bool ReadBoolean() { if (IsEmpty()) throw new ArgumentNullException(\"Reading from empty input stream\"); n--; bool bit = ((buffer \u003e\u003e n) \u0026 1) == 1; if (n == 0) FillBuffer(); return bit; } public static char ReadChar() { if (IsEmpty()) throw new ArgumentNullException(\"Reading from empty input stream\"); // special case when aligned byte if (n == 8) { int y = buffer; FillBuffer(); return (char)(y \u0026 0xff); } // combine last n bits of current buffer with first 8-n bits of new buffer int x = buffer; x \u003c\u003c= (8 - n); int oldN = n; FillBuffer(); if (IsEmpty()) throw new ArgumentNullException(\"Reading from empty input stream\"); n = oldN; x |= (int)((uint)buffer \u003e\u003e n); return (char)(x \u0026 0xff); // the above code doesn't quite work for the last character if n = 8 // because buffer will be -1, so there is a special case for aligned byte } public static char ReadChar(int r) { if (r \u003c 1 || r \u003e 16) throw new ArgumentNullException(\"Illegal value of r = \" + r); // optimize r = 8 case if (r == 8) return ReadChar(); byte x = 0; for (int i = 0; i \u003c r; i++) { x \u003c\u003c= 1; bool bit = ReadBoolean(); if (bit) x |= 1; } return (char)x; } public static String ReadString() { if (IsEmpty()) throw new ArgumentNullException(\"Reading from empty input stream\"); StringBuilder sb = new StringBuilder(); while (!IsEmpty()) { char c = ReadChar(); sb.Append(c); } return sb.ToString(); } public static short ReadShort() { short x = 0; for (int i = 0; i \u003c 2; i++) { byte c =(byte) ReadChar(); x \u003c\u003c= 8; x |= c; } return x; } public static int ReadInt() { int x = 0; for (int i = 0; i \u003c 4; i++) { byte c =(byte) ReadChar(); x \u003c\u003c= 8; x |= c; } return x; } public static int ReadInt(int r) { if (r \u003c 1 || r \u003e 32) throw new ArgumentException(\"Illegal value of r = \" + r); // optimize r = 32 case if (r == 32) return ReadInt(); int x = 0; for (int i = 0; i \u003c r; i++) { x \u003c\u003c= 1; bool bit = ReadBoolean(); if (bit) x |= 1; } return x; } public static long ReadLong() { long x = 0; for (int i = 0; i \u003c 8; i++) { char c = ReadChar(); x \u003c\u003c= 8; x |= c; } return x; } public static double ReadDouble() { return BitConverter.Int64BitsToDouble(ReadLong()); } public static float readFloat() { return BitConverter.ToSingle(BitConverter.GetBytes(ReadInt()),0); } public static byte ReadByte() { char c = ReadChar(); return (byte)(c \u0026 0xff); } } public class BinaryStdOut { private static TextWriter output; // output stream (standard output) private static int buffer; // 8-bit buffer of bits to write private static int n; // number of bits remaining in buffer private static bool isInitialized; // has BinaryStdOut been called for first time? // don't instantiate private BinaryStdOut() { } // initialize BinaryStdOut private static void Initialize() { output = Console.Out; buffer = 0; n = 0; isInitialized = true; } private static void WriteBit(bool bit) { if (!isInitialized) Initialize(); // add bit to buffer buffer \u003c\u003c= 1; if (bit) buffer |= 1; // if buffer is full (8 bits), write out as a single byte n++; if (n == 8) ClearBuffer(); } /** * Writes the 8-bit byte to standard","date":"2021-05-20","objectID":"/2021/05/algorithm12/:1:1","tags":["算法","字符串压缩"],"title":"算法 字符串压缩","uri":"/2021/05/algorithm12/"},{"categories":"算法","content":"基因数据\r双位编码压缩 基因的一个简单性质是，它由4 种不同的字符组成。这些字符可以用两个比特编码， 基因都是4个编码，用2个bit表示基因四个字符，byte可以存储8bit，存储4个基因。 public static void Compress() { Alphabet DNA = Alphabet.DNA; String s = BinaryStdIn.ReadString(); int n = s.Length; BinaryStdOut.Write(n); Console.WriteLine(); // Write two-bit code for char. for (int i = 0; i \u003c n; i++) { short d =(short) DNA.ToIndex(s[i]);//0,1,2,3 BinaryStdOut.Write(d, 2);//输入 2 bit } BinaryStdOut.Close(); } public static void Expand() { Alphabet DNA = Alphabet.DNA; // Read two bits; write char. for (int i = 0; i \u003c 33; i++) { char c = BinaryStdIn.ReadChar(2);//指定将2bit转化成char Console.Write(DNA.ToChar(c)); } BinaryStdOut.Close(); } 测试 [TestMethod] public void GenomeCompressTest() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\genomeTiny.txt\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { Console.WriteLine(\"Compress\"); Console.SetIn(stream); Genome.Compress(); } //ATAGATGCATAGCGCATAGCTAGATGTGCTAGC //292dÉÈîr@ } [TestMethod] public void GenomeExpandTest() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\genomeTinyExpand.txt\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { Console.WriteLine(\"Expand\"); Console.SetIn(stream); Genome.Expand(); } //ATAGATGCATAGCGCATAGCTAGATGTGCTAGC } ","date":"2021-05-20","objectID":"/2021/05/algorithm12/:1:2","tags":["算法","字符串压缩"],"title":"算法 字符串压缩","uri":"/2021/05/algorithm12/"},{"categories":"算法","content":"游程编码(Run-Length Encoding)\r比特流中最简单的冗余形式就是一长串重复的比特。 0000000000000001111111000000011111111111 该字符串含有15个0，7个1，7个0，11个1，将该比特字符串编码为15，7，7，11，所有的1和0都是交替出现的，用4位表四长度以连续的0作为开头，就可以得到16位长的字符串。 1111011101111011 压缩率为16/40=40% 需要解决几个问题： 应该使用多少比特来记录游程的长度？ 当某个游程的长度超过了能够记录的最大长度时怎么办？ 当游程的长度所需的比特数小于记录长度的比特数时怎么办？ 如何解决 游程长度应该在0 到255 之间，使用8 位编码 在需要的情况下使用长度为0 的游程来保证所有游程的长度均小于256; 我们也会将较短的游程编码，虽然这样做有可能使输出变得更长。 public class RunLength { private static int R = 256; private static int LG_R = 8; public static void Expand() { bool b = false; while (!BinaryStdIn.IsEmpty()) { int run=BinaryStdIn.ReadInt(LG_R); for (int i = 0; i \u003crun; i++) BinaryStdOut.Write(b); b = !b; } BinaryStdOut.Close(); } public static void Compress() { byte run = 0; bool old = false; while (!BinaryStdIn.IsEmpty()) { bool b = BinaryStdIn.ReadBoolean(); if (b != old) { BinaryStdOut.Write(run, LG_R); run = 1; old = !old; } else { if (run == R - 1)//如果超过256位了就重新计算 { BinaryStdOut.Write(run, LG_R); run = 0; BinaryStdOut.Write(run, LG_R);//跳过下一个变换，就是0个1 } run++; } } BinaryStdOut.Write(run, LG_R); BinaryStdOut.Close(); } } 测试 [TestMethod] public void RunLengthCompressTest() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\4runs.bin\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { Console.WriteLine(\"Compress\"); Console.SetIn(stream); RunLength.Compress(); } } [TestMethod] public void RunLengthExpandTest() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\4runsExpand.txt\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { Console.WriteLine(\"Expand\"); Console.SetIn(stream); RunLength.Expand(); } } 游程编码广泛用于位图的主要原因是，随着分辨率的提高它的效果也会大大的提 高。证明这一点很简单。假设将上一个例子中的分辨率提高一倍， 总比特数变为了原来的4 倍； 游程的数最变为约原来的2 倍; 游程的长度变为约原来的2 倍； 压缩后的比特数量变为约原来的2倍； 压缩率变成了原来的一半！ ","date":"2021-05-20","objectID":"/2021/05/algorithm12/:1:3","tags":["算法","字符串压缩"],"title":"算法 字符串压缩","uri":"/2021/05/algorithm12/"},{"categories":"算法","content":"霍夫曼压缩\r主要思想是放弃文本文件的普通保存方式： 不再使用7 位或8 位二进制数表示每一个字符，而是用较少的比特表示出现频率高的字符，用较多的比特表示出现频率低的字符。 假设需要将字符串A B R A C A D A B R A ! 编码。由7 位ASCII 字符编码我们可以得到比特字符串： 要将这段比特字符串解码，只需每次读取7 位并根据ASCII 编码表将它转换为字符，在这种标准的编码下，只出现了一次的D 和出现了5 次的A 所需的比特数是一样的 霍夫曼压缩的思想是通过用较少的比特表示出现频繁的字符而用较多的比特表示偶尔出现的字符来节省空间，这样字符串所使用的总比特数就会降低。 我们可以试着将最短的比特字符串赋予最常用的字符，将A 编码为0 、B 编码为1 、R 为00 、C 为0 1 、D 为10 、！为II 。这样A BRACADABRA! 的编码就是01000010100100011 。这种表示方法只用了17 位，而7 位的ASCII 编码则用了77 位。但这种表示方法并不完整，因为它需要空格来区分字符。如果所有字符编码都不会成为其他字符编码的前缀，那么就不需要分隔符了,添加前缀A为0，B为1111，C为110，D为100，R为1110，！为101. 前缀单词查找树\r表示前缀码的一种简便方法就是使用单词查找树，事实上，任意含有M 个空链接的单词查找树都为M 个字符定义了一种前缀码方法：我们将空链接替换为指向叶子结点（含有两个空链接的结点）的链接，每个叶子结点都含有一个需要编码的字符。 不同的前缀是影响压缩率的，寻找最优前缀码的通用方法是D .Huffinan 在1952 年发现的（当时他还是个学生），因此被称为霍夫曼编码。 使用前缀码进行数据压缩需要经过5 个主要步骤。 构造一棵编码单词查找树； 将该树以字节流的形式写入输出以供展开时使用； 使用该树将字节流编码为比特流。 在展开时需要： 读取单词查找树（保存在比特流的开头） 使用该树将比特流解码。 单词查找树结点\rpublic class Node : IComparable\u003cNode\u003e { public char ch; public int freq; public Node left, right; public Node(char ch, int freq, Node left, Node right) { this.ch = ch; this.freq = freq; this.left = left; this.right = right; } // is the node a leaf node? public bool IsLeaf() { if(((left == null) \u0026\u0026 (right == null)) || ((left != null) \u0026\u0026 (right != null))) { return (left == null) \u0026\u0026 (right == null); } else { throw new ArgumentException(\"is not leaf\"); } } // compare, based on frequency public int CompareTo(Node that) { return this.freq - that.freq; } } 被编码的字符放在叶子结点中并在每个结点中维护了一个名为freq 的实例变最来表示以它为根结点的子树中的所有字符出现的频率。 前缀码展开\r使用前缀码压缩\r对千任意单词查找树，它都能产生一张将树中的字符和比特字符串（用由0 和1 组成的String 字符串表示）相对应的编译表。编译表就是一张将每个字符和它的比特字符串相关联的符号表： 为了提升效率，我们使用了一个由字符索引的数组st[] 而非普 通的符号表，因为字符的数最并不多。在构造该符号表时，buildCode () 递归遍历整棵树并为每个结点维护了一条从根结点到它的路径所对应的二进制字符串（ 0 表示左链接， 1 表示右链接） /// \u003csummary\u003e /// 使用单词查找树构造编译表(递归) /// \u003c/summary\u003e /// \u003cparam name=\"st\"\u003e\u003c/param\u003e /// \u003cparam name=\"x\"\u003e\u003c/param\u003e /// \u003cparam name=\"s\"\u003e\u003c/param\u003e private static void BuildCode(String[] st, Node x, String s) { if (!x.IsLeaf()) { BuildCode(st, x.left, s + '0'); BuildCode(st, x.right, s + '1'); } else { st[x.ch] = s; } } 单词查找树构造\r我们将需要被编码的字符放在叶子结点中并在每个结点中维护了一个名为freq 的实例变最来表示以它为根结点的子树中的所有字符出现的频率。构造的第一步是创建一片由许多只有一个结点（ 即叶子结点）的树所组成的森林。每棵树都表示输入流中的一个字符，每个结点中的freq 变戴的值都表示了它在输入流中的出现频率。在我们的例子中，输入含有8 个t, 5 个e, 11 个空格等（特别提示： 为了得到这些频率，需要读取整个输入流－霍夫曼编码是一个两轮算法， 因为需要再次读取输入流才能压缩它)。接下来自底向上根据频率构造这棵编码的单词查找树。在构造时将它看作一棵结点中含有频率信息的二叉树； 在构造后，我们才将它看作一棵用千编码的单词查找树。构造过程如下： 首先找到两个频率最小的结点，然后创建一个以二者为子结点的新结点（新结点的频率值为它的两个子结点的频率值之和） 。这个操作会将森林中树的数量减一。然后不断重复这个过程，找到森林中的两棵频率最小的树并用相同的方式创建一个新的结点。用优先队列能够轻易实现这个过程，随着这个过程的继续，我们构造的单词查找树将越来越大， 而森林中的树会越来越少。最终，所有的结点会被合并为一棵单独的单词查找树。 LF换行，SP空格 最优性\r在树中高频率的字符比低频率的字符离根结点更近，因此编码所需的比特更少，所以这种编码的方式更好。 加权外部路径长度:它是所有叶子结点的权重（频率）和深度之积的和。 给定一个含有r 个符号的集合和它们的频率，霍夫曼算法所构造的前缀码是最优的。 写入和读取单词查找树\r第一位是0, 对应着根结点；下一个遇到是含有A 的叶子结点，因此下一位为1, 紧接着是01000001 , 即\"A\" 的8 位ASCII 编码。下两位均为0, 因为遇到的都是两个内部结点， 首先读取一个比特以得到当前结点的类型，如果是叶子结点（比特为1) 那么就读取字符的 编码并创建一个叶子结点；如果是内部结点（比特为0) 那么就创建一个内部结点并（递归地）继续构造它的左右子树。 霍夫曼压缩实现\r压缩 读取输入 将输入中的每个char 值的出现频率制成表格； 根据频率构造相应的霍夫曼编码树； 构造编译表，将输入中的每个char 值和一个比特字符串相关联； 将单词查找树编码为比特字符串并写入输出流； 将单词总数编码为比特字符串并写入输出流； 使用编译表翻译每个输入字符 展开 读取单词查找树（编码在比特流的开头）； 读取需要解码的字符数量； 使用单词查找树将比特流解码。 ","date":"2021-05-20","objectID":"/2021/05/algorithm12/:1:4","tags":["算法","字符串压缩"],"title":"算法 字符串压缩","uri":"/2021/05/algorithm12/"},{"categories":"算法","content":"字符串查找\r","date":"2021-05-05","objectID":"/2021/05/algorithm11/:1:0","tags":["算法","字符串查找"],"title":"算法 字符串查找","uri":"/2021/05/algorithm11/"},{"categories":"算法","content":"单词查找树\r单词查找树是由链接的结点所组成的数据结构，这些链接可能为空，也可能指向其他结点。 每个结点都只可能有一个指向它的结点，称为它的父结点（只有一个结点除外，即根结点，没有任何结点指向根结点）。 每个结点都含有R 条链接， 其中R为字母表的大小。 单词查找树一般都含有大最的空链接，因此在绘制一棵单词查找树时一般会忽略空链接。 尽管链接指向的是结点，但是也可以看作链接指向的是另一棵单词查找树， 值为空的结点在符号表中没有对应的键，它们的存在是为了简化单词查找树中的查找操作。 查找\r键的尾字符所对应的结点中的值非空，这是一次命中的查找~所对应的值就是键的尾字符所对应的结点中保存的值。 键的尾字符所对应的结点中的值为空，这是一次未命中的查找一符号表中不存在被查找的键。 查找结束于一条空链接这也是一次未命中的查找。 插入\r在到达键的尾字符之前就遇到了一个空链接。在这种情况下，字符查找树中不存在与键的尾字符对应的结点，因此需要为键中还未被检查的每个字符创建一个对应的结点并将键的值保存到最后一个字符的结点中。 在遇到空链接之前就到达了键的尾字符。在这种情况下，和关联性数组一样，将该结点的值设为键所对应的值 表示\r将空链接考虑进来将会突出单词查找树的以下重要性质： 每个结点都含有R 个链接，对应着每个可能出现的字符； 字符和键均隐式地保存在数据结构中。 每个结点都含有一个值和26 个链接 public class TrieST\u003cValue\u003e { private static readonly int R = 256; // extended ASCII,基数 private Node root; // 树的根 private int n; // number of keys in trie // R-way trie node private class Node { public Object val; public Node[] next = new Node[R]; } public TrieST() { } /// \u003csummary\u003e /// 返回给定关联的值 /// \u003c/summary\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public Value Get(String key) { if (key == null) throw new ArgumentException(\"argument to get() is null\"); Node x = Get(root, key, 0); if (x == null) return default(Value); return (Value)x.val; } /// \u003csummary\u003e /// 此符号表是否包含给定的键 /// \u003c/summary\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public bool Contains(string key) { if (key == null) throw new ArgumentException(\"argument to contains() is null\"); return Get(key) != null; } private Node Get(Node x, String key, int d) { if (x == null) return null; if (d == key.Length) return x; char c = key[d]; return Get(x.next[c], key, d + 1); } /// \u003csummary\u003e /// 将键值对插入符号表，覆盖旧值 /// 如果键已在符号表中，则使用新值。 /// \u003c/summary\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003cparam name=\"val\"\u003e\u003c/param\u003e public void Put(String key, Value val) { if (key == null) throw new ArgumentException(\"first argument to put() is null\"); if (val == null) Delete(key); else root = Put(root, key, val, 0); } private Node Put(Node x, String key, Value val, int d) { //如果key存在于以x 为根结点的子单词查找树中则更新与它相关联的值 if (x == null) x = new Node(); if (d == key.Length) { if (x.val == null) n++; x.val = val; return x; } char c = key[d];////找到笫d 个字符所对应的子单词查找树 x.next[c] = Put(x.next[c], key, val, d + 1); return x; } /// \u003csummary\u003e /// 返回此符号表中的键值对的数量。 /// \u003c/summary\u003e /// \u003creturns\u003e\u003c/returns\u003e public int Size() { return n; } /// \u003csummary\u003e /// 此符号表是否为空 /// \u003c/summary\u003e /// \u003creturns\u003e\u003c/returns\u003e public bool IsEmpty() { return Size() == 0; } /// \u003csummary\u003e /// 返回所有键 /// \u003c/summary\u003e /// \u003creturns\u003e\u003c/returns\u003e public IEnumerable\u003cstring\u003e Keys() { return KeysWithPrefix(\"\"); } public IEnumerable\u003cstring\u003e KeysWithPrefix(String prefix) { Queue\u003cString\u003e results = new Queue\u003cString\u003e(); Node x = Get(root, prefix, 0); Collect(x, new StringBuilder(prefix), results); return results; } private void Collect(Node x, StringBuilder prefix, Queue\u003cString\u003e results) { if (x == null) return; if (x.val != null) results.Enqueue(prefix.ToString()); for (char c = (char)0; c \u003c R; c++) { prefix.Append(c); Collect(x.next[c], prefix, results); prefix.Remove(prefix.Length - 1, 1); } } /// \u003csummary\u003e /// 返回符号表中与pattern匹配的所有键， /// \u003c/summary\u003e /// \u003cparam name=\"pattern\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public IEnumerable\u003cString\u003e KeysThatMatch(String pattern) { Queue\u003cString\u003e results = new Queue\u003cString\u003e(); Collect(root, new StringBuilder(), pattern, results); return results; } private void Collect(Node x, StringBuilder prefix, String pattern, Queue\u003cString\u003e results) { if (x == null) return; int d = prefix.Length; if (d == pattern.Length \u0026\u0026 x.val != null) results.Enqueue(prefix.ToString()); if (d == pattern.Length) return; char c = pattern[d]; if (c == '.') { for (char ch = (char)0; ch \u003c R; ch++) { prefix.Append(ch); Collect(x.next[ch], prefix, pattern, results); prefix.Remove(prefix.Length - 1, 1); } } else { prefix.Append(c); Collect(x.next[c], prefix, pattern, results); prefix.Remove(prefix.Length - 1, 1); } } /// \u003csummary\u003e /// 返回符号表中的字符串，该字符串是{@code query}的最长前缀， /// \u003c/summary\u003e /// \u003cparam name=\"query\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public String LongestPrefixOf(","date":"2021-05-05","objectID":"/2021/05/algorithm11/:1:1","tags":["算法","字符串查找"],"title":"算法 字符串查找","uri":"/2021/05/algorithm11/"},{"categories":"算法","content":"三向单词查找树\r三向单词查找树(TST) 。在三向单词查找树中，每个结点都含有一个字符、三条链接和一个值。这三条链接分别对应着当前字母小于、等于和大于结点字母的所有键。 如果遇到了一个空链接或者当键结束时结点的值为空，那么查找未命中；如果键结束时结点的值非空则查找命中。在插入一个新键时，首先进行查找，然后和在单词查找树一样，在树中补全键末尾的所有结点。 public class TST\u003cValue\u003e { private int n; // 树的大小 private Node\u003cValue\u003e root; // 树的根节点 public class Node\u003cValue\u003e { public char c; // 字符 public Node\u003cValue\u003e left, mid, right; // 左中右子三向单词查找树 public Value val; // 和宇符串相关联的值 } /// \u003csummary\u003e /// 初始化一个空的字符串表 /// Initializes an empty string symbol table. /// \u003c/summary\u003e public TST() { } public int Size() { return n; } public bool Contains(string key) { if (key == null) { throw new ArgumentNullException(\"argument to contains() is null\"); } return Get(key) != null; } public Value Get(string key) { if (key == null) { throw new ArgumentNullException(\"calls get() with null argument\"); } if (key.Length == 0) throw new ArgumentException(\"key must have length \u003e= 1\"); Node\u003cValue\u003e x = Get(root, key, 0); if (x == null) return default(Value); return x.val; } // return subtrie corresponding to given key private Node\u003cValue\u003e Get(Node\u003cValue\u003e x, String key, int d) { if (x == null) return null; if (key.Length == 0) throw new ArgumentException(\"key must have length \u003e= 1\"); char c = key[d]; if (c \u003c x.c) return Get(x.left, key, d); else if (c \u003e x.c) return Get(x.right, key, d); else if (d \u003c key.Length - 1) return Get(x.mid, key, d + 1); else return x; } public void Put(String key, Value val) { if (key == null) { throw new ArgumentNullException(\"calls put() with null key\"); } if (!Contains(key)) n++; else if (val == null) n--; // delete existing key root = Put(root, key, val, 0); } private Node\u003cValue\u003e Put(Node\u003cValue\u003e x, String key, Value val, int d) { char c = key[d]; if (x == null) { x = new Node\u003cValue\u003e(); x.c = c; } if (c \u003c x.c) x.left = Put(x.left, key, val, d); else if (c \u003e x.c) x.right = Put(x.right, key, val, d); else if (d \u003c key.Length - 1) x.mid = Put(x.mid, key, val, d + 1); else x.val = val; return x; } /// \u003csummary\u003e /// 返回符号表中的字符串，该字符串是query的最长前缀， /// \u003c/summary\u003e /// \u003cparam name=\"query\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public String LongestPrefixOf(String query) { if (query == null) { throw new ArgumentNullException(\"calls longestPrefixOf() with null argument\"); } if (query.Length == 0) return null; int length = 0; Node\u003cValue\u003e x = root; int i = 0; while (x != null \u0026\u0026 i \u003c query.Length) { char c = query[i]; if (c \u003c x.c) x = x.left; else if (c \u003e x.c) x = x.right; else { i++; if (x.val != null) length = i; x = x.mid; } } return query.Substring(0, length); } public IEnumerable\u003cstring\u003e Keys() { Queue\u003cstring\u003e queue = new Queue\u003cstring\u003e(); Collect(root, new StringBuilder(), queue); return queue; } /// \u003csummary\u003e /// 返回集合中以{@code prefix}开头的所有键。 /// \u003c/summary\u003e /// \u003cparam name=\"prefix\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public IEnumerable\u003cString\u003e KeysWithPrefix(String prefix) { if (prefix == null) { throw new ArgumentNullException(\"calls keysWithPrefix() with null argument\"); } Queue\u003cString\u003e queue = new Queue\u003cString\u003e(); Node\u003cValue\u003e x = Get(root, prefix, 0); if (x == null) return queue; if (x.val != null) queue.Enqueue(prefix); Collect(x.mid, new StringBuilder(prefix), queue); return queue; } /// \u003csummary\u003e /// subtrie中所有以x为根且具有给定前缀的键 /// \u003c/summary\u003e /// \u003cparam name=\"x\"\u003e\u003c/param\u003e /// \u003cparam name=\"prefix\"\u003e\u003c/param\u003e /// \u003cparam name=\"queue\"\u003e\u003c/param\u003e private void Collect(Node\u003cValue\u003e x, StringBuilder prefix, Queue\u003cString\u003e queue) { if (x == null) return; Collect(x.left, prefix, queue); if (x.val != null) queue.Enqueue(prefix.ToString() + x.c); Collect(x.mid, prefix.Append(x.c), queue); prefix.Remove(prefix.Length - 1, 1); Collect(x.right, prefix, queue); } /// \u003csummary\u003e /// 返回符号表中与{@code pattern}匹配的所有键，其中。 符号被视为通配符。 /// \u003c/summary\u003e /// \u003cparam name=\"pattern\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public IEnumerable\u003cString\u003e KeysThatMatch(String pattern) { Queue\u003cString\u003e queue = new Queue\u003cString\u003e(); Collect(root, new StringBuilder(), 0, pattern, queue); return queue; } private void Collect(Node\u003cValue\u003e x, StringBuilder prefix, int i, String pattern, Queue\u003cString\u003e q","date":"2021-05-05","objectID":"/2021/05/algorithm11/:1:2","tags":["算法","字符串查找"],"title":"算法 字符串查找","uri":"/2021/05/algorithm11/"},{"categories":"算法","content":"字符串符号表\r","date":"2021-05-05","objectID":"/2021/05/algorithm11/:1:3","tags":["算法","字符串查找"],"title":"算法 字符串查找","uri":"/2021/05/algorithm11/"},{"categories":"算法","content":"子字符串查找\r子宇符串查找： 给定一段长度为N 的文本和一个长度为M 的模式 ( pattern) 字符串，在文本中找到一个和该模式相符的子字符串 子字符串查找有一个简单而使用广泛的暴力算法。虽然它在最坏情况下的运行时间与MN 成正比，但是在处理许多应用程序中的字符串时（除了一些变态的情况之外），它的实际运行时间一般 与M + N 成正比。另外，它很好地利用了大多数计算机系统中标准的结构特性，因此即使是更加巧妙的算法也很难超越它经过优化后的版本的性能。 在19 80 年， M.O.Rabin 和R.M.Karp 使用散列开发出了一种与暴力算法儿乎一样简单但运行时间与M+N 成正比的概率极高的算法。另外，它们的算法还可以扩展到二维的模式和文本中，这使 得它比其他算法更适用于图像处理。， ","date":"2021-05-05","objectID":"/2021/05/algorithm11/:2:0","tags":["算法","字符串查找"],"title":"算法 字符串查找","uri":"/2021/05/algorithm11/"},{"categories":"算法","content":"暴力子字符串查找\r在最坏情况下，暴力子字符串查找算法在长度为N 的文本中查找长度为M 的模式需要-NM 次字符比较， public static int Search(string pat, string txt) { int M = pat.Length; int N = txt.Length; for (int i = 0; i \u003c= N - M; i++) { int j; for (j = 0; j \u003c M; j++) { if(txt[i+j]!=pat[j]) break; } if (j == M) return i;//找到匹配 } return N;//未找到匹配 } 另一种显式回退暴力算法 public static int ShowBackSearch(string pat, string txt) { int j, M = pat.Length; int i, N = txt.Length; for (i = 0, j = 0; i \u003c N \u0026\u0026 j \u003c M; i++) { if (txt[i] == pat[j]) j++; else { i -= j;//显示回退 j = 0; } } if (j == M) return j - M;//找到匹配 else return N;//未找到匹配 } ","date":"2021-05-05","objectID":"/2021/05/algorithm11/:2:1","tags":["算法","字符串查找"],"title":"算法 字符串查找","uri":"/2021/05/algorithm11/"},{"categories":"算法","content":"Knuth-Morris-Pratt\r算法的基本思想是当出现不匹配时，就能知晓一部分文本的内容。 假设字母表中只有两个字符，查找的模式字符串为B A A A A A A A A A 。现在，假设已经匹配了模式中的5 个字符，第6 个字符匹配失败。当发现不匹配的字符时，可以知道文本中的前6 个字符肯定是BAAAAB ( 前5 个匹配，第6 个失败），文本指针现在指向的是末尾的字符B 。你可以观察到，这里不需要回退文本指针i , 因为正文中的前4 个字符都是A,均与模式的第一个字符不匹配。KMP 算法的主要思想是提前判断如何重新开始查找，而这种判断只取决于模式本身。 使用一个数组dfa[] []来记录匹配失败时模式指针j 应该回退多远。对于每个字符c , 在比较了c 和pat.charAt(j) 之后， dfa[c] [j]表示的是应该和下个文本字符比较的模式字符的位置。在查找中， dfs[txt.charAt(i)][j] 是在比较了txt.charAt(i) 和pat.charAt(j) 之后应该和txt.charAt(i+1) 比较的模式字符位置。 要体验在DFA 中的子字符串查找操作，你可以先想象一下它所完成的两件最简单的任务。在 查找过程的开始，从文本的开头进行查找，起始状态为0 。它停留在0 状态并扫描文本，直到找到一个和模式的首字母相同的字符。这时它移动到下一个状态并开始运行。在这个过程的最后，当它找到一个匹配时，它会不断地匹配模式中的字符与文本，自动机的状态会不断前进直到状态M 。 构造dfa [] [] 数组\rpublic class KMP { private int R; // the radix private int m; // length of pattern private int[,] dfa; // KMP[c][j] public KMP(string pat) { this.R = 256; this.m = pat.Length; // build DFA from pattern //由模式宇符串构造DFA dfa = new int[R , m]; dfa[pat[0],0] = 1; for (int x = 0, j = 1; j \u003c m; j++)//j是pat的序号 { //计算dfa[][j] for (int c = 0; c \u003c R; c++) dfa[c,j] = dfa[c,x]; // 复制匹配失败情况下的值 dfa[pat[j],j] = j + 1; // 设置匹配成功情况下的值 x = dfa[pat[j],x]; // 更新重启状态 } } public KMP(char[] pattern, int R) { this.R = R; this.m = pattern.Length; // build DFA from pattern int m = pattern.Length; dfa = new int[R,m]; dfa[pattern[0],0] = 1; for (int x = 0, j = 1; j \u003c m; j++) { for (int c = 0; c \u003c R; c++) dfa[c,j] = dfa[c,x]; // Copy mismatch cases. dfa[pattern[j],j] = j + 1; // Set match case. x = dfa[pattern[j],x]; // Update restart state. } } public int Search(string txt) { // simulate operation of DFA on text //模拟DFA处理文本txt 时的操作 int n = txt.Length; int i, j; for (i = 0, j = 0; i \u003c n \u0026\u0026 j \u003c m; i++) { j = dfa[txt[i],j]; } if (j == m) return i - m; // 找到(到达模式字符串的结尾) return n; // 未找到(到达文本字符串的结尾) } public int Search(char[] text) { // simulate operation of DFA on text int n = text.Length; int i, j; for (i = 0, j = 0; i \u003c n \u0026\u0026 j \u003c m; i++) { j = dfa[text[i],j]; } if (j == m) return i - m; // found return n; // not found } } 测试 [TestMethod] public void KMPTest() { string[] args =new [] { \"abracadabra abacadabrabracabracadabrabrabracad\", \"rab abacadabrabracabracadabrabrabracad\", \"bcara abacadabrabracabracadabrabrabracad\", \"rabrabracad abacadabrabracabracadabrabrabracad\", \"abacad abacadabrabracabracadabrabrabracad\", }; foreach (var arg in args) { Console.WriteLine(\"/*********************Start*********************/\"); string pat= arg.Split(' ')[0]; string txt= arg.Split(' ')[1]; char[] pattern = pat.ToArray(); char[] text = txt.ToArray(); KMP kmp1 = new KMP(pat); int offset1 = kmp1.Search(txt); KMP kmp2 = new KMP(pattern, 256); int offset2 = kmp2.Search(text); // print results Console.WriteLine(\"text: \"); Console.WriteLine(txt); Console.WriteLine(\"pattern: \"); for (int i = 0; i \u003c offset1; i++) Console.Write(\" \"); Console.WriteLine(pat); Console.WriteLine(\"pattern: \"); for (int i = 0; i \u003c offset2; i++) Console.Write(\" \"); Console.WriteLine(pat); Console.WriteLine(\"/*********************End*********************/\"); } } ","date":"2021-05-05","objectID":"/2021/05/algorithm11/:2:2","tags":["算法","字符串查找"],"title":"算法 字符串查找","uri":"/2021/05/algorithm11/"},{"categories":"算法","content":"Boyer-Moore\r","date":"2021-05-05","objectID":"/2021/05/algorithm11/:2:3","tags":["算法","字符串查找"],"title":"算法 字符串查找","uri":"/2021/05/algorithm11/"},{"categories":"算法","content":"正则表达式\r","date":"2021-05-05","objectID":"/2021/05/algorithm11/:2:4","tags":["算法","字符串查找"],"title":"算法 字符串查找","uri":"/2021/05/algorithm11/"},{"categories":"算法","content":"字符串\r","date":"2021-04-26","objectID":"/2021/04/algorithm10/:0:0","tags":["算法","字符串排序"],"title":"算法 字符串排序","uri":"/2021/04/algorithm10/"},{"categories":"算法","content":"字母表\r将字符串转化成数字， using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace SuddenGale.AlgorithmEngine.Character { /// \u003csummary\u003e /// 字母 /// \u003c/summary\u003e public class Alphabet { /// \u003csummary\u003e /// The binary alphabet { 0, 1 }. /// \u003c/summary\u003e public static readonly Alphabet BINARY = new Alphabet(\"01\"); /// \u003csummary\u003e /// The octal alphabet { 0, 1, 2, 3, 4, 5, 6, 7 }. /// \u003c/summary\u003e public static readonly Alphabet OCTAL = new Alphabet(\"01234567\"); /// \u003csummary\u003e /// The decimal alphabet { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }. /// \u003c/summary\u003e public static readonly Alphabet DECIMAL = new Alphabet(\"0123456789\"); /// \u003csummary\u003e /// The hexadecimal alphabet { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F }. /// \u003c/summary\u003e public static readonly Alphabet HEXADECIMAL = new Alphabet(\"0123456789ABCDEF\"); /// \u003csummary\u003e /// The DNA alphabet { A, C, T, G }. /// \u003c/summary\u003e public static readonly Alphabet DNA = new Alphabet(\"ACGT\"); /// \u003csummary\u003e /// The lowercase alphabet { a, b, c, ..., z }. /// \u003c/summary\u003e public static readonly Alphabet LOWERCASE = new Alphabet(\"abcdefghijklmnopqrstuvwxyz\"); /// \u003csummary\u003e /// The uppercase alphabet { A, B, C, ..., Z }. /// \u003c/summary\u003e public static readonly Alphabet UPPERCASE = new Alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"); /// \u003csummary\u003e /// The protein alphabet { A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S, T, V, W, Y }. /// \u003c/summary\u003e public static readonly Alphabet PROTEIN = new Alphabet(\"ACDEFGHIKLMNPQRSTVWY\"); /// \u003csummary\u003e /// The base-64 alphabet (64 characters). /// \u003c/summary\u003e public static readonly Alphabet BASE64 = new Alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"); /// \u003csummary\u003e /// The ASCII alphabet (0-127). /// \u003c/summary\u003e public static readonly Alphabet ASCII = new Alphabet(128); /// \u003csummary\u003e /// The extended ASCII alphabet (0-255). /// \u003c/summary\u003e public static readonly Alphabet EXTENDED_ASCII = new Alphabet(256); /// \u003csummary\u003e /// The Unicode 16 alphabet (0-65,535). /// \u003c/summary\u003e public static readonly Alphabet UNICODE16 = new Alphabet(65536); private char[] alphabet; // the characters in the alphabet /// \u003csummary\u003e /// indices:指标 /// 序号是Ascii，值是基字母的序号 /// \u003c/summary\u003e private int[] inverse; // indices /// \u003csummary\u003e /// 字母基数 /// \u003c/summary\u003e private readonly int R; /// \u003csummary\u003e /// 根据alpha中的字符创建一张新的字母表 /// \u003c/summary\u003e /// \u003cparam name=\"alpha\"\u003e\u003c/param\u003e public Alphabet(System.String alpha) { // check that alphabet contains no duplicate chars //检查字母是否包含重复的字符 bool[] unicode = new bool[65536]; for (int i = 0; i \u003c alpha.Length; i++) { char c = alpha[i]; if (unicode[c]) throw new ArgumentException(\"Illegal alphabet: repeated character = '\" + c + \"'\"); unicode[c] = true; } alphabet = alpha.ToCharArray(); R = alpha.Length; inverse = new int[65536]; for (int i = 0; i \u003c inverse.Length;i++) inverse[i] = -1; // can't use char since R can be as big as 65,536 //不能使用char，因为R可以达到65,536 for (int c = 0; c \u003c R; c++) inverse[alphabet[c]] = c; } private Alphabet(int radix) { this.R = radix; alphabet = new char[R]; inverse = new int[R]; // can't use char since R can be as big as 65,536 for (int i = 0; i \u003c R; i++) alphabet[i] = (char)i; for (int i = 0; i \u003c R; i++) inverse[i] = i; } public Alphabet():this(256) { } /// \u003csummary\u003e /// c 在字母表之中吗 /// \u003c/summary\u003e /// \u003cparam name=\"c\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public bool Contains(char c) { return inverse[c] != -1; } /// \u003csummary\u003e /// 基数 /// \u003c/summary\u003e /// \u003creturns\u003e\u003c/returns\u003e public int Radix() { return R; } /// \u003csummary\u003e /// 表示一个索引所需的位数 /// \u003c/summary\u003e /// \u003creturns\u003e\u003c/returns\u003e public int LgR() { int lgR = 0; for (int t = R - 1; t \u003e= 1; t /= 2) lgR++; return lgR; } /// \u003csummary\u003e /// 获取c的索引，在0-(R-1)之间 /// \u003c/summary\u003e /// \u003cparam name=\"c\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public int ToIndex(char c) { if (c \u003e= inverse.Length || inverse[c] == -1) { throw new ArgumentException(\"Character \" + c + \" not in alphabet\"); } return inverse[c]; } /// \u003csummary\u003e /// 将S转化为R进制的整数.返回基字母的序号 /// \u003c/summary\u003e /// \u003cpara","date":"2021-04-26","objectID":"/2021/04/algorithm10/:1:0","tags":["算法","字符串排序"],"title":"算法 字符串排序","uri":"/2021/04/algorithm10/"},{"categories":"算法","content":"字符串排序\r第一类方法会从右到左检查键中的字符。这种方法一般被称为低位优先(LSD ) 的字符串排序。使用数字(digit) 代替字符(character ) 的原因要追溯到相同方法在各种数字类型中的应用。 第二类方法会从左到右检查键中的字符，首先查看的是最高位的字符。这些方法通常称为高位优先(MSD) 的字符串排序。高位优先的字符串排序的吸引人之处在于，它们不一定需要检查所有的输入就能够完成排序。高位优先的字符串排序和快速排序类似，因为它们都会将需要排序的数组切分为独立的部分并递归地用相同的方法处理子数组来完成排序。 ","date":"2021-04-26","objectID":"/2021/04/algorithm10/:2:0","tags":["算法","字符串排序"],"title":"算法 字符串排序","uri":"/2021/04/algorithm10/"},{"categories":"算法","content":"键索引计数法\r假设数组a [] 中的每个元素都保存了一个名字和一个组号，其中组号在0 到R -1 之间， 代码a[i].key () 会返回指定学生的组号。 频率统计和频率转化成索引\r使用int 数组count [] 计算每个键出现的频率，对于数组a[]中的每个元素，都使用它的键访问count[] 中的相应元素并将其加1 。如果键为r , 则将count[r+1] 加1 。首先将count[3] 加1 , 因为Anderson 在第二组中，然后会将count[4] 加2, 因为Brown 和Davis 都在第三组中. 数据分类和回写\r将所有元素（学生）移动到一个辅助数组aux[]中以进行排序。每个元素在aux[] 中的位置是由它的键（组别）对应的count[] 值决定，在移动之后将count[] 中对应元素的值加1 , 以保证count[r] 总是下一个键为r 的元素在aux[] 中的索引位置。这个过程只需遍历一遍数据即可产生排序结果， 回写就是将aux[]写到源数组a[] 键索引计数法排序N个键为0到R-1之间的整数的元素需要访问数组11N+ 4R+ 1 次。 ","date":"2021-04-26","objectID":"/2021/04/algorithm10/:2:1","tags":["算法","字符串排序"],"title":"算法 字符串排序","uri":"/2021/04/algorithm10/"},{"categories":"算法","content":"低位优先字符串排序\r如果字符串的长度均为W, ==那就从右向左以每个位置的字符作为键==，用键索引计数法将字符串排序W 遍。 低位优先的字符串排序算法能够稳定地将定长字符串排序。 低位优先的字符串排序的意义重大，因为它是一种适用于一般应用的线性时间排序算法。无论N 有多大，它都只遍历W 次数据。 public class LSD { private static readonly int BITS_PER_BYTE = 8; private LSD() { } /// \u003csummary\u003e /// 根据前w个字符进行排序 /// \u003c/summary\u003e /// \u003cparam name=\"a\"\u003e\u003c/param\u003e /// \u003cparam name=\"w\"\u003e\u003c/param\u003e public static void Sort(string[] a, int w) { int n = a.Length; int R = 256; // extend ASCII alphabet size string[] aux = new string[n]; for (int d = w - 1; d \u003e= 0; d--) { //根据d个字符用键索引计数法排序 // 计算出现频率 int[] count = new int[R + 1]; for (int i = 0; i \u003c n; i++) count[a[i][d] + 1]++; // 将频率转化成索引 for (int r = 0; r \u003c R; r++) count[r + 1] += count[r]; // 将元素分类 for (int i = 0; i \u003c n; i++) aux[count[a[i][d]]++] = a[i]; // 回写 for (int i = 0; i \u003c n; i++) a[i] = aux[i]; } } /// \u003csummary\u003e /// 以升序重新排列32位整数数组。 /// 这比Arrays.sort（）快2-3倍。 /// \u003c/summary\u003e /// \u003cparam name=\"a\"\u003e\u003c/param\u003e public static void Sort(int[] a) { int BITS = 32; // each int is 32 bits int R = 1 \u003c\u003c BITS_PER_BYTE; // each bytes is between 0 and 255 int MASK = R - 1; // 0xFF int w = BITS / BITS_PER_BYTE; // each int is 4 bytes int n = a.Length; int[] aux = new int[n]; for (int d = 0; d \u003c w; d++) { // 计算出现频率 int[] count = new int[R + 1]; for (int i = 0; i \u003c n; i++) { int c = (a[i] \u003e\u003e BITS_PER_BYTE * d) \u0026 MASK; count[c + 1]++; } // 将频率转化成索引 for (int r = 0; r \u003c R; r++) count[r + 1] += count[r]; // for most significant byte, 0x80-0xFF comes before 0x00-0x7F //对于最高有效字节，0x80-0xFF位于0x00-0x7F之前 if (d == w - 1) { int shift1 = count[R] - count[R / 2]; int shift2 = count[R / 2]; for (int r = 0; r \u003c R / 2; r++) count[r] += shift1; for (int r = R / 2; r \u003c R; r++) count[r] -= shift2; } //分类 for (int i = 0; i \u003c n; i++) { int c = (a[i] \u003e\u003e BITS_PER_BYTE * d) \u0026 MASK; aux[count[c]++] = a[i]; } // 回写 for (int i = 0; i \u003c n; i++) a[i] = aux[i]; } } } 测试 [TestMethod] public void LSDFixture() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\words3.txt\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { List\u003cstring\u003e lines=new List\u003cstring\u003e(); while (!stream.EndOfStream) { lines.Add(stream.ReadLine().Trim()); } var a = lines.ToArray(); int n = a.Length; // 检查固定长度 int w = a[0].Length; for (int i = 0; i \u003c n; i++) { if (a[i].Length != w) { throw new ArgumentException($\"{a[i]} length is error\"); } } // sort the strings LSD.Sort(a, w); // print results for (int i = 0; i \u003c n; i++) Console.WriteLine(a[i]); } } ","date":"2021-04-26","objectID":"/2021/04/algorithm10/:2:2","tags":["算法","字符串排序"],"title":"算法 字符串排序","uri":"/2021/04/algorithm10/"},{"categories":"算法","content":"高位优先的字符串排序\r从左向右遍历所有字符。我们知道，以a 开头的字符串应该排在以b 开头的字符串前面实现这种思想的一个很自然方法就是一种递归算法，被称为高位优先(MSD) 的字符串排序， 高位优先的字符串排序会将数组切分为能够独立排序的子数组来完成排序任务，但它的切分会为每个首字母得到一个子数组， 使用了一个接受两个参数的私有方法toChar()来将字符串中字符索引转化为数组索引，当指定的位置超过了字符串的末尾时该方法返回-1 。然后将所有返回值加1 , 得到一个非负的int 值并用 它作为count[] 的索引。这种转换意味着字符串中的每个字符都可能产生R+1 中不同的值： 0 表示字符串的结尾， 1 表示字母表 的第一个字符， 2 表示字母表的第二个字符，等等，int count[] = new int[R+2]; 创建记录统计频率的数组（将所有值设为0) 。 高位优先的字符串排序的成本与字母表中的字符数量有很大关系。我们可以很容易地令排序算法修接受一个Alphabet 对象作为参数，以改进基于较小的字母表的字符串排序程序的性能。完成这一点需要进行如下改动： 在构造函数中用一个 alpha 对象保存字母表 ； 在构造函数中将R 设为alpha.R(); 在charAt() 方法中将s.charAt(d) 替换为alpha.tolndex(s.charAt(d)) 。 public class MSD { private static readonly int BITS_PER_BYTE = 8; private static readonly int BITS_PER_INT = 32; /// \u003csummary\u003e /// extended ASCII alphabet size /// 基数 /// \u003c/summary\u003e private static readonly int R = 256; /// \u003csummary\u003e /// cutoff to insertion sort /// 小数组切换的阈值 /// \u003c/summary\u003e private static readonly int CUTOFF = 15; private MSD() { } /// \u003csummary\u003e /// Rearranges the array of extended ASCII strings in ascending order. /// \u003c/summary\u003e /// \u003cparam name=\"a\"\u003e\u003c/param\u003e public static void Sort(string[] a) { int n = a.Length; string[] aux = new string[n]; Sort(a, 0, n - 1, 0, aux); } /// \u003csummary\u003e /// return dth character of s, -1 if d = length of string /// \u003c/summary\u003e /// \u003cparam name=\"s\"\u003e\u003c/param\u003e /// \u003cparam name=\"d\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e private static int CharAt(string s, int d) { if(d \u003e= 0 \u0026\u0026 d \u003c= s.Length) { throw new ArgumentException(\"d and s is not match\"); } if (d == s.Length) return -1; return s[d]; } /// \u003csummary\u003e /// sort from a[lo] to a[hi], starting at the dth character /// \u003c/summary\u003e /// \u003cparam name=\"a\"\u003e\u003c/param\u003e /// \u003cparam name=\"lo\"\u003e\u003c/param\u003e /// \u003cparam name=\"hi\"\u003e\u003c/param\u003e /// \u003cparam name=\"d\"\u003e\u003c/param\u003e /// \u003cparam name=\"aux\"\u003e\u003c/param\u003e private static void Sort(string[] a, int lo, int hi, int d, String[] aux) { //以第d 个字符为键,将a[lo] 至a[hi] 排序 // cutoff to insertion sort for small subarrays // 小数组切换插入排序 if (hi \u003c= lo + CUTOFF) { Insertion(a, lo, hi, d); return; } // compute frequency counts //计算频率 int[] count = new int[R + 2]; for (int i = lo; i \u003c= hi; i++) { int c = CharAt(a[i], d); count[c + 2]++; } // transform counts to indicies // 转化成索引 for (int r = 0; r \u003c R + 1; r++) count[r + 1] += count[r]; // distribute //分类 for (int i = lo; i \u003c= hi; i++) { int c = CharAt(a[i], d); aux[count[c + 1]++] = a[i]; } // copy back for (int i = lo; i \u003c= hi; i++) a[i] = aux[i - lo]; // recursively sort for each character (excludes sentinel -1) //递归的以每个字符为键进行排序 for (int r = 0; r \u003c R; r++) Sort(a, lo + count[r], lo + count[r + 1] - 1, d + 1, aux); } /// \u003csummary\u003e /// insertion sort a[lo..hi], starting at dth character /// \u003c/summary\u003e /// \u003cparam name=\"a\"\u003e\u003c/param\u003e /// \u003cparam name=\"lo\"\u003e\u003c/param\u003e /// \u003cparam name=\"hi\"\u003e\u003c/param\u003e /// \u003cparam name=\"d\"\u003e\u003c/param\u003e private static void Insertion(String[] a, int lo, int hi, int d) { for (int i = lo; i \u003c= hi; i++) for (int j = i; j \u003e lo \u0026\u0026 Less(a[j], a[j - 1], d); j--) Exch(a, j, j - 1); } /// \u003csummary\u003e /// exchange a[i] and a[j] /// \u003c/summary\u003e /// \u003cparam name=\"a\"\u003e\u003c/param\u003e /// \u003cparam name=\"i\"\u003e\u003c/param\u003e /// \u003cparam name=\"j\"\u003e\u003c/param\u003e private static void Exch(String[] a, int i, int j) { String temp = a[i]; a[i] = a[j]; a[j] = temp; } /// \u003csummary\u003e /// is v less than w, starting at character d /// \u003c/summary\u003e /// \u003cparam name=\"v\"\u003e\u003c/param\u003e /// \u003cparam name=\"w\"\u003e\u003c/param\u003e /// \u003cparam name=\"d\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e private static bool Less(String v, String w, int d) { // assert v.substring(0, d).equals(w.substring(0, d)); for (int i = d; i \u003c Math.Min(v.Length, w.Length); i++) { if (v[i] \u003c w[i]) return true; if (v[i] \u003e w[i]) return false; } return v.Length \u003c w.Length; } /// \u003csummary\u003e /// Rearranges the array of 32-bit integers in ascending order. /// Currently assumes that the integers are nonnegative. /// \u003c/summary\u003e /// \u003cparam name=\"a\"\u003e\u003c/param\u003e public static void Sort(int[] a) { int n = a.Length; int[] aux = new int[n]; Sort(a, 0, n - 1, 0, aux); } /// \u003csummary\u003e /// MSD sort from a[lo] to a[hi], starting at the dth byte","date":"2021-04-26","objectID":"/2021/04/algorithm10/:2:3","tags":["算法","字符串排序"],"title":"算法 字符串排序","uri":"/2021/04/algorithm10/"},{"categories":"算法","content":"三向字符串快速排序\r根据高位优先的字符串排序算法改进快速排序，根据键的首字母进行三向切分，仅在中间千数组中的下一个字符 三向字符串快速排序根据的仍然是键的首字母并使用递归方法将其余部分的键排序。对于字符串的排序，这个方法比普通的快速排序和高位优先的字符串排序更友好。实际上，它就是这两种算法的结合。 在将字符串数组a[] 排序时， 根据它们的首字母进行三向切分，然后（递归地）将得到的三个子数组排序： 一个含有所有首字母小于切分字符的字符串子数组，一个含有所有首字母等于切分字符的字符串的子数组（排序时忽略它们的首字母）， 一个含有所有首字母大于切分字符的字符串的子数组。 随机化\r和快速排序一样，最好在排序之前将数组打乱或是将第一个元素和一个随机位置的元素交换以得到一个随机的切分元素。 性能\r要将含有N个随机字符串的数组排序，三向字符串快速排序平均需要比较字符～2NInN次。 假设你架设了一个网站并希望分析它产生的流量． 。你可以从系统管理员那里得到网站的所有活动，每项活动的信息中都含有发起者的域名 public class Quick3string { private static readonly int CUTOFF = 15; private Quick3string() { } public static void Sort(string[] a) { UtilGuard.Shuffle(a); Sort(a, 0, a.Length - 1, 0); if (!IsSorted(a)) { throw new ArgumentException(\"list is not sorted\"); } ; } private static int CharAt(string s, int d) { if (d \u003c 0 \u0026\u0026 d \u003e s.Length) { throw new ArgumentException(\"\"); }; if (d == s.Length) return -1; return s[d]; } private static void Sort(String[] a, int lo, int hi, int d) { // cutoff to insertion sort for small subarrays if (hi \u003c= lo + CUTOFF) { Insertion(a, lo, hi, d); return; } int lt = lo, gt = hi; int v = CharAt(a[lo], d); int i = lo + 1; while (i \u003c= gt) { int t = CharAt(a[i], d); if (t \u003c v) Exch(a, lt++, i++); else if (t \u003e v) Exch(a, i, gt--); else i++; } // a[lo..lt-1] \u003c v = a[lt..gt] \u003c a[gt+1..hi]. Sort(a, lo, lt - 1, d); if (v \u003e= 0) Sort(a, lt, gt, d + 1); Sort(a, gt + 1, hi, d); } private static void Insertion(String[] a, int lo, int hi, int d) { for (int i = lo; i \u003c= hi; i++) for (int j = i; j \u003e lo \u0026\u0026 Less(a[j], a[j - 1], d); j--) Exch(a, j, j - 1); } private static void Exch(String[] a, int i, int j) { String temp = a[i]; a[i] = a[j]; a[j] = temp; } private static bool Less(String v, String w, int d) { if( !v.Substring(0, d).Equals(w.Substring(0, d))) throw new ArgumentException($\"{v}; {w}\"); for (int i = d; i \u003c Math.Min(v.Length, w.Length); i++) { if (v[i] \u003c w[i]) return true; if (v[i] \u003e w[i]) return false; } return v.Length\u003c w.Length; } private static bool IsSorted(String[] a) { for (int i = 1; i \u003c a.Length; i++) if (a[i].CompareTo(a[i - 1]) \u003c 0) return false; return true; } } 测试 [TestMethod] public void Quick3StringFixture() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\shells.txt\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { List\u003cstring\u003e lines = new List\u003cstring\u003e(); while (!stream.EndOfStream) { lines.AddRange(stream.ReadLine().Trim().Split(' ')); } var a = lines.ToArray(); int n = a.Length; CodeTimer.Time(\"Quick3String sort:\", 1, () =\u003e { // sort the strings Quick3string.Sort(a); }); // print results for (int i = 0; i \u003c n; i++) Console.WriteLine(a[i]); } //Quick3String sort: // Time Elapsed: 3ms // Time Elapsed (one time):3ms // CPU time: 0ns // CPU time (one time): 0ns // Gen 0: 0 // Gen 1: 0 // Gen 2: 0 } ","date":"2021-04-26","objectID":"/2021/04/algorithm10/:2:4","tags":["算法","字符串排序"],"title":"算法 字符串排序","uri":"/2021/04/algorithm10/"},{"categories":"算法","content":"字符串排序算法的选择\r","date":"2021-04-26","objectID":"/2021/04/algorithm10/:2:5","tags":["算法","字符串排序"],"title":"算法 字符串排序","uri":"/2021/04/algorithm10/"},{"categories":"算法","content":"加权有向图\r找到从一个顶点到达另一个顶点的成本最小的路径。 在一幅加权有向图中，从顶点s 到顶点t 的最短路径是所有从s 到t 的路径中的权重最小者。 最短路径性质 路径是有向的， 权重不一定等价于距离 并不是所有顶点都是可达的 负权重会使问题更复杂 最短路径不一定是唯一的。 可能存在平行边和自环。 我们的重点是单点最短路径问题，其中给出了起点s , 计算的结果是一棵最短路径树(SPT), 它包含了顶点s 到所有可达的顶点的最短路径。如图所示。 定义：给定一幅加权有向图和一个顶点s , 以s 为起点的一棵最短路径树是图的一幅子图，它包含s和从s 可达的所有顶点。这棵有向树的根结点为s,树的每条路径都是有向图中的一条最短路径。 ","date":"2021-04-23","objectID":"/2021/04/algorithm9/:1:0","tags":["算法","加权有向图"],"title":"算法 加权有向图","uri":"/2021/04/algorithm9/"},{"categories":"算法","content":"加权有向图的数据结构\redgeTo[v]:最短路径树中的边，连接v和它父节点的边， distTo[v] :到达起点的距离, 为从s 到v的已知最短路径的长度。该路径上的所有顶点均在树中且路径上的最后一条边为edgeTo[v] using SuddenGale.AlgorithmEngine.Structure; using System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Text; namespace SuddenGale.AlgorithmEngine.Graph { public class DirectedEdge:IComparable\u003cDirectedEdge\u003e { private readonly int v;//边的起点 private readonly int w;//边的终点 private readonly double weight;//边的权重 public DirectedEdge(int v, int w, double weight) { if (v \u003c 0) throw new ArgumentException(\"Vertex names must be nonnegative integers\"); if (w \u003c 0) throw new ArgumentException(\"Vertex names must be nonnegative integers\"); if (Double.IsNaN(weight)) throw new ArgumentException(\"Weight is NaN\"); this.v = v; this.w = w; this.weight = weight; } public int From() { return v; } public int To() { return w; } public double Weight() { return weight; } public override string ToString() { return $\"{v}-\u003e{w} {weight:F2}\"; } public int CompareTo(DirectedEdge other) { return this.weight.CompareTo(other.Weight()); } } public class EdgeWeightedDigraph { private static readonly String NEWLINE = System.Environment.NewLine; private readonly int V; // 顶点总数 private int E; // 边的总数 private LinkedBagNet\u003cDirectedEdge\u003e[] adj; // 顶点index的临接表 private int[] indegree; // vertex 的度 public EdgeWeightedDigraph(int V) { if (V \u003c 0) throw new ArgumentException(\"Number of vertices in a Digraph must be nonnegative\"); this.V = V; this.E = 0; this.indegree = new int[V]; adj = new LinkedBagNet\u003cDirectedEdge\u003e[V]; for (int v = 0; v \u003c V; v++) adj[v] = new LinkedBagNet\u003cDirectedEdge\u003e(); } public EdgeWeightedDigraph(int V, int E):this(V) { if (E \u003c 0) throw new ArgumentException(\"Number of edges in a Digraph must be nonnegative\"); Random random = new Random(); for (int i = 0; i \u003c E; i++) { int v = random.Next(V); int w = random.Next(V); double weight = Math.Round(100 * random.NextDouble()) / 100.0; DirectedEdge e = new DirectedEdge(v, w, weight); AddEdge(e); } } public EdgeWeightedDigraph(StreamReader stream) { if (stream == null) throw new ArgumentNullException(\"argument is null\"); try { this.V = int.Parse(stream.ReadLine()); if (V \u003c 0) throw new ArgumentException(\"number of vertices in a Digraph must be nonnegative\"); indegree = new int[V]; adj = new LinkedBagNet\u003cDirectedEdge\u003e[V]; for (int v = 0; v \u003c V; v++) { adj[v] = new LinkedBagNet\u003cDirectedEdge\u003e(); } int E = int.Parse(stream.ReadLine()); if (E \u003c 0) throw new ArgumentException(\"Number of edges must be nonnegative\"); for (int i = 0; i \u003c E; i++) { string line = stream.ReadLine().Trim(); if (!string.IsNullOrEmpty(line) \u0026\u0026 line.Split(' ').Count() == 3) { int v = int.Parse(line.Split(' ')[0]); int w = int.Parse(line.Split(' ')[1]); double weight = double.Parse(line.Split(' ')[2]); AddEdge(new DirectedEdge(v, w, weight)); } } } catch (Exception e) { throw new ArgumentException(\"invalid input format in EdgeWeightedDigraph constructor\", e); } } public EdgeWeightedDigraph(EdgeWeightedDigraph G): this(G.V) { this.E = G.Edge(); for (int v = 0; v \u003c G.V; v++) this.indegree[v] = G.Indegree(v); for (int v = 0; v \u003c G.V; v++) { // reverse so that adjacency list is in same order as original Stack\u003cDirectedEdge\u003e reverse = new Stack\u003cDirectedEdge\u003e(); foreach (DirectedEdge e in G.adj[v]) { reverse.Push(e); } foreach (DirectedEdge e in reverse) { adj[v].Add(e); } } } public int Vertic() { return V; } public int Edge() { return E; } // throw an IllegalArgumentException unless {@code 0 \u003c= v \u003c V} private void validateVertex(int v) { if (v \u003c 0 || v \u003e= V) throw new ArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1)); } public void AddEdge(DirectedEdge e) { int v = e.From(); int w = e.To(); validateVertex(v); validateVertex(w); adj[v].Add(e); indegree[w]++; E++; } public IEnumerable\u003cDirectedEdge\u003e Adj(int v) { validateVertex(v); return adj[v]; } public int Outdegree(int v) { validateVertex(v); return adj[v].Length; } public int Indegree(int v) { validateVertex(v); return indegree[v]; } p","date":"2021-04-23","objectID":"/2021/04/algorithm9/:1:1","tags":["算法","加权有向图"],"title":"算法 加权有向图","uri":"/2021/04/algorithm9/"},{"categories":"算法","content":"Dijkstra算法\r寻找加权无向图中的最小生成树的Prim 算法：构造最小生成树的每一步都向这棵树中添加一条新的边。Dijkstra 算法采用了类似的方法来计算最短路径树。首先将distTo[s]初始化为0, distTo[] 中的其他元素初始化为正无穷。==然后将distTo [] 最小的非树顶点放松并加入树中，如此这般，直到所有的顶点都在树中或者所有的非树顶点的distTo[]值均为无穷大。== Prim 算法每次添加的都是离树最近的非树顶点， Dijkstra算法每次添加的都是离起点最近的非树顶点。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using SuddenGale.AlgorithmEngine.Structure; namespace SuddenGale.AlgorithmEngine.Graph { public class DijkstraSP { private double[] distTo; // distTo[v] = distance of shortest s-\u003ev path，最小树的长度 private DirectedEdge[] edgeTo; // edgeTo[v] = last edge on shortest s-\u003ev path,最小树中的边 private IndexMinPQ\u003cDouble\u003e pq; //顶点优先队列，保存需要放松的下一个顶点，所有添加进最小树的边的To，每次放松最小值 public DijkstraSP(EdgeWeightedDigraph G, int s) { foreach (DirectedEdge e in G.Edges()) { if (e.Weight() \u003c 0) throw new ArgumentException(\"edge \" + e + \" has negative weight\"); } distTo = new double[G.Vertic()]; edgeTo = new DirectedEdge[G.Vertic()]; ValidateVertex(s); for (int v = 0; v \u003c G.Vertic(); v++) distTo[v] = Double.PositiveInfinity; distTo[s] = 0.0; // relax vertices in order of distance from s pq = new IndexMinPQ\u003cDouble\u003e(G.Vertic()); pq.Insert(s, distTo[s]); while (!pq.IsEmpty()) { int v = pq.DelMin(); foreach (DirectedEdge e in G.Adj(v)) Relax(e); } // check optimality conditions if(!Check(G, s)) throw new Exception(\"Check return false\"); } // relax edge e and update pq if changed private void Relax(DirectedEdge e) { int v = e.From(), w = e.To(); if (distTo[w] \u003e distTo[v] + e.Weight()) { distTo[w] = distTo[v] + e.Weight();//更新最小树的长度 edgeTo[w] = e;//更新最小树 if (pq.Contains(w)) pq.DecreaseKey(w, distTo[w]); else pq.Insert(w, distTo[w]); } } public double DistTo(int v) { ValidateVertex(v); return distTo[v]; } public bool HasPathTo(int v) { ValidateVertex(v); return distTo[v] \u003c Double.PositiveInfinity; } public IEnumerable\u003cDirectedEdge\u003e PathTo(int v) { ValidateVertex(v); if (!HasPathTo(v)) return null; Stack\u003cDirectedEdge\u003e path = new Stack\u003cDirectedEdge\u003e(); for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.From()]) { path.Push(e); } return path; } private bool Check(EdgeWeightedDigraph G, int s) { // check that edge weights are nonnegative foreach (DirectedEdge e in G.Edges()) { if (e.Weight() \u003c 0) { Console.WriteLine(\"negative edge weight detected\"); return false; } } // check that distTo[v] and edgeTo[v] are consistent if (distTo[s] != 0.0 || edgeTo[s] != null) { Console.WriteLine(\"distTo[s] and edgeTo[s] inconsistent\"); return false; } for (int v = 0; v \u003c G.Vertic(); v++) { if (v == s) continue; if (edgeTo[v] == null \u0026\u0026 distTo[v] != Double.PositiveInfinity) { Console.WriteLine(\"distTo[] and edgeTo[] inconsistent\"); return false; } } // check that all edges e = v-\u003ew satisfy distTo[w] \u003c= distTo[v] + e.weight() for (int v = 0; v \u003c G.Vertic(); v++) { foreach (DirectedEdge e in G.Adj(v)) { int w = e.To(); if (distTo[v] + e.Weight() \u003c distTo[w]) { Console.WriteLine(\"edge \" + e + \" not relaxed\"); return false; } } } // check that all edges e = v-\u003ew on SPT satisfy distTo[w] == distTo[v] + e.weight() for (int w = 0; w \u003c G.Vertic(); w++) { if (edgeTo[w] == null) continue; DirectedEdge e = edgeTo[w]; int v = e.From(); if (w != e.To()) return false; if (distTo[v] + e.Weight() != distTo[w]) { Console.WriteLine(\"edge \" + e + \" on shortest path not tight\"); return false; } } return true; } private void ValidateVertex(int v) { int V = distTo.Length; if (v \u003c 0 || v \u003e= V) throw new ArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1)); } } } 测试 [TestMethod()] public void DijkstraSPTest() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\tinyEWG.txt\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { AlgorithmEngine.Graph.EdgeWeightedDigraph G = new AlgorithmEngine.Graph.EdgeWeightedDigraph(stream); int s = 0; DijkstraSP sp = new DijkstraSP(G, s); //打印最短路径 for (int t = 0; t \u003c G.Vertic(); t++) { if (sp.HasPathTo(t)) { Console.Write($\"{s} to {t} {sp.DistT","date":"2021-04-23","objectID":"/2021/04/algorithm9/:1:2","tags":["算法","加权有向图"],"title":"算法 加权有向图","uri":"/2021/04/algorithm9/"},{"categories":"算法","content":"任意两点的最短路径\rpublic class DijkstraAllPairsSP { private DijkstraSP[] all; public DijkstraAllPairsSP(EdgeWeightedDigraph G) { all = new DijkstraSP[G.Vertic()]; for (int v = 0; v \u003c G.Vertic(); v++) all[v] = new DijkstraSP(G, v); } public IEnumerable\u003cDirectedEdge\u003e Path(int s, int t) { ValidateVertex(s); ValidateVertex(t); return all[s].PathTo(t); } public bool HasPath(int s, int t) { ValidateVertex(s); ValidateVertex(t); return Dist(s, t) \u003c Double.PositiveInfinity; } public double Dist(int s, int t) { ValidateVertex(s); ValidateVertex(t); return all[s].DistTo(t); } // throw an IllegalArgumentException unless {@code 0 \u003c= v \u003c V} private void ValidateVertex(int v) { int V = all.Length; if (v \u003c 0 || v \u003e= V) throw new ArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1)); } } 测试 [TestMethod()] public void DijkstraAllPairsSPTest() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\tinyEWD.txt\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { AlgorithmEngine.Graph.EdgeWeightedDigraph G = new AlgorithmEngine.Graph.EdgeWeightedDigraph(stream); DijkstraAllPairsSP spt = new DijkstraAllPairsSP(G); for (int v = 0; v \u003c G.Vertic(); v++) { Console.WriteLine($\"{v}\"); } for (int v = 0; v \u003c G.Vertic(); v++) { Console.Write($\"{v}: \"); for (int w = 0; w \u003c G.Vertic(); w++) { if (spt.HasPath(v, w)) Console.Write($\"{spt.Dist(v, w)} \"); else Console.Write(\" Inf \"); } Console.WriteLine(); } Console.WriteLine(); // print all-pairs shortest paths for (int v = 0; v \u003c G.Vertic(); v++) { for (int w = 0; w \u003c G.Vertic(); w++) { if (spt.HasPath(v, w)) { Console.Write($\"{v} to {w} {spt.Dist(v, w)} \"); foreach (DirectedEdge e in spt.Path(v, w)) Console.Write(e + \" \"); Console.WriteLine(); } else { Console.WriteLine($\"{v} to {w} no path\", v, w); } } } } } } ","date":"2021-04-23","objectID":"/2021/04/algorithm9/:1:3","tags":["算法","加权有向图"],"title":"算法 加权有向图","uri":"/2021/04/algorithm9/"},{"categories":"算法","content":"无环加权有向图的最短路径\r该算法的特点 能够在线性事件内解决单点的最短路径问题 能够处理负权重的边 能够解决相关的问题。例如找到最长的路径。 首先，将distTo[s] 初始化为0, 其他distTo[] 元素初始化为无穷大，然后一个一个地按照==拓扑顺序==放松所有顶点。 按照拓扑顺序放松顶点，就能在和E+V 成正比的时间内解决无环加权有向图的单点最短路径问题。 在拓扑排序后，构造函数会扫描整幅图并将每条边放松一次。==在已知加权图是无环的情况下，它是找出最短路径的最好方法。== using System; using System.Collections.Generic; namespace SuddenGale.AlgorithmEngine.Graph { public class AcyclicSP { private double[] distTo; // distTo[v] = distance of shortest s-\u003ev path private DirectedEdge[] edgeTo; // edgeTo[v] = last edge on shortest s-\u003ev path public AcyclicSP(EdgeWeightedDigraph G, int s) { distTo = new double[G.Vertic()]; edgeTo = new DirectedEdge[G.Vertic()]; ValidateVertex(s); for (int v = 0; v \u003c G.Vertic(); v++) distTo[v] = Double.PositiveInfinity; distTo[s] = 0.0; // 拓扑排序 Topological topological = new Topological(G); if (!topological.HasOrder()) throw new ArgumentException(\"Digraph is not acyclic.\"); foreach (int v in topological.Order()) { foreach (DirectedEdge e in G.Adj(v)) Relax(e); } } // relax edge e private void Relax(DirectedEdge e) { int v = e.From(), w = e.To(); if (distTo[w] \u003e distTo[v] + e.Weight()) { distTo[w] = distTo[v] + e.Weight(); edgeTo[w] = e; } } public double DistTo(int v) { ValidateVertex(v); return distTo[v]; } public bool HasPathTo(int v) { ValidateVertex(v); return distTo[v] \u003c Double.PositiveInfinity; } public IEnumerable\u003cDirectedEdge\u003e PathTo(int v) { ValidateVertex(v); if (!HasPathTo(v)) return null; Stack\u003cDirectedEdge\u003e path = new Stack\u003cDirectedEdge\u003e(); for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.From()]) { path.Push(e); } return path; } private void ValidateVertex(int v) { int V = distTo.Length; if (v \u003c 0 || v \u003e= V) throw new ArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1)); } } } 测试 public void AcyclicSPTest() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\tinyEWDAG.txt\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { AlgorithmEngine.Graph.EdgeWeightedDigraph G = new AlgorithmEngine.Graph.EdgeWeightedDigraph(stream); int s = 5; AcyclicSP sp = new AcyclicSP(G, s); for (int v = 0; v \u003c G.Vertic(); v++) { if (sp.HasPathTo(v)) { Console.Write($\"{s} to {v} ({sp.DistTo(v)}) \"); foreach (DirectedEdge e in sp.PathTo(v)) { Console.Write(e + \" \"); } Console.WriteLine(); } else { Console.WriteLine($\"{s} to {v} no path.\"); } } } // 5 to 0 (0.73) 5-\u003e4 0.35 4-\u003e0 0.38 // 5 to 1 (0.32) 5-\u003e1 0.32 // 5 to 2 (0.62) 5-\u003e7 0.28 7-\u003e2 0.34 // 5 to 3 (0.61) 5-\u003e1 0.32 1-\u003e3 0.29 // 5 to 4 (0.35) 5-\u003e4 0.35 // 5 to 5 (0) // 5 to 6 (1.13) 5-\u003e1 0.32 1-\u003e3 0.29 3-\u003e6 0.52 // 5 to 7 (0.28) 5-\u003e7 0.28 } 基于拓扑排序的方法比Dijkstra 算法快的倍数与Dijkstra 算法中所有优先队列操作的总成本成正比。 最长路径\rusing System; using System.Collections.Generic; namespace SuddenGale.AlgorithmEngine.Graph { /// \u003csummary\u003e /// 无环权重有向图的最长路径 /// \u003c/summary\u003e public class AcyclicLP { private double[] distTo; // distTo[v] = distance of longest s-\u003ev path private DirectedEdge[] edgeTo; // edgeTo[v] = last edge on longest s-\u003ev path public AcyclicLP(EdgeWeightedDigraph G, int s) { distTo = new double[G.Vertic()]; edgeTo = new DirectedEdge[G.Vertic()]; ValidateVertex(s); for (int v = 0; v \u003c G.Vertic(); v++) distTo[v] = Double.NegativeInfinity; distTo[s] = 0.0; // relax vertices in topological order Topological topological = new Topological(G); if (!topological.HasOrder()) throw new ArgumentException(\"Digraph is not acyclic.\"); foreach (int v in topological.Order()) { foreach (DirectedEdge e in G.Adj(v)) Relax(e); } } // relax edge e, but update if you find a *longer* path private void Relax(DirectedEdge e) { int v = e.From(), w = e.To(); if (distTo[w] \u003c distTo[v] + e.Weight()) { distTo[w] = distTo[v] + e.Weight(); edgeTo[w] = e; } } public double DistTo(int v) { ValidateVertex(v); return distTo[v]; } public bool HasPathTo(int v) { ValidateVertex(v); return distTo[v] \u003e Double.NegativeInfinity; } public IEnumerable\u003cDirectedEdge\u003e PathTo(int v) { ValidateVertex(v); if (!HasPathTo(v)) return null; Stack\u003cDirectedEdge\u003e path = new Stack\u003cDirectedEdge\u003e(","date":"2021-04-23","objectID":"/2021/04/algorithm9/:1:4","tags":["算法","加权有向图"],"title":"算法 加权有向图","uri":"/2021/04/algorithm9/"},{"categories":"算法","content":"负权重加权有向图的最短路径\r也许最明显的改变就是当存在负权重的边时，权重较小的路径含有的边可能会比权重较大的路径更多。在只存在正权重的边时，我们的重点在于寻找近路；但当存在负权重的边时，我们可能会为了经过负权重的边而绕弯。这种效应使得我们要将查找“最短“路径的感觉转变为对算法本质的理解。 中间探究过程不说了，直接说结论 负权重环：加权有向图中的负权重环是一个总权重（环上的所有边的权重之和）为负的有向环。 ==假设从s 到可达的某个顶点v 的路径上的某个顶点在一个负权重环上。在这种情况下，从s 到v 的最短路径是不可能存在的，因为可以用这个负权重环构造权重任意小的路径。==换句话说，在负权重环存在的情况下，最短路径问题是没有意义的 4，7，5，4，7，5不停兜圈子最短路径就会不停减少。所以最短路径失去了意义。 要求最短路径上的任意顶点都不存在负权重环意味着最短路径是简单的，而且与正权重边的图一样都能够得到此类顶点的最短路径树。 之前算法都是限制的。1：不允许负权重环的存在。2：不接受有向环。 基于队列的Bellman-Ford 算法\r只有上一轮中的distTo[]值发生变化的顶点指出的边才能够改变其他distTo[] 元素的值。为了记录这样的顶点， 我们使用了一条FIFO 队列首先将起点加入队列，然后按照以下步骤计算最短路径树。 Bellman-Ford 算法基于以下两种其他的数据结构： 一条用来保存即将被放松的顶点的队列q ; 一个由顶点索引的boolean 数组onQ[] , 用来指示顶点是否已经存在于队列中， 顶点重复插入队列。 在某一轮中，改变了edgeTo[] 和distTo [] 的值的所有顶点都会在下一轮中处理。 负权重的边\r放松边0→2 和0→4 并将顶点2 、4 加入队列。 放松边2→7 并将顶点7 加入队列。放松边4→5 并将顶点5 加入队列。然后放松失效的边 4→7 。 放松边7→3 和5 →1 并将顶点3 和1 加入队列。放松失效的边5 → 4 和5 →7 。 放松边3→6 并将顶点6 加入队列。放松失效的边1→3 。 放松边6→4 并将顶点4 加入队列。这条负权重边使得到顶点4 的路径变短， 因此它的边需要被再次放松（它们在第二轮中已经被放松过） 。从起点到顶点5 和1 的距离巳经失效并会在下一轮中修正。 放松边4 →5 并将顶点5 加入队列。放松失效的边4 →7 。 放松边5→1 并将顶点1 加入队列。放松失效的边5 →4 和5→7 。 放松无效的边1→3 。队列为空。 将所有边放松V 轮之后当且仅当队列非空时有向图中才存在从起点可达的负权重环。 如果是这样， edgeTo [] 数组所表示的子图中必然含有这个负权重环。因此，要实现 negativeCycl e() , 会根据edgeTo[] 中的边构造一幅加权有向图并在该图中检测环。 using System; using System.Collections.Generic; using System.Linq; namespace SuddenGale.AlgorithmEngine.Graph { public class BellmanFordSP { // for floating-point precision issues private static readonly double EPSILON = 1E-14; /// \u003csummary\u003e /// 从起点到某个顶点的路径长度, /// distTo[v] = distance of shortest s-\u003ev path, /// \u003c/summary\u003e private double[] distTo; /// \u003csummary\u003e /// 从起点到某个顶点的最后一条边, /// edgeTo[v] = last edge on shortest s-\u003ev path /// \u003c/summary\u003e private DirectedEdge[] edgeTo; /// \u003csummary\u003e /// onQueue[v] = is v currently on the queue? /// 该顶点是否存在于队列中 /// \u003c/summary\u003e private bool[] onQueue; /// \u003csummary\u003e /// 正在被放松的顶点， /// queue of vertices to relax /// \u003c/summary\u003e private Queue\u003cint\u003e queue; /// \u003csummary\u003e /// relax的调用次数, /// number of calls to relax()， /// \u003c/summary\u003e private int cost; /// \u003csummary\u003e /// edgeTo[]中的是否有负权重环 /// negative cycle (or null if no such cycle) /// \u003c/summary\u003e private IEnumerable\u003cDirectedEdge\u003e cycle; public BellmanFordSP(EdgeWeightedDigraph G, int s) { distTo = new double[G.Vertic()]; edgeTo = new DirectedEdge[G.Vertic()]; onQueue = new bool[G.Vertic()]; for (int v = 0; v \u003c G.Vertic(); v++) distTo[v] = Double.PositiveInfinity; distTo[s] = 0.0; // Bellman-Ford algorithm queue = new Queue\u003cint\u003e(); queue.Enqueue(s); onQueue[s] = true; while (queue.Any() \u0026\u0026 !HasNegativeCycle()) { int v = queue.Dequeue(); onQueue[v] = false; Relax(G, v); } if(!Check(G, s)) throw new ArgumentException(\"check return false \"); } // relax vertex v and put other endpoints on queue if changed private void Relax(EdgeWeightedDigraph G, int v) { foreach (DirectedEdge e in G.Adj(v)) { int w = e.To(); if (distTo[w] \u003e distTo[v] + e.Weight() + EPSILON) { distTo[w] = distTo[v] + e.Weight(); edgeTo[w] = e; if (!onQueue[w])//只有上一轮中发送变化的值才会改变，防止将顶点重复插入队列 { queue.Enqueue(w); onQueue[w] = true; } } if (++cost % G.Vertic() == 0)//负环会造成循环，导致放松的次数一直增加，最总会达到顶点数，这个时候在最小生成树上一定能检测出负环 { FindNegativeCycle(); if (HasNegativeCycle()) return; // found a negative cycle } } } public bool HasNegativeCycle() { return cycle != null; } public IEnumerable\u003cDirectedEdge\u003e NegativeCycle() { return cycle; } // by finding a cycle in predecessor graph private void FindNegativeCycle() { int V = edgeTo.Length; EdgeWeightedDigraph spt = new EdgeWeightedDigraph(V);//在最短路径上肯定存在负环 for (int v = 0; v \u003c V; v++) if (edgeTo[v] != null) spt.AddEdge(edgeTo[v]); EdgeWeightedDirectedCycle finder = new EdgeWeightedDirectedCycle(spt);//所以只在最短路径上寻找环，找到的环一定是负环 cycle = finder.Cycle(); } public double DistTo(int v) { ValidateVertex(v); if (HasNegativeCycle()) throw new ArgumentException(\"Negative cost cycle exists\"); return distTo[v]; } public bool HasPathTo(int v) { ValidateVertex(v); return distTo[v] \u003c Double.PositiveInfinity; } public IEnumerable\u003cDirectedEdge\u003e PathTo(int v) { ValidateVertex(v); if (HasNegativeCycle()) th","date":"2021-04-23","objectID":"/2021/04/algorithm9/:1:5","tags":["算法","加权有向图"],"title":"算法 加权有向图","uri":"/2021/04/algorithm9/"},{"categories":"算法","content":"加权无向图\r最小生成树：一棵含有其所有顶点的无环连通子图，一幅加权无向图的最小生成树(MST)是它的一棵权值(树中所有边的权值之和)最小的生成时。 约定 只考虑连通图 边的权重不一定表示距离 边的权重可能是0或者负数 所有边的权重都各不相同 public class Edge : IComparable\u003cEdge\u003e { private readonly int _v;//顶点总数 private readonly int _w;//边的总数 private readonly double _weight;//邻接表 public Edge(int v, int w, double weight) { if (v \u003c 0) throw new ArgumentException(\"vertex index must be a nonnegative integer\"); if (w \u003c 0) throw new ArgumentException(\"vertex index must be a nonnegative integer\"); if (Double.IsNaN(weight)) throw new ArgumentException(\"Weight is NaN\"); this._v = v; this._w = w; this._weight = weight; } public double Weight() { return _weight; } public int Either() { return _v; } public int Other(int vertex) { if (vertex == _v) return _w; else if (vertex == _w) return _v; else throw new ArgumentException(\"Illegal endpoint\"); } public int CompareTo(Edge that) { return this._weight.CompareTo(that.Weight()); } public override String ToString() { return $\"{_v:D2}-{_w:D2} {_weight}\"; } } public class EdgeWeightedGraph { private static readonly String NEWLINE = System.Environment.NewLine; private readonly int _vertices; private int _edge; private LinkedBagNet\u003cEdge\u003e[] _adj; public EdgeWeightedGraph(int V) { if (V \u003c 0) throw new ArgumentException(\"Number of vertices must be nonnegative\"); this._vertices = V; this._edge = 0; _adj = new LinkedBagNet\u003cEdge\u003e[V]; for (int v = 0; v \u003c V; v++) { _adj[v] = new LinkedBagNet\u003cEdge\u003e(); } } public EdgeWeightedGraph(int V, int E): this(V) { if (E \u003c 0) throw new ArgumentException(\"Number of edges must be nonnegative\"); Random random=new Random(); for (int i = 0; i \u003c E; i++) { int v = random.Next(V); int w = random.Next(V); double weight = Math.Round(100 * random.NextDouble()) / 100.0; Edge e = new Edge(v, w, weight); AddEdge(e); } } public EdgeWeightedGraph(StreamReader stream) { if (stream == null) throw new ArgumentException(\"argument is null\"); try { this._vertices = int.Parse(stream.ReadLine()); _adj = new LinkedBagNet\u003cEdge\u003e[_vertices]; for (int v = 0; v \u003c _vertices; v++) { _adj[v] = new LinkedBagNet\u003cEdge\u003e(); } int E = int.Parse(stream.ReadLine()); if (E \u003c 0) throw new ArgumentException(\"Number of edges must be nonnegative\"); for (int i = 0; i \u003c E; i++) { string line = stream.ReadLine().Trim(); if (!string.IsNullOrEmpty(line) \u0026\u0026 line.Split(' ').Count() == 3) { int v = int.Parse(line.Split(' ')[0]); int w = int.Parse(line.Split(' ')[1]); double weight = double.Parse(line.Split(' ')[2]); AddEdge(new Edge(v,w,weight)); } } } catch (Exception e) { throw new ArgumentException(\"invalid input format in EdgeWeightedGraph constructor\", e); } } public EdgeWeightedGraph(EdgeWeightedGraph G):this(G._vertices) { this._edge = G.Edge(); for (int v = 0; v \u003c G._vertices; v++) { Stack\u003cEdge\u003e reverse = new Stack\u003cEdge\u003e(); foreach (Edge e in G._adj[v]) { reverse.Push(e); } foreach (Edge e in reverse) { _adj[v].Add(e); } } } public int Vertices() { return _vertices; } public int Edge() { return _edge; } private void validateVertex(int v) { if (v \u003c 0 || v \u003e= _vertices) throw new ArgumentException(\"vertex \" + v + \" is not between 0 and \" + (_vertices - 1)); } public void AddEdge(Edge e) { int v = e.Either(); int w = e.Other(v); validateVertex(v); validateVertex(w); _adj[v].Add(e); _adj[w].Add(e); _edge++; } public IEnumerable\u003cEdge\u003e Adj(int v) { validateVertex(v); return _adj[v]; } public int Degree(int v) { validateVertex(v); return _adj[v].Length; } public IEnumerable\u003cEdge\u003e Edges() { LinkedBagNet\u003cEdge\u003e list = new LinkedBagNet\u003cEdge\u003e(); for (int v = 0; v \u003c _vertices; v++) { int selfLoops = 0; foreach (Edge e in _adj[v]) { if (e.Other(v) \u003e v) { list.Add(e); } // add only one copy of each self loop (self loops will be consecutive) else if (e.Other(v) == v) { if (selfLoops % 2 == 0) list.Add(e); selfLoops++; } } } return list; } public override String ToString() { StringBuilder s = new StringBuilder(); s.Append(_vertices + \" \" + _edge + NEWLINE); for (int v = 0; v \u003c _vertices; v++) { s.Append(v + \": \"); foreach (Edge e in _adj[v]) { s.Ap","date":"2021-04-20","objectID":"/2021/04/algorithm8/:1:0","tags":["算法","加权无向图"],"title":"算法 加权无向图","uri":"/2021/04/algorithm8/"},{"categories":"算法","content":"贪心算法\r使用切分定理找到最小生成树的一条边，不断重复直到找到最小生成树的所有边。 ","date":"2021-04-20","objectID":"/2021/04/algorithm8/:1:1","tags":["算法","加权无向图"],"title":"算法 加权无向图","uri":"/2021/04/algorithm8/"},{"categories":"算法","content":"Prim算法\rPrim算法能够得到任意加权无向图的最小生成树。 每一步都会为一棵生长中的树添加一条边。一开始这棵树只有一个顶点，然后会向它添加V-1条边。 prim算法的核心是如何快速高校找到最小权重的横切边。失效的边是连接到已经在最小数的顶点，直到将所有顶点添加到最小树 Prim算法的延时实现计算一幅含有V个顶点和E条边的连通加权无向图的最小生成树所需的空间与E成正比，所需的时间与ElogE成正比。 /// \u003csummary\u003e /// 最小生成树 /// \u003c/summary\u003e public class LazyPrimMST { private static readonly double FLOATING_POINT_EPSILON = 1E-12;//ε private double _weight; // 最小生成树的总权重 private Queue\u003cEdge\u003e _mst; // 最小生成树的边 private bool[] _marked; private MinPQNet\u003cEdge\u003e _pq; // 横切边(包括失效的边) public LazyPrimMST(EdgeWeightedGraph G) { _mst = new Queue\u003cEdge\u003e(); _pq = new MinPQNet\u003cEdge\u003e();//最小优先队列，因为要找到最小的邻接边 _marked = new bool[G.Vertices()]; for (int v = 0; v \u003c G.Vertices(); v++) if (!_marked[v]) prim(G, v); } private void prim(EdgeWeightedGraph G, int s) { scan(G, s); while (_pq.Any())//直到优先队列中没有边 { Edge e = _pq.DeleteMin(); // 找到最小优先队列 int v = e.Either(), w = e.Other(v); // 该边的两个顶点 if (_marked[v] \u0026\u0026 _marked[w]) continue;// lazy，这两个顶点已经被访问过就是失效边。相当于从优先队列删除 _mst.Enqueue(e); // 另一个顶点没有访问过，就添加到最小生成树 _weight += e.Weight(); //计算总权重 if (!_marked[v]) scan(G, v); if (!_marked[w]) scan(G, w); // 将新添加顶点的邻接表对应的边添加到最小优先队列 } } /// \u003csummary\u003e /// 将其邻接表添加到队列中 /// \u003c/summary\u003e /// \u003cparam name=\"G\"\u003e\u003c/param\u003e /// \u003cparam name=\"v\"\u003e\u003c/param\u003e private void scan(EdgeWeightedGraph G, int v) { _marked[v] = true; foreach (Edge e in G.Adj(v)) if (!_marked[e.Other(v)]) _pq.Insert(e);//如果另一个顶点没有被访问过就将与该顶点的边添加到最小优先队列，不然就是失效边 } public IEnumerable\u003cEdge\u003e Edges() { return _mst; } public double Weight() { return _weight; } private bool check(EdgeWeightedGraph G) { // check weight double totalWeight = 0.0; foreach (Edge e in Edges()) { totalWeight += e.Weight(); } if (Math.Abs(totalWeight - Weight()) \u003e FLOATING_POINT_EPSILON) { Console.Write($\"Weight of edges does not equal weight(): {totalWeight} vs. {Weight()}\\n\"); return false; } // check that it is acyclic UF uf = new UF(G.Vertices()); foreach (Edge e in Edges()) { int v = e.Either(), w = e.Other(v); if (uf.Find(v) == uf.Find(w)) { Console.Write(\"Not a forest\"); return false; } uf.Union(v, w); } // check that it is a spanning forest foreach (Edge e in G.Edges()) { int v = e.Either(), w = e.Other(v); if (uf.Find(v) != uf.Find(w)) { Console.Write(\"Not a spanning forest\"); return false; } } // check that it is a minimal spanning forest (cut optimality conditions) foreach (Edge e in Edges()) { // all edges in MST except e uf = new UF(G.Vertices()); foreach (Edge f in _mst) { int x = f.Either(), y = f.Other(x); if (f != e) uf.Union(x, y); } // check that e is min weight edge in crossing cut foreach (Edge f in G.Edges()) { int x = f.Either(), y = f.Other(x); if (uf.Find(x) != uf.Find(y)) { if (f.Weight() \u003c e.Weight()) { Console.Write(\"Edge \" + f + \" violates cut optimality conditions\"); return false; } } } } return true; } } 测试 [TestMethod()] public void LazyPrimMSTTest() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\tinyEWG.txt\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { AlgorithmEngine.Graph.EdgeWeightedGraph G = new AlgorithmEngine.Graph.EdgeWeightedGraph(stream); LazyPrimMST mst = new LazyPrimMST(G); foreach (Edge e in mst.Edges()) { Console.WriteLine(e); } Console.Write($\"{mst.Weight()}\\n\"); } //00 - 07 0.16 //01 - 07 0.19 //00 - 02 0.26 //02 - 03 0.17 //05 - 07 0.28 //04 - 05 0.35 //06 - 02 0.4 //1.81 } ","date":"2021-04-20","objectID":"/2021/04/algorithm8/:1:2","tags":["算法","加权无向图"],"title":"算法 加权无向图","uri":"/2021/04/algorithm8/"},{"categories":"算法","content":"Prim即时算法\r改进上面的Prim算法 在优先队列中删除失效的边，优先队列中只包含树顶点和非树顶点之间的横切边。 在添加V之后只会更新W到最小树的权重。只需要保存最小的权重边即可。 如果顶点v不在树中但至少含有一条边和树相连，那么edgeTo[v]是将v和树连接的最短边，distTo[v]为这条边的权重。 所有这类顶点v都保存在一条索引优先队列中，索引v关联的值是edgeTo[v]的边的权重 关键在于优先队列中的最小键即是权重最小的横切边的权重了，而和它相关联的顶点v就是下一个将被添加到树种的顶点。 public class PrimMST { private static readonly double FLOATING_POINT_EPSILON = 1E-12; private Edge[] edgeTo; //顶点v距离树最近的边 private double[] distTo; // 顶点v距离树最近的权重 private bool[] marked; // 如果v在树中则为true private KeyMinPQNet\u003cDouble\u003e pq;//有效的横切边 public PrimMST(EdgeWeightedGraph G) { edgeTo = new Edge[G.Vertices()]; distTo = new double[G.Vertices()]; marked = new bool[G.Vertices()]; pq = new KeyMinPQNet\u003cDouble\u003e(G.Vertices()); for (int v = 0; v \u003c G.Vertices(); v++) distTo[v] = Double.PositiveInfinity;//正无穷，为常数，应该是最大数 for (int v = 0; v \u003c G.Vertices(); v++) if (!marked[v]) prim(G, v); } private void prim(EdgeWeightedGraph G, int s) { distTo[s] = 0.0;//distTo[s]=0.0 pq.Insert(s, distTo[s]);//将序号和权重压入 while (!pq.IsEmpty) { int v = pq.DeleteMin();//找到最小的权重 scan(G, v); } } private void scan(EdgeWeightedGraph G, int v) { marked[v] = true; foreach (Edge e in G.Adj(v))//查找v的邻接边 { int w = e.Other(v);//获取边对应的顶点 if (marked[w]) continue; //邻接顶点访问过 if (e.Weight() \u003c distTo[w])//更新权重 { distTo[w] = e.Weight(); edgeTo[w] = e; if (pq.Contains(w)) pq.DecreaseKey(w, distTo[w]);//更新 else pq.Insert(w, distTo[w]);//添加 } } } public IEnumerable\u003cEdge\u003e Edges() { Queue\u003cEdge\u003e mst = new Queue\u003cEdge\u003e(); for (int v = 0; v \u003c edgeTo.Length; v++) { Edge e = edgeTo[v]; if (e != null) { mst.Enqueue(e); } } return mst; } public double Weight() { double weight = 0.0; foreach (Edge e in Edges()) weight += e.Weight(); return weight; } private bool check(EdgeWeightedGraph G) { // check weight double totalWeight = 0.0; foreach (Edge e in Edges()) { totalWeight += e.Weight(); } if (Math.Abs(totalWeight - Weight()) \u003e FLOATING_POINT_EPSILON) { Console.Write($\"Weight of edges does not equal weight():{totalWeight} vs. { Weight()}\\n\"); return false; } // check that it is acyclic UF uf = new UF(G.Vertices()); foreach (Edge e in Edges()) { int v = e.Either(), w = e.Other(v); if (uf.Find(v) == uf.Find(w)) { Console.Write(\"Not a forest\"); return false; } uf.Union(v, w); } // check that it is a spanning forest foreach (Edge e in G.Edges()) { int v = e.Either(), w = e.Other(v); if (uf.Find(v) != uf.Find(w)) { Console.Write(\"Not a spanning forest\"); return false; } } // check that it is a minimal spanning forest (cut optimality conditions) foreach (Edge e in Edges()) { // all edges in MST except e uf = new UF(G.Vertices()); foreach (Edge f in Edges()) { int x = f.Either(), y = f.Other(x); if (f != e) uf.Union(x, y); } // check that e is min weight edge in crossing cut foreach (Edge f in G.Edges()) { int x = f.Either(), y = f.Other(x); if (uf.Find(x) != uf.Find(y)) { if (f.Weight() \u003c e.Weight()) { Console.Write(\"Edge \" + f + \" violates cut optimality conditions\"); return false; } } } } return true; } } 测试 [TestMethod()] public void PrimMSTTest() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\tinyEWG.txt\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { AlgorithmEngine.Graph.EdgeWeightedGraph G = new AlgorithmEngine.Graph.EdgeWeightedGraph(stream); PrimMST mst = new PrimMST(G); foreach (Edge e in mst.Edges()) { Console.WriteLine(e); } Console.Write($\"{mst.Weight()}\\n\"); } //01 - 07 0.19 //00 - 02 0.26 //02 - 03 0.17 //04 - 05 0.35 //05 - 07 0.28 //06 - 02 0.4 //00 - 07 0.16 //1.81 } 算法轨迹 找到一幅连通的加权无向图的最小生成树，所需的时间ElogV成正比。 命题N：Prim算法的即时实现计算一幅含有V个顶点和E条边的连通加权无向图的最小生成树所需的空间和V成正比，所需的时间和ElogV成正比。 ","date":"2021-04-20","objectID":"/2021/04/algorithm8/:1:3","tags":["算法","加权无向图"],"title":"算法 加权无向图","uri":"/2021/04/algorithm8/"},{"categories":"算法","content":"Kruskal算法\r主要思想：按照边的权重顺序(从小到大)处理它们，将边加入最小生成树种(图种的黑色边)，加入的边不会与已经加入的边构成环，直到树中含有V-1条边为止。 命题O:Kruskal算法能够计算任意加权无向图的最小生成树。 Kruskal实现：将会使用一条优先队列来将边按照权重排序，用一个union-find数据结构来识别会形成环的边，以及一条队列来保存最小生成树的所有边。 Kruskal：计算一幅含有V个顶点和E条边的连通加权无向图的最小生成树所需的空间和E成正比，所需的时间和ElogE成正比。 public class KruskalMST { private static readonly double FLOATING_POINT_EPSILON = 1E-12; private double _weight; private Queue\u003cEdge\u003e _mst = new Queue\u003cEdge\u003e(); public KruskalMST(EdgeWeightedGraph G) { MinPQNet\u003cEdge\u003e pq = new MinPQNet\u003cEdge\u003e(); foreach (Edge e in G.Edges()) { pq.Insert(e);//将所有边接入优先队列 } UF uf = new UF(G.Vertices()); while (!pq.IsEmpty \u0026\u0026 _mst.Count() \u003c G.Vertices() - 1) { Edge e = pq.DeleteMin();//找到最小权重边 int v = e.Either();//边的两个顶点 int w = e.Other(v); if (uf.Find(v) != uf.Find(w))//标识符不相等，不连通 { uf.Union(v, w); // 添加连通 _mst.Enqueue(e); // 将边压入 _weight += e.Weight(); } } } public IEnumerable\u003cEdge\u003e Edges() { return _mst; } public double Weight() { return _weight; } private bool check(EdgeWeightedGraph G) { // check total weight double total = 0.0; foreach (Edge e in Edges()) { total += e.Weight(); } if (Math.Abs(total - Weight()) \u003e FLOATING_POINT_EPSILON) { Console.Write($\"Weight of edges does not equal weight(): {total} vs. {Weight()}\\n\"); return false; } // check that it is acyclic UF uf = new UF(G.Vertices()); foreach (Edge e in Edges()) { int v = e.Either(), w = e.Other(v); if (uf.Find(v) == uf.Find(w)) { Console.Write(\"Not a forest\"); return false; } uf.Union(v, w); } // check that it is a spanning forest foreach (Edge e in G.Edges()) { int v = e.Either(), w = e.Other(v); if (uf.Find(v) != uf.Find(w)) { Console.Write(\"Not a spanning forest\"); return false; } } // check that it is a minimal spanning forest (cut optimality conditions) foreach (Edge e in Edges()) { // all edges in MST except e uf = new UF(G.Vertices()); foreach (Edge f in _mst) { int x = f.Either(), y = f.Other(x); if (f != e) uf.Union(x, y); } // check that e is min weight edge in crossing cut foreach (Edge f in G.Edges()) { int x = f.Either(), y = f.Other(x); if (uf.Find(x) != uf.Find(y)) { if (f.Weight() \u003c e.Weight()) { Console.Write(\"Edge \" + f + \" violates cut optimality conditions\"); return false; } } } } return true; } } 测试 [TestMethod()] public void KruskalMSTTest() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\tinyEWG.txt\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { AlgorithmEngine.Graph.EdgeWeightedGraph G = new AlgorithmEngine.Graph.EdgeWeightedGraph(stream); KruskalMST mst = new KruskalMST(G); foreach (Edge e in mst.Edges()) { Console.WriteLine(e); } Console.Write($\"{mst.Weight()}\\n\"); } //00 - 07 0.16 //02 - 03 0.17 //01 - 07 0.19 //00 - 02 0.26 //05 - 07 0.28 //04 - 05 0.35 //06 - 02 0.4 //1.81 } ","date":"2021-04-20","objectID":"/2021/04/algorithm8/:1:4","tags":["算法","加权无向图"],"title":"算法 加权无向图","uri":"/2021/04/algorithm8/"},{"categories":"算法","content":"有向图\r有向图：边是单向的，每条边所连接的两个顶点都是一个有序对。 定义：一幅有方向性的图(或有向图)是由一组顶点和一组由方向的边组成的，每条有方向的边都连接这有序的一对顶点。 出度：该顶点指出边的总数。 入度：指向该顶点边的总数。 头：有向边的第一个顶点 尾：有向边的第二个顶点 有向路径：一系列顶点组成，每个顶点都存在一条有向边指向序列的下一个顶点。 有向环：一条至少含有一条边且起点和终点相同的有向路径。 简单有向环：一条(除起点和终点)不含有重复的顶点和边的环。 长度：路径或环的长度为边的数量。 有向图的API public class Digraph { private static readonly String NEWLINE = System.Environment.NewLine; private readonly int _vertices; // 有向图顶点的数量 private int _edge; // 有向图边的数量 private LinkedBagNet\u003cint\u003e[] _adj; //有向图的邻接表 private int[] _indegree; // 有向图的度 /// \u003csummary\u003e /// 顶点 /// \u003c/summary\u003e public int Vertices =\u003e _vertices; /// \u003csummary\u003e /// 边 /// \u003c/summary\u003e public int Edge =\u003e _edge; /// \u003csummary\u003e /// 顶点V的邻接图，也可以是顶点V射出边的数量 /// \u003c/summary\u003e public LinkedBagNet\u003cint\u003e[] Adj =\u003e _adj; /// \u003csummary\u003e /// 入射到顶点V的数量 /// \u003c/summary\u003e public int[] Indegree =\u003e _indegree; public Digraph(int V) { if (V \u003c 0) throw new ArgumentException(\"Number of vertices in a Digraph must be nonnegative\"); this._vertices = V; this._edge = 0; _indegree = new int[V]; _adj = new LinkedBagNet\u003cint\u003e[V]; for (int v = 0; v \u003c V; v++) { _adj[v] = new LinkedBagNet\u003cint\u003e(); } } public Digraph(StreamReader stream) { if (stream == null) throw new ArgumentException(\"argument is null\"); try { this._vertices = int.Parse(stream.ReadLine()); if (_vertices \u003c 0) throw new ArgumentException(\"number of vertices in a Digraph must be nonnegative\"); _indegree = new int[_vertices]; _adj = new LinkedBagNet\u003cint\u003e[_vertices]; for (int v = 0; v \u003c _vertices; v++) { _adj[v] = new LinkedBagNet\u003cint\u003e(); } int E = int.Parse(stream.ReadLine()); if (E \u003c 0) throw new ArgumentException(\"number of edges in a Digraph must be nonnegative\"); for (int i = 0; i \u003c E; i++) { string line = stream.ReadLine(); if (!string.IsNullOrEmpty(line) \u0026\u0026 line.Split(' ').Count() == 2) { int v = int.Parse(line.Split(' ')[0]); int w = int.Parse(line.Split(' ')[1]); addEdge(v, w); } } } catch (Exception e) { throw new ArgumentException(\"invalid input format in Digraph constructor\", e); } } public Digraph(Digraph G) { if (G == null) throw new ArgumentException(\"argument is null\"); this._vertices = G.Vertices; this._vertices = G.Edge; if (_vertices \u003c 0) throw new ArgumentException(\"Number of vertices in a Digraph must be nonnegative\"); // update indegrees _indegree = new int[_vertices]; for (int v = 0; v \u003c _vertices; v++) this._indegree[v] = G._indegree[v]; // update adjacency lists _adj = new LinkedBagNet\u003cint\u003e[_vertices]; for (int v = 0; v \u003c _vertices; v++) { _adj[v] = new LinkedBagNet\u003cint\u003e(); } for (int v = 0; v \u003c G.Vertices; v++) { // reverse so that adjacency list is in same order as original Stack\u003cint\u003e reverse = new Stack\u003cint\u003e(); foreach (int w in G.Adj[v]) { reverse.Push(w); } foreach (int w in reverse) { _adj[v].Add(w); } } } private void validateVertex(int v) { if (v \u003c 0 || v \u003e= _vertices) throw new ArgumentException(\"vertex \" + v + \" is not between 0 and \" + (Vertices - 1)); } /// \u003csummary\u003e /// Adds the directed edge v→w to this digraph. /// \u003c/summary\u003e /// \u003cparam name=\"v\"\u003e\u003c/param\u003e /// \u003cparam name=\"w\"\u003e\u003c/param\u003e public void addEdge(int v, int w) { validateVertex(v); validateVertex(w); _adj[v].Add(w); _indegree[w]++; _edge++; } /// \u003csummary\u003e /// 返回从顶点v射出是线数量 /// \u003c/summary\u003e /// \u003cparam name=\"v\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public int Outdegree(int v) { validateVertex(v); return _adj[v].Length; } /// \u003csummary\u003e /// 逆转图 /// \u003c/summary\u003e /// \u003creturns\u003e\u003c/returns\u003e public Digraph Reverse() { Digraph reverse = new Digraph(_vertices); for (int v = 0; v \u003c _vertices; v++) { foreach (int w in Adj[v]) { reverse.addEdge(w, v); } } return reverse; } public override String ToString() { StringBuilder s = new StringBuilder(); s.Append(_vertices + \" vertices, \" + _edge + \" edges \" + NEWLINE); for (int v = 0; v \u003c _vertices; v++) { s.Append(String.Format(\"%d: \", v)); foreach (int w in Adj[v]) { s.Append(String.Format(\"%d \", w)); } s.Append(NEWLINE); } return s.ToString(); } } ","date":"2020-12-19","objectID":"/2020/12/algorithm7/:1:0","tags":["算法","有向图"],"title":"算法 有向图","uri":"/2020/12/algorithm7/"},{"categories":"算法","content":"符号有向图\r和之前一样 public class SymbolDigraph { private ST\u003cString, int\u003e _st; private String[] _keys; private Digraph _graph; public SymbolDigraph(String filename, String delimiter) { _st = new ST\u003cString, int\u003e(); // First pass builds the index by reading strings to associate // distinct strings with an index StreamReader reader = new StreamReader(filename); while (!reader.EndOfStream) { String[] a = reader.ReadLine().Split(delimiter.ToCharArray()); for (int i = 0; i \u003c a.Length; i++) { if (!_st.Contains(a[i])) _st.Add(a[i], _st.Count()); } } // inverted index to get string keys in an array _keys = new String[_st.Count()]; foreach (String name in _st.Keys()) { _keys[_st.Get(name)] = name; } // second pass builds the digraph by connecting first vertex on each // line to all others _graph = new Digraph(_st.Count()); reader = new StreamReader(filename); while (!reader.EndOfStream) { String[] a = reader.ReadLine().Split(delimiter.ToCharArray()); int v = _st.Get(a[0]); for (int i = 1; i \u003c a.Length; i++) { int w = _st.Get(a[i]); _graph.AddEdge(v, w); } } } public bool Contains(String s) { return _st.Contains(s); } public int Index(String s) { return _st.Get(s); } public int IndexOf(String s) { return _st.Get(s); } public String Name(int v) { validateVertex(v); return _keys[v]; } public String NameOf(int v) { validateVertex(v); return _keys[v]; } public Digraph G() { return _graph; } public Digraph Digraph() { return _graph; } private void validateVertex(int v) { int V = _graph.Vertices; if (v \u003c 0 || v \u003e= V) throw new ArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1)); } 测试 [TestMethod()] public void SymbolDigraphTest() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\routes.txt\"); SymbolDigraph sg = new SymbolDigraph(data, \" \"); Digraph graph = sg.Digraph(); StreamReader reader = new StreamReader(data); while (!reader.EndOfStream) { String source = reader.ReadLine().Split(' ')[0]; if (sg.Contains(source)) { Console.Write($\"{source} :\"); int s = sg.Index(source); foreach (int v in graph.Adj[s]) { Console.Write(\" \" + sg.Name(v)); } } else { Console.WriteLine(\"input not contain '\" + source + \"'\"); } Console.WriteLine(); } //JFK: ORD ATL MCO //ORD : ATL PHX DFW HOU DEN //ORD : ATL PHX DFW HOU DEN //DFW : HOU PHX //JFK: ORD ATL MCO //ORD : ATL PHX DFW HOU DEN //ORD : ATL PHX DFW HOU DEN //ATL : MCO HOU //DEN: LAS PHX //PHX: LAX //JFK : ORD ATL MCO //DEN : LAS PHX //DFW: HOU PHX //ORD: ATL PHX DFW HOU DEN //LAS : PHX LAX //ATL: MCO HOU //HOU: MCO //LAS : PHX LAX } ","date":"2020-12-19","objectID":"/2020/12/algorithm7/:1:1","tags":["算法","有向图"],"title":"算法 有向图","uri":"/2020/12/algorithm7/"},{"categories":"算法","content":"查找所有节点\r可达性：是否存在一条从S到达顶点V的有向路径 深度搜索 public class DirectedDFS { private bool[] _marked; private int _count; //顶点数量 public DirectedDFS(Digraph G, int s) { _marked = new bool[G.Vertices]; validateVertex(s); dfs(G, s); } public DirectedDFS(Digraph G, IEnumerable\u003cint\u003e sources) { _marked = new bool[G.Vertices]; validateVertices(sources); foreach (int v in sources) { if (!_marked[v]) dfs(G, v); } } /// \u003csummary\u003e /// 深度搜素 /// \u003c/summary\u003e /// \u003cparam name=\"G\"\u003e\u003c/param\u003e /// \u003cparam name=\"v\"\u003e\u003c/param\u003e private void dfs(Digraph G, int v) { _count++; _marked[v] = true; foreach (int w in G.Adj[v]) { if (!_marked[w]) dfs(G, w); } } public bool Marked(int v) { validateVertex(v); return _marked[v]; } public int Count() { return _count; } private void validateVertex(int v) { int V = _marked.Length; if (v \u003c 0 || v \u003e= V) throw new ArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1)); } // throw an IllegalArgumentException unless {@code 0 \u003c= v \u003c V} private void validateVertices(IEnumerable\u003cint\u003e vertices) { if (vertices == null) { throw new ArgumentException(\"argument is null\"); } foreach (int v in vertices) { if (v == default) { throw new ArgumentException(\"vertex is null\"); } validateVertex(v); } } } 测试 [TestMethod()] public void DirectedDFSTest() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\tinyDG.txt\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { AlgorithmEngine.Graph.Digraph G = new AlgorithmEngine.Graph.Digraph(stream); DirectedDFS dfs=new DirectedDFS(G,9); for (int v = 0; v \u003c G.Vertices; v++) { if (dfs.Marked(v)) Console.Write(v + \" \"); } } } 可达性非递归 public class NonrecursiveDirectedDFS { private bool[] _marked; public NonrecursiveDirectedDFS(Digraph G, int s) { _marked = new bool[G.Vertices]; validateVertex(s); IEnumerator\u003cint\u003e[] adj =new IEnumerator\u003cint\u003e[G.Vertices]; for (int v = 0; v \u003c G.Vertices; v++) adj[v] = G.Adj[v].GetEnumerator(); Stack\u003cint\u003e stack = new Stack\u003cint\u003e(); _marked[s] = true; stack.Push(s); while (stack.Any()) { int v = stack.Peek(); if (adj[v].MoveNext()) { int w = adj[v].Current; if (!_marked[w]) { _marked[w] = true; stack.Push(w); } } else { stack.Pop(); } } } public bool Marked(int v) { validateVertex(v); return _marked[v]; } private void validateVertex(int v) { int V = _marked.Length; if (v \u003c 0 || v \u003e= V) throw new ArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1)); } } ","date":"2020-12-19","objectID":"/2020/12/algorithm7/:1:2","tags":["算法","有向图"],"title":"算法 有向图","uri":"/2020/12/algorithm7/"},{"categories":"算法","content":"寻找所有路径\r深度搜索 public class DepthFirstDirectedPaths { private bool[] _marked; private int[] _edgeTo; private readonly int s; // 起点 public DepthFirstDirectedPaths(Digraph G, int s) { _marked = new bool[G.Vertices]; _edgeTo = new int[G.Vertices]; this.s = s; validateVertex(s); dfs(G, s); } private void dfs(Digraph G, int v) { _marked[v] = true; foreach (int w in G.Adj[v]) { if (!_marked[w]) { _edgeTo[w] = v; dfs(G, w); } } } public bool HasPathTo(int v) { validateVertex(v); return _marked[v]; } public IEnumerable\u003cint\u003e PathTo(int v) { validateVertex(v); if (!HasPathTo(v)) return null; Stack\u003cint\u003e path = new Stack\u003cint\u003e(); for (int x = v; x != s; x = _edgeTo[x]) path.Push(x); path.Push(s); return path; } private void validateVertex(int v) { int V = _marked.Length; if (v \u003c 0 || v \u003e= V) throw new ArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1)); } } 测试 [TestMethod()] public void DepthFirstDirectedPathsTest() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\tinyDG.txt\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { AlgorithmEngine.Graph.Digraph G = new AlgorithmEngine.Graph.Digraph(stream); DepthFirstDirectedPaths dfs=new DepthFirstDirectedPaths(G,9); for (int v = 0; v \u003c G.Vertices; v++) { if (dfs.HasPathTo(v)) { Console.Write($\"{9} to {v}: \"); foreach (int x in dfs.PathTo(v)) { if (x == 9) Console.Write(x); else Console.Write(\"-\" + x); } Console.WriteLine(); } else { Console.Write($\"9 to {v}: not connected\\n\"); } } } //9 to 0: 9 - 11 - 4 - 3 - 2 - 0 //9 to 1: 9 - 11 - 4 - 3 - 2 - 0 - 1 //9 to 2: 9 - 11 - 4 - 3 - 2 //9 to 3: 9 - 11 - 4 - 3 //9 to 4: 9 - 11 - 4 //9 to 5: 9 - 11 - 4 - 3 - 5 //9 to 6: not connected //9 to 7: not connected //9 to 8: not connected //9 to 9: 9 //9 to 10: 9 - 10 //9 to 11: 9 - 11 //9 to 12: 9 - 11 - 12 } 广度搜索 广度搜索需要一个队列辅助，基本和无向图一样 public class BreadthFirstDirectedPaths { private static readonly int INFINITY = int.MaxValue; private bool[] _marked; private int[] _edgeTo; private int[] _distTo; public BreadthFirstDirectedPaths(Digraph G, int s) { _marked = new bool[G.Vertices]; _distTo = new int[G.Vertices]; _edgeTo = new int[G.Vertices]; for (int v = 0; v \u003c G.Vertices; v++) _distTo[v] = INFINITY; validateVertex(s); bfs(G, s); } public BreadthFirstDirectedPaths(Digraph G, IEnumerable\u003cint\u003e sources) { _marked = new bool[G.Vertices]; _distTo = new int[G.Vertices]; _edgeTo = new int[G.Vertices]; for (int v = 0; v \u003c G.Vertices; v++) _distTo[v] = INFINITY; validateVertices(sources); bfs(G, sources); } // BFS from single source private void bfs(Digraph G, int s) { Queue\u003cint\u003e q = new Queue\u003cint\u003e(); _marked[s] = true; _distTo[s] = 0; q.Enqueue(s); while (q.Any()) { int v = q.Dequeue(); foreach (int w in G.Adj[v]) { if (!_marked[w]) { _edgeTo[w] = v; _distTo[w] = _distTo[v] + 1; _marked[w] = true; q.Enqueue(w); } } } } // BFS from multiple sources private void bfs(Digraph G, IEnumerable\u003cint\u003e sources) { Queue\u003cint\u003e q = new Queue\u003cint\u003e(); foreach (int s in sources) { _marked[s] = true; _distTo[s] = 0; q.Enqueue(s); } while (q.Any()) { int v = q.Dequeue(); foreach (int w in G.Adj[v]) { if (!_marked[w]) { _edgeTo[w] = v; _distTo[w] = _distTo[v] + 1; _marked[w] = true; q.Enqueue(w); } } } } public bool HasPathTo(int v) { validateVertex(v); return _marked[v]; } public int DistTo(int v) { validateVertex(v); return _distTo[v]; } public IEnumerable\u003cint\u003e PathTo(int v) { validateVertex(v); if (!HasPathTo(v)) return null; Stack\u003cint\u003e path = new Stack\u003cint\u003e(); int x; for (x = v; _distTo[x] != 0; x = _edgeTo[x]) path.Push(x); path.Push(x); return path; } private void validateVertex(int v) { int V = _marked.Length; if (v \u003c 0 || v \u003e= V) throw new ArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1)); } // throw an IllegalArgumentException unless {@code 0 \u003c= v \u003c V} private void validateVertices(IEnumerable\u003cint\u003e vertices) { if (vertices == null) { throw new ArgumentException(\"argument is null\"); } foreach (int v in vertices) { if (v == default) { throw n","date":"2020-12-19","objectID":"/2020/12/algorithm7/:1:3","tags":["算法","有向图"],"title":"算法 有向图","uri":"/2020/12/algorithm7/"},{"categories":"算法","content":"寻找有向环\r调度问题\r一种广泛的模型是给定一组任务并安排它们的执行顺序，限制条件是这些任务的执行方法和起始时间。哪些任务必须在哪些任务之前完成，最重要的限制条件叫优先级限制。 优先级限制下调度问题：一组关于任务完成的先后次序的优先级限制。 拓扑排序：==有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素（或者说明无法做到这一点）。==等价于调度问题，获得拓扑排序是为了解决调度问题。 如果一个有优先级限制的问题中存在有向环，那么这个问题无解。 有向无环图（DAG）:不含有环的有向图。 深度搜索，就跟拿根绳走迷宫是一样的 public class DirectedCycle { private bool[] _marked; private int[] _edgeTo; private bool[] _onStack; //该顶点是否在栈 private Stack\u003cint\u003e _cycle; // 环栈 public DirectedCycle(Digraph G) { _marked = new bool[G.Vertices]; _onStack = new bool[G.Vertices]; _edgeTo = new int[G.Vertices]; for (int v = 0; v \u003c G.Vertices; v++) if (!_marked[v] \u0026\u0026 _cycle == null) dfs(G, v); } private void dfs(Digraph G, int v) { _onStack[v] = true; _marked[v] = true; foreach (int w in G.Adj[v]) { // 环已经被发现 if (_cycle != null) return; // 新的顶点且环没有被发现 else if (!_marked[w]) { _edgeTo[w] = v; dfs(G, w); } else if (_onStack[w])//查找到环，压入环栈 { _cycle = new Stack\u003cint\u003e(); for (int x = v; x != w; x = _edgeTo[x]) { _cycle.Push(x); } _cycle.Push(w); _cycle.Push(v); } } _onStack[v] = false; } public bool HasCycle() { return _cycle != null; } public IEnumerable\u003cint\u003e Cycle() { return _cycle; } private bool check() { if (HasCycle()) { // verify cycle int first = -1, last = -1; foreach (int v in _cycle) { if (first == -1) first = v; last = v; } if (first != last) { Console.Write(\"cycle begins with %d and ends with %d\\n\", first, last); return false; } } return true; } } 测试 [TestMethod()] public void DirectedCycleTest() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\tinyDG.txt\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { AlgorithmEngine.Graph.Digraph G = new AlgorithmEngine.Graph.Digraph(stream); DirectedCycle finder = new DirectedCycle(G); if (finder.HasCycle()) { Console.Write(\"Directed cycle: \"); foreach (int v in finder.Cycle())//只能找到一个环 { Console.Write(v + \" \"); } Console.WriteLine(); } else { Console.WriteLine(\"No directed cycle\"); } //Directed cycle: 3 5 4 3 } } 广度搜索，就像一个人有影分身走不同的路径 public class DirectedCycleX { private Stack\u003cint\u003e _cycle; public DirectedCycleX(Digraph G) { int[] indegree = new int[G.Vertices]; for (int v = 0; v \u003c G.Vertices; v++) { indegree[v] = G.Indegree[v]; } //所有没有入射边的顶点压入队列 Queue\u003cint\u003e queue = new Queue\u003cint\u003e(); for (int v = 0; v \u003c G.Vertices; v++) if (indegree[v] == 0) queue.Enqueue(v); while (queue.Any())//广度搜索 { int v = queue.Dequeue(); foreach (int w in G.Adj[v]) { indegree[w]--;//去除掉从没有入射边顶点射出的边，并查看是否有没有入射边的顶点 if (indegree[w] == 0) queue.Enqueue(w); } } int[] edgeTo = new int[G.Vertices]; int root = -1; for (int v = 0; v \u003c G.Vertices; v++) { if (indegree[v] == 0) continue; else root = v;//入射边大于0的顶点，有环 foreach (int w in G.Adj[v]) { if (indegree[w] \u003e 0) { edgeTo[w] = v; } } } if (root != -1) { // find any vertex on cycle bool[] visited = new bool[G.Vertices]; while (!visited[root]) { visited[root] = true; root = edgeTo[root]; } // extract cycle _cycle = new Stack\u003cint\u003e(); int v = root; do { _cycle.Push(v); v = edgeTo[v]; } while (v != root); _cycle.Push(root); } } public IEnumerable\u003cint\u003e Cycle() { return _cycle; } public bool HasCycle() { return _cycle != null; } private bool check() { if (HasCycle()) { int first = -1, last = -1; foreach (int v in _cycle) { if (first == -1) first = v; last = v; } if (first != last) { Console.Write(\"cycle begins with %d and ends with %d\\n\", first, last); return false; } } return true; } } 测试 [TestMethod] public void DirectedCycleXTest() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\tinyDG.txt\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { AlgorithmEngine.Graph.Digraph G = new AlgorithmEngine.Graph.Digraph(stream); DirectedCycleX finder = new DirectedCycleX(G); if (finder.HasCycle()) { Console.Write(\"Directed cycle: \"); foreach (int v in finder.Cycle()) { Console.Write(v + \" \"); } Console.WriteLine(); } else { Console.WriteLine(\"No directed cycle\"); } //Directed cycle: 12 9 11 12 } } 顶点排序\r基于深度优先搜索的顶点排序，深度优先搜索正好只会访问每个顶点一次。 如果将dfs()","date":"2020-12-19","objectID":"/2020/12/algorithm7/:1:4","tags":["算法","有向图"],"title":"算法 有向图","uri":"/2020/12/algorithm7/"},{"categories":"算法","content":"强连通性问题\r强连通：如果两个顶点v和w是相互可达的，则称它们为强连通。 两个顶点是强连通的当且仅当它们都在一个普通的有向环中。 性质： 自反性：任意顶点V和自己都是强连通的 对称性：如果v和w是强连通的，那么w和v也是强连通的。 传递性：如果v和w是强连通的且w和x也是强连通的，那么v和x也是强连通的。 强连通可以帮助进行归类，可以帮助生物学家解决生态的问题 Kosaraju算法\rKosaraju算法的步骤 对给定的G，使用DepthFirstOrder来计算它的反向图G的逆后序排序。 在G中进行标准的深度优先搜索，按照上一步的顺序来访问所有未被标记过的顶点。 在构造函数中，所有在同一个递归dfs()调用中被访问到的顶点都在同一个强连通分量中，将它们按照和CC相同的方式识别出来。 /// \u003csummary\u003e /// Kosaraju算法 /// \u003c/summary\u003e public class KosarajuSharirSCC { private bool[] _marked; //已访问过的顶点 private int[] _id; //强连通分量的标识符 private int _count; //强连通分量的数量 public KosarajuSharirSCC(Digraph G) { DepthFirstOrder dfo = new DepthFirstOrder(G.Reverse());//这边注意是G.Reverse _marked = new bool[G.Vertices]; _id = new int[G.Vertices]; foreach (int v in dfo.ReversePost())//拓扑排序的顶点 { if (!_marked[v])//遍历拓扑排序的顶点 { dfs(G, v);// _count++;//找到一个新的连通量 } } } private void dfs(Digraph G, int v) { _marked[v] = true; _id[v] = _count;//强连通分量的顶点对应的id都一样 foreach (int w in G.Adj[v]) { if (!_marked[w]) dfs(G, w); } } public int Count() { return _count; } public bool StronglyConnected(int v, int w) { validateVertex(v); validateVertex(w); return _id[v] == _id[w]; } public int Id(int v) { validateVertex(v); return _id[v]; } private void validateVertex(int v) { int V = _marked.Length; if (v \u003c 0 || v \u003e= V) throw new ArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1)); } } 测试 [TestMethod()] public void KosarajuTest() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\tinyDG.txt\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { AlgorithmEngine.Graph.Digraph G = new AlgorithmEngine.Graph.Digraph(stream); KosarajuSharirSCC scc=new KosarajuSharirSCC(G); // number of connected components int m = scc.Count(); Console.WriteLine(m + \" strong components\"); // compute list of vertices in each strong component Queue\u003cint\u003e[] components = new Queue\u003cint\u003e[m]; for (int i = 0; i \u003c m; i++) { components[i] = new Queue\u003cint\u003e(); } for (int v = 0; v \u003c G.Vertices; v++) { components[scc.Id(v)].Enqueue(v);//将每一种连通向都 } // print results for (int i = 0; i \u003c m; i++) { foreach (int v in components[i]) { Console.Write(v + \" \"); } Console.WriteLine(); } } //5 strong components //1 //0 2 3 4 5 //9 10 11 12 //6 8 //7 } 命题H:使用深度优先搜索查找给定有向图G的反向图GR（也就是上面的拓扑排序），根据由此得到的所有顶点的逆后序再次用深度优先搜索处理有向图G(Kosaraju算法),其构造函数中的每一次递归调用所标记的顶点都在同一个强连通分量之中。 顶点对的可达性\r有向图G的传递闭包是由相同的一组顶点组成的另一幅有向图，在传递闭包中存在一条从v指向w的边当且仅当在G中w是从v可达的。 传递闭包不如用深度优先搜索算法 public class TransitiveClosure { private DirectedDFS[] tc; public TransitiveClosure(Digraph G) { tc = new DirectedDFS[G.Vertices]; for (int v = 0; v \u003c G.Vertices; v++) tc[v] = new DirectedDFS(G, v); } public bool Reachable(int v, int w) { validateVertex(v); validateVertex(w); return tc[v].Marked(w); } private void validateVertex(int v) { int V = tc.Length; if (v \u003c 0 || v \u003e= V) throw new ArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1)); } } 测试： [TestMethod()] public void TransitiveClosureTest() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\tinyDG.txt\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { AlgorithmEngine.Graph.Digraph G = new AlgorithmEngine.Graph.Digraph(stream); TransitiveClosure tc = new TransitiveClosure(G); // print header Console.Write(\"// \"); for (int v = 0; v \u003c G.Vertices; v++) Console.Write($\" {v:D2}\"); Console.WriteLine(); Console.WriteLine(\"//--------------------------------------------\"); // print transitive closure for (int v = 0; v \u003c G.Vertices; v++) { Console.Write($\"// {v:D2}: \"); for (int w = 0; w \u003c G.Vertices; w++) { if (tc.Reachable(v, w)) Console.Write(\" T\"); else Console.Write(\" \"); } Console.WriteLine(); } } // 00 01 02 03 04 05 06 07 08 09 10 11 12 //-------------------------------------------- // 00: T T T T T T // 01: T // 02: T T T T T T // 03: T T T T T T // 04: T T T T T T // 05: T T T T T T // 06: T T T T T T T T T T T T // 07: T T T T T T T T T T T T T // 08: T T T T T T T T T T T T // 09: T T T T T T T T T T // 10: T T T T T T T T T T // 1","date":"2020-12-19","objectID":"/2020/12/algorithm7/:1:5","tags":["算法","有向图"],"title":"算法 有向图","uri":"/2020/12/algorithm7/"},{"categories":"算法","content":"总结\r","date":"2020-12-19","objectID":"/2020/12/algorithm7/:1:6","tags":["算法","有向图"],"title":"算法 有向图","uri":"/2020/12/algorithm7/"},{"categories":"算法","content":"图\r无向图，有向图，加权图，加权有向图 将对象称为触点，将整数对称为连接，将等价类称为连通分量或是简称分量 ","date":"2020-12-16","objectID":"/2020/12/algorithm6/:0:0","tags":["算法","无向图"],"title":"算法 图 无向图","uri":"/2020/12/algorithm6/"},{"categories":"算法","content":"连通性问题\r目标：编写一个程序来过滤序列中所有无意义的整数对 程序输入p,q，如果已知的所有整数都不能说明p,q是相连的，则将这对整数写到输出中，如果已知数据已经可以证明，则忽略。 将对象称为触电，将整数对称为连接。将等价类称为连通分量。简称分量 public class UF { private int[] _parent; //父初触点 private byte[] _rank; //等级，相当于树中的深度 private int _count; //分量数量 public UF(int n) { if (n \u003c 0) throw new ArgumentException(); _count = n; _parent = new int[n]; _rank = new byte[n]; for (int i = 0; i \u003c n; i++) { _parent[i] = i; _rank[i] = 0; } } public int Find(int p) { validate(p); while (p != _parent[p]) { _parent[p] = _parent[_parent[p]]; // path compression by halving p = _parent[p]; } return p; } public int Count() { return _count; } public bool Connected(int p, int q) { return Find(p) == Find(q); } /// \u003csummary\u003e /// 在p和q之间添加连接线 /// \u003c/summary\u003e /// \u003cparam name=\"p\"\u003e\u003c/param\u003e /// \u003cparam name=\"q\"\u003e\u003c/param\u003e public void Union(int p, int q) { int rootP = Find(p); int rootQ = Find(q); if (rootP == rootQ) return; // make root of smaller rank point to root of larger rank // 使较小等级的根指向较大等级的根 if (_rank[rootP] \u003c _rank[rootQ]) _parent[rootP] = rootQ; else if (_rank[rootP] \u003e _rank[rootQ]) _parent[rootQ] = rootP; else //相当情况 { _parent[rootQ] = rootP; _rank[rootP]++; } _count--; } // validate that p is a valid index private void validate(int p) { int n = _parent.Length; if (p \u003c 0 || p \u003e= n) { throw new ArgumentException(\"index \" + p + \" is not between 0 and \" + (n - 1)); } } } ","date":"2020-12-16","objectID":"/2020/12/algorithm6/:1:0","tags":["算法","无向图"],"title":"算法 图 无向图","uri":"/2020/12/algorithm6/"},{"categories":"算法","content":"Quick-find算法\r该算法的目标就是让所有连通的触电（索引）对应的值都相同。 public class QuickFindUF { private int[] _id; //连通分量 private int _length; public QuickFindUF(int length) { _length = length; _id = new int[length]; for (int i = 0; i \u003c length; i++) _id[i] = i; } public int Length() { return _length; } public int Find(int p) { validate(p); return _id[p]; } // validate that p is a valid index private void validate(int p) { int n = _id.Length; if (p \u003c 0 || p \u003e= n) { throw new ArgumentException(\"index \" + p + \" is not between 0 and \" + (n - 1)); } } public bool Connected(int p, int q) { validate(p); validate(q); return _id[p] == _id[q]; } public void Union(int p, int q) { validate(p); validate(q); //将p和q归并到相同的分量中 int pID = _id[p]; // needed for correctness int qID = _id[q]; // to reduce the number of array accesses // 如果p和q已经在相同的分量之中则不需要采取任何行动 if (pID == qID) return; //将p的分量重命名为q的名称 for (int i = 0; i \u003c _id.Length; i++) if (_id[i] == pID) _id[i] = qID; _length--; } } 命题F：在Quick-find算法中，每次find()调用只需要访问id[]数组一次。而归并两个分量的union()操作访问数组的次数在(N+3)到(2N+1)之间。 ","date":"2020-12-16","objectID":"/2020/12/algorithm6/:1:1","tags":["算法","无向图"],"title":"算法 图 无向图","uri":"/2020/12/algorithm6/"},{"categories":"算法","content":"Quick-unit算法\r还是以触点作为索引。每个触点对应的值是另一个触点(也可以是自己)，这称为连接，find方法，从第一个触点开始，得到第二个触点，在得到第4个触点。 public class QuickUnionUF { private int[] _parent; private int _length; public QuickUnionUF(int length) { _parent = new int[length]; _length = length; for (int i = 0; i \u003c length; i++) { _parent[i] = i;//初始化每个触点都指向自己 } } public int Length() { return _length; } public int Find(int p) { validate(p); while (p != _parent[p])//找出根触点 p = _parent[p]; return p; } // validate that p is a valid index private void validate(int p) { int n = _parent.Length; if (p \u003c 0 || p \u003e= n) { throw new ArgumentException(\"index \" + p + \" is not between 0 and \" + (n - 1)); } } public bool Connected(int p, int q) { return Find(p) == Find(q); } public void Union(int p, int q) { //将P和Q的根节点统一 int rootP = Find(p); int rootQ = Find(q); if (rootP == rootQ) return; _parent[rootP] = rootQ; _length--; } } 定义：一颗树的带下是它的结点的数量，树中的一个节点的深度是它到根节点的路径上的链接数。树的高度是它的所有节点中的最大深度。 命题G:Quick-Union算法中find()方法访问数组的次数为1加上给定触点对应的节点的深度的两倍，union()和connected()访问数组的次数为两次find()操作。 最坏情况下还是N^2 ","date":"2020-12-16","objectID":"/2020/12/algorithm6/:1:2","tags":["算法","无向图"],"title":"算法 图 无向图","uri":"/2020/12/algorithm6/"},{"categories":"算法","content":"加权Quick-union算法\r记录每棵树的大小并总是将较小的树连接到较大的树上。 public class WeightedQuickUnionUF { /// \u003csummary\u003e /// 父链接数组(触点索引) /// \u003c/summary\u003e private int[] _parent; /// \u003csummary\u003e /// 各个节点所对应权重的大小 /// \u003c/summary\u003e private int[] _size; /// \u003csummary\u003e /// 连通分量的数量 /// \u003c/summary\u003e private int _length; public WeightedQuickUnionUF(int length) { _length = length; _parent = new int[length]; _size = new int[length]; for (int i = 0; i \u003c length; i++) { _parent[i] = i; _size[i] = 1;//刚开始所有权重为1 } } public int Length() { return _length; } public bool Connected(int p, int q) { return Find(p) == Find(q); } private void validate(int p) { int n = _parent.Length; if (p \u003c 0 || p \u003e= n) { throw new ArgumentException(\"index \" + p + \" is not between 0 and \" + (n - 1)); } } public int Find(int p) { validate(p); while (p != _parent[p]) p = _parent[p]; return p; } public void Union(int p, int q) { int rootP = Find(p); int rootQ = Find(q); if (rootP == rootQ) return; //将小树的根节点链接到大树的根节点 if (_size[rootP] \u003c _size[rootQ]) { _parent[rootP] = rootQ; _size[rootQ] += _size[rootP]; } else { _parent[rootQ] = rootP;// _size[rootP] += _size[rootQ]; } _length--; } } 命题H:对于N个触点，加权quick-union算法构造的森林中的任意节点的深度最多为logN。 推论：对于加权quick-union算法和N个触点，在最坏情况下find(),connected()和uniond的成本的增长数量级为logN。 ","date":"2020-12-16","objectID":"/2020/12/algorithm6/:1:3","tags":["算法","无向图"],"title":"算法 图 无向图","uri":"/2020/12/algorithm6/"},{"categories":"算法","content":"无向图\r无向图：图是由一组顶点和一组能够将连个顶点相连的边组成的。 一般使用0-(V-1)来表示一张含有V个顶点的图中的各个顶点。用V-W的记法来表示连接V和W的边。 由两种特殊的图： 自环：一条连接一个顶点和自身的边 连接同一对顶点的两条边称为平行边。 图的定义和绘出的图像无关 两个顶点通过同一条边相连时，称为这两个顶点是相邻的。并称该连接依附于这两个顶点。 顶点的度数表示依附于它的边总数，也就是连接到该顶点的边的条数。 子图是一幅图的所有边的一个子集（以及它们所依附的所有顶点）组成的图。 路径是边顺序连接一系列顶点。 简单路径是一条没有重复顶点的路径。 环是一条至少含有一条边且起点和终点相同的路径。 简单环：一条(除了起点和终点必须相同之外)不含有重复顶点和边的环。 长度：路径和环的长度为其包含的边数。 连通：如果两个顶点之间存在一条连接双方的路径时，一个顶点和另一个顶点是连通的。路径用u-v-w-x来表示这条u到x的路径。 连通图：从任意一个顶点都存在一条路径到达另一个任意顶点。 极大连通子图：一个非连通的图由若干连通子图组成。 无环图：不包含环的图。 树：一幅无环连通图。 森林：互不相连的树组成的集合。 连通图的生成树：是连通图的一个子集，它包含连通图中所有顶点并是一颗树。 图的生成树森林：所有连通子图的生成树的集合。 树的辨别条件，一幅含有V个结点的图G，满足一点就是树： G有(V-1)条边且不含有环； G有(V-1)条边是连通的； G是连通的，但删除任意一条边都会使它不再连通 G是无环图，但添加任意一条边都会产生一条环。 G中任意一对顶点之间仅存一条简单的路径。 图的密度：已经连接的顶点对占所有可能被连接顶点对的比列。 二分图：能够将所有结点分为两部分的图，图的每条边所连接的两个顶点都分别属于不同的部分。 加粗的是一类，不加粗的是另一类 ","date":"2020-12-16","objectID":"/2020/12/algorithm6/:2:0","tags":["算法","无向图"],"title":"算法 图 无向图","uri":"/2020/12/algorithm6/"},{"categories":"算法","content":"图的实现\r图的数据表示： 图的代码表示需要满足以下两个条件： 预留出足够的空间 Graph的实例方法实现一定要快 代码是实现 邻接矩阵：使用一个V乘V的布尔矩阵，需要V^2^个布尔值的空间，空间是不可能满足的，造成很多浪费。 边的数组，使用Edge类，含有两个int实例变量，不满足第二个。 邻接标数组：零点为索引的列表数组，每个元素都是和该顶点相邻的列表数组。 顶点为V，边为E。 邻接标的特性： 使用的空间和V+E成正比； 添加一条边所需的时间为常数。 遍历顶点V的所有相邻点所需的时间和V的度数成正比（处理每个相邻顶点所需的时间为常数） public class Graph { private static readonly string NEWLINE = System.Environment.NewLine; private readonly int _vertices; private int _edge; private LinkedBagNet\u003cint\u003e[] _adj;//序号就是顶点 public int Vertices =\u003e _vertices; public Graph(int vertices) { if (vertices \u003c 1) throw new ArgumentException(\"this vertices is less than zero\"); this._vertices = vertices; this._edge = 0; _adj = new LinkedBagNet\u003cint\u003e[vertices]; for (int i = 0; i \u003c vertices; i++) { _adj[i] = new LinkedBagNet\u003cint\u003e(); } } public Graph(StreamReader stream) { if (stream == null) throw new ArgumentException(\"this stream is null\"); try { var vertices = int.Parse(stream.ReadLine()); if (vertices \u003c 1) throw new ArgumentException(\"this vertices value is too small\"); this._vertices = vertices; _adj = new LinkedBagNet\u003cint\u003e[vertices]; for (int i = 0; i \u003c vertices; i++) { _adj[i] = new LinkedBagNet\u003cint\u003e(); } int edge = int.Parse(stream.ReadLine()); if (edge \u003c 1) throw new ArgumentException(\"this edges is too small\"); for (int i = 0; i \u003c edge; i++) { string line = stream.ReadLine(); if (!string.IsNullOrEmpty(line) \u0026\u0026 line.Split(' ').Count() == 2) { int v =int.Parse( line.Split(' ')[0]); int w =int.Parse( line.Split(' ')[1]); validateVertex(v); validateVertex(w); AddEdge(v, w); } } } catch (Exception ex) { throw new ArgumentException(\"this readstream is not legitimate\"); } } public Graph(Graph graph) { this._vertices = graph._vertices; this._edge = graph._edge; if(_vertices\u003c1) throw new ArgumentException(\"this vertices is too small\"); _adj=new LinkedBagNet\u003cint\u003e[_vertices]; for (int i = 0; i \u003c _vertices; i++) { _adj[i]=new LinkedBagNet\u003cint\u003e(); } for (int i = 0; i \u003c _vertices; i++) { foreach (var value in graph._adj[i]) { _adj[i].Add(value); } } } private void validateVertex(int v) { if (v \u003c 0 || v \u003e _vertices) throw new ArgumentException(\"this v does not in range\"); } public void AddEdge(int v, int w) { validateVertex(v); validateVertex(w); _edge++; _adj[v].Add(w); _adj[w].Add(v); } public int Degree(int v) { validateVertex(v); return _adj[v].Length; } } ","date":"2020-12-16","objectID":"/2020/12/algorithm6/:3:0","tags":["算法","无向图"],"title":"算法 图 无向图","uri":"/2020/12/algorithm6/"},{"categories":"算法","content":"图生成器\rpublic static class GraphGenerator { private class Edge : IComparable\u003cEdge\u003e { private int _v; private int _w; public Edge(int v, int w) { if (v \u003c w) { this._v = v; this._w = w; } else { this._v = w; this._w = v; } } public int CompareTo(Edge other) { if (ReferenceEquals(this, other)) return 0; if (ReferenceEquals(null, other)) return 1; var vComparison = _v.CompareTo(other._v); if (vComparison != 0) return vComparison; var wComparison = _w.CompareTo(other._w); if (wComparison != 0) return wComparison; return 0; } } /// \u003csummary\u003e /// 生成简单图 /// \u003c/summary\u003e /// \u003cparam name=\"V\"\u003e顶点数量\u003c/param\u003e /// \u003cparam name=\"E\"\u003e边的数量\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static Graph Simple(int V, int E) { if (E \u003e (long)V * (V - 1) / 2) throw new ArgumentException(\"Too many edges\"); if (E \u003c 0) throw new ArgumentException(\"Too few edges\"); Graph G = new Graph(V); List\u003cEdge\u003e set = new List\u003cEdge\u003e(); var random=new Random(); while (G.Edge \u003c E) { int v = random.Next(V); int w = random.Next(V); Edge e = new Edge(v, w); if ((v != w) \u0026\u0026 !set.Contains(e)) { set.Add(e); G.AddEdge(v, w); } } return G; } /// \u003csummary\u003e /// 生成简单图 /// \u003c/summary\u003e /// \u003cparam name=\"V\"\u003e顶点的数量\u003c/param\u003e /// \u003cparam name=\"p\"\u003e选择边的概率\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static Graph Simple(int V, double p) { if (p \u003c 0.0 || p \u003e 1.0) throw new ArgumentException(\"Probability must be between 0 and 1\"); Graph G = new Graph(V); for (int v = 0; v \u003c V; v++) for (int w = v + 1; w \u003c V; w++) if (new Random().NextDouble()\u003cp) G.AddEdge(v, w); return G; } public static Graph Complete(int V) { return Simple(V, 1.0); } /// \u003csummary\u003e /// 在V1和V2顶点上返回完整的二分图 /// \u003c/summary\u003e /// \u003cparam name=\"V1\"\u003e\u003c/param\u003e /// \u003cparam name=\"V2\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static Graph CompleteBipartite(int V1, int V2) { return Bipartite(V1, V2, V1 * V2); } /// \u003csummary\u003e /// /// \u003c/summary\u003e /// \u003cparam name=\"V1\"\u003e\u003c/param\u003e /// \u003cparam name=\"V2\"\u003e\u003c/param\u003e /// \u003cparam name=\"E\"\u003e边数\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static Graph Bipartite(int V1, int V2, int E) { if (E \u003e (long)V1 * V2) throw new ArgumentException(\"Too many edges\"); if (E \u003c 0) throw new ArgumentException(\"Too few edges\"); Graph G = new Graph(V1 + V2); int[] vertices = new int[V1 + V2]; for (int i = 0; i \u003c V1 + V2; i++) vertices[i] = i; vertices.Shuffle(); List\u003cEdge\u003e set = new List\u003cEdge\u003e(); Random randon=new Random(); while (G.Edge \u003c E) { int i = randon.Next(V1); int j = V1 + randon.Next(V2); Edge e = new Edge(vertices[i], vertices[j]); if (!set.Contains(e)) { set.Add(e); G.AddEdge(vertices[i], vertices[j]); } } return G; } public static Graph Bipartite(int V1, int V2, double p) { if (p \u003c 0.0 || p \u003e 1.0) throw new ArgumentException(\"Probability must be between 0 and 1\"); int[] vertices = new int[V1 + V2]; for (int i = 0; i \u003c V1 + V2; i++) vertices[i] = i; vertices.Shuffle(); Graph G = new Graph(V1 + V2); for (int i = 0; i \u003c V1; i++) for (int j = 0; j \u003c V2; j++) if (new Random().NextDouble() \u003c p) G.AddEdge(vertices[i], vertices[V1 + j]); return G; } /// \u003csummary\u003e /// /// \u003c/summary\u003e /// \u003cparam name=\"V\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static Graph Path(int V) { Graph G = new Graph(V); int[] vertices = new int[V]; for (int i = 0; i \u003c V; i++) vertices[i] = i; vertices.Shuffle(); for (int i = 0; i \u003c V - 1; i++) { G.AddEdge(vertices[i], vertices[i + 1]); } return G; } /// \u003csummary\u003e /// 树图 /// \u003c/summary\u003e /// \u003cparam name=\"V\"\u003e顶点数\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static Graph BinaryTree(int V) { Graph G = new Graph(V); int[] vertices = new int[V]; for (int i = 0; i \u003c V; i++) vertices[i] = i; vertices.Shuffle(); for (int i = 1; i \u003c V; i++) { G.AddEdge(vertices[i], vertices[(i - 1) / 2]); } return G; } /// \u003csummary\u003e /// 环图 /// \u003c/summary\u003e /// \u003cparam name=\"V\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static Graph Cycle(int V) { Graph G = new Graph(V); int[] vertices = new int[V]; for (int i = 0; i \u003c V; i++) vertices[i] = i; vertices.Shuffle(); for (int i = 0; i \u003c V - 1; i++) { G.AddEdge(vertices[i], vertices[i + 1]); } G.AddEdge(vertices[V - 1], vertices[0]); r","date":"2020-12-16","objectID":"/2020/12/algorithm6/:4:0","tags":["算法","无向图"],"title":"算法 图 无向图","uri":"/2020/12/algorithm6/"},{"categories":"算法","content":"图的处理算法\r图的表示和实现是分开的 Search(Graph graph, int s)：找到和起点S连通的所有顶点。 Marked(int v)：v和s是连通的吗 从图中起点开始沿着路径到达其他顶点并标记每个路过的顶点。 ","date":"2020-12-16","objectID":"/2020/12/algorithm6/:5:0","tags":["算法","无向图"],"title":"算法 图 无向图","uri":"/2020/12/algorithm6/"},{"categories":"算法","content":"深度优先算法(DFS)\r查找所有节点\rTremaux搜索： 选择一条没有标记过的通道，在走过的路上铺一条绳子 标记所有第一次路过的路口和通道 当回退到路口已没有可走的通道时继续回退。 Tremaux可以保证找到一条路，但不能保证完全探索整张图。 深度优先搜索：利用递归遍历所有的边和顶点，在访问一个顶点时，将它标记为已访问，递归地访问它所有没有被标记过的邻居顶点。 命题A:深度优先搜索标记与起点连通的所有顶点所需的时间和顶点的度数之和成正比。 将图会化成单向通道，当V-W时，要么递归调用(w没有被标记过)，要么跳过这条边(w已经被标记过)，第二次从w-v遇到这条边，会忽略它，因为另一端v肯定被访问过。 深度搜索每条边都被访问两次，第一次访问标记，第二次访问会发现这个顶点被标记过。 深度优先搜索示例 0邻接表2，1，5，优先访问2， 2邻接表0，1，3，4，0标记过，然后访问1， 1邻接表0，2，都标记过，访问3的邻接标 3邻接表，5，4，2，先访问5，再访问4，2被标记过， 这边应该再检查2邻接表中的4，所有点都访问过。 需要解决的问题：两个给定的顶点是否连通？有多少个连通子图？ public class DepthFirstSearch { private bool[] _marked;//s-v的路径记录 private int _count;//连接到s的顶点数量 public int Count =\u003e _count; public DepthFirstSearch(Graph graph, int s) { _marked = new bool[graph.Vertices]; validateVertex(s); dfs(graph,s); } private void dfs(Graph G, int v) { _count++; _marked[v] = true;//访问过的节点为true foreach (int w in G.Adj[v]) { if (!_marked[w]) { dfs(G, w);//递归调用 } } } private void validateVertex(int v) { int V = _marked.Length; if (v \u003c 0 || v \u003e= V) throw new ArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1)); } public bool Marked(int v) { validateVertex(v); return _marked[v]; } } 测试 [TestMethod()] public void DepthFirstTest() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\tinyG.txt\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { AlgorithmEngine.Graph.Graph graph = new AlgorithmEngine.Graph.Graph(stream); Console.WriteLine($\"Graph vertices:{graph.Vertices}\"); DepthFirstSearch search = new DepthFirstSearch(graph, 1); for (int v = 0; v \u003c graph.Vertices; v++) { if(search.Marked(v)) Console.Write(v+\" \"); } } } //Graph vertices:13 //0 1 2 3 4 5 6 深度搜索：无递归 /// \u003csummary\u003e /// 深度优先算法,无递归 /// \u003c/summary\u003e public class NonrecursiveDFS { private bool[] _marked; public NonrecursiveDFS(Graph G, int s) { _marked = new bool[G.Vertices]; validateVertex(s); // 保存邻接表 IEnumerator[] adj = new IEnumerator\u003cint\u003e[G.Vertices]; for (int v = 0; v \u003c G.Vertices; v++) adj[v] = G.Adj.GetEnumerator(); // 需要一个额外的栈来存放节点 Stack\u003cint\u003e stack = new Stack\u003cint\u003e(); _marked[s] = true; stack.Push(s); while (stack.Any()) { int v = stack.Peek(); if (adj[v].MoveNext()) { int w =(int) adj[v].Current; if (!_marked[w]) { //标记节点 _marked[w] = true; stack.Push(w);//压栈 } } else { stack.Pop();//访问完该节点的所有邻接点，出栈 } } } public bool Marked(int v) { validateVertex(v); return _marked[v]; } private void validateVertex(int v) { int V = _marked.Length; if (v \u003c 0 || v \u003e= V) throw new ArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1)); } } 深度优先算法是查找所有的节点。 寻找所有路径\r通过添加实例变量edgeTo()整型数组来模仿Tremaux搜索中绳子的作用。它用来记录每个顶点到起点的路径。 public class DepthFirstPaths { private bool[] _marked; private int[] _edgeTo; /// \u003csummary\u003e /// start /// \u003c/summary\u003e private readonly int _start; public DepthFirstPaths(Graph G, int s) { this._start = s; _edgeTo = new int[G.Vertices]; _marked = new bool[G.Vertices]; validateVertex(s); dfs(G, s); } private void dfs(Graph G, int v) { _marked[v] = true; foreach(int w in G.Adj[v]) { if (!_marked[w]) { _edgeTo[w] = v;//通到w是v dfs(G, w); } } } public bool HasPathTo(int v) { validateVertex(v); return _marked[v]; } public IEnumerable\u003cint\u003e PathTo(int v) { validateVertex(v); if (!HasPathTo(v)) return null; Stack\u003cint\u003e path = new Stack\u003cint\u003e();//通过栈先进后出 for (int x = v; x != _start; x = _edgeTo[x]) path.Push(x); path.Push(_start); return path; } private void validateVertex(int v) { int V = _marked.Length; if (v \u003c 0 || v \u003e= V) throw new ArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1)); } } 测试代码： [TestMethod()] public void DepthFirstPathsTest() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\tinyG.txt\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { AlgorithmEngine.Graph.Graph graph = new AlgorithmEngine.Graph.Graph(stream); Console.WriteLine($\"Graph vertices:{graph.Vertices}\"); DepthFirstPaths dfs = new DepthFirstPaths(graph, 1); for (int v = 0; v \u003c graph.Vertices; v++) { if (dfs.HasPathTo(v)) { Console.Write($\"1 to {v}","date":"2020-12-16","objectID":"/2020/12/algorithm6/:5:1","tags":["算法","无向图"],"title":"算法 图 无向图","uri":"/2020/12/algorithm6/"},{"categories":"算法","content":"广度优先搜索(BFS)\r最短路径\r广度优先搜索(BFS)解决了单点最短路径的问题。 深度搜索就像一个人在走迷宫，广度搜索就像一组人在走迷宫，每个人都有绳子，当两个人相遇的时候，会合并使用较短绳子的那个人。 在深度搜索中，使用了LIFO（后进先出）栈来描述走过的路径。 在广度搜索中，按照距离与起点的距离的顺序来遍历所有顶点，使用FIFO先进先出队列来替换LIFO后进先出队列。 public class BreadthFirstPaths { private static readonly int INFINITY = int.MaxValue; private bool[] _marked; //到达该顶点的最短路径是否已知 private int[] _edgeTo; // edgeTo[v] = s 表示指向顶点v的顶点是s，也表示边s-V private int[] _distTo; // distTo[v] = s 表示s到达到v的边的数量 public BreadthFirstPaths(Graph G, int s) { _marked = new bool[G.Vertices]; _distTo = new int[G.Vertices]; _edgeTo = new int[G.Vertices]; validateVertex(s); bfs(G, s); } public BreadthFirstPaths(Graph G, IEnumerable\u003cint\u003e sources) { _marked = new bool[G.Vertices]; _distTo = new int[G.Vertices]; _edgeTo = new int[G.Vertices]; for (int v = 0; v \u003c G.Vertices; v++) _distTo[v] = INFINITY; validateVertices(sources); bfs(G, sources); } private void bfs(Graph G, int s) { Queue\u003cint\u003e q = new Queue\u003cint\u003e(); for (int v = 0; v \u003c G.Vertices; v++) _distTo[v] = INFINITY; _distTo[s] = 0; _marked[s] = true; q.Enqueue(s); while (q.Any()) { int v = q.Dequeue(); foreach (int w in G.Adj[v]) { if (!_marked[w]) { _edgeTo[w] = v; _distTo[w] = _distTo[v] + 1; _marked[w] = true; q.Enqueue(w); } } } } private void bfs(Graph G, IEnumerable\u003cint\u003e sources) { Queue\u003cint\u003e q = new Queue\u003cint\u003e(); foreach (int s in sources) { _marked[s] = true; _distTo[s] = 0; q.Enqueue(s); } while (q.Any()) { int v = q.Dequeue(); foreach (int w in G.Adj[v]) { if (!_marked[w]) { _edgeTo[w] = v; _distTo[w] = _distTo[v] + 1; _marked[w] = true; q.Enqueue(w); } } } } public bool HasPathTo(int v) { validateVertex(v); return _marked[v]; } public int DistTo(int v) { validateVertex(v); return _distTo[v]; } public IEnumerable\u003cint\u003e PathTo(int v) { validateVertex(v); if (!HasPathTo(v)) return null; Stack\u003cint\u003e path = new Stack\u003cint\u003e(); int x; for (x = v; _distTo[x] != 0; x = _edgeTo[x]) path.Push(x); path.Push(x); return path; } private void validateVertex(int v) { int V = _marked.Length; if (v \u003c 0 || v \u003e= V) throw new ArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1)); } private void validateVertices(IEnumerable\u003cint\u003e vertices) { if (vertices == null) { throw new ArgumentException(\"argument is null\"); } int V = _marked.Length; foreach (int v in vertices) { if (v \u003c 0 || v \u003e= V) { throw new ArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1)); } } } } 测试： [TestMethod()] public void BreadthFirstPathsTest() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\tinyG.txt\"); Console.WriteLine(data); using (StreamReader stream = new StreamReader(data)) { AlgorithmEngine.Graph.Graph G = new AlgorithmEngine.Graph.Graph(stream); int s =1; BreadthFirstPaths bfs = new BreadthFirstPaths(G, s); for (int v = 0; v \u003c G.Vertices; v++) { if (bfs.HasPathTo(v)) { Console.Write($\"{s} to {v} ({bfs.DistTo(v)}): \"); foreach (int x in bfs.PathTo(v)) { if (x == s) Console.Write(x); else Console.Write(\"-\" + x); } Console.Write(System.Environment.NewLine); } else { Console.Write($\"{s} to{v} (-): not connected\\n\"); } } } //1 to 0(1): 1 - 0 //1 to 1(0): 1 //1 to 2(2): 1 - 0 - 2 //1 to 3(3): 1 - 0 - 5 - 3 //1 to 4(3): 1 - 0 - 6 - 4 //1 to 5(2): 1 - 0 - 5 //1 to 6(2): 1 - 0 - 6 //1 to7(-): not connected //1 to8(-): not connected //1 to9(-): not connected //1 to10(-): not connected //1 to11(-): not connected //1 to12(-): not connected } 命题B:对于从S可达的任意顶点V,edgeTo[]数组在第二步之后就已经完成了。和深度优先搜索一样，一旦所有的顶点都已经被标记，余下的计算工作就只是在检查连接到各个已被标记的顶点的边而已。 命题B:广度搜索所需的时间在最坏情况下和V+E成正比。 二分图\r/// \u003csummary\u003e /// 使用广度优先搜索 /// \u003c/summary\u003e public class BipartiteX { private static readonly bool WHITE = false; private static readonly bool BLACK = true; private bool _isBipartite; private bool[] _color; private bool[] _marked; private int[] _edgeTo; private Queue\u003cint\u003e _cycle; public bool IsBipartite =\u003e _isBipartite; public BipartiteX(Graph G) { _isBipartite = true; _color = new bool[G.Vertices]; _marked = new bool[G.Vertices]; _edgeTo = new int[G.Vertices]; for (int v = 0; v \u003c G.Vertices \u0026\u0026 _isBip","date":"2020-12-16","objectID":"/2020/12/algorithm6/:5:2","tags":["算法","无向图"],"title":"算法 图 无向图","uri":"/2020/12/algorithm6/"},{"categories":"算法","content":"深度搜索和广度搜索\r深度优先：不断深入图，栈中保存了所有分叉的顶点 广度优先：像扇面扫描一样，队列中保存了所有访问过的最前端节点。 连通分量\r深度搜索比Union-Find快，但实际Union-Find更快，因为Union-Find不需要完整构建整个图， 当只需要判断连通性，需要有大量连通性查询和插入混合操作时，推荐使用Union-Find算法 当需要图的抽象数据类型的时候，推荐使用深度优先。 ","date":"2020-12-16","objectID":"/2020/12/algorithm6/:5:3","tags":["算法","无向图"],"title":"算法 图 无向图","uri":"/2020/12/algorithm6/"},{"categories":"算法","content":"符号图\r在实际使用中，图都是通过文件和网页定义了，使用的是字符串来代替顶点。 顶点为字符串 用指定分隔符来隔开顶点名 每一行都表示一组边的集合。 顶点总数V和边的总数都是隐式定义的。 public class SymbolGraph { private ST\u003cString, int\u003e _st; //符号名-索引 private String[] _keys; // 索引-符号名 private Graph _graph; // 图 public SymbolGraph(String filename, String delimiter) { _st = new ST\u003cString, int\u003e(); var stream = new StreamReader(filename); while (!stream.EndOfStream) {//第一遍构造顶点 String[] a = stream.ReadLine().Split(delimiter.ToCharArray()); for (int i = 0; i \u003c a.Length; i++) { if (!_st.Contains(a[i]))//为每个不同的字符串关联一个索引 _st.Add(a[i], _st.Count()); } } _keys = new String[_st.Count()];//用来获得顶点名的反向索引是一个数组 foreach (String name in _st.Keys()) { _keys[_st.Get(name)] = name; } _graph = new Graph(_st.Count()); stream = new StreamReader(filename);//第二遍构造边 while (!stream.EndOfStream) { String[] a = stream.ReadLine().Split(delimiter.ToCharArray());//将每一行的顶点和该行的其他顶点相连 int v = _st.Get(a[0]); for (int i = 1; i \u003c a.Length; i++) { int w = _st.Get(a[i]); _graph.AddEdge(v, w); } } } public bool Contains(String s) { return _st.Contains(s); } public int Index(String s) { return _st.Get(s); } public int IndexOf(String s) { return _st.Get(s); } public String Name(int v) { validateVertex(v); return _keys[v]; } public String NameOf(int v) { validateVertex(v); return _keys[v]; } public Graph Graph() { return _graph; } private void validateVertex(int v) { int V = _graph.Vertices; if (v \u003c 0 || v \u003e= V) throw new ArgumentException(\"vertex \" + v + \" is not between 0 and \" + (V - 1)); } } 测试： [TestMethod()] public void SymbolGraph() { var data = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\\\\routes.txt\"); SymbolGraph sg = new SymbolGraph(data, \" \"); AlgorithmEngine.Graph.Graph graph = sg.Graph(); StreamReader reader=new StreamReader(data); while (!reader.EndOfStream) { String source = reader.ReadLine().Split(' ')[0]; if (sg.Contains(source)) { Console.Write($\"{source} :\"); int s = sg.Index(source); foreach (int v in graph.Adj[s]) { Console.Write(\" \" + sg.Name(v)); } } else { Console.WriteLine(\"input not contain '\" + source + \"'\"); } Console.WriteLine(); } // JFK: ORD ATL MCO // ORD : ATL JFK PHX DFW HOU DEN // ORD: ATL JFK PHX DFW HOU DEN // DFW: HOU ORD PHX // JFK : ORD ATL MCO // ORD : ATL JFK PHX DFW HOU DEN // ORD: ATL JFK PHX DFW HOU DEN // ATL: MCO ORD HOU JFK // DEN: LAS PHX ORD // PHX : LAS LAX DEN ORD DFW // JFK : ORD ATL MCO // DEN : LAS PHX ORD // DFW : HOU ORD PHX // ORD : ATL JFK PHX DFW HOU DEN // LAS: PHX LAX DEN // ATL : MCO ORD HOU JFK // HOU: MCO DFW ATL ORD // LAS: PHX LAX DEN } ","date":"2020-12-16","objectID":"/2020/12/algorithm6/:5:4","tags":["算法","无向图"],"title":"算法 图 无向图","uri":"/2020/12/algorithm6/"},{"categories":"算法","content":"查找\r统计多本书中每个单词出现的频率，使用符号表(字典)，但是怎么快速定位到Key是一个难题，当Key数据量上亿了之后还能快速定位吗 查找的成本模型：比较次数，数组的访问次数 ","date":"2020-12-15","objectID":"/2020/12/algorithm5/:1:0","tags":["算法","字典"],"title":"算法 字典","uri":"/2020/12/algorithm5/"},{"categories":"算法","content":"字典\rpublic interface ISearchDict\u003cTKey, TValue\u003e : IDisposable { bool IsEmpty { get; } int Length { get; } bool Contains(TKey key); TValue this[TKey key] { get;set; } TValue Get(TKey key); void Add(TKey key, TValue value); void Delete(TKey key); } ","date":"2020-12-15","objectID":"/2020/12/algorithm5/:2:0","tags":["算法","字典"],"title":"算法 字典","uri":"/2020/12/algorithm5/"},{"categories":"算法","content":"无序链表字典顺序查找\r值得注意的是：这边使用递归实现删除，这个设计非常巧妙 public class SequentialSearchSTNet\u003cTKey, TValue\u003e : ISearchDict\u003cTKey, TValue\u003e { private int _length; private Node _first; private class Node:IDisposable { public TKey Key { set; get; } public TValue Value { set; get; } public Node Next { set; get; } public Node(TKey key,TValue value,Node next) { Key = key; Value = value; Next = next; } public void Dispose() { Dispose(true); } protected virtual void Dispose(bool disposing) { if(disposing) { Key = default; Value = default; } } } public SequentialSearchSTNet() { _length = 0; _first = null; } public bool IsEmpty =\u003e _length==0; public int Length =\u003e _length; public void Add(TKey key, TValue value) { if (key == default || value == default) throw new ArgumentNullException(\"this key or value is default value\"); if(_first!=null) { for (Node x = _first; x != null; x = x.Next) { if (key.Equals(x.Key)) { x.Value = value; return; } } } _first = new Node(key, value, _first); _length++; } public bool Contains(TKey key) { if (key == default) throw new ArgumentNullException(\" this key is default value\"); if(!IsEmpty) { for(Node x=_first;x!=null;x=x.Next) { if(key.Equals(x.Key)) { return true; } } } return false; } public TValue Get(TKey key) { if (key == default||IsEmpty) return default; for(var x =_first;x!=null;x=x.Next) { if (key.Equals(x.Key)) return x.Value; } return default; } public TValue this[TKey key] { get =\u003e Get(key); set =\u003e Add(key,value); } public void Delete(TKey key) { if (key == default) throw new ArgumentNullException(\" this key is default value\"); _first = delete(_first, key); } /// \u003csummary\u003e /// 通过递归实现删除结点，这个设计非常巧妙 /// \u003c/summary\u003e /// \u003cparam name=\"x\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e private Node delete(Node x,TKey key) { if (x == null) return null; if(key.Equals(x.Key)) { _length--; return x.Next; } x.Next = delete(x.Next, key);//这边非常巧妙的跳过了当前个,delete方法如果next是要删除对象就返回了x.next.next,如果不是就返回x.next; return x; } public void Dispose() { Dispose(true); } protected virtual void Dispose(bool disposing) { if (disposing) { if (!IsEmpty) { for (var x = _first; x != null; x = x.Next) { x.Dispose(); } _length = 0; _first = null; } } } } 命题A:在含有N对键值的基于(无序)链表的符号表中，未命中的查找和插入操作都需要N次比较。命中的查找在最坏情况下需要N次比较。特别的，向一个空表插入N个不同的键需要~N^2/2次比较。 推论：向一个空表中插入N个不同的键需要~N^2/2次比较。 ","date":"2020-12-15","objectID":"/2020/12/algorithm5/:2:1","tags":["算法","字典"],"title":"算法 字典","uri":"/2020/12/algorithm5/"},{"categories":"算法","content":"有序数组字典二分查找\r有序字典的查找效率肯定高的多。 public interface IBinarySearchDict\u003cTKey,TValue\u003e: ISearchDict\u003cTKey, TValue\u003e { int Capacity { get; } /// \u003csummary\u003e /// 找到key对应的Index /// \u003c/summary\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e int Rank(TKey key); void DeleteMin(); void DeleteMax(); TKey Min(); TKey Max(); TKey Floor(TKey key); TKey Ceiling(TKey key); } public class BinarySearchSTNet\u003cTKey, TValue\u003e : IBinarySearchDict\u003cTKey, TValue\u003e where TKey : IComparable { private int _length; private int _capacity; private TKey[] _keys; private TValue[] _values; public BinarySearchSTNet():this(2) { } public BinarySearchSTNet(int capacity) { _capacity = capacity; _keys = new TKey[capacity]; _values = new TValue[capacity]; _length = 0; } public TValue this[TKey key] { get =\u003e Get(key); set =\u003e Add(key,value); } public bool IsEmpty =\u003e _length==0; public int Length =\u003e _length; public int Capacity =\u003e _capacity; private void resize(int capacity) { if (capacity \u003c _length) throw new ArgumentException(\"this capacity is less than length\"); var temkey = new TKey[capacity]; var temvalue = new TValue[capacity]; for(int i=0;i\u003c_length;i++) { temkey[i] = _keys[i]; temvalue[i] = _values[i]; } _keys = temkey; _values = temvalue; } public void Add(TKey key, TValue value) { if (key == default) throw new ArgumentException(\"this key is default\"); if (value == default) { Delete(key); return; } int i = Rank(key); if(i\u003c_length \u0026\u0026 _keys[i].CompareTo(key)==0) { _values[i] = value; } if (_length == _keys.Length) resize(2 * _keys.Length); for (int j = _length; j \u003e i; j--) { _keys[j] = _keys[j - 1]; _values[j] = _values[j - 1]; } _keys[i] = key; _values[i] = value; _length++; } public bool Contains(TKey key) { if (key == default||IsEmpty) return false; int i = Rank(key); if (i \u003c _length \u0026\u0026 key.CompareTo(_keys[i]) == 0) return true; return false; } public void Delete(TKey key) { if (key == default) return; if(Contains(key)) { int i = Rank(key); for(int j=i;j\u003c_length-1;j++) { _keys[j] = _keys[j + 1]; _values[j] = _values[j + 1]; } _keys[_length - 1] = default; _values[_length - 1] = default; _length--; if (_length\u003e0\u0026\u0026_length == _keys.Length / 4) resize(_keys.Length / 2); } } public void DeleteMax() { if (!IsEmpty) Delete(Max()); } public void DeleteMin() { if (!IsEmpty) Delete(Min()); } public void Dispose() { throw new NotImplementedException(); } protected virtual void Dispose(bool disposing) { if(disposing) { if(!IsEmpty) { for(int i=0;i\u003c_length;i++) { _keys[i] = default; _values[i] = default; } _length = 0; _keys = null; _values = null; } } } public TKey Ceiling(TKey key) { if (key == default) return default; int i = Rank(key); if (i == _length) return default; return _keys[i]; } public TKey Floor(TKey key) { if (key == default) return default; int i = Rank(key); if (i \u003c _length \u0026\u0026 key.CompareTo(_keys[i]) == 0) return _keys[i]; if (i == 0) return default; return _keys[i - 1]; } public TValue Get(TKey key) { if (key == default || IsEmpty) return default; int i = Rank(key); if (i \u003c _length \u0026\u0026 _keys[i].CompareTo(key) == 0) return _values[i]; return default; } public TKey Max() { if (!IsEmpty) return _keys[_length - 1]; return default; } public TKey Min() { if (!IsEmpty) return _keys[0]; return default; } /// \u003csummary\u003e /// 秩，key所在的等级,使用迭代 /// \u003c/summary\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public int Rank(TKey key) { if (key == default) throw new ArgumentException(\"this key is default\"); int lo = 0; int hi = _length - 1; while(lo\u003c=hi) { int mid = lo + (hi - lo) / 2; int cmp = key.CompareTo(_keys[mid]); if (cmp \u003c 0) hi = mid - 1; else if (cmp \u003e 0) lo = mid + 1; else return mid; } return lo; } } 命题B：在N个键的有序数组中进行二分查找最多需要（lgN+1）次比较（无论是否成功）。 缺点:Add太慢了，基于有序数组的字典所需要访问数组的次数是数组长度的平方级别。 命题B(续):向大小为N的有序数组中插入一个新的元素在最坏情况下需要访问2N次数组，向空字典中插入N个元素在最坏情况下需要访问N^2次数组。 查找是LgN是目标之一，但是插入是2N似乎代价太大了，要支持高效的插入，似乎链式结构可以满足，但是链式结构是无法使用二分查找的。那么二叉查找树似乎就是我们一直追寻的目标。 ","date":"2020-12-15","objectID":"/2020/12/algorithm5/:2:2","tags":["算法","字典"],"title":"算法 字典","uri":"/2020/12/algorithm5/"},{"categories":"算法","content":"二叉查找树\r二叉树中，每个结点只有一个父结点指向自己，每个结点都只有左右两个链接。分别指向左子结点和右子结点。 二叉树的定义：每个结点都含有一个Comparable的键（以及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。 计数器\r插入\r查找\r最好和最坏的情况\r命题C:在由N个随机键构造的二叉查找树，查找命中平均所需的比较次数为~2InN（约1.39lgN） 命题D:在由N个随机键构造的二叉查找树中插入操作和查找未命中平均所需的比较次数未~2InN（1.39lgN）. Floor\r主要就是更新结点指向 命题E：在一颗二叉查找树中，所有操作的最坏情况下所需的事件都和树 的高度成正比。 /// \u003csummary\u003e /// Get,Add,Delete等都使用递归 /// \u003c/summary\u003e /// \u003ctypeparam name=\"TKey\"\u003e\u003c/typeparam\u003e /// \u003ctypeparam name=\"TValue\"\u003e\u003c/typeparam\u003e public class BSTNet\u003cTKey, TValue\u003e : IBSTSearchDict\u003cTKey, TValue\u003e where TKey : IComparable { private class Node { public TKey Key { set; get; } public TValue Value { set; get; } public Node Left { set; get; } public Node Right { set; get; } /// \u003csummary\u003e /// 每个结点计数器，每个结点下拥有结点的数量，包含自己 /// \u003c/summary\u003e public int Length { set; get; } public Node(TKey key,TValue value,int length) { this.Key = key; this.Value = value; this.Length = length; } } public BSTNet() { _root = null; } private Node _root; public TValue this[TKey key] { get =\u003e Get(key); set =\u003e Add(key,value); } public bool IsEmpty =\u003e length()==0; public int Length =\u003e length(); private int length() { return length(_root); } private int length(Node node) { if (node == null) return 0; else return node.Length; } private int length(TKey lo, TKey hi) { if (lo == default) throw new ArgumentException(\"this low key is default\"); if (hi == default) throw new ArgumentException(\"this high is default\"); if (lo.CompareTo(hi) \u003e 0) return 0; if (Contains(hi)) return Rank(hi) - Rank(lo) + 1; else return Rank(hi) - Rank(lo); } public int Rank(TKey key) { if (key == default) throw new ArgumentException(\"this key is default\"); return rank(key, _root); } private int rank(TKey key, Node node) { if (node == null) return 0; int cmp = key.CompareTo(node.Key); if (cmp \u003c 0) return rank(key, node.Left); else if (cmp \u003e 0) return 1 + length(node.Left) + rank(key, node.Right); else return length(node.Left); } public bool Contains(TKey key) { if (key == default) throw new ArgumentException(\"this key is default value\"); return Get(key) != default; } public TValue Get(TKey key) { return get(_root, key); } private TValue get(Node node,TKey key) { if (key == default || node == null) return default; int cmp = key.CompareTo(node.Key); if (cmp \u003c 0) return get(node.Left, key); if (cmp \u003e 0) return get(node.Right, key); return node.Value; } public void Add(TKey key, TValue value) { if (key == default) throw new ArgumentException(\"this key is default value\"); if (value == default) { Delete(key); return; } _root = add(_root,key,value); } /// \u003csummary\u003e /// 使用了递归，所有查询的结点计数器都+1； /// \u003c/summary\u003e /// \u003cparam name=\"node\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e private Node add(Node node,TKey key,TValue value) { if (node == null) return new Node(key, value, 1); int cmp = key.CompareTo(node.Key); if (cmp \u003c 0) node.Left = add(node.Left, key, value);//追加到结点左边 if (cmp \u003e 0) node.Right = add(node.Right, key, value);//追加到结点右边 else node.Value = value; node.Length = 1 + length(node.Left) + length(node.Right);//计数器自增 return node; } public TKey Ceiling(TKey key) { if (key == default || IsEmpty) return default; Node tem = ceiling(_root, key); if (tem == null) throw new ArgumentException(\"this key is too large\"); else return tem.Key; } private Node ceiling(Node node,TKey key) { if (node == null) return null; int cmp = key.CompareTo(node.Key); if (cmp == 0) return node; if(cmp\u003c0) { Node tem = ceiling(node.Left, key); if (tem != null) return tem; else return node; } return ceiling(node.Right, key); } public void Delete(TKey key) { if (key == default) return; _root = delete(_root, key); } private Node delete(Node node,TKey key) { if (node == null || key == default) return default; int cmp = key.CompareTo(node.Key); if (cmp \u003c 0) node.Left = delete(node.Left, key); else if (cmp \u003e 0) node.Right = delete(node.Right, key); else { //该结点就是删除的结点 if (node.Right == null) return node.Left; else if (node.Left == null) return node.Right; else { Node tem = node;","date":"2020-12-15","objectID":"/2020/12/algorithm5/:2:3","tags":["算法","字典"],"title":"算法 字典","uri":"/2020/12/algorithm5/"},{"categories":"算法","content":"平衡查找树(2-3查找树)\r二叉查找树最坏的情况还是很糟糕的，平衡查找树可以有效解决这个问题，无论数组的初始状态如何，它的运行时间都是对数级别的。 定义：一颗2-3查找树由以下结点组成： 2-结点，含有一个键和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树种的键都大于该结点。 3-结点，含有两个键（及其对应的值）和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树种的键都位于该结点的两个键之间。右链接指向的2-3树的键都大于该结点。 一颗完美平衡的2-3查找树种的所有空连接到根结点的距离都应该是相同的。 查找\r插入\r先进行一次未命中的查找，然后把新结点挂在树的底部，如果未命中的查找结束于一个2-结点，就将2-结点换成3-结点。如果未命中的查找结束于一个3-结点，就先将3-结点换成4-结点，然后转换成2-3树。 4结点转换成2-3树要麻烦，如果4-结点的父结点是2-结点，那么4-结点就转换成一个3-结点和2个2-结点。 如果4-结点的父结点是2-结点，爷结点也是2-结点，那么就一次向上转换，直到根结点，然后树的根高就会加一。 分解4-结点一共有6种情况 4结点的分解不会影响树的有序性和平衡性 命题F:在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过lgN个。 含有10亿个结点的一颗2-3树的高度仅在19-30之间，最后访问30个结点就能够在10亿个键中进行任意插入和查找。 ","date":"2020-12-15","objectID":"/2020/12/algorithm5/:2:4","tags":["算法","字典"],"title":"算法 字典","uri":"/2020/12/algorithm5/"},{"categories":"算法","content":"红黑二叉查找树(红黑树)\r通过红链接将2-3查找树的3-结点变成两个2结点的链接。 红黑树的定义： 红链接均为左链接 没有任何一个结点同时和两条红链接相连。 该树是一个完美黑色平衡树，任意空连接到根结点的路径上的黑链接数量相同。 如果将红链接画平 结点中通过一个属性Color来判定指向该结点是红色还是黑色。同时约定空连接为黑色 旋转\r左旋转：右链接转化为左链接 2-结点插入\r3-结点插入\r有三种情况，通过0次，1次，2次旋转以及颜色的变化得到期望的结果。 颜色变化\r底部插入\r插入总结\r删除最小键\r如果查找的键在最底部，可以直接删除它。 如果不在最底部，就需要和后继结点交换。问题就可以转换成在一棵根结点不是2-结点的子树中删除最小的键。 命题G:一棵大小为N的红黑树的高度不会超过2lgN 命题H:一棵大小为N的红黑树中，根结点到任意结点的平均路径长度为~1.00LgN。 命题I:在一棵红黑树中，以下操作在最坏情况下所需的时间是对数级别：查找，插入，查找最小键，查找最大键，floor，ceiling,rank,select(),删除最小键，删除最大键，删除，范围查询。 千亿的数据量十几次比较就可以找到。 public class RedBlackBSTNet\u003cTKey, TValue\u003e : IRedBlackBST\u003cTKey, TValue\u003e where TKey : IComparable\u003cTKey\u003e { private static readonly bool RED = true; private static readonly bool BLACK = false; private Node _root; private class Node { public TKey Key { set; get; } public TValue Value { set; get; } public Node Right { set; get; } public Node Left { set; get; } /// \u003csummary\u003e /// 指向该结点的颜色 /// \u003c/summary\u003e public bool Color { set; get; } /// \u003csummary\u003e /// 该结点下的结点量，包括本结点 /// \u003c/summary\u003e public int Length { set; get; } public Node(TKey key,TValue value,bool color,int length) { this.Key = key; this.Value = value; this.Color = color; this.Length = length; } } public RedBlackBSTNet() { } /// \u003csummary\u003e /// 默认空结点是黑色 /// \u003c/summary\u003e /// \u003cparam name=\"node\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e private bool isRed(Node node) { if (node == null) return false; return node.Color == RED; } private int length(Node node) { if (node == null) return 0; return node.Length; } private int length() { return length(_root); } public TValue this[TKey key] { get =\u003eGet(key); set =\u003e Add(key,value); } public bool IsEmpty =\u003e _root==null; public int Length =\u003e length(); public void Add(TKey key, TValue value) { if (key == default) return; if (value == default) { Delete(key); return; } _root = add(_root, key, value); _root.Color = BLACK; } /// \u003csummary\u003e /// 这边在递归的上一层修改了颜色 /// \u003c/summary\u003e /// \u003cparam name=\"node\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e private Node add(Node node,TKey key,TValue value) { if (node == null) return new Node(key, value, RED, 1);//新增结点都是3-结点 int cmp = key.CompareTo(node.Key); if (cmp \u003c 0) node.Left = add(node.Left, key, value); else if (cmp \u003e 0) node.Right = add(node.Right, key, value); else node.Value = value; //修改颜色，让所有的红色结点都是左节点，直接看插入总结 if (isRed(node.Right) \u0026\u0026 !isRed(node.Left)) node = rotateLeft(node);//右边是红色，左边不是红色 if (isRed(node.Left) \u0026\u0026 isRed(node.Left.Left)) node = rotateRight(node);//如果左边是红色，左边的左边也是红色 if (isRed(node.Left) \u0026\u0026 isRed(node.Right)) flipColors(node);//如果左右连边都是红色 node.Length = length(node.Left) + length(node.Right) + 1; return node; } /// \u003csummary\u003e /// 翻转颜色,三个结点颜色全部反转 /// \u003c/summary\u003e /// \u003cparam name=\"node\"\u003e\u003c/param\u003e private void flipColors(Node node) { //node must have opposite color of its two children node.Color = !node.Color; node.Left.Color = !node.Left.Color; node.Right.Color = !node.Right.Color; } /// \u003csummary\u003e /// 红左链接变成红右连接，node-\u003eh,tem-\u003ex /// \u003c/summary\u003e /// \u003cparam name=\"node\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e private Node rotateRight(Node h) { Node x = h.Left; h.Left = x.Right; x.Right = h; x.Color = x.Right.Color; x.Right.Color = RED; x.Length = h.Length; h.Length = length(h.Left) + length(h.Right) + 1; return x; } /// \u003csummary\u003e /// 红右连接变成左连接 /// \u003c/summary\u003e /// \u003cparam name=\"h\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e private Node rotateLeft(Node h) { Node x = h.Right; h.Right = x.Left; x.Left = h; x.Color = x.Left.Color; x.Left.Color = RED; x.Length = h.Length; h.Length = length(h.Left) + length(h.Right) + 1; return x; } public TKey Ceiling(TKey key) { if (key == default || IsEmpty) return default; Node node = ceiling(_root, key); if (node == null) throw new ArgumentException(\"this key is too small\"); else return node.Key; } private Node ceiling(Node node,TKey key) { if (node == null) return null; int cmp = key.CompareTo(node.Key); if (cmp == 0) return node; if(cmp\u003e0) return ceiling(node.Right, key); Node tem = ceiling(node.Left, key); if (tem != null) return tem; else return node; ","date":"2020-12-15","objectID":"/2020/12/algorithm5/:2:5","tags":["算法","字典"],"title":"算法 字典","uri":"/2020/12/algorithm5/"},{"categories":"算法","content":"散列表(哈希表)\r如果所有的键都是小整数，可以用一个数组来实现无序的符号表，将键作为数组的索引而数组中键i处储存的就是它对应的值。用算术操作将键转化为数组的索引来访问数组中的键值对。 用散列函数将被查找的键转化为数组的一个索引。 处理碰撞和冲突过程，有两个方法：拉链法和线性探测法。 散列表是时间和空间上作出权衡的例子，如果没有内存限制，可以直接将键作为数组的索引，查找操作只需要访问内存一次就可以完成。 概率论是数学分析重大成果，使用散列标，可以实现在一般应用中有常数级别的查找和插入操作的符号表。 散列函数\r将key转化为[0-M]内的整数。 转化的整数在[0-(M-1)]上是均匀分布的。 余留法\r使用素数余留法 HashCode\r将hashcode的返回值转化为数组的索引。通过hashcode和余留发结合起来产生0到M-1的整数。 private int hash(Key x) { return (x.hashCode() \u0026 0x7fffffff) \u0026 M } 软缓存\r将每个键的散列值缓存起来，这样减少计算散列值的时间 一致性，高校性，均匀性 假设J:使用散列函数能够均匀并独立地将所有的键散布于0到M-1之间。 处理碰撞\r拉链法\r将M的数组中每个元素指向一个链表。链表中每个结点都存储了散列值为该元素的索引键值对。 需要M足够大，这样链表就比较小。 命题K:在一张含有M条链表和N个键的散列表中，任意一条链表中的键的数量均在N/M的常数因子范围内的概率无限趋向于1。 性质L:在一张含有M条链表和N个键的散列表中，未命中查找和插入操作所需的比较次数为~N/M public class SeparateChainingHashSTNet\u003cTKey, TValue\u003e { private static readonly int INIT_CAPACITY = 4; private int _length; private int _capacity; private SequentialSearchSTNet\u003cTKey, TValue\u003e[] st; public int Length =\u003e _length; public int Capacity =\u003e _capacity; public SeparateChainingHashSTNet(): this(INIT_CAPACITY) { } public SeparateChainingHashSTNet(int capacity) { this._capacity = capacity; st =new SequentialSearchSTNet\u003cTKey,TValue\u003e[capacity]; for (int i = 0; i \u003c capacity; i++) st[i] = new SequentialSearchSTNet\u003cTKey, TValue\u003e(); } private void resize(int chains) { SeparateChainingHashSTNet\u003cTKey, TValue\u003e temp = new SeparateChainingHashSTNet\u003cTKey, TValue\u003e(chains); for (int i = 0; i \u003c _capacity; i++) { foreach (TKey key in st[i].Keys) { temp.Add(key, st[i].Get(key)); } } this._capacity = temp.Capacity; this._length = temp.Length; this.st = temp.st; } /// \u003csummary\u003e /// 计算散列值 /// \u003c/summary\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e private int hash(TKey key) { return (key.GetHashCode() \u0026 0x7fffffff) % _capacity; } public bool isEmpty() =\u003e Length == 0; public bool Contains(TKey key) { if (key == null) throw new ArgumentException(\"argument to contains() is null\"); return get(key) != null; } public TValue get(TKey key) { if (key == null) throw new ArgumentException(\"argument to get() is null\"); int i = hash(key); return st[i].Get(key); } public void Add(TKey key, TValue val) { if (key == null) throw new ArgumentException(\"first argument to put() is null\"); if (val == null) { delete(key); return; } if (_length \u003e= 10 * _capacity) resize(2 * _capacity); int i = hash(key); if (!st[i].Contains(key)) _length++; st[i].Add(key, val); } public void delete(TKey key) { if (key == null) throw new ArgumentException(\"argument to delete() is null\"); int i = hash(key); if (st[i].Contains(key)) _length--; st[i].Delete(key); if (_capacity \u003e INIT_CAPACITY \u0026\u0026 _length \u003c= 2 * _capacity) resize(_capacity / 2); } } 线性探测法\r用大小为M的数组保存N个键值对，M\u003eN,依靠数组中的空位解决碰撞冲突。开放地址散列表。 当发生碰撞时，直接使用散列标中下一个位置 键 public class LinearProbingHashSTNet\u003cTKey, TValue\u003e { private static readonly int INIT_CAPACITY = 4; private int _length; private int _capacity; private TKey[] _keys; private TValue[] _values; public int Length =\u003e _length; public int Capacity =\u003e _capacity; public TKey[] Keys =\u003e _keys; public TValue[] Values =\u003e _values; public LinearProbingHashSTNet():this(INIT_CAPACITY) { } public LinearProbingHashSTNet(int capacity) { _capacity = capacity; _length = 0; _keys = new TKey[capacity]; _values = new TValue[capacity]; } public bool IsEmpty =\u003e _length == 0; public bool Contains(TKey key) { if (key == null) throw new ArgumentException(\"argument to contains() is null\"); return Get(key) != null; } private int hash(TKey key) { return (key.GetHashCode() \u0026 0x7fffffff) % _capacity; } private void resize(int capacity) { LinearProbingHashSTNet\u003cTKey, TValue\u003e temp = new LinearProbingHashSTNet\u003cTKey, TValue\u003e(capacity); for (int i = 0; i \u003c _capacity; i++) { if (_keys[i] != null) { temp.Add(_keys[i], _values[i]); } } _keys = temp.Keys; _values = temp.Values; _capacity = temp.Capacity; } public void Add(TKey key, TValue val) { if (key == null) throw new ArgumentException(\"first argument to put() is null\"); if (val == null) { Delete(key); return; } // double table size if 50% full if (_length \u003e= Capacity / 2) re","date":"2020-12-15","objectID":"/2020/12/algorithm5/:2:6","tags":["算法","字典"],"title":"算法 字典","uri":"/2020/12/algorithm5/"},{"categories":"算法","content":"字典总结\r大多数程序员的第一选择都是散列标，然后才是红黑树。 ","date":"2020-12-15","objectID":"/2020/12/algorithm5/:2:7","tags":["算法","字典"],"title":"算法 字典","uri":"/2020/12/algorithm5/"},{"categories":"算法","content":"堆\r堆：当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。 命题O:根结点是堆有序的二叉树中的最大结点 二叉堆：一组能够用堆有序的完全的二叉树排序的元素，并在数组中按照层级存储（不使用数组的第一个位置）。 命题P:一棵大小为N的完全二叉树的高度为lgN。 ","date":"2020-12-12","objectID":"/2020/12/algorithm4/:1:0","tags":["算法","堆","优先队列"],"title":"算法 堆 优先队列","uri":"/2020/12/algorithm4/"},{"categories":"算法","content":"堆有序上浮\r由下至上的堆有序（上浮）实现 private void swim(int k) { while(k\u003e1\u0026\u0026less(k/2,k)) { exch(k/2,k); k=k/2; } } ","date":"2020-12-12","objectID":"/2020/12/algorithm4/:1:1","tags":["算法","堆","优先队列"],"title":"算法 堆 优先队列","uri":"/2020/12/algorithm4/"},{"categories":"算法","content":"堆有序下沉\r由上至下的堆有序（下沉）实现。 命题R:用下沉操作由N个元素构造堆只需少于2N次比较以及小于N次交换。 private void sink(int k) { while(2*k \u003c= N) { int j=2*k; if(j\u003cN\u0026\u0026less(j,j+1)) j++;//找到子结点中较大的那个 if(!less(k,j)) break;，//根节点应该比较大的那个大，否则就需要交换。 exch(k,j); k=j;//一直交换到最底层 } } ","date":"2020-12-12","objectID":"/2020/12/algorithm4/:1:2","tags":["算法","堆","优先队列"],"title":"算法 堆 优先队列","uri":"/2020/12/algorithm4/"},{"categories":"算法","content":"堆有序排序\rpublic class HeapSortNet\u003cTItem\u003e where TItem : IComparable\u003cTItem\u003e { ///注意这边有一个Bug忽略了数组的第一个元素。下面的优先队列消除了这个Bug public static void Sort(TItem[] items) { int n = items.Length; // 构造堆 for (int k = n / 2; k \u003e= 1; k--) Sink(items, k, n);//K的值需要比N的大 // 堆排序 while (n \u003e 1) { Exch(items, 1, n--);//将最大的放到最后 Sink(items, 1, n);//将最大之前的那个找出来放到第一个 } } /// \u003csummary\u003e /// 下沉 /// \u003c/summary\u003e /// \u003cparam name=\"items\"\u003e\u003c/param\u003e /// \u003cparam name=\"k\"\u003e\u003c/param\u003e /// \u003cparam name=\"n\"\u003e\u003c/param\u003e private static void Sink(TItem[] items, int k, int n) { while (2 * k \u003c= n) { int j = 2 * k; if (j \u003c n \u0026\u0026 Less(items, j, j + 1)) j++; if (!Less(items, k, j)) break; Exch(items, k, j); k = j; } } private static bool Less(TItem[] items, int i, int j) { return items[i - 1].CompareTo(items[j - 1]) \u003c 0; } private static void Exch(TItem[] items, int i, int j) { TItem swap = items[i - 1]; items[i - 1] = items[j - 1]; items[j - 1] = swap; } } 命题S:将N个元素排序，堆排序只需要少于（2NlgN+2N）次比较（以及一半次数的交换） 改进：大多数在下沉排序期间重新插入堆的元素会被直接加入到堆底。 Floyd在1964年观察发现，可以通过免去检查元素是否到达正确位置来节省时间， 下沉中总是直接提升较大的子节点直至到达堆底，然后再使元素上浮到正确的位置，可以将比较次数减少一半 唯一能够同时最优地利用空间和时间的方法，最坏情况下也能保证~2NlgN次比较和恒定的额外空间。在嵌入式或底成本的移动设备中很流行，无法利用缓存，很少于其他元素进行比较。 ","date":"2020-12-12","objectID":"/2020/12/algorithm4/:1:3","tags":["算法","堆","优先队列"],"title":"算法 堆 优先队列","uri":"/2020/12/algorithm4/"},{"categories":"算法","content":"优先队列\r就是用堆的方式排列的数组。支持查找最大最小元素和插入元素 ","date":"2020-12-12","objectID":"/2020/12/algorithm4/:2:0","tags":["算法","堆","优先队列"],"title":"算法 堆 优先队列","uri":"/2020/12/algorithm4/"},{"categories":"算法","content":"最大优先队列\r最大优先队列：支持删除最大元素和插入元素 基于堆的优先队列：存储在数组[1……N]中，数组[0]没有使用。 命题Q:对于一个含有N个元素的基于堆的优先队列，插入元素操作只需要不超过（lgN+1）次比较，删除最大元素的操作需要不超过2lgN次比较。 /// \u003csummary\u003e /// 优先队列 /// \u003c/summary\u003e /// \u003ctypeparam name=\"TItem\"\u003e\u003c/typeparam\u003e public interface IMaxHeapQueue\u003cTItem\u003e : IEnumerable\u003cTItem\u003e, IDisposable { bool IsEmpty { get; } int Length { get; } void Insert(TItem x); TItem DeleteMax(); TItem Max(); } ​ public class MaxPQNet\u003cTItem\u003e : IMaxHeapQueue\u003cTItem\u003e where TItem : IComparable\u003cTItem\u003e { private TItem[] _items; private int _length; private IComparer\u003cTItem\u003e _comparer; public MaxPQNet(int capacity) { _items=new TItem[capacity+1]; _length = 0; } public MaxPQNet():this(1) { } public MaxPQNet(int capacity, IComparer\u003cTItem\u003e comparer):this(capacity) { _comparer = comparer; } public MaxPQNet(TItem[] items) { _length = items.Length; _items = new TItem[items.Length + 1]; for (int i = 0; i \u003c _length; i++) _items[i + 1] = items[i]; for (int k = _length / 2; k \u003e= 1; k--) sink(k); } private void sink(int k) { while (k*2\u003c=_length) { int j = 2 * k; if (j \u003c _length \u0026\u0026 less(j, j + 1)) j++; if(!less(k,j)) break; exch(k,j); k = j; } } private void swim(int k) { while (k \u003e 1 \u0026\u0026 less(k / 2, k)) { exch(k,k/2); k = k / 2; } } private bool less(int i, int j) { if (_comparer == null) { return _items[i].CompareTo(_items[j]) \u003c 0; } else { return _comparer.Compare(_items[i], _items[j]) \u003c 0; } } private void exch(int i, int j) { var item = _items[i]; _items[i] = _items[j]; _items[j] = item; } private void resize(int capacity) { if(capacity\u003c_length) throw new ConfigurationException(\"this capacity is error less than Length\"); var tempitems = new TItem[capacity]; for (int i = 1; i \u003c _length+1; i++) { tempitems[i] = _items[i]; } _items = tempitems; } public IEnumerator\u003cTItem\u003e GetEnumerator() { if (!IsEmpty) { var temitem = new TItem[_length-1]; for (int i = 0; i \u003c _length; i++) { temitem[i] = _items[i + 1]; } var temmaxpq=new MaxPQ\u003cTItem\u003e(temitem); while (!temmaxpq.IsEmpty()) { yield return temmaxpq.DelMax(); } } } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } protected virtual void Dispose(bool disposing) { if (disposing) { if (!IsEmpty) { for (int i = 1; i \u003c _length+1; i++) { _items[i] = default; } } } } public void Dispose() { Dispose(true); } public bool IsEmpty =\u003e Length == 0; public int Length =\u003e _length; public void Insert(TItem item) { if(_length==_items.Length-1) resize(_length*2); _items[++_length] = item; swim(_length); } public TItem DeleteMax() { if (IsEmpty) return default; var item = _items[1]; exch(1,_length--);//把最小值交换到第一个重新堆排序 _items[_length + 1] = default; sink(1); if(_length\u003e0\u0026\u0026_length==(_items.Length-1)/4) resize(_items.Length/2); return item; } public TItem Max() { if (IsEmpty) return default; return _items[1]; } } 堆上优先队列 ","date":"2020-12-12","objectID":"/2020/12/algorithm4/:2:1","tags":["算法","堆","优先队列"],"title":"算法 堆 优先队列","uri":"/2020/12/algorithm4/"},{"categories":"算法","content":"最小优先队列\r根结点是最小值，其他相同 public class MinPQNet\u003cTItem\u003e : IMinHeapQueue\u003cTItem\u003e where TItem : IComparable\u003cTItem\u003e { private TItem[] _items; private int _length; private IComparer\u003cTItem\u003e _comparer; public MinPQNet(int capacity) { _items = new TItem[capacity + 1]; _length = 0; } public MinPQNet() : this(1) { } public MinPQNet(int capacity, IComparer\u003cTItem\u003e comparer) : this(capacity) { _comparer = comparer; } public MinPQNet(TItem[] items) { _length = items.Length; _items = new TItem[items.Length + 1]; for (int i = 0; i \u003c _length; i++) _items[i + 1] = items[i]; for (int k = _length / 2; k \u003e= 1; k--) sink(k); } private void sink(int k) { while (k * 2 \u003c= _length) { int j = 2 * k; if (j \u003c _length \u0026\u0026 greater(j, j + 1)) j++; if (!greater(k, j)) break; exch(k, j); k = j; } } private void swim(int k) { while (k \u003e 1 \u0026\u0026 greater(k / 2, k)) { exch(k, k / 2); k = k / 2; } } private bool greater(int i, int j) { if (_comparer == null) { return _items[i].CompareTo(_items[j]) \u003e 0; } else { return _comparer.Compare(_items[i], _items[j]) \u003e 0; } } private void exch(int i, int j) { var item = _items[i]; _items[i] = _items[j]; _items[j] = item; } private void resize(int capacity) { if (capacity \u003c _length) throw new ConfigurationException(\"this capacity is error less than Length\"); var tempitems = new TItem[capacity]; for (int i = 1; i \u003c _length + 1; i++) { tempitems[i] = _items[i]; } _items = tempitems; } public IEnumerator\u003cTItem\u003e GetEnumerator() { if (!IsEmpty) { var temitem = new TItem[_length - 1]; for (int i = 0; i \u003c _length; i++) { temitem[i] = _items[i + 1]; } var temmaxpq = new MinPQ\u003cTItem\u003e(temitem); while (!temmaxpq.IsEmpty()) { yield return temmaxpq.DelMin(); } } } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } protected virtual void Dispose(bool disposing) { if (disposing) { if (!IsEmpty) { for (int i = 1; i \u003c _length + 1; i++) { _items[i] = default; } } } } public void Dispose() { Dispose(true); } public bool IsEmpty =\u003e Length == 0; public int Length =\u003e _length; public void Insert(TItem item) { if (_length == _items.Length - 1) resize(_length * 2); _items[++_length] = item; swim(_length); } public TItem DeleteMin() { if (IsEmpty) return default; var item = _items[1]; exch(1, _length--);//把最小值交换到第一个重新堆排序 _items[_length + 1] = default; sink(1); if (_length \u003e 0 \u0026\u0026 _length == (_items.Length - 1) / 4) resize(_items.Length / 2); return item; } public TItem Min() { if (IsEmpty) return default; return _items[1]; } } ","date":"2020-12-12","objectID":"/2020/12/algorithm4/:2:2","tags":["算法","堆","优先队列"],"title":"算法 堆 优先队列","uri":"/2020/12/algorithm4/"},{"categories":"算法","content":"索引优先队列\r可以快速访问已经插入队列中的项。 不会改变插入队列中项的数据结构 命题Q(续):在一个大小为N的索引优先队列中，插入(insert)元素，改变优先级，删除，删除最小元素和删除最大元素操作所需要的比较次数和LogN成正比。 示例为最大索引优先队列，简单改写就可以变成最小索引优先队列 /// \u003csummary\u003e /// 增加一个key，key对应一个索引，实际交换排序是控制key对应的索引 /// \u003c/summary\u003e /// \u003ctypeparam name=\"TItem\"\u003e\u003c/typeparam\u003e public class KeyMaxPQNet\u003cTItem\u003e : IMaxKeyHeap\u003cTItem\u003e where TItem:IComparable\u003cTItem\u003e { private int _length; private int _capacity; /// \u003csummary\u003e /// key对应的索引 /// \u003c/summary\u003e private int[] _keysIndex; /// \u003csummary\u003e /// 索引对应的key /// \u003c/summary\u003e private int[] _indexesKey; /// \u003csummary\u003e /// key对应的item /// \u003c/summary\u003e private TItem[] _items; public bool IsEmpty =\u003e _length == 0; public int Length =\u003e _length; public int Capacity =\u003e _capacity; public KeyMaxPQNet(TItem[] items) { if (items == null || !items.Any()) throw new ArgumentNullException(\"items is empty\"); _length = 0; _capacity = items.Length; _items = new TItem[_capacity + 1]; _keysIndex = new int[_capacity + 1]; _indexesKey = new int[_capacity + 1]; for (int i = 0; i \u003c= _capacity; i++) { _keysIndex[i] = -1; //初始化所有key对应的index都是-1，index对应的key都是0 } foreach (var item in items) { this.Insert(item); } } public KeyMaxPQNet(int capacity) { if(capacity\u003c0) throw new ArgumentException(\"this argument capacity is error and can not less zero\"); this._capacity = capacity; _length = 0; _items=new TItem[capacity+1]; _keysIndex=new int[capacity+1]; _indexesKey=new int[capacity+1]; for (int i = 0; i \u003c= capacity;i++) { _keysIndex[i] = -1;//初始化所有key对应的index都是-1，index对应的key都是0 } } public void Insert(TItem item) { var key = _length+1; Insert(key,item); } public void Insert(int key, TItem item) { validateKey(key); if (!Contains(key)) throw new ArgumentException(\"this index has existed\"); _length++; _keysIndex[key] = _length; _indexesKey[_length] = key; _items[key] = item; swim(_length); } /// \u003csummary\u003e /// if Empty,throw exception /// \u003c/summary\u003e /// \u003creturns\u003e\u003c/returns\u003e public TItem DeleteMax() { if (IsEmpty) throw new NullReferenceException(\"this is empty queue\"); int max = _indexesKey[1]; var item = _items[max]; exch(1,_length--); sink(1); _keysIndex[max] = -1; _items[max] = default; _indexesKey[_length + 1] = -1; return item; } public void Delete(int key) { validateKey(key); if(!Contains(key)) throw new ArgumentException(\"this index is not in this queue\"); var k = _keysIndex[key]; exch(k,_length--);//这边已经排除最后一项 swim(k); sink(k); _items[key] = default; _keysIndex[key] = -1; } public void Replace(int key, TItem item) { validateKey(key); if(!Contains(key)) throw new NullReferenceException(\"this key not in queue\"); _items[key] = item; swim(_keysIndex[key]); sink(_keysIndex[key]); } public TItem KeyOf(int key) { validateKey(key); if(!Contains(key)) return default; return _items[key]; } public int MaxKey() { if(IsEmpty) throw new ArgumentException(\"this is null queue\"); return _indexesKey[1]; } public TItem Max() { if(IsEmpty) throw new ArgumentException(\"this is null queue\"); return _items[_indexesKey[1]]; } public bool Contains(int key) { validateKey(key); return _keysIndex[key] != -1; } public IEnumerator\u003cTItem\u003e GetEnumerator() { if (!IsEmpty) { var queue=new KeyMaxPQNet\u003cTItem\u003e(_items); for (int i = 1; i \u003c= _items.Length; i++) { yield return queue.DeleteMax(); } } } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } public void Dispose() { Dispose(true); } protected virtual void Dispose(bool disposing) { if (disposing) { while (!IsEmpty) { DeleteMax(); } } } private bool less(int indexi,int indexj) { return _items[_indexesKey[indexi]].CompareTo(_items[_indexesKey[indexj]]) \u003c 0; } private void validateKey(int key) { if (key \u003c 0 || key \u003e _capacity) throw new ArgumentException(\"this key is invalid\"); } private void swim(int index) { while (index\u003e1 \u0026\u0026 less(index/2,index)) { exch(index, index / 2); index = index / 2; } } private void sink(int index) { while (2 * index \u003c= _length) { int indexj = 2 * index; if (indexj \u003c _length \u0026\u0026 less(indexj, indexj + 1)) indexj++; if (!less(index, indexj)) break; exch(index, indexj); index = indexj; } } ","date":"2020-12-12","objectID":"/2020/12/algorithm4/:2:3","tags":["算法","堆","优先队列"],"title":"算法 堆 优先队列","uri":"/2020/12/algorithm4/"},{"categories":"算法","content":"排序算法应用\r多向并归 索引优先队列用例解决多向归并问题：它将多个有序的输入流归并成一个有序的输出流。 输入可能来自于多种科学仪器的输出（按时间排序） 多个音乐网站或电影网站的信息列表（名称或艺术家名字） 商业交易（按时间排序） 使用优先队列，无论输入有多长都可以把它们全部读入并排序 交易数据按照日期排序 商业计算 信息搜索 运筹学：调度问题，负载均衡 事件驱动模拟 数值计算：浮点数来进行百万次计算，一些数值的计算使用优先队列和排序来计算精确度，曲线下区域的面积，数值积分方法就是使用一个优先队列来存储一组小间隔中每段的近似精确度。积分的过程就是山区精确度最低的间隔并将其分为两半。 组合搜索：一组状态演化成另一组状态可能的步骤和步骤的优先级。 Prim算法和Dijkstra算法: Kruskal算法: 霍夫曼压缩： 字符串处理： ","date":"2020-12-12","objectID":"/2020/12/algorithm4/:3:0","tags":["算法","堆","优先队列"],"title":"算法 堆 优先队列","uri":"/2020/12/algorithm4/"},{"categories":"算法","content":"排序特点\r性质T:快速排序是最快的通用排序算法。 对原始数据类型使用（三向切分）快速排序，对引用类型使用归并排序。 命题U:平均来说，基于切分的选择算法的运行时间是线性级别的。 ","date":"2020-12-12","objectID":"/2020/12/algorithm4/:4:0","tags":["算法","堆","优先队列"],"title":"算法 堆 优先队列","uri":"/2020/12/algorithm4/"},{"categories":"算法","content":"排序\r比较和交换： public class AssistSort\u003cT\u003e where T : IComparable\u003cT\u003e { public static void Shuffle(T[] seq) { int n = seq.Length; var random = new Random(Guid.NewGuid().GetHashCode()); for (int i = 0; i \u003c n; i++) { // choose index uniformly in [0, i] int r = (int)(random.Next(n)); T swap = seq[r]; seq[r] = seq[i]; seq[i] = swap; } } // does v == w ? public static bool Eq(T v, T w) { if (ReferenceEquals(v, w)) return true; // optimization when reference equal return v.CompareTo(w) == 0; } public static void Exch(T[] seq, int value, int min) { if (seq == null) throw new ArgumentNullException(\"seq is null\"); if (value \u003e seq.Length - 1 || value \u003c 0) throw new ArgumentException(\"value is not in seq\"); if (min \u003e seq.Length - 1 || min \u003c 0) throw new ArgumentException(\"min is not in seq\"); T t = seq[value]; seq[value] = seq[min]; seq[min] = t; } public static bool Less(T value, T compare) { if (value == null) throw new ArgumentNullException(\"value is null\"); if (compare == null) throw new ArgumentNullException(\"compare is null\"); return value.CompareTo(compare) \u003c 0; } public static void Show(T[] seq) { if (seq == null) throw new ArgumentNullException(\"seq is null\"); if (!seq.Any()) throw new ArgumentException(\"seq length equal 0\"); Console.WriteLine(string.Join(\" \", seq)); } public static bool IsSorted(T[] seq) { if (seq == null) throw new ArgumentNullException(\"seq is null\"); if (!seq.Any()) throw new ArgumentException(\"seq length equal 0\"); for (int i = 1; i \u003c seq.Length; i++) { if (Less(seq[i], seq[i - 1])) return false; } return true; } public static bool IsSorted(T[] seq, int lo, int hi) { if (seq == null) throw new ArgumentNullException(\"seq is null\"); if (seq.Any() || seq.Length \u003c 2) throw new ArgumentException(\"seq length is abnormal\"); if (lo \u003c 0 || lo \u003e seq.Length - 1 || (lo + 1) == seq.Length) throw new ArgumentException(\"lo is abnormal\"); if (hi \u003c 0 || hi \u003e seq.Length - 1 || hi \u003c lo) throw new ArgumentException(\"hi is abnormal\"); for (int i = lo + 1; i \u003c= hi; i++) if (Less(seq[i], seq[i - 1])) return false; return true; } } ","date":"2020-11-28","objectID":"/2020/11/algorithm3/:1:0","tags":["算法","排序"],"title":"算法 排序","uri":"/2020/11/algorithm3/"},{"categories":"算法","content":"选择排序\r运行时间与初始状态无关 数据移动是最少的，只用了N次交换，交换次数和数组的大小是线性关系， 找到剩余元素中最小数与第一个交换 结论A：对于长度为N的数组，选择排序的需要大约N^2/2次比较和N次交换 public class SelectionSort\u003cT\u003e where T : System.IComparable\u003cT\u003e { public static void Sort(T[] seq) { if (seq == null) throw new ArgumentNullException(\"seq is null\"); if (!seq.Any()) return; var count = seq.Length; for (int i = 0; i \u003c count; i++) { int min = i; //找出剩余项中最小项的位置 for (int j = i + 1; j \u003c count; j++) { //if (seq[j].CompareTo(seq[min]) \u003c 0) min = j; if (AssistSort\u003cT\u003e.Less(seq[j], seq[min])) min = j; } //将最小项与min交换 AssistSort\u003cT\u003e.Exch(seq, i, min); //调用静态方法非常消耗性能 //T t = seq[i]; //seq[i] = seq[min]; //seq[min] = t; } } } ","date":"2020-11-28","objectID":"/2020/11/algorithm3/:1:1","tags":["算法","排序"],"title":"算法 排序","uri":"/2020/11/algorithm3/"},{"categories":"算法","content":"插入排序\r像打牌一项，将每一张排插入到已经有序的牌中的适当位置。 运行时间取决于元素的初始顺序。 结论B：对于随机不重复的数组，平均情况下插入排序需要N^2/4次比较和交换。最坏情况下需要N^2/2次交换和交换，最好情况下需要N-1次比较和0次交换。 public class InsertionSort\u003cT\u003e where T : IComparable\u003cT\u003e { public static void Sort(T[] seq) { if (seq == null) throw new ArgumentNullException(\"seq is null\"); if (!seq.Any()) return; int count = seq.Length; for (int i = 0; i \u003c count; i++) { for (int j = i; j \u003e 0 \u0026\u0026 AssistSort\u003cT\u003e.Less(seq[j], seq[j - 1]); j--) { AssistSort\u003cT\u003e.Exch(seq, j, j - 1); } } // 5 4 3 1 2 // 4 5 3 1 2 // 4 3 5 1 2 // 3 4 5 1 2 // 1 3 4 5 2 // 1 2 3 4 5 //1 2 4 3 5 //1 2 } public static void Sort(T[] seq, int lo, int hi) { if (seq == null) throw new ArgumentNullException(\"seq is null\"); if (!seq.Any()) return; if (hi \u003c lo || lo \u003c 0 || hi \u003c 0 || lo \u003e seq.Length || hi \u003e seq.Length) throw new ArgumentException(\"Parameter error\"); for (int i = lo + 1; i \u003c hi; i++) { for (int j = i; j \u003e lo \u0026\u0026 AssistSort\u003cT\u003e.Less(seq[j], seq[j - 1]); j--) { //交换，每个seq[j]相当于被访问了2次，跟seq[j+1]和seq[j-1]各比较一次 AssistSort\u003cT\u003e.Exch(seq, j, j - 1); } } } } ","date":"2020-11-28","objectID":"/2020/11/algorithm3/:1:2","tags":["算法","排序"],"title":"算法 排序","uri":"/2020/11/algorithm3/"},{"categories":"算法","content":"插入排序改进减少比较\r结论C：插入排序需要的交换操作和数组中倒置的数量相同，需要比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。 改进插入排序，只需要在内循环中将较大的元素都向右移动而不总是交换两个元素。这样访问数组的次数能够减半。 public static class InsertionSortX\u003cT\u003e where T : IComparable\u003cT\u003e { public static void Sort(T[] seq) { if (seq == null) throw new ArgumentNullException(\"seq is null\"); if (!seq.Any()) return; int n = seq.Length; // put smallest element in position to serve as sentinel int exchanges = 0; for (int i = n - 1; i \u003e 0; i--) { if (AssistSort\u003cT\u003e.Less(seq[i], seq[i - 1])) { AssistSort\u003cT\u003e.Exch(seq, i, i - 1); exchanges++; } } if (exchanges == 0) return; // insertion sort with half-exchanges for (int i = 2; i \u003c n; i++) { T v = seq[i]; int j = i; while (AssistSort\u003cT\u003e.Less(v, seq[j - 1])) { //右移，seq[j]只跟当前比较的值V比较了1次 seq[j] = seq[j - 1]; j--; } seq[j] = v; } } } 插入和选择比较 ","date":"2020-11-28","objectID":"/2020/11/algorithm3/:1:3","tags":["算法","排序"],"title":"算法 排序","uri":"/2020/11/algorithm3/"},{"categories":"算法","content":"插入排序改进二分快速定位\r可以看到插入左边都是已近排号顺序的，可以使用二分法快速确定待插入数的位置。 public static class BinaryInsertionSort\u003cT\u003e where T : IComparable\u003cT\u003e { public static void Sort(T[] seq) { if (seq == null) throw new ArgumentNullException(\"seq is null\"); if (!seq.Any()) return; int n = seq.Length; for (int i = 1; i \u003c n; i++) { // binary search to determine index j at which to insert a[i] T v = seq[i]; int lo = 0, hi = i; while (lo \u003c hi) { int mid = lo + (hi - lo) / 2; if (AssistSort\u003cT\u003e.Less(v, seq[mid])) hi = mid; else lo = mid + 1; } // insetion sort with \"half exchanges\" // (insert a[i] at index j and shift a[j], ..., a[i-1] to right) for (int j = i; j \u003e lo; --j) seq[j] = seq[j - 1]; seq[lo] = v; } } } 结论D：对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数。 ","date":"2020-11-28","objectID":"/2020/11/algorithm3/:1:4","tags":["算法","排序"],"title":"算法 排序","uri":"/2020/11/algorithm3/"},{"categories":"算法","content":"希尔排序\r大规模乱序的插入排序很慢，因为它只会交换相邻的元素，如果最小的元素正好在数组的尽头，那么把它移动到正确位置就需要N-1次移动，希尔排序就是为了解决这个问题，交换不相邻的元素以对数组的局部进行排序。 希尔排序的思想：数组中任意间隔为h的元素都是有序的，这样的数组成为h有序数组。一个h有序的数组是h个相互独立的有序数组组成的一个数组。 希尔排序高效的原因是：它权衡了子数组的规模和有序性。 /// \u003csummary\u003e /// 希尔排序，插入排序的变种 /// 其实就是从h项开始选定，跟之前的h项进行比较交换 /// 然后再缩小h进行重复的插入排序，h缩小的顺序，1 4 13 40.。。。 /// 最后一次一定是1，就是插入排序，只不过这时序列已经大部分顺序，所以进行了少量交换操作 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public class ShellSort\u003cT\u003e where T : IComparable\u003cT\u003e { public static void Sort(T[] seq) { if (seq == null) throw new ArgumentNullException(\"seq is null\"); if (!seq.Any()) return; int count = seq.Length; int h = 1; //求出最大限度间隔， while (h \u003c count / 3) h = 3 * h + 1;//1 4 13 40 121 364 1093 while (h \u003e= 1) {//将数组变成h有序 for (int i = h; i \u003c count; i++) { //将a[i]插入a[i-h],a[i-2*h],a[i-3*h]..... for (int j = i; j \u003e= h \u0026\u0026 AssistSort\u003cT\u003e.Less(seq[j], seq[j - h]); j -= h) { AssistSort\u003cT\u003e.Exch(seq, j, j - h); } } h = h / 3; } //0 1 2 3 4 5 6 h=4 //4:0 5:1 6:2 //h=1 //1:0 2:1 3:2 } public static void SortPro(T[] seq) { if (seq == null) throw new ArgumentNullException(\"seq is null\"); if (!seq.Any()) return; int count = seq.Length; int h = 1; //求出最大限度间隔， while (h \u003c count / 2) h = 2 * h + 1;//1 3 7 15 31 while (h \u003e= 1) {//将数组变成h有序 for (int i = h; i \u003c count; i++) { for (int j = i; j \u003e= h \u0026\u0026 AssistSort\u003cT\u003e.Less(seq[j], seq[j - h]); j -= h) { AssistSort\u003cT\u003e.Exch(seq, j, j - h); } } h = h / 2; } } public static void SortPlus(T[] seq) { if (seq == null) throw new ArgumentNullException(\"seq is null\"); if (!seq.Any()) return; int count = seq.Length; int h = 1; //求出最大限度间隔， while (h \u003c count / 4) h = 4 * h + 1;//1 5 21 85 while (h \u003e= 1) {//将数组变成h有序 for (int i = h; i \u003c count; i++) { for (int j = i; j \u003e= h \u0026\u0026 AssistSort\u003cT\u003e.Less(seq[j], seq[j - h]); j -= h) { AssistSort\u003cT\u003e.Exch(seq, j, j - h); } } h = h / 4; } } } 希尔排序对任意排序的数组表现都很好。 希尔排序能够解决一些初级排序算法无能为力的问题，通过提升速度来解决其他方式无法解决的问题是研究算法的设计和性能的主要原因。 希尔排序：当一个h有序的数组按照增幅K排序后，它仍然是h有序的 希尔排序的运行时间不到平方级别，在最后情况下是N^(3/2) 性质E：使用递增序列1，4，13，40，121，364……的希尔排序所需的比较次数不会超出N的若干倍乘以递增序列的长度。 如果需要解决一个排序问题，优先先使用希尔，再使用其他，因为它不需要额外的内存，其他的高效排序不会比希尔排序快2倍。 ","date":"2020-11-28","objectID":"/2020/11/algorithm3/:1:5","tags":["算法","排序"],"title":"算法 排序","uri":"/2020/11/algorithm3/"},{"categories":"算法","content":"归并排序自顶而下\r归并排序核心思想是：可以先(递归地)将整个数组分成两半分别排序，然后结果归并起来。 性能：能够将任意长度为N的数组排序所需的时间和NlogN成正比。 分而治之 /// \u003csummary\u003e /// 归并排序,自顶而下，使用了分治的思想,NlgN /// 核心思想就是两个顺序数列合并成一个数列 /// 将数列以中间index为界分为前后，然后递归分，直到子数组只有2个然后合并。 /// 浪费了大量的空间，每次合并都需一个Auxiliary /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public class MergeSortUB\u003cT\u003e where T : IComparable\u003cT\u003e { /// \u003csummary\u003e /// 将数列low-mid和ming-high合并 /// low-mid必须顺序 /// mid-high必须顺序 /// \u003c/summary\u003e /// \u003cparam name=\"seq\"\u003e数列\u003c/param\u003e /// \u003cparam name=\"aux\"\u003e合并需要数组\u003c/param\u003e /// \u003cparam name=\"lo\"\u003elow所在index\u003c/param\u003e /// \u003cparam name=\"mid\"\u003emind所在index\u003c/param\u003e /// \u003cparam name=\"hi\"\u003ehi所在index\u003c/param\u003e private static void Merge(T[] seq, T[] aux, int lo, int mid, int hi)//aux:auxiliary备用 { // 合并前两个数列必须是顺序的,私有方法不需要验证 //if(!AssistSort\u003cT\u003e.IsSorted(seq, lo, mid)) // throw new ArgumentException(\"seq is not sort in low to mid\"); //if(!AssistSort\u003cT\u003e. IsSorted(seq, mid //+1, hi)) // throw new ArgumentException(\"seq is not sort in mid to high\"); // 备份 for (int k = lo; k \u003c= hi; k++) { aux[k] = seq[k]; } // 合并算法，i左半边开始位,j右半边开始位 int i = lo, j = mid + 1; for (int k = lo; k \u003c= hi; k++) { if (i \u003e mid) seq[k] = aux[j++];//左半边用尽，取右半边元素 else if (j \u003e hi) seq[k] = aux[i++];//右半边用尽，取左半边元素 else if (AssistSort\u003cT\u003e.Less(aux[j], aux[i])) seq[k] = aux[j++];//右半边元素小于左边元素，取右半边元素 else seq[k] = aux[i++];//取左半边元素 } } private static void Sort(T[] seq, T[] aux, int lo, int hi) { if (hi \u003c= lo) return; int mid = lo + (hi - lo) / 2; Sort(seq, aux, lo, mid); Sort(seq, aux, mid + 1, hi); Merge(seq, aux, lo, mid, hi); } public static void Sort(T[] seq) { if (seq == null) throw new ArgumentNullException(\"seq is null\"); if (!seq.Any()) return; T[] aux = new T[seq.Length]; Sort(seq, aux, 0, seq.Length - 1); } } 通过一棵树来解释归并的性能，每个节点都标识通过Merge()方法并归成的子数组，这棵树正好n层，k表示在K层，K层有2^K^个节点，每个节点的长度为2^(n-k)^，那么并归最多需要2^(n-k)^次比较。那么每层需要比较次数2^K^2^(n-k)^=2^n^，n层总共为n2^n^=NlgN; 命题F:对于长度为N的任意数组，自顶向下的并归需要1/2NlgN至NlgN次比较。 命题G:对于长度为N的任意数组，自顶向下的归并排序最多需要访问数组6NlgN次。 ","date":"2020-11-28","objectID":"/2020/11/algorithm3/:1:6","tags":["算法","排序"],"title":"算法 排序","uri":"/2020/11/algorithm3/"},{"categories":"算法","content":"归并统计交换次数\r/// \u003csummary\u003e /// 统计交换次数，自顶而下并归方法 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public class Inversion\u003cT\u003e where T : IComparable\u003cT\u003e { public static long Count(T[] seq) { T[] b = new T[seq.Length]; T[] aux = new T[seq.Length]; for (int i = 0; i \u003c seq.Length; i++) b[i] = seq[i]; long inversions = Count(seq, b, aux, 0, seq.Length - 1); return inversions; } private static long Count(T[] a, T[] b, T[] aux, int lo, int hi) { long inversions = 0; if (hi \u003c= lo) return 0; int mid = lo + (hi - lo) / 2; inversions += Count(a, b, aux, lo, mid); inversions += Count(a, b, aux, mid + 1, hi); inversions += Merge(b, aux, lo, mid, hi); if (inversions != Brute(a, lo, hi)) throw new Exception(\"inversion is not right\"); return inversions; } private static long Merge(T[] a, T[] aux, int lo, int mid, int hi) { long inversions = 0; // copy to aux[] for (int k = lo; k \u003c= hi; k++) { aux[k] = a[k]; } // merge back to a[] int i = lo, j = mid + 1; for (int k = lo; k \u003c= hi; k++) { if (i \u003e mid) a[k] = aux[j++]; else if (j \u003e hi) a[k] = aux[i++]; else if (AssistSort\u003cT\u003e.Less(aux[j], aux[i])) { a[k] = aux[j++]; inversions += (mid - i + 1); } else a[k] = aux[i++]; } return inversions; } private static long Brute(T[] a, int lo, int hi) { long inversions = 0; for (int i = lo; i \u003c= hi; i++) for (int j = i + 1; j \u003c= hi; j++) if (AssistSort\u003cT\u003e.Less(a[j], a[i])) inversions++; return inversions; } } ","date":"2020-11-28","objectID":"/2020/11/algorithm3/:1:7","tags":["算法","排序"],"title":"算法 排序","uri":"/2020/11/algorithm3/"},{"categories":"算法","content":"归并排序小数组用插值排序\r使用插入排序处理小规模数组（长度小于15），一般可以将归并排序的运行时间减少10%~15% ","date":"2020-11-28","objectID":"/2020/11/algorithm3/:1:8","tags":["算法","排序"],"title":"算法 排序","uri":"/2020/11/algorithm3/"},{"categories":"算法","content":"归并排序改进a[mid]小于等于a[mid+1]\r这样使得任意有序的子数组算法运行时间线性 ","date":"2020-11-28","objectID":"/2020/11/algorithm3/:1:9","tags":["算法","排序"],"title":"算法 排序","uri":"/2020/11/algorithm3/"},{"categories":"算法","content":"归并排序不复制元素到辅助数组\r","date":"2020-11-28","objectID":"/2020/11/algorithm3/:1:10","tags":["算法","排序"],"title":"算法 排序","uri":"/2020/11/algorithm3/"},{"categories":"算法","content":"归并排序自底向上\r/// \u003csummary\u003e /// 并归排序,自底而上，使用了分治的思想,NlgN /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public class MergeSortBU\u003cT\u003e where T : IComparable\u003cT\u003e { /// \u003csummary\u003e /// 将数列low-mid和ming-high合并 /// low-mid必须顺序 /// mid-high必须顺序 /// \u003c/summary\u003e /// \u003cparam name=\"seq\"\u003e数列\u003c/param\u003e /// \u003cparam name=\"aux\"\u003e合并需要数组\u003c/param\u003e /// \u003cparam name=\"lo\"\u003elow所在index\u003c/param\u003e /// \u003cparam name=\"mid\"\u003emind所在index\u003c/param\u003e /// \u003cparam name=\"hi\"\u003ehi所在index\u003c/param\u003e private static void Merge(T[] seq, T[] aux, int lo, int mid, int hi) { // copy to aux[] for (int k = lo; k \u003c= hi; k++) { aux[k] = seq[k]; } // merge back to a[] int i = lo, j = mid + 1; for (int k = lo; k \u003c= hi; k++) { if (i \u003e mid) seq[k] = aux[j++]; // this copying is unneccessary else if (j \u003e hi) seq[k] = aux[i++]; else if (AssistSort\u003cT\u003e.Less(aux[j], aux[i])) seq[k] = aux[j++]; else seq[k] = aux[i++]; } } public static void Sort(T[] seq) { if (seq == null) throw new ArgumentNullException(\"seq is null\"); if (!seq.Any()) return; int n = seq.Length; T[] aux = new T[n]; for (int len = 1; len \u003c n; len *= 2) // 1 2 4 8 16 { for (int lo = 0; lo \u003c n - len; lo += len + len) { int mid = lo + len - 1; int hi = Math.Min(lo + len + len - 1, n - 1); Merge(seq, aux, lo, mid, hi); } } } } 命题H:对于长度为N的任意数组，自底向上归并排序需要1/2NlgN至NlgN次比较，最多访问数组6NlgN次。 当数组长度为2的幂的时候，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同。 自底向上的归并排序比较适合链表组织的数据。这种方法只需要重新组织链表的链接就能将链表原地排序 自顶向下：化整为零。 自下向上：循序渐进。 命题I:没有任何基于比较的算法能够保证使用少于lg(N!)~NlgN次比较将长度为N的数组排序。 命题J：归并排序是一种渐进最有的基于比较排序的算法 ","date":"2020-11-28","objectID":"/2020/11/algorithm3/:1:11","tags":["算法","排序"],"title":"算法 排序","uri":"/2020/11/algorithm3/"},{"categories":"算法","content":"快速排序\r应用最广泛的系统。快速排序的内循环比大多数排序算法都要短小，这意味着它无论是在理论上还是在实际中都要更快。它的主要缺点是非常脆弱，在实现时要非常小心才能避免低劣的性能。 快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了 在归并排序中， 一个数组被等分为两半；在快速排序中，切分(partition ) 的位置取决于数组的内容。 快速排序和归并排序是互补的，快速排序方式当两个子数组都有序时，整个数据就自然有序了。 快速算法怎么将序列切分呢，哪个相当于中点的数是这样的，这个数的前面都比这个数小，这个数的后面都比这个数大， /// \u003csummary\u003e /// 快速算法应该是并归算法的一个变种，并归算是找中点，一切为二 /// 快速算法也是分治算法的一种，怎么将序列切分呢，哪个相当于中点的数是这样的，这个数的前面都比这个数小，这个数的后面都比这个数大， /// 这样不断切分，最后自然切分完自然序列排序好了。 /// 如果有大量重复的数据这个实现有点问题 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public static class QuickSort\u003cT\u003e where T : IComparable\u003cT\u003e { public static void Sort(T[] seq) { if (seq == null) throw new ArgumentNullException(\"seq is null\"); if (!seq.Any()) return; Sort(seq, 0, seq.Length - 1); } private static void Sort(T[] seq, int lo, int hi) { if (hi \u003c= lo) return; int j = Partition(seq, lo, hi); Sort(seq, lo, j - 1); Sort(seq, j + 1, hi); } /// \u003csummary\u003e /// 切分 /// a[lo..hi] =\u003e a[lo..j-1] = a[j] = a[j+1..hi] /// \u003c/summary\u003e /// \u003cparam name=\"seq\"\u003e\u003c/param\u003e /// \u003cparam name=\"lo\"\u003e\u003c/param\u003e /// \u003cparam name=\"hi\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e private static int Partition(T[] seq, int lo, int hi) { int i = lo; int j = hi + 1; T v = seq[lo]; //确保index k之前的数都比其小，index k之后的数都比其大 while (true) { // 找到第一个比第一项大的数index叫largeindex while (AssistSort\u003cT\u003e.Less(seq[++i], v)) { if (i == hi) break; } // 找到最后一个比第一项小的数index,litindex while (AssistSort\u003cT\u003e.Less(v, seq[--j])) { if (j == lo) break; // redundant since a[lo] acts as sentinel } // 检查第一个和最后一个是否交叉了 if (i \u003e= j) break; //将第一个项和最后一个项交换，确保比第一项小的数再第一项前面 AssistSort\u003cT\u003e.Exch(seq, i, j); } //这个切分点就是第一个数 AssistSort\u003cT\u003e.Exch(seq, lo, j); // 现在, a[lo .. j-1] \u003c= a[j] \u003c= a[j+1 .. hi] return j; } } 交换部分 可能出现的问题： 原地切分：使用辅助数组，很容易实现切分，但切分后的数组复制回去的开销会比较多。 别越界： 保持随机性： 终止循环： 处理切分元素值的重复情况 终止递归 性能优势： 用一个递增的索引将数组元素和一个定值比较。很难有排序算法比这更小的内循环。 快速排序的比较次数比较少。 快速排序最好的情况是：每次都正好将数组对半分， 命题K:将长度为N的无重复数组排序，快速排序平均需要2NlnN次比较。 命题L:快速排序最多需要约N^2/2次比较，但随机打乱数组能够预防这种情况。每次切分找到的切分值都是最大值或最小值 ","date":"2020-11-28","objectID":"/2020/11/algorithm3/:1:12","tags":["算法","排序"],"title":"算法 排序","uri":"/2020/11/algorithm3/"},{"categories":"算法","content":"快速排序该进熵最优\r如果有大量重复的元素，将数组切成三份，小于，等于和大于 /// \u003csummary\u003e /// 该算法主要针对序列中有大量相同的项，将序列分为三部分，小于，等于，大于 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public class QuickSort3WaySort\u003cT\u003e where T : IComparable\u003cT\u003e { private static void Sort(T[] seq, int lo, int hi) { if (hi \u003c= lo) return; //切分的lt，gt int lt = lo, gt = hi; T v = seq[lo]; int i = lo + 1; //切分 while (i \u003c= gt) { int cmp = seq[i].CompareTo(v); if (cmp \u003c 0) AssistSort\u003cT\u003e.Exch(seq, lt++, i++); else if (cmp \u003e 0) AssistSort\u003cT\u003e.Exch(seq, i, gt--); else i++; } //切分完成 // a[lo..lt-1] \u003c v = a[lt..gt] \u003c a[gt+1..hi]. Sort(seq, lo, lt - 1); Sort(seq, gt + 1, hi); } public static void Sort(T[] seq) { if (seq == null) throw new ArgumentNullException(\"seq is null\"); if (!seq.Any()) return; //AssistSort\u003cT\u003e.Shuffle(seq); Sort(seq, 0, seq.Length - 1); } } ","date":"2020-11-28","objectID":"/2020/11/algorithm3/:1:13","tags":["算法","排序"],"title":"算法 排序","uri":"/2020/11/algorithm3/"},{"categories":"算法","content":"快速排序改进三取样切分并小数组插入\r取子数组的中位数为切分点，取样大小s设为3并用大小s设为3并用大小居中的元素切分的效果最好。 ","date":"2020-11-28","objectID":"/2020/11/algorithm3/:1:14","tags":["算法","排序"],"title":"算法 排序","uri":"/2020/11/algorithm3/"},{"categories":"算法","content":"\r问题： 小数组时插入排序比快速排序要快 因为递归，快速排序sort()方法在小数组中也会调用自己。 简单操作将 if(hi \u003c= lo) return; 替换成 if(hi \u003c= lo+M) { Insertion.Sort(a,lo,hi); return;} /// \u003csummary\u003e /// 快速算法的痛点是在小序列的排序性能并不好，所有该X实现在小序列的时候排序采用插入排序算法 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public class QuickSortX\u003cT\u003e where T : IComparable\u003cT\u003e { private static readonly int INSERTION_SORT_CUTOFF = 8; private static void Sort(T[] seq, int lo, int hi) { if (hi \u003c= lo) return; // cutoff to insertion sort (Insertion.sort() uses half-open intervals) int n = hi - lo + 1; if (n \u003c= INSERTION_SORT_CUTOFF)//少量数组插入排序 { InsertionSort\u003cT\u003e.Sort(seq, lo, hi + 1); return; } int j = Partition(seq, lo, hi); Sort(seq, lo, j - 1); Sort(seq, j + 1, hi); } // partition the subarray a[lo..hi] so that a[lo..j-1] \u003c= a[j] \u003c= a[j+1..hi] // and return the index j. private static int Partition(T[] seq, int lo, int hi) { int n = hi - lo + 1; int m = Median3(seq, lo, lo + n / 2, hi);//三取样点，lo,中点,hi AssistSort\u003cT\u003e.Exch(seq, m, lo); int i = lo; int j = hi + 1; T v = seq[lo]; // a[lo] is unique largest element while (AssistSort\u003cT\u003e.Less(seq[++i], v)) { if (i == hi) { AssistSort\u003cT\u003e.Exch(seq, lo, hi); return hi; } } // a[lo] is unique smallest element while (AssistSort\u003cT\u003e.Less(v, seq[--j])) { if (j == lo + 1) return lo; } // the main loop while (i \u003c j) { AssistSort\u003cT\u003e.Exch(seq, i, j); while (AssistSort\u003cT\u003e.Less(seq[++i], v)) ; while (AssistSort\u003cT\u003e.Less(v, seq[--j])) ; } // put partitioning item v at a[j] AssistSort\u003cT\u003e.Exch(seq, lo, j); // now, a[lo .. j-1] \u003c= a[j] \u003c= a[j+1 .. hi] return j; } private static int Median3(T[] seq, int i, int j, int k) { return (AssistSort\u003cT\u003e.Less(seq[i], seq[j]) ? (AssistSort\u003cT\u003e.Less(seq[j], seq[k]) ? j : AssistSort\u003cT\u003e.Less(seq[i], seq[k]) ? k : i) : (AssistSort\u003cT\u003e.Less(seq[k], seq[j]) ? j : AssistSort\u003cT\u003e.Less(seq[k], seq[i]) ? k : i)); } public static void Sort(T[] seq) { if (seq == null) throw new ArgumentNullException(\"seq is null\"); if (!seq.Any()) return; //AssistSort\u003cT\u003e.Shuffle(seq); Sort(seq, 0, seq.Length - 1); } } 命题M:不存在任何基于比较的排序算法能够保证在NH-N次比较之内将N个元素排序， 命题N:三向切分的快速排序需要(2ln2)NH次比较 ","date":"2020-11-28","objectID":"/2020/11/algorithm3/:1:15","tags":["算法","排序"],"title":"算法 排序","uri":"/2020/11/algorithm3/"},{"categories":"算法","content":"快速排序中型数组排序\r/// \u003csummary\u003e /// 该算法进一步升级，不仅在小序列排序时实现插入排序，在中型序列实现三分排序。 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public class QuickBentleyMcIlroySort\u003cT\u003e where T : IComparable\u003cT\u003e { // cutoff to insertion sort, must be \u003e= 1 private static readonly int INSERTION_SORT_CUTOFF = 8; // cutoff to median-of-3 partitioning private static readonly int MEDIAN_OF_3_CUTOFF = 40; /// \u003csummary\u003e /// Rearranges the array in ascending order, using the natural order. /// \u003c/summary\u003e /// \u003cparam name=\"seq\"\u003e\u003c/param\u003e public static void Sort(T[] seq) { if (seq == null) throw new ArgumentNullException(\"seq is null\"); if (!seq.Any()) return; Sort(seq, 0, seq.Length - 1); } private static void Sort(T[] seq, int lo, int hi) { int n = hi - lo + 1; // cutoff to insertion sort if (n \u003c= INSERTION_SORT_CUTOFF) { InsertionSort(seq, lo, hi); return; } // use median-of-3 as partitioning element else if (n \u003c= MEDIAN_OF_3_CUTOFF) { int m = Median3(seq, lo, lo + n / 2, hi); AssistSort\u003cT\u003e.Exch(seq, m, lo); } // use Tukey ninther as partitioning element else {//其实就是扩大切分点的寻找范围，最有希望找到中间点，达到最有的快速排序 int eps = n / 8; int mid = lo + n / 2; int m1 = Median3(seq, lo, lo + eps, lo + eps + eps); int m2 = Median3(seq, mid - eps, mid, mid + eps); int m3 = Median3(seq, hi - eps - eps, hi - eps, hi); int ninther = Median3(seq, m1, m2, m3); AssistSort\u003cT\u003e.Exch(seq, ninther, lo); } // Bentley-McIlroy 3-way partitioning int i = lo, j = hi + 1; int p = lo, q = hi + 1; T v = seq[lo]; while (true) { while (AssistSort\u003cT\u003e.Less(seq[++i], v)) if (i == hi) break; while (AssistSort\u003cT\u003e.Less(v, seq[--j])) if (j == lo) break; // pointers cross if (i == j \u0026\u0026 AssistSort\u003cT\u003e.Eq(seq[i], v)) AssistSort\u003cT\u003e.Exch(seq, ++p, i); if (i \u003e= j) break; AssistSort\u003cT\u003e.Exch(seq, i, j); if (AssistSort\u003cT\u003e.Eq(seq[i], v)) AssistSort\u003cT\u003e.Exch(seq, ++p, i); if (AssistSort\u003cT\u003e.Eq(seq[j], v)) AssistSort\u003cT\u003e.Exch(seq, --q, j); } i = j + 1; for (int k = lo; k \u003c= p; k++) AssistSort\u003cT\u003e.Exch(seq, k, j--); for (int k = hi; k \u003e= q; k--) AssistSort\u003cT\u003e.Exch(seq, k, i++); Sort(seq, lo, j); Sort(seq, i, hi); } // sort from a[lo] to a[hi] using insertion sort private static void InsertionSort(T[] seq, int lo, int hi) { for (int i = lo; i \u003c= hi; i++) for (int j = i; j \u003e lo \u0026\u0026 AssistSort\u003cT\u003e.Less(seq[j], seq[j - 1]); j--) AssistSort\u003cT\u003e.Exch(seq, j, j - 1); } // return the index of the median element among a[i], a[j], and a[k] private static int Median3(T[] seq, int i, int j, int k) { return (AssistSort\u003cT\u003e.Less(seq[i], seq[j]) ? (AssistSort\u003cT\u003e.Less(seq[j], seq[k]) ? j : AssistSort\u003cT\u003e.Less(seq[i], seq[k]) ? k : i) : (AssistSort\u003cT\u003e.Less(seq[k], seq[j]) ? j : AssistSort\u003cT\u003e.Less(seq[k], seq[i]) ? k : i)); } } ","date":"2020-11-28","objectID":"/2020/11/algorithm3/:1:16","tags":["算法","排序"],"title":"算法 排序","uri":"/2020/11/algorithm3/"},{"categories":"算法","content":"Bag（包）\r背包：不支持删除元素的集合数据类型。 public interface IBag\u003cTItem\u003e : IEnumerable\u003cTItem\u003e, IDisposable { bool IsEmpty { get; } int Length { get; } void Add(TItem item); } ","date":"2020-11-22","objectID":"/2020/11/algorithm2/:1:0","tags":["算法","包","栈","队列"],"title":"算法 包 栈 队列","uri":"/2020/11/algorithm2/"},{"categories":"算法","content":"数组实现\rpublic class ResizingArrayBagNet\u003cTItem\u003e:IBag\u003cTItem\u003e { private TItem[] _items; private int _length; public ResizingArrayBagNet() { _items=new TItem[2]; _length = 0; } public IEnumerator\u003cTItem\u003e GetEnumerator() { if (!IsEmpty) { for (var i = 0; i \u003c _length; i++) { yield return _items[i]; } } } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } public void Dispose() { throw new NotImplementedException(); } protected virtual void Dispose(bool disposing) { if (disposing) { if (!IsEmpty) { for (var i = 0; i \u003c _length ; i++) { _items[i] = default; } } } } public bool IsEmpty =\u003e _length == 0; public int Length =\u003e _length; public void Add(TItem item) { if(_length==_items.Length) resize(_length*2); _items[_length++] = item; } private void resize(int capacity) { var temitems=new TItem[capacity]; Array.Copy(_items,0,temitems,0,_length); _items = temitems; } } ","date":"2020-11-22","objectID":"/2020/11/algorithm2/:1:1","tags":["算法","包","栈","队列"],"title":"算法 包 栈 队列","uri":"/2020/11/algorithm2/"},{"categories":"算法","content":"链表下压栈\rpublic class LinkedBagNet\u003cTItem\u003e : IBag\u003cTItem\u003e { private Node _first; private int _length; private class Node { public TItem Item { set; get; } public Node Next { set; get; } } public LinkedBagNet() { _length = 0; _first = default; } public IEnumerator\u003cTItem\u003e GetEnumerator() { if (!IsEmpty) { var temnode = _first; while (temnode != default) { var item = temnode.Item; temnode = temnode.Next; yield return item; } } } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } public void Dispose() { Dispose(true); } protected virtual void Dispose(bool disposing) { if (disposing) { if (!IsEmpty) { var temnode = _first; while (temnode != default) { temnode.Item = default; temnode = temnode.Next; } } } } public bool IsEmpty =\u003e _length == 0; public int Length =\u003e _length; public void Add(TItem item) { Node oldeNode = _first; _first=new Node(); _first.Item = item; _first.Next = oldeNode; _length++; } } ","date":"2020-11-22","objectID":"/2020/11/algorithm2/:1:2","tags":["算法","包","栈","队列"],"title":"算法 包 栈 队列","uri":"/2020/11/algorithm2/"},{"categories":"算法","content":"Stack（栈）\r栈：后进先出。 游离：弹出的元素所在的引用必须要置空，不然没办法被垃圾回收器回收。 public interface IStack\u003cTItem\u003e : IEnumerable\u003cTItem\u003e, IDisposable { bool IsEmpty { get; } int Length { get; } void Push(TItem item); TItem Pop(); } 栈应用：算术表达式求值： 将操作数压入操作数栈 将运算符压入运算栈 忽略左括号 在遇到右括号时，弹出一个运算符，弹出所需要数量的操作数，并将运算符和操作数的运算结果压入操作数栈。 ","date":"2020-11-22","objectID":"/2020/11/algorithm2/:2:0","tags":["算法","包","栈","队列"],"title":"算法 包 栈 队列","uri":"/2020/11/algorithm2/"},{"categories":"算法","content":"数组实现\rpublic class ResizingArrayStackNet\u003cTItem\u003e : IStack\u003cTItem\u003e { private TItem[] _items; private int _length; public ResizingArrayStackNet() { _items = new TItem[2]; _length = 0; } public int Length =\u003e _length; public bool IsEmpty =\u003e _length == 0; private void resize(int capacity) { var temitems=new TItem[capacity]; Array.Copy(_items,0,temitems,0,_items.Length); _items = temitems; } public void Push(TItem item) { if(_length==_items.Length) resize(2*_length); _items[_length++] = item; } public TItem Pop() { if (IsEmpty) return default; TItem item = _items[--_length] ; _items[_length] = default; if(_length\u003e0 \u0026\u0026 _length==_items.Length/4) resize( _items.Length / 2); return item; } public IEnumerator\u003cTItem\u003e GetEnumerator() { if(!IsEmpty) { for(var i=0;i\u003c_length;i++) { yield return _items[i]; } } } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } public void Dispose() { Dispose(true); } protected virtual void Dispose(bool disposing) { if (disposing) { if (!IsEmpty) { for (var i = 0; i \u003c _length; i++) { _items[i] = default; } } } } } ","date":"2020-11-22","objectID":"/2020/11/algorithm2/:2:1","tags":["算法","包","栈","队列"],"title":"算法 包 栈 队列","uri":"/2020/11/algorithm2/"},{"categories":"算法","content":"链表实现下压堆栈\rpublic class LinkedStackNet\u003cTItem\u003e : IStack\u003cTItem\u003e { private Node _first; private class Node { public TItem Item { set; get; } public Node Next { set; get; } } public LinkedStackNet() { _length = 0; _first = default; } public IEnumerator\u003cTItem\u003e GetEnumerator() { if (!IsEmpty) { var temnode = _first; while (temnode != default) { var item = temnode.Item; temnode = temnode.Next; yield return item; } } } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } public void Dispose() { Dispose(true); } protected virtual void Dispose(bool disposing) { if (disposing) { if (!IsEmpty) { var temnode = _first; while (temnode != default) { temnode.Item = default; temnode = temnode.Next; } _length=0； _first=default; } } } private int _length; public bool IsEmpty =\u003e _length == 0; public int Length =\u003e _length ; public void Push(TItem item) { Node oldfirst = _first; _first=new Node(); _first.Item = item; _first.Next = oldfirst; _length++; } public TItem Pop() { if (IsEmpty) return default; var item = _first.Item;//不存在游离的问题，这个Node被GC回收 _first = _first.Next; _length--; return item; } } ","date":"2020-11-22","objectID":"/2020/11/algorithm2/:2:2","tags":["算法","包","栈","队列"],"title":"算法 包 栈 队列","uri":"/2020/11/algorithm2/"},{"categories":"算法","content":"Queue（队列）\r队列：先进先出（FIFO） public interface IQueue\u003cTItem\u003e : IEnumerable\u003cTItem\u003e, IDisposable { bool IsEmpty { get; } int Length { get; } void Enqueue(TItem item); TItem Dequeue(); } ","date":"2020-11-22","objectID":"/2020/11/algorithm2/:3:0","tags":["算法","包","栈","队列"],"title":"算法 包 栈 队列","uri":"/2020/11/algorithm2/"},{"categories":"算法","content":"数组实现\rpublic class ResizingArrayQueueNet\u003cTItem\u003e : IQueue\u003cTItem\u003e { public ResizingArrayQueueNet() { _first = 0; _last = 0; _items=new TItem[2]; } public IEnumerator\u003cTItem\u003e GetEnumerator() { if (!IsEmpty) { for (var i = _first; i \u003c _last; i++) { yield return _items[i]; } } } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } public void Dispose() { Dispose(true); } protected virtual void Dispose(bool disposing) { if (disposing) { if (!IsEmpty) { for (var i = _first; i \u003c _last; i++) { _items[i] = default; } _items = null; } } } private TItem[] _items; private int _first; private int _last; public bool IsEmpty =\u003e (_last - _first) == 0; public int Length =\u003e _last-_first; private void resize(int size) { var temitems=new TItem[size]; var temlength = Length; Array.Copy(_items,_first,temitems,0,Length); _first = 0; _last = temlength; _items = temitems; } public void Enqueue(TItem item) { if(_last==_items.Length) resize(Length*2); _items[_last++] = item; } public TItem Dequeue() { if (IsEmpty) return default; var item = _items[_first++]; if(Length\u003c_items.Length/4) resize(_items.Length/2); return item; } } ","date":"2020-11-22","objectID":"/2020/11/algorithm2/:3:1","tags":["算法","包","栈","队列"],"title":"算法 包 栈 队列","uri":"/2020/11/algorithm2/"},{"categories":"算法","content":"链表实现下压队列\rpublic class LinkedQueueNet\u003cTItem\u003e : IQueue\u003cTItem\u003e { private Node _first; private Node _last; private int _length; public LinkedQueueNet() { _first = null; _last = null; _length = 0; } private class Node { public TItem Item { set; get; } public Node Next { set; get; } } public IEnumerator\u003cTItem\u003e GetEnumerator() { if (!IsEmpty) { var temnode = _first; while (temnode != default) { var item = temnode.Item; temnode = temnode.Next; yield return item; } } } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } public void Dispose() { Dispose(true); } protected virtual void Dispose(bool disposing) { if (disposing) { if (!IsEmpty) { var temfirst = _first; while (temfirst != default) { temfirst.Item = default; temfirst = temfirst.Next; } _length = 0; } } } public bool IsEmpty =\u003e _length == 0; public int Length =\u003e _length; public void Enqueue(TItem item) { var temnode = _last; _last = new Node(); _last.Item = item; _last.Next = null; if (IsEmpty) _first = _last; else temnode.Next = _last; _length++; } public TItem Dequeue() { if (_length \u003e 0) { var temitem = _first.Item; _first = _first.Next; _length--; return temitem; } return default; } } ","date":"2020-11-22","objectID":"/2020/11/algorithm2/:3:2","tags":["算法","包","栈","队列"],"title":"算法 包 栈 队列","uri":"/2020/11/algorithm2/"},{"categories":"OPCUA","content":"前言\r一毕业第一个项目就做了OPC数据转发，面向API编程，调用固定接口，定时器轮询从OPC DA2.0 Server中获取数据写到数据库，定时器5分钟写一次，数据量比较大，有几千个点，当时是数据库有一个主表，通过主表的触发器，会为每个点生成一个子表，数据都往子表里写。可以说非常low了。有时候数据库和server需要走Network,DA是需要配置COM的，非常的麻烦。就开始研究OPCUA,也是面向API编程，调包程序员。再后来项目不需要就不研究了。在Github上找过其源码但是没有看过觉得真是一大遗憾，有一种只问其声，未见其人的感觉，非常的不爽。最近要写一个组件用到OPCUA，所以仔细看了它的源码。OPC的网上资料很少，有一本书写的太过理论，学组件还是直接看源码，源码看懂了再看概念理论就会非常清晰了。 底层通讯\rApplicationInstance:该类是服务的包装类，提供了加载参数，启动服务的方法。相当于服务入口。 Server:最重要的服务类： Server的接口非常多，但是扩展却非常容易，自己扩展只需要继承StandardServer就可以了。它是怎么实现各种订阅，浏览，事件，方法等功能的呢，这里面最重要的是用了一个Manager的思想。关注ServerInternal属性，其是ServerInternalData类，这个类非常像外观模式，包含了很多Manager。每个Manager是相当于一个组件管理器。比如NodeManager，所有的节点管理都在这个Manager中，还有SubscriptionManager,SessionManager,EventManager等。服务除了Manager，还有Certificate，OPCUA的安全这一块做的真好，TransportListeners管理所有的Host。 Server中TransportListeners，底层通讯。 OPCUA默认实现了三种Host:UaHttpsChannelListener,UaTcpChannelListener,NullListener,这边用到了空对象模式，从名字就可以看出来Listener的职责就说监听连接，TCP监听实现是通过完成端口模型。 在OnAccept中：一旦有链接，就创建Channel来处理数据请求 channel内部对Socket完成端口模型进行了封装，TcpMessageSocket 在TcpMessageSocket内部： 接受数据完成端口模型，最终调用了Channel的OnMessageReceived方法 在Channel中处理消息，在ProcessRequestMessage方法内部调用了m_RequestReceived回调函数，其实是调用了Listener中的OnRequestReceived方法，该方法实际上是将请求给了专门ReceiveDataHandle类：SessionEndpoint类来处理请求，这个类其实对请求数据的一种管理，所有的请求都给了SessionEndpoint中BeginProcessRequest方法，这个SessionEndpoint管理器会创建一些具体解析请求的类，来处理请求ProcessRequestAsyncResult， 在具体处理数据内部肯定是调用管理器类SessionEndpoint来具体请求数据，这边将找到的Service保存到m_Service中，只不过这边又做了一个请求处理队列，ServerForContext就是Server，server最后还是调用这个类的CallSynchronously方法，然后调用m_service的 ProcessRequestAsyncResult调用m_service 这个m_service就是一开始在SessionEndpoint管理的服务，这些服务最后都指向Server中的一个方法。 比如Browse服务就是Server中的Browse方法。 通讯框架总结\rServer管理所有的Listener集合 Listener负责监听 Channel负责处理链接，解析消息结构 TcpMessageSocket负责封装Socket来收发消息 SessionEndpoint封装所有对消息体处理的服务，这些服务其实都是Server中方法委托。 TcpMessageSocket接受到消息最终调用SessionEndpoint中的BeginProcessRequest方法，然后生成了消息处理类ProcessRequestAsyncResult，该类将请求给了server中的RequestQueue,Server处理队列最终是调用ProcessRequestAsyncResult中的方法找到SessionEndpoint中对应的处理服务，调用server中对应的方法。 Server负责创建SessionEndpoint实例，Listen负责调用SessionEndpoint实例方法解析数据，channel负责解析数据类型调用Listen方法。 协议格式\r在Channel的OnMessageReceived方法中，协议头中前4个字节是消息的类型：也就是消息ID，详情可以看TcpMessageType类 channel中的ReadSymmetricMessage方法，可以消息头：一共24个字节 MessageType;MessageSize;channelID;tokenId;sequenceNumber;requestId都是4个字节 channel解密TokenID 通过Token解密消息，还可以看出消息的最后字节是Signature。 还是在Channel的ReadSymmetricMessage 方法中 消息的最后还有一些没有用的填充消息，在签名的前一个字节为填充长度 协议内容： MessageType;MessageSize;channelID;tokenId;sequenceNumber;requestId;MessageBogy;Padding;Signature. 总结 整个协议的格式都是在Channel的ReadSymmetricMessage方法中解析的，主要解析了协议头，签名和获取MessageBody并进行解密。 消息体\r在channel的ProcessRequestMessage方法中看到对消息体的解析，将MessageBody解析成ServiceRequest 整个解析职责是交给了BinaryDecoder类,Decoder实际是调用IEncodeable来进行解码，这边有点像迭代器模式，集合实现IEnumerable,而调用者使用IEnumator进行遍历。 MessageBody:NodeId+NodeValue+IEncodeable。，通过NodeId获取实际是IEncodeableType,调用其Decode方法，获取IEncodeable，然后显示转化为IServiceRequest接口 通过ID来获取解码类，进行解码： 解码类从哪里来呢？通过工厂，工厂通过反射获取程序集中所有IEncodeable 至此解析出具体请求类进行回调，也就是将请求类交给SessionEndpoint进行处理。 总结：Channel调用Decoder，这边Decoder负责解析MessageBody,具体的解析操作职责给IEncodeable的子类。解析完后将IEncodeable显示转化为IServiceRequest交给SessionEndpoint处理。 感悟\r软件中的架构大体和现实世界差不多，如果一个需求有多个不同的操作，就将其抽象为子类，一个管理器Manager或者XXXer负责管理所有的子类集合，子类可以由专门的工厂类创建也可以是由管理器创建。 现实生活中一个公司就相当于一个软件，有一个总经理（Master/Server/Instance）总经理负责协调各个部门，每个部门的部长就相当于(Manager/Presenter/Controller…)，它负责安排这个部门的职责，也就是管理部门里面的员工集合，员工就是具体干活的类，这些类可以由基类派生或实现统一的接口。派生类如何生成可以由部长负责，也可以由部长请求公司的HR相当于工厂生成派生类。工厂可以是抽象工厂也可以工厂模式，为每个部门生成一个工厂子类。 以OPCUA的通讯为例： Server就相当于总经理，通讯组件(销售)就相当于一个通讯部门这边部长和总经理和二为一，可能这个部门非常重要，总经理想亲自管理，Listeners就相当于具体干活的员工，每个Listener(销售)负责一个通讯线的对接，每当有通讯连接就派Channel(具体负责哪个厂)去负责对接内容，Channel说对接内容还需要一个人去专门的地方去就派了MessageSocket通过完成端口模型去取通讯消息，MessageSocket每次取到消息就把消息给Channel解析，Channel先解析这是上面类型的消息，将其具体解析为一个请求文件，这个请求文件都汇总给了由Listener指派的SessionEndpoint这个人（有点像总经理秘书），这个人将负责管理所有的请求文件种类。它收到请求文件其实就把请求给了总经理，总经理根据不同的请求将请求转发给其他部门的人干。 ","date":"2020-10-31","objectID":"/2020/10/opcua1-source/:0:0","tags":["OPCUA","源码解析"],"title":"OPCUA 源码解析","uri":"/2020/10/opcua1-source/"},{"categories":"嵌入式","content":"在B站上看到有大佬做了个8位计算机，非常感兴趣，同时想了解一下计算机底层到底是怎么运作的，就跟着做了一个。以下是笔记，写的比较细。 先show一下代码 序号 指令 说明 0 OUT 显示 1 ADD 15 加上地址15的值 2 JC 4 进位跳转到地址4 3 JMP 0 没有进位跳转到地址0 4 SUB 15 减去地址15的值 5 OUT 显示 6 JZ 0 为0跳转到地址0 7 JMP 4 不为0跳转到地址4 15地址设置成15； 代码意思是：值自增15，如果到达进位255就变成自减15，如果自荐到达0就自增。 基础知识\r","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:0:0","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"二极管\r单项导通器件 1874年，德国科学家发现晶体的整流功能 由半导体硅材料制成，硅本身是没有电极的，在做晶体管的时候做了杂化处理，在一段加入了硼，一段加入了磷，硼这端会多出电子空穴，而磷这一端会多出自由电子，有意思的事情就发生了。 因为Si是4个电子，P有3个电子，N有5个电子，所以单纯的硅会形成4个共价键非常稳定。 硅: 磷：N 硼：P 当杂化之后，P端就会有很多电子空穴，N端会多出很多自由电子，在PN交界的地方，N端电子会自动移动到P端，形成一个耗尽区，耗尽区的电压为0.7V,所以大多5V的芯片低电压为0.2V，如果超过0.7V则视为高电压 如果加入正电压会使耗尽区扩大，造成正向偏压，如果加入反向电压，大于耗尽区0.7V电压的时候，电子从N极向P极移动没有任何障碍。 绘出曲线，横坐标是电源电压，纵坐标是电流，负向电压的时候几乎没有电流，负向电压特别大的时候会击穿，正向电压大于0.7V的时候会很快获得很大的电流。 二极管的这一特性可以做一个桥式整流电路 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:1:0","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"三极管\r三极管就是二极管的升级，例如NPN型三极管 这样在NP的交界处就会形成两个耗尽区， 可以看成两个二极管背靠背相连，不管电源处于哪个状态总有一个二极管处于反向加压的状态，不导通。但是如果中间加一个电源（第二个电源），大量电子会从P端出来，通过电源到达N端形成通路 形成通路后，大量电子会到P端，形成反向偏压， 如果整体来看，P端非常的窄，并不会存储大量电子，大量电子在第一个电源的驱动下回到电源，形成电流，因为第一个电源的电压比较大，驱动力比较大，第二个电源电压比较小，驱动力比较小 这种现象简而言之就是 一个小电流被放大成一个大电流， 一个断路变成一个通路 这种晶体管叫双极结晶体管， 晶体管有两种工作方式： 通过电流，将一个小电流放大成大电流， 通过电压，只要基极和发射机有电势差，集电极和发射极就会产生大电流，这种又叫场效应管 双极结型晶体管做的放大电路 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:2:0","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"门电路\r晶体管的基本原理已经知道了，门电路就是基于三极管构成相关电路 非门电路： 与门电路： 或门电路 异或门 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:3:0","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"锁存器\r锁存器用来做寄存器 将或门改造一下就可以就是SR锁存器 SR锁存器 再次进阶D锁存器,D锁存器是构建寄存器的基础，本计算机种所有的寄存器都是由D锁存器构造 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:4:0","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"触发器\r触发器是为了获取极短时间内的上升沿 第一种方法： 从0变成1的时候，非门需要几个纳秒的时候才能将状态转过来，所以在非常短的时候内会出现都为1，这个时候与门输出1，然后非门后的状态0输入，导致输出变为0，这样输出只有几个纳秒是1。 第二种方法： 通过电容来实现 电容和电阻，当信号来的时候电容充电，获得输出1，当几十纳秒后，电容充满电，信号就变成0了 计算时间 D触发器，就是将之前的SR锁存器的Enable改造一下 SR触发器： SR触发器，在SR都为1的时候，处于一种无效的状态，没有任何输出。当SR变成0的时候，谁慢一点谁就会被触发。这是一种随机状态。 为了解决这个问题： 第一种情况 JK都为0，这是一种随机状态，也成为不确定状态 第二种状态K=1,J=0的时候，处于reset状态，Q=0,反Q=1 第三种状态K=0,J=1的时候，处于set状态Q=1,反Q=0 最有意思的是第四种状态K=1,J=1的时候，信号会发生一次对调 这样会出现问题 在这个脉冲内做了很多次转换，也就是只要两个输入都是高电平，这个转换就一直持续。 这种情况叫做抢先。 所以发现这个根本原因出现这个脉冲电路上，这个上升沿时间太多了。如果时间控制在100ns的时间内就可以只完成1次转换。 把1K电阻换成100电阻，已经控制了100ns的时间，发现还是不行 因为信号有抖动，边缘探测不锐利 用主从JK触发器来解决这个问题 高电压的时候使第一个锁存器工作，在低电压的时候使第二个锁存器工作。 这样就完全可以避免之前的问题 可以看到这有两个锁存器，这两个锁存器不可能同时工作，clock高电位第一个锁存器工作，clock低电位第二个锁存器工作，主从对应的RS正好相反 如果高电压，主锁存器是SET，到低电压的时候从锁存器就是reset， 如果都是1的时候，那么主锁存器执行的操作是由从锁存器的状态决定的，而从锁存器的状态正好与主锁存器状态相反 这样当一个脉冲来的时候，set和reset会执行一次交换。 基本模块\r计算机需要的模块：1.主脉冲，2.计数器，3.计数器寄存器，4.寄存器A，5.寄存器B，6.ROM，7.指令寄存器，9.显示模块，9.控制模块，10.标志位寄存器。 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:5:0","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"主脉冲模块\r","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:6:0","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"主脉冲\r主脉冲使用555芯片 时许分析 开始的时候，没有上电 开始上电的时候 通过电容放电和充电的时间来控制方波的占空比， 外界的电容和电阻决定了方波的长度 通过公式来计算 总的时间是0.139S 在5号引脚加入一个0.01uf的电容接地，可以降噪 当有信号的时候，一堆晶体管需要获取更多的电量，这个时候就会从电源端拉出更多的电流，就会形成电路中非常常见的过充的现象。 电线也会产生一些阻抗，也会阻止电流的变化，所以这个电压就会跳上去， 直接的办法给电路接一个非常短的线路 给正极和负极加一个电容，在电路需要电流的时候给电路提供更多的电流。 在四号引脚接入一个5V高电平，防止Reset锁存器，这样就不存在误操作。 调整时钟的速度，把100K换成可变电阻 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:6:1","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"单步脉冲\r为了更好的测试电路，需要有一个单步脉冲，类似程序的单步执行，按钮按一下给一个脉冲 单步脉冲的意思是按1下产生1个脉冲，用555芯片来消除按钮的抖动 555芯片，消除抖动电路，可以控制灯亮的时间 电阻是1M，电容是2uf，0.1uf，0.1S时间间隔，这边要注意在电路不同的状态，6，7的电压应该是5V， 稳态和单稳态 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:6:2","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"切换电路\r将两个状态的输出型号添加到一个开关中，切换开关可以切换2个状态、 但是开关会有一个新的问题，当切换的时候有一个延迟的问题，这个时候需要一个新的555芯片来解决这个问题，其实是用到555芯片内的SR锁存器 开关有一个特性叫做先断后连， 这个电路主要是解决开关弹跳的问题， 将这三个电路合并起来 这样就可以在自动和手动切换 HLT作用是关闭定时器，接入低电平， 74LS04有6个非门 这样一个电路需要用到三种芯片效率非常低，可以把电路给改一下 跟之前的效果一样，只用到了与非门 最终效果 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:6:3","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"总线\rBUS的工作原理： 这8条线没有回路，可以跑1bit的数据这非常的灵活 Load:表示数据可以放到芯片中 Enable:表示数据从芯片放到Bus中 这里面边上的蓝色线就是控制线，可以看到这个控制线就是Clock,所有的部件同步Load enable线来控制芯片将数据写到总线中，这需要同时只有1个芯片进行这样的操作，不然就会造成混乱 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:7:0","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"三态门\r在总线中有一个非常重要的事情，就是同一时间只有一个部件向总线中输出数据，每个部件的输出端其实就是芯片内部门电路的输出端。 通常都会用两个这样输出， 三态门：，0，1，和断路三种状态 74LS245 8路三态门芯片 每个模块都接入一个Enable线，每个模块都接入Bus中， 同1时刻只有一个模块Enable线为true，就可以保证只有该数据写入到总线中。 当load为高电平的时候，它会在下一个时钟周期高电平到来的时候将总线中数据读取到模块中。 所有需要写入总线的模块都需要该245模块 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:7:1","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"寄存器\r整个计算机需要8位寄存器A，8位寄存器B，4位计数器寄存器，8位指令寄存器 寄存器的构造是使用D锁存器，有高信号就可以保存住高信号 可以通过D触发器来构建寄存器，同时加入一个Load控制，下面这种是Load为0的情况，输出是什么输入还是什么 Load为1的情况，输入什么输出还是什么 74LS74内有2个D触发器 通过搭建上面的电路可以实现 数据不可以直接输出到总线中，需要在输出中加入74LS245 三态门 74LS173由4个D触发器，包含Load和Enable 因为需要外接小灯查看寄存器中的值，所以173芯片中的三态门一直处于打开状态，外界一个三态门来控制输出。 本计算机种需要用到三个相同原理的寄存器模块，寄存器A，寄存器B，指令寄存器。 指令寄存器就是与寄存器A的方向相反 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:8:0","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"ALU\r","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:9:0","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"补码\r编码方式： 用最高位表示符号位，这样-5和5相加得2是不对的 另一种编码方式：得1补码：用反码表示负数 -5和5相加得到都是1，这就是得1补码的原因 比正确的结果少1；如果将结果加1就可以得到正确的结果 第三种编码方式：得2补码，反码+1表示负数 每一位都有含义 取反+1； 补码：取反+1表示负数，上面为解释为什么取反+1比较好。 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:9:1","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"全加器\r1位加法运算，一共就8中情况，前四种不考虑前面的进位，后四种情况考虑一下之前的进位 结果有两位，第一位表示结算结果，第二位表示是否有进位 第一位前四种情况可以用异或门来表示 0，0 =》0 0，1=》1 1，0=》1 1，1=》0 第二位前四种情况可以用与门来表示 0，0=》0 0，1=》0 1，0=》0 1，1=》1 进位4种情况：可以发现第一位进位四种情况正好和之前的相反 那么进位的第一位变化的四种情况就可以直接在之前的结果后面加如一个异或门。异或门可以控制结果取反， 有进位的第二位四种情况，不仅要考虑本身有进位还要考虑第一位出现进位的情况 将进位情况求和 这个电路叫做1位全加器 每个全加器需要2个异或门，2个与门，1一个或门 1个异或门需要2个晶体管 1个与门需要2个晶体管 1个或门需要2个晶体管 那么可以总结出1个全加器需要10个晶体管，也就是10个三极管，也就是10个晶体管可以计算出1位计算器。 4个全加器组合成4位加法器 需要的材料和电路图 74LS86内有4个异或门芯片 74LS08内有4个与门芯片 74LS32内有4个或门 2个四位拨叉开关 1个面包板 4个小灯显示结果1个进位 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:9:2","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"ALU\rArithmetic Logic Unit:算术逻辑单元 该模块其实完全由全加器构成 用寄存器A和寄存器B，中间加入ALU逻辑电路，这样该模块就可以计算出寄存器A和寄存器B的求和或相减。 对寄存器中的数据进行操作 通过之前的全加器来构建逻辑单元 ， 如何做减法， 现在全加器可以实现加法，是否可以将被减数变成负数然后执行加法运算 通过异或门，当A为1的时候相当于取反，当A为0的时候原样输出 通过异或门获取反码 4位加法器有一个进位，将这个1和控制器连接起来，如果如果控制器是减法的话，那正好需要进位 这样就实现了一个数补码加1的操作。 中间的就是ALU 先要进行测试，测试是有必要的， 如果出现故障需要先排除故障，先从最简单的部分入手，然后慢慢缩小范围。 先设置A寄存器是0，B寄存器是0 然后让B存器器是0，然后让A每一位依次置1，查看是否有问题，发现问题然后跟踪这条线， 然后让A寄存器是0，然后B依次置1； 出现问题需要刨根问底将其找出来。 不要慌，从第一步开始的第一个异常，首先分析可能出现这个现象的原因，大多数情况下都想不出， 查看接线是否正常，接线正常后查看所有输出输入，特定的输入产生特定的输出，通过万用表量输入和输出电压。 将ALU中产生的数据直连到总线中，每当有脉冲的时候，A寄存器从总线中读取值，ALU从A中读值，从B中读值进行加操作，并将操作的结果放到总线中，1个脉冲实现加放到总线中读取总线数据的操作。 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:9:3","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"ROM\r本计算机构建了16个字节的内存； 内存的构建有两种方式， 1.直接通过D锁存器构建 2.直接通过一个电容和一个晶体管构建，然后有一个电容不停刷新这个电容的数据。 1word的寄存器，1个字节寄存器，输入输出，写和读 16个字节 哪个字节的Enable开，哪个字节的数据就被读出来， 这样需要对16个字节进行编码 第一步 需要对16个字节进行编码，每个字节有8个D锁存器，也就是128个D锁存器 0-16这16个数字表示地址，也就是4个bit位，这样一个数字代表一个字节。 地址译码单元直接输出这个地址，地址译码单元怎么构造，首先需要有4个bit输入，每个输入有高低输出，然后构建一个有5个输入的与门，1位标识load，然后四位对应地址，那么就有16个5位输入与门，代表16个地址 这个地址电路应该在内存电路的前面，4个输入就可以让内存电路输出该地址的数据。 74LS189就是一个内存芯片，是一个64bit的存储器，有4个地址输入，16个地址位每个地址位4个输出，其使用的方式就是D寄存器的方式构建的内存 因为这边189的输出都是低电位有效，所以需要74LS04非门进行反转，最后接入一个245三态门输出到总线中 地址线需要处理，需求是：实现从总线中读取，或者手动设置。 通过4Bit寄存器来获得输入，地址寄存器。74LS173正好满足条件 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:10:0","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"地址输入\r希望这个地址寄存器能切换模式手动模式和自动模式，自动模式是从总线中读取地址，手动模式用拨码开关来指定地址。 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:10:1","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"选择电路\r74LS157可以实现二选一电路 对拨码开关的控制，可以获得1个明确0，1信号 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:10:2","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"值输入\r希望可以手动向内存中写入值，同时也可以选择从总线中读入值。 又是一个选择电路，但是这边又8Bit输入，所以就用了2块74LS157芯片 到这可以控制手动输入地址和值的ROM就做好了 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:10:3","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"计数器\r一个计算机仅仅只有脉冲是不可能正常运行的，必须还要有可以指示程序运行的计数器，指示程序运行到 了哪一步。 当我们从计算机中运行程序，这些程序放在内存中，它是一条条指令，为了执行这些指令需要从内存中读取它，在这个8位计算器中需要从地址0开始执行。先执行地址0的指令，然后执行地址1的指令，需要确定当前在哪个地址上执行，所以我们需要程序计数器。 在上面我们由JK触发器构造了一个计数器，这个程序技术器也是由4位组成 ，指向下一条需要指向的指令，需要能从总线中读取数据 ，这样可以跳转到别的地址。 程序计数器的功能： 第一个CO就是程序控制器的输出，把值放到总线中 第二个J就是jump,从总线中读取数据，只获取4位数据， 第三个CE就是控制，控制计数器开始计数和停止计数。不一定每个脉冲都需要计数，当CE活动的时候，将计数器开始计数 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:11:0","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"二分电路\r怎么把脉冲变成明确的计数信号呢？ 这就需要之前的基础知识：主从触发器 主从触发器的特性，在一次脉冲来的时候会进行Q和反Q的切换，如果构建多个主从触发器，将第一个主从触发器的反Q接到下一个主从触发器的Q，会发生什么呢？ DM7476就是使用主从触发器来构造了JK触发器 可以发现这个JK触发器在下降沿的时候触发。 接了一个JK触发器可以看的更清楚一些，在每个脉冲周期，JK触发器交换了一次 当去掉一个显示的时候，可以发现这个Q亮到不亮再到亮用了2个脉冲周期 这个电路称为二分电路，通过JK触发器，将原来的主脉冲的周期扩大了一倍。 在原来二分电路的基础上再加一个二分JK触发器，把第一个触发器的输出接到下一个JK触发器的输入 第二个JK的转换速度是前一个的一半，是4倍的主脉冲周期 构建4个JK触发器，每一个都是前一个的周期的一半 这样我们就获得了一个2进制的计数器，可以从0计数到15， ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:11:1","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"计数器\r本计算机的计数器就是使用了这一原理构建，这边我们使用74LS161作为计数器 其有4个输入，4个输出，是否写入控制线，CLock控制线，Enable输入输出控制线，清除控制线 这个芯片非常有用，它的Clock内部加了一个非门，这样上升沿变成下降沿，我们的JK触发器也是下降沿触发器 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:11:2","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"显示\r共阴极和共阳极数码管 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:12:0","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"构建真值表\r通过这个真值表可以获取a这个值什么时候亮 如果需要显示真正的数据，必须要建立一个真值表，将真值表转化成电路，这样的电路就是解析器， EEPROM可以替代计算机中任何的组合逻辑。 组合逻辑：任何一个状态的输入对应一个状态的输出 时序逻辑：寄存器，锁存器，计数器，输出不进取决于当前的状态也取决于之前的状态。 有许多种ROM芯片，这个芯片是只读的，还有一种可以变成的只读芯片的就叫做PROM，提供了一个空白的芯片，只能写入一次，写入之后就不能改变了。EPROM可以重复写入，在紫外线的作用下可以擦除内部的数据 EEPROM是电可擦写存储器，用电就可以擦除。 AT28C16可擦写只读存储器，可以存2K个字节 有两种封装形式，直插和贴片， 8条IO引脚，数据引脚 11条地址引线，接地线和电源 反CE，反OE和反WE 需要给WE 一个100ns-1000ns的时间， 用一个电容和一个电阻来实现。RC震荡电路， 1nf，和680欧姆电阻。 通过EEPROM来实现真值表，左边是地址，右边的值。 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:12:1","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"Arduino写入数据\r看以下Arduino Nano的引脚数根本不够，因为地址线11根，数据线8根 需要另选一个方案来向EPROM中写入数据。 通过一个引脚输出地址，8根引脚输出数据，1根引脚怎么输出数据呢 这边用到了8个D触发器，思路基本和计数器一样，只不过计数的Enable线就是脉冲线，这样脉冲来一次就+1; 这边的enable线是通过按钮输入，按下为1不按为0 这边用74LS74来构建，其有两个D触发器 用4个74芯片的D触发器输出连接到输入，构建了一个8位寄存器来获得8个连续的输入。 当脉冲来的时候按钮按下为输入1，不按为输入0 Arduino一根数据线输入数据问题解决就可以运用上面的思路，找到74HC595这个芯片 那么现在只需要3根线来控制数据输入，数据输入线DS，时钟线SH_CP，和控制输出线ST_CP 地址线有11条，所以需要2个595芯片 这样我们的Arduino写入EEPRom模块就做好了 现在来写程序吧； //定义好各个引脚的标志 #define SHIFT_DATA 2 #define SHIFT_CLK 3 #define SHIFT_LATCH 4 #define EEPROM_D0 5 #define EEPROM_D7 12 #define WRITE_EN 13 /* * 使用移位寄存器将地址数据输出 */ void setAddress(int address, bool outputEnable) { shiftOut(SHIFT_DATA, SHIFT_CLK, MSBFIRST, (address \u003e\u003e 8) | (outputEnable ? 0x00 : 0x80));//将地址写入到595中，高8位 shiftOut(SHIFT_DATA, SHIFT_CLK, MSBFIRST, address);//将地址写入到595中，低8位 //设置595输出地址 digitalWrite(SHIFT_LATCH, LOW); digitalWrite(SHIFT_LATCH, HIGH); digitalWrite(SHIFT_LATCH, LOW); } /* * 从指定地址的EEPROM读取一个字节 */ byte readEEPROM(int address) { for (int pin = EEPROM_D0; pin \u003c= EEPROM_D7; pin++) { pinMode(pin, INPUT); } setAddress(address, /*outputEnable*/ true); byte data = 0; for (int pin = EEPROM_D7; pin \u003e= EEPROM_D0; pin--) { data = (data \u003c\u003c 1) + digitalRead(pin); } return data; } /* * 将字节写入指定地址的EEPROM。 */ void writeEEPROM(int address, byte data) { setAddress(address, /*outputEnable*/ false);//设置地址到595中并输出地址 for (int pin = EEPROM_D0; pin \u003c= EEPROM_D7; pin++) { pinMode(pin, OUTPUT);//设置引脚 } for (int pin = EEPROM_D0; pin \u003c= EEPROM_D7; pin++) { digitalWrite(pin, data \u0026 1);//将数据写到引脚中，只取最后一位 data = data \u003e\u003e 1; } digitalWrite(WRITE_EN, LOW);//写入EMROM delayMicroseconds(1); digitalWrite(WRITE_EN, HIGH); delay(10); } /* * 读取EEPROM的内容并将其打印到串行监视器。 */ void printContents() { for (int base = 0; base \u003c= 255; base += 16) { byte data[16]; for (int offset = 0; offset \u003c= 15; offset++) { data[offset] = readEEPROM(base + offset); } char buf[80]; sprintf(buf, \"%03x: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\", base, data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8], data[9], data[10], data[11], data[12], data[13], data[14], data[15]); Serial.println(buf); } } // 用于共阳极7段显示的4位十六进制解码器 //byte data[] = { 0x81, 0xcf, 0x92, 0x86, 0xcc, 0xa4, 0xa0, 0x8f, 0x80, 0x84, 0x88, 0xe0, 0xb1, 0xc2, 0xb0, 0xb8 }; // 用于共阴极7段显示的4位十六进制解码器 byte data[] = { 0x7e, 0x30, 0x6d, 0x79, 0x33, 0x5b, 0x5f, 0x70, 0x7f, 0x7b, 0x77, 0x1f, 0x4e, 0x3d, 0x4f, 0x47 }; void setup() { // put your setup code here, to run once: pinMode(SHIFT_DATA, OUTPUT); pinMode(SHIFT_CLK, OUTPUT); pinMode(SHIFT_LATCH, OUTPUT); digitalWrite(WRITE_EN, HIGH);//写低电平有效 pinMode(WRITE_EN, OUTPUT); Serial.begin(57600); // Erase entire EEPROM Serial.print(\"擦除 EEPROM\"); for (int address = 0; address \u003c= 2047; address ++) { writeEEPROM(address, 0x55); if (address % 64 == 0) { writeEEPROM(address, 0x55); Serial.print(\".\"); } } Serial.println(\" done\"); // 写入数据 Serial.print(\"编辑 EEPROM\"); for (int address = 0; address \u003c sizeof(data); address ++ ) {//sizeof(data)=16 writeEEPROM(address, data[address]); if (address % 64 == 0) {//数据一共64Bit， writeEEPROM(address, data[address]); Serial.print(\".\"); } } Serial.println(\" 完成\"); // 读EEPROM中的值 Serial.println(\"读.... EEPROM\"); printContents(); } void loop() { // put your main code here, to run repeatedly: } 重点看一下 /* * 使用移位寄存器将地址数据输出 */ void setAddress(int address, bool outputEnable) { shiftOut(SHIFT_DATA, SHIFT_CLK, MSBFIRST, (address \u003e\u003e 8) | (outputEnable ? 0x00 : 0x80)); shiftOut(SHIFT_DATA, SHIFT_CLK, MSBFIRST, address); digitalWrite(SHIFT_LATCH, LOW); digitalWrite(SHIFT_LATCH, HIGH); digitalWrite(SHIFT_LATCH, LOW); } shiftout:一次将数据字节移出一位。从最高（即最左边）或最低（最右边）有效位开始。每个位依次写入数据引脚，然后向时钟引脚脉冲（先变高，然后变低），以指示该位可用。 MSBFIRST:最高位有效在先 至此EEPEOM的真值表写入完毕，我们只使用了16个地址的数据，真是极大的浪费呢 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:12:2","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"如何显示数据\r第一种方案是用三个EEPROM来表示百，十，个三个位的数据 这种方案显然造成EEPROM的极大浪费 第二种方案：复杂一点点，将选择这种方案，就是顺序让每一个数码管显示，当速度非常块的时候，数码管看上去就像一直显示的一样，怎么才能让数码管顺序显示 这边我们就用到了上面计数器的原理，构建一个单独的显示脉冲，然后通过2个JK触发器就可以获得4种不同的编码状态，00,01,10,11 这边用74LS76,其正好有两个JK触发器 同时需要将00，01，10，11进行解码，将其变成0001，0010，0100，1000，这样将这四条线连接到4个数码管，数码管就会顺序显示，这边我们用到了74LS139 可以看到该编码器完美满足我们的需求。 构建公用真值表 就是用A10,A9,A8，来表示个位十位百位 这样真值表就比较复杂了 举个例子321这个值的真值表： 改进程序 #define SHIFT_DATA 2 #define SHIFT_CLK 3 #define SHIFT_LATCH 4 #define EEPROM_D0 5 #define EEPROM_D7 12 #define WRITE_EN 13 /* 使用移位寄存器输出地址位和outputEnable信号。 */ void setAddress(int address, bool outputEnable) { shiftOut(SHIFT_DATA, SHIFT_CLK, MSBFIRST, (address \u003e\u003e 8) | (outputEnable ? 0x00 : 0x80)); shiftOut(SHIFT_DATA, SHIFT_CLK, MSBFIRST, address); digitalWrite(SHIFT_LATCH, LOW); digitalWrite(SHIFT_LATCH, HIGH); digitalWrite(SHIFT_LATCH, LOW); } /* 从指定地址的EEPROM读取一个字节。 */ byte readEEPROM(int address) { for (int pin = EEPROM_D0; pin \u003c= EEPROM_D7; pin += 1) { pinMode(pin, INPUT); } setAddress(address, /*outputEnable*/ true); byte data = 0; for (int pin = EEPROM_D7; pin \u003e= EEPROM_D0; pin -= 1) { data = (data \u003c\u003c 1) + digitalRead(pin); } return data; } /* 将字节写入指定地址的EEPROM。 */ void writeEEPROM(int address, byte data) { setAddress(address, /*outputEnable*/ false); for (int pin = EEPROM_D0; pin \u003c= EEPROM_D7; pin += 1) { pinMode(pin, OUTPUT); } for (int pin = EEPROM_D0; pin \u003c= EEPROM_D7; pin += 1) { digitalWrite(pin, data \u0026 1); data = data \u003e\u003e 1; } digitalWrite(WRITE_EN, LOW); delayMicroseconds(1); digitalWrite(WRITE_EN, HIGH); delay(10); } /* 读取EEPROM的内容并将其打印到串行监视器。 */ void printContents() { for (int base = 0; base \u003c= 255; base += 16) { byte data[16]; for (int offset = 0; offset \u003c= 15; offset += 1) { data[offset] = readEEPROM(base + offset); } char buf[80]; sprintf(buf, \"%03x: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\", base, data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8], data[9], data[10], data[11], data[12], data[13], data[14], data[15]); Serial.println(buf); } } void setup() { // put your setup code here, to run once: pinMode(SHIFT_DATA, OUTPUT); pinMode(SHIFT_CLK, OUTPUT); pinMode(SHIFT_LATCH, OUTPUT); digitalWrite(WRITE_EN, HIGH); pinMode(WRITE_EN, OUTPUT); Serial.begin(57600); // Bit patterns for the digits 0..9 byte digits[] = { 0x7e, 0x30, 0x6d, 0x79, 0x33, 0x5b, 0x5f, 0x70, 0x7f, 0x7b }; writeEEPROM(0,0); Serial.println(\"写入个位 \"); for (int value = 0; value \u003c= 255; value += 1) { writeEEPROM(value, digits[value % 10]); } Serial.println(\"写入十位\"); for (int value = 0; value \u003c= 255; value += 1) { writeEEPROM(value + 256, digits[(value / 10) % 10]); } Serial.println(\"写入百位\"); for (int value = 0; value \u003c= 255; value += 1) { writeEEPROM(value + 512, digits[(value / 100) % 10]); } Serial.println(\"写入符号位\"); for (int value = 0; value \u003c= 255; value += 1) { writeEEPROM(value + 768, 0); } Serial.println(\"写入个位 (后半部)\"); for (int value = -128; value \u003c= 127; value += 1) { writeEEPROM((byte)value + 1024, digits[abs(value) % 10]); } Serial.println(\"写入十位 (后半部)\"); for (int value = -128; value \u003c= 127; value += 1) { writeEEPROM((byte)value + 1280, digits[abs(value / 10) % 10]); } Serial.println(\"写入百位 (后半部)\"); for (int value = -128; value \u003c= 127; value += 1) { writeEEPROM((byte)value + 1536, digits[abs(value / 100) % 10]); } Serial.println(\"写入符号位 (后半部)\"); for (int value = -128; value \u003c= 127; value += 1) { if (value \u003c 0) { writeEEPROM((byte)value + 1792, 0x01); } else { writeEEPROM((byte)value + 1792, 0); } } // Read and print out the contents of the EERPROM Serial.println(\"读..... EEPROM\"); printContents(); } void loop() { // put your main code here, to run repeatedly: } ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:12:3","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"控制数据显示\r现在数据显示的问题已经解决了，下面怎么控制其从Bus种读取数据显示，这边肯定不能直接显示总线的数据，因为总线的数据是不断变化的，所以需要一个8bit寄存器控制读取总线中的数据，然后控制其显示， 这边使用不同的芯片74LS273 这边有8个输入，8个输出，一个脉冲引脚，一个重置线 这边有一个问题，这个芯片没有IEnable线，如果主脉冲接进来，每次脉冲变化都会读取值，这个问题可以通过一个与门来解决，通过与门接入脉冲和控制线，控制线为1的时候，脉冲变化才有效 做个简单的总结，将已经做好的部件连接到总线 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:12:4","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"控制器\r现在这个部件就缺少一个控制逻辑就可以正常工作了，来看看有多少个控制线 目前有14根控制线，还要做一个HTL停机线，在主脉冲中 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:13:0","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"如何控制\r现在我们写一个程序，来手动运行这个程序 LDA 14 //将内存地址14中内容读取到A寄存器 ADD 15 //把内存地址15中内容与A寄存器中值相加放到寄存器 OUT //把A寄存器中的内容放到输出模块 这会很奇怪，这些命令是哪里来的，在之前的计算机构造中没有构造任何与命令有关的内容，实际上这些是我们自己定义的，你可以定义任何想做的命令，这是不是非常酷。 下面我们来定义 LDA：0001 ADD:0010 OUT:1110 那么程序就被翻译成机器语言了 LADA 14 // 0001 1110 ADD 15 // 0010 1111 OUT // 1110 xxxx 这个程序一共三行，我们在加上行号 LADA 14 // 0000 0001 1110 ADD 15 // 0001 0010 1111 OUT // 0010 1110 xxxx 所以想要运行这个程序我们需要将值写到ROM中，进入手动模式输入ROM值 地址 值 0000 0001 1110 0001 0010 1111 0010 1110 0000 1110 0001 1100(28) 1111 0000 1110(14) 这个代码翻译成高级语言就是28+14=？ 现在我们需要手动控制程序的运行 首先将指令从内存中读出来放到指令寄存器中，指令寄存器告诉我们数据将怎么解析。 取址周期就是将指令从内存中取出来放到指令寄存器中。 计算器中所有的组件都是由程序计数器来协调，计数器记录了当前执行到哪条指令。计数器是从0开始的。 一开始0000 首先将计数器的值放到内存地址寄存器中， 计数器输出+ CO 内存地址寄存器输入+ MI 给一个脉冲 可以看到这边计数器和内存地址寄存器都是0， 而0地址上ROM的值就是0001 1110 将内存地址中的值放到指令寄存器中 将内存输出打开+ RO 指令寄存器输入+ II 给一个脉冲 可以看到ROM中数据给了指令寄存器 这两步操作取址的操作就完成了，要执行下一个代码，计数器加一 计数器加1 CE+ 给一个脉冲，计数器加一变成0001 计数器加一 执行任何的代码都需要上面的三步，上面三步又称取址周期，其实就是将计数器对应的ROM中的值放到指令寄存器中，然后计数器加1。下面来解析命令和执行命令，这才是与命令相关的控制逻辑 LDA指令 LDA 14 ，**控制器看到指令寄存器的高四位是0001，就知道这是对应LDA的操作，**就会执行LDA的控制，这是由控制器完成的，我们稍后构建它，现在还是手动操作，假设自己的控制器 将指令寄存器后4BIt 输入到内存地址寄存器中 ，以获得内存地址14中的内容 指令寄存器输出 + IO 内存地址寄存器输入 + MI 给一个脉冲 因为指令寄存器只有第四位接入到总线中，所以地址寄存器获取第四位的地址数据，ROM中显示了该地址中的值，也就是0001 1100其值为28 将内存地址中的值输出到寄存器A 内存输出+ RO 寄存器A输入+ AI 给一个脉冲 可以看到内存中的值给了寄存器A，同时因为寄存器B位0，ALU就显示了A+0的值， 至此完成了LDA的命令，将地址14中的值放到寄存器A中。下面执行第二个命令 ADD指令解析 ADD 15， 要执行到该指令现到取到该指令，跟之前的三部取址周期一样 指令计数器的值给地址寄存器 内存地址中的值给指令寄存器 计数器加1，这个时候控制器通过指令寄存器高四位0010分析出执行ADD控制 将指令寄存器后4bit输入到内存地址寄存器中 指令寄存器输出+ IO 内存地址寄存器输入+ MI 给一个脉冲 将指令寄存器中的低四位放到地址寄存器中，这个时候ROM显示该地址中的值 0000 1110 其值位14 将内存地址15中的值放到B寄存器中，ALU会自动计算出值 内存输出+ RO 寄存器B输入+ BI 给一个脉冲 可以看到ALU自动算出求和的值 将ALU中的值输出到寄存器A中 ALU的输出 +EO 寄存器A输入+AI 给一个脉冲 这边寄存器A获得ALU的值，同时ALU更新了，这边非常酷，锁操作只发生在脉冲的上升沿， OUT命令 OUT，前3步是一样的 将A寄存器中的值显示出来 将A寄存器输出+ AO output寄存器输入 OI 给一个脉冲 到这程序执行完了 总结一下 这些小的指令称为微指令，这些微指令的前三步都是相同的，之后的操作是不同的， 所以需要控制位对每个指令构造控制逻辑 反正我控制位按照一定的顺序排序 每一种微指令对应一种控制序列。 真正的微指令会占用余下的时间片，实际上我们需要一个独立的计数器，所以需要一个独立的计数器 上面通过手动的方式设置控制位，然后手动发送一次主脉冲，在两个主脉冲之间改变它的控制位，，所以我们实际上还需要另一个脉冲来控制 ，这边可以用主脉冲的倒转，通过非门开获得另一个脉冲 这边还要将各个指令分步，才能够让控制器知道执行到了哪一步，可以看到每个指令最多5步，有些步数可以合并就合并了。从T0-T4，而有些指令用不到4步，那么多余的步数计算机什么也不做就浪费了。这是无法避免的 下降沿的时候触发 现在脉冲有了，步数分解有了，需要将脉冲变成步数，这和程序计数器是一样的，使用74LS161,这是一个四位的计数器， 计数器有了，现在要将计数器解码，这边用到了74LS138芯片, 可以看到其转换成明确信号，这边和显示部分用到的138解码是一样的逻辑 这边我们可以可以清晰的看到程序走到了哪个时间片，哪一步 下面我们构建非常酷的事情，也就是控制器的真值表 第一个取址，可以看到前两步， 第二个LDA用了剩余的三步，最后一步什么也没做。 第三个ADD也是三部 用两个28C16就可以完成其组合逻辑，其有11条地址线，8个输出线。 将真值表输入到28C16中就可以完成控制 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:13:1","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"Reset\r这边如果程序执行完成，需要将所有的寄存器清空，这边我们构建这样一个reset电路用来一个74LS00来构建 将reset和~reset接到所有的寄存器 到目前为止，计算机的主体部分就做好了 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:13:2","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"Arduino写入指令\rArduino的接线方式和之前的显示解码器的方式相同，这边就不过多说了。 直接上程序 #define SHIFT_DATA 2 #define SHIFT_CLK 3 #define SHIFT_LATCH 4 #define EEPROM_D0 5 #define EEPROM_D7 12 #define WRITE_EN 13 #define HLT 0b1000000000000000 // Halt clock HLT信号 #define MI 0b0100000000000000 // Memory address register in 内存地址输入 #define RI 0b0010000000000000 // RAM data in 内存数据输入 #define RO 0b0001000000000000 // RAM data out 内存数据输出 #define IO 0b0000100000000000 // Instruction register out 指令寄存器输出 #define II 0b0000010000000000 // Instruction register in 指令寄存器输入 #define AI 0b0000001000000000 // A register in A寄存器输入 #define AO 0b0000000100000000 // A register out A寄存器输出 #define EO 0b0000000010000000 // ALU out ALU输出 #define SU 0b0000000001000000 // ALU subtract 减法 #define BI 0b0000000000100000 // B register in B寄存器输入 #define OI 0b0000000000010000 // Output register in 输出寄存器输入 #define CE 0b0000000000001000 // Program counter enable 程序计数允许 #define CO 0b0000000000000100 // Program counter out 程序计数器输出 #define J 0b0000000000000010 // Jump (program counter in) 程序计数器输入（JUMP） uint16_t data[] = { // 列是步数，行是不同的指令 MI|CO, RO|II|CE, 0, 0, 0, 0, 0, 0, // 0000 - NOP MI|CO, RO|II|CE, IO|MI, RO|AI, 0, 0, 0, 0, // 0001 - LDA 加载 MI|CO, RO|II|CE, IO|MI, RO|BI, EO|AI, 0, 0, 0, // 0010 - ADD 加法 MI|CO, RO|II|CE, IO|MI, RO|BI, EO|AI|SU, 0, 0, 0, // 0011 - SUB 减法 MI|CO, RO|II|CE, IO|MI, AO|RI, 0, 0, 0, 0, // 0100 - STA 将寄存器A中值写入ROM中 MI|CO, RO|II|CE, IO|AI, 0, 0, 0, 0, 0, // 0101 - LDI 将指令寄存器中值写入寄存器A MI|CO, RO|II|CE, IO|J, 0, 0, 0, 0, 0, // 0110 - JMP 跳转到指令寄存器第四位的计数 MI|CO, RO|II|CE, 0, 0, 0, 0, 0, 0, // 0111 MI|CO, RO|II|CE, 0, 0, 0, 0, 0, 0, // 1000 MI|CO, RO|II|CE, 0, 0, 0, 0, 0, 0, // 1001 MI|CO, RO|II|CE, 0, 0, 0, 0, 0, 0, // 1010 MI|CO, RO|II|CE, 0, 0, 0, 0, 0, 0, // 1011 MI|CO, RO|II|CE, 0, 0, 0, 0, 0, 0, // 1100 MI|CO, RO|II|CE, 0, 0, 0, 0, 0, 0, // 1101 MI|CO, RO|II|CE, AO|OI, 0, 0, 0, 0, 0, // 1110 - OUT 输出 MI|CO, RO|II|CE, HLT, 0, 0, 0, 0, 0, // 1111 - HLT 停机 }; /* *使用移位寄存器输出地址位和outputEnable信号。 */ void setAddress(int address, bool outputEnable) { shiftOut(SHIFT_DATA, SHIFT_CLK, MSBFIRST, (address \u003e\u003e 8) | (outputEnable ? 0x00 : 0x80)); shiftOut(SHIFT_DATA, SHIFT_CLK, MSBFIRST, address); digitalWrite(SHIFT_LATCH, LOW); digitalWrite(SHIFT_LATCH, HIGH); digitalWrite(SHIFT_LATCH, LOW); } /* * 从指定地址的EEPROM读取一个字节。 */ byte readEEPROM(int address) { for (int pin = EEPROM_D0; pin \u003c= EEPROM_D7; pin += 1) { pinMode(pin, INPUT); } setAddress(address, /*outputEnable*/ true); byte data = 0; for (int pin = EEPROM_D7; pin \u003e= EEPROM_D0; pin -= 1) { data = (data \u003c\u003c 1) + digitalRead(pin); } return data; } /* * 将字节写入指定地址的EEPROM。 */ void writeEEPROM(int address, byte data) { setAddress(address, /*outputEnable*/ false);//设置地址 for (int pin = EEPROM_D0; pin \u003c= EEPROM_D7; pin += 1) { pinMode(pin, OUTPUT);//设置数据输出引脚 } for (int pin = EEPROM_D0; pin \u003c= EEPROM_D7; pin += 1) { digitalWrite(pin, data \u0026 1);//每个数据引脚赋值 data = data \u003e\u003e 1; } digitalWrite(WRITE_EN, LOW);//设置脉冲 delayMicroseconds(1); digitalWrite(WRITE_EN, HIGH); delay(10); } /* * 读取EEPROM的内容并将其打印到串行监视器。 */ void printContents() { for (int base = 0; base \u003c= 255; base += 16) { byte data[16]; for (int offset = 0; offset \u003c= 15; offset += 1) { data[offset] = readEEPROM(base + offset); } char buf[80]; sprintf(buf, \"%03x: %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\", base, data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8], data[9], data[10], data[11], data[12], data[13], data[14], data[15]); Serial.println(buf); } } void setup() { // put your setup code here, to run once: pinMode(SHIFT_DATA, OUTPUT); pinMode(SHIFT_CLK, OUTPUT); pinMode(SHIFT_LATCH, OUTPUT); digitalWrite(WRITE_EN, HIGH); pinMode(WRITE_EN, OUTPUT); Serial.begin(57600); // 写数据 Serial.print(\"写 EEPROM\"); writeEEPROM(0, 0); // 将微码的8个高位写到EEPROM的前128个字节中 for (int address = 0; address \u003c sizeof(data)/sizeof(data[0]); address += 1) { writeEEPROM(address, data[address] \u003e\u003e 8); if (address % 64 == 0) { writeEEPROM(address, data[address] \u003e\u003e 8","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:13:3","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"标志跳转\r现在讨论一个问题： ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:14:0","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"这是不是计算机\r这是不是计算机，还只是一个计算器 这个计算机的频率只有300HZ左右 是否需要乘法，指数，对数，三角函数等指令，这些指令肯定是做不出来的，那么问题就回来了我们真正需要什么样的指令，什么样的指令才能称为计算机，计算机是什么？ 计算机: 可以完成任何的指令 可以完成任何的可计算的问题 什么是可计算的什么是不可计算的 这不是计算机性能的问题，是通过算法能完成的问题 那么问题就变成了我们需要完成什么样的算法。 这个问题在计算机早期图灵就进行研究过 1936年 他写了关于这个问题的一篇论文。这篇论文得出的结论是，他可以发明一种机器，可以完成任何计算序列 他是这样描述的： 有一个无限长的纸带，上面有方格，有1和0两种状态，有一个小旗子可以指向这些方格，小旗子有一个状态A，一次只能移动一个。 有一个小旗子和其状态的真值表 现在这个状态，A ,浏览状态是1，就将1写到袋子上，然后向左移动一格，自身的状态变成C，就变成了下面的状态 根据这个真值表进行一直不停的循环做，一旦停止到Halt，纸带上就是结果， 这个机器就能完成任何的数学算法。只需要设置好这个指令表就好了 实际上图灵还提高一个更好的计算机，称为通用计算机，这个机器上有一个指令表，是一个最基本的状态，其他计算机可以通过编码的方法将算法映射到这个指令表上 到这边就知道了任何可计算的问题都可以变成一个可计算的序列 在同一个时期邱奇也思考了相同的问题 他写了一篇论文关于什么是计算能力的定义，从完全不同的角度切入这个问题，他提出新的数学系统称为论的演算。 这便有一些变量，有一些函数，还有一些函数的结果 在论文的后面，他定义了一些函数，他用这个方法表达计算机，有点像现在的Lambda表达式 这篇论文的结论是：不是所有的问题都可以通过计算解决，有些可以，有些不可以， 在1936年两个人从两种不同的角度思考了这个问题 当图灵在8月份读到邱奇的论文，将邱奇的论文放到了附录中，任何问题可以转换成论的计算的问题都可以转化成一个可计算的问题 我们计算机和图灵机比较还缺少什么呢，图灵机有一个操作我们做不到，同一个指令可以有不同的操作 如果纸带是空格向右移动如果纸带为1向左移动， 有一种指令叫做有条件跳转指令可以做到这一点，它和我们的跳转指令有一点像，现在的跳转指令只能跳转到固定的地址 左右等价 根据不同的值来进行不同的行为 所以我们可以说如果实现条件跳转指令我们就可以模拟任何图灵机 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:14:1","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"条件跳转\r准备实现两个条件跳转指令，为0跳转和进位跳转0 为0跳转，这个跳转需要计算ALU中所有的值是否为0 ， 使用这个电路我们就可以判断是否为0 74LS08有4个与门和74LS02有4个Nor门 进位跳转 ALU中高4位芯片有一个进位引脚，我们很容易就可以判断出是否进位了。 这边就搭建好了2个标识，但是有一个问题， 在获得这个标识后，加命令还有一步就是将ALU中的值放到寄存器A中，这样在进行跳转指令的时候标识就没有了， 所以这边需要将进位标识存起来，这边我们需要一个173芯片 其实Internal x86也有进位标识计数器 一共32位 这样就多了一个控制线，FI：标识Flag的输入，NOP：无操作 这是新的真值表，用了10个地址位，非常棒 直接用Arduino写入真值表 #define SHIFT_DATA 2 #define SHIFT_CLK 3 #define SHIFT_LATCH 4 #define EEPROM_D0 5 #define EEPROM_D7 12 #define WRITE_EN 13 #define HLT 0b1000000000000000 // Halt clock HLT信号 #define MI 0b0100000000000000 // Memory address register in 内存地址输入 #define RI 0b0010000000000000 // RAM data in 内存数据输入 #define RO 0b0001000000000000 // RAM data out 内存数据输出 #define IO 0b0000100000000000 // Instruction register out 指令寄存器输出 #define II 0b0000010000000000 // Instruction register in 指令寄存器输入 #define AI 0b0000001000000000 // A register in A寄存器输入 #define AO 0b0000000100000000 // A register out A寄存器输出 #define EO 0b0000000010000000 // ALU out ALU输出 #define SU 0b0000000001000000 // ALU subtract 减法 #define BI 0b0000000000100000 // B register in B寄存器输入 #define OI 0b0000000000010000 // Output register in 输出寄存器输入 #define CE 0b0000000000001000 // Program counter enable 程序计数允许 #define CO 0b0000000000000100 // Program counter out 程序计数器输出 #define J 0b0000000000000010 // Jump (program counter in) 程序计数器输入（JUMP） #define FI 0b0000000000000001 // Flags in Flags 标志位输入 #define FLAGS_Z0C0 0 #define FLAGS_Z0C1 1 #define FLAGS_Z1C0 2 #define FLAGS_Z1C1 3 #define JC 0b0111 #define JZ 0b1000 uint16_t UCODE_TEMPLATE[16][8] = { { MI|CO, RO|II|CE, 0, 0, 0, 0, 0, 0 }, // 0000 - NOP { MI|CO, RO|II|CE, IO|MI, RO|AI, 0, 0, 0, 0 }, // 0001 - LDA { MI|CO, RO|II|CE, IO|MI, RO|BI, EO|AI|FI, 0, 0, 0 }, // 0010 - ADD { MI|CO, RO|II|CE, IO|MI, RO|BI, EO|AI|SU|FI, 0, 0, 0 }, // 0011 - SUB { MI|CO, RO|II|CE, IO|MI, AO|RI, 0, 0, 0, 0 }, // 0100 - STA { MI|CO, RO|II|CE, IO|AI, 0, 0, 0, 0, 0 }, // 0101 - LDI { MI|CO, RO|II|CE, IO|J, 0, 0, 0, 0, 0 }, // 0110 - JMP { MI|CO, RO|II|CE, 0, 0, 0, 0, 0, 0 }, // 0111 - JC { MI|CO, RO|II|CE, 0, 0, 0, 0, 0, 0 }, // 1000 - JZ { MI|CO, RO|II|CE, 0, 0, 0, 0, 0, 0 }, // 1001 { MI|CO, RO|II|CE, 0, 0, 0, 0, 0, 0 }, // 1010 { MI|CO, RO|II|CE, 0, 0, 0, 0, 0, 0 }, // 1011 { MI|CO, RO|II|CE, 0, 0, 0, 0, 0, 0 }, // 1100 { MI|CO, RO|II|CE, 0, 0, 0, 0, 0, 0 }, // 1101 { MI|CO, RO|II|CE, AO|OI, 0, 0, 0, 0, 0 }, // 1110 - OUT { MI|CO, RO|II|CE, HLT, 0, 0, 0, 0, 0 }, // 1111 - HLT }; uint16_t ucode[4][16][8];//主要把指令根据进位划分一下 void initUCode() { // ZF = 0, CF = 0 memcpy(ucode[FLAGS_Z0C0], UCODE_TEMPLATE, sizeof(UCODE_TEMPLATE)); // ZF = 0, CF = 1 memcpy(ucode[FLAGS_Z0C1], UCODE_TEMPLATE, sizeof(UCODE_TEMPLATE)); ucode[FLAGS_Z0C1][JC][2] = IO|J; // ZF = 1, CF = 0 memcpy(ucode[FLAGS_Z1C0], UCODE_TEMPLATE, sizeof(UCODE_TEMPLATE)); ucode[FLAGS_Z1C0][JZ][2] = IO|J; // ZF = 1, CF = 1 memcpy(ucode[FLAGS_Z1C1], UCODE_TEMPLATE, sizeof(UCODE_TEMPLATE)); ucode[FLAGS_Z1C1][JC][2] = IO|J; ucode[FLAGS_Z1C1][JZ][2] = IO|J; } /* * 使用移位寄存器输出地址位和outputEnable信号。 */ void setAddress(int address, bool outputEnable) { shiftOut(SHIFT_DATA, SHIFT_CLK, MSBFIRST, (address \u003e\u003e 8) | (outputEnable ? 0x00 : 0x80)); shiftOut(SHIFT_DATA, SHIFT_CLK, MSBFIRST, address); digitalWrite(SHIFT_LATCH, LOW); digitalWrite(SHIFT_LATCH, HIGH); digitalWrite(SHIFT_LATCH, LOW); } /* * 从指定地址的EEPROM读取一个字节。 */ byte readEEPROM(int address) { for (int pin = EEPROM_D0; pin \u003c= EEPROM_D7; pin += 1) { pinMode(pin, INPUT); } setAddress(address, /*outputEnable*/ true); byte data = 0; for (int pin = EEPROM_D7; pin \u003e= EEPROM_D0; pin -= 1) { data = (data \u003c\u003c 1) + digitalRead(pin); } return data; } /* * 将字节写入指定地址的EEPROM。 */ void writeEEPROM(int address, byte data) { setAddress(address, /*outputEnable*/ false); for (int pin = EEPROM_D0; pin \u003c= EEPROM_D7; pin += 1) { pinMode(pin, OUTPUT); } for (int pin = EEPROM_D0; pin \u003c= EEPROM_D7; pin += 1) { digitalWrite(pin, data \u0026 1); data = data \u003e\u003e 1; } digitalWrite(WRITE_EN, LOW); delayMicroseconds(1); digitalWrite(WRITE_EN, HIGH); delay(10); } /* *读取EEPR","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:14:2","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"总结\r我收获了什么： 计算机底层是怎么运行，控制器是怎么控制 调试的时候也遇到一些坑 ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:15:0","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"寄存器没有正常工作\r指令计数器工作正常，寄存器A和寄存器B工作不正常，这三个模块是同一个脉冲线接过来的，先接入指令计数器，再接入寄存器A和寄存器B, 一开始并没有怀疑脉冲线的问题，因为指令计数器正常工作，寄存器没有正常工作，检查了寄存器的接线发现没有问题，量了电压发现脉冲电压非常小0.02V波动，这也太不正常了，量了下指令计数器的电压是正常的，这就很奇怪了，后来发现最后寄存器脉冲线短路接地了，导致一直没有脉冲， ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:15:1","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"控制器没有正常工作\r发现控制器是输出不正常，做了个简单的测试电路，手动检查控制器的eprom内存的值，发现确实没有输出正确的值，检查Arduino nano的写入接线和视频中接线不同，导致写入数据地址也不相同，调整Arduino nano和控制线，输出正常， ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:15:2","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"嵌入式","content":"经验\r每个模块先用跳线接一下再进行测试，如果发现测试没有问题再用标准接线将其接通， 正常调试需要一步步执行，当出现异常了先解决出现的第一个异常，然后再解决剩余的异常，遇到异常不要慌，一步步解决，不要跳过问题进行下一个问题。 引用\r大佬的视频教程，截图基本都源自于该大佬，并稍加改动 https://space.bilibili.com/413461202/ ","date":"2020-08-09","objectID":"/2020/08/embedded-8bitcomputer/:15:3","tags":["嵌入式","8位计算机"],"title":"嵌入式 8位计算机","uri":"/2020/08/embedded-8bitcomputer/"},{"categories":"DotNet基础","content":"网络威胁\r1.窃听：网络传输是在公共信道上进行的，特别是HTTP传输大多以明文传输，黑客进行窃听，获取敏感信息。 2.伪装：这个基本每个人都遇到过，早期诈骗，说你账户被盗要求你登录改密码，会进入一个与官网相似的改密码页面来获取你的真实密码。 3.篡改：信息在提交到服务器之前被非法修改，黑客可以盗取用户的Session、Cache信息，来修改提交到服务器的请求信息。 4.抵赖：用户可以否定自己曾经做过的事情。在日常生活中也会遇到同样的问题，比如领导明明安排的一个任务，但你可能忘记了就说不知道，没人通知你，这就叫抵赖 ","date":"2020-06-02","objectID":"/2020/06/dotnetbase12-certificate/:1:0","tags":["DotNet基础","证书加密签名"],"title":"DotNet基础 证书加密签名","uri":"/2020/06/dotnetbase12-certificate/"},{"categories":"DotNet基础","content":"基本概念\r证书是针对上述网络威胁建立起来的解决方案，基本概念： CA(Certificate Authority)：数字证书认证中心。发放、管理、废除数字证书的机构，CA的作用是检查证书持有者身份的合法性，并签发证书（在证书上签字），以防证书被伪造或篡改，以及对证书和密钥进行管理。 证书有以下信息：证书颁布机构，证书的有效期，公钥，私钥，签名及所用算法，指纹和指纹算法。 证书颁布机构（Issuer）：指出是什么机构发布的这个证书，也就是指明这个证书是哪个公司创建的(只是创建证书，不是指证书的使用者)。 证书有效期（Valid from , Valid to）：证书的使用期限。 过了有效期限，证书就会作废，不能使用了 主体（Subject）：证书是发布给谁的，或者说证书的所有者 签名所使用的算法（Signature algorithm）：指的这个数字证书的数字签名所使用的加密算法。 指纹及指纹算法（Thumbprint, Thumbprint algorithm）：这个是用来保证证书的完整性的，也就是说确保证书没有被修改过。 其原理就是在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的hash值(指纹)是会变化的。 ","date":"2020-06-02","objectID":"/2020/06/dotnetbase12-certificate/:2:0","tags":["DotNet基础","证书加密签名"],"title":"DotNet基础 证书加密签名","uri":"/2020/06/dotnetbase12-certificate/"},{"categories":"DotNet基础","content":"证书的特性\r保密性（Privacy）：确认信息的保密，不被窃取。 鉴别与授权（Authentication \u0026 Authorization）：确认对方的身份并确保其不越权 完整性（Integrity）：确保你收到信息没有被篡改 抗抵赖性（Non-Repudiation）：有证据保证交易不被否认 ","date":"2020-06-02","objectID":"/2020/06/dotnetbase12-certificate/:2:1","tags":["DotNet基础","证书加密签名"],"title":"DotNet基础 证书加密签名","uri":"/2020/06/dotnetbase12-certificate/"},{"categories":"DotNet基础","content":"证书的常见形式\r.CER，文件是二进制格式，只保存证书，不保存私钥。公钥，指纹，加密算法 cer证书内容\r.PEM，一般是文本格式，可保存证书，可保存私钥。 .PFX，二进制格式，同时包含证书和私钥，一般有密码保护。 .JKS，二进制格式，同时包含证书和私钥，一般有密码保护。 ","date":"2020-06-02","objectID":"/2020/06/dotnetbase12-certificate/:2:2","tags":["DotNet基础","证书加密签名"],"title":"DotNet基础 证书加密签名","uri":"/2020/06/dotnetbase12-certificate/"},{"categories":"DotNet基础","content":"应用与实现\r","date":"2020-06-02","objectID":"/2020/06/dotnetbase12-certificate/:3:0","tags":["DotNet基础","证书加密签名"],"title":"DotNet基础 证书加密签名","uri":"/2020/06/dotnetbase12-certificate/"},{"categories":"DotNet基础","content":"证书创建\r微软官方给了一个证书创建帮助类https://docs.microsoft.com/en-us/archive/blogs/dcook/creating-a-self-signed-certificate-in-c 可以使用其很方便的创建一个证书 /// \u003csummary\u003e /// 创建证书 /// \u003c/summary\u003e /// \u003creturns\u003e\u003c/returns\u003e public bool CreateCertificate() { var commonName = m_CertificateCommonName; var password = m_Password; var path = m_CertificatePath; var certificateName = commonName; if (!commonName.StartsWith(\"CN=\", StringComparison.OrdinalIgnoreCase)) certificateName = \"CN=\" + commonName; byte[] certificateData = Certificate.CreateSelfSignCertificatePfx(certificateName, //host name DateTime.Now, //not valid before DateTime.Now.AddYears(5), //not valid after password); var filename = Path.Combine(path, commonName); if (!filename.EndsWith(\".pfx\")) { filename = filename + \".pfx\"; } using (BinaryWriter binWriter = new BinaryWriter(File.Open(filename, FileMode.Create))) { binWriter.Write(certificateData); binWriter.Flush(); } if (TryGetCertificate(out X509Certificate2 cert)) { selfCertificate = cert; } RunInfo = \"创建成功\"; return true; } 导出cer证书 /// \u003csummary\u003e /// 尝试导出cer证书文件，也就是公钥证书 /// \u003c/summary\u003e /// \u003creturns\u003e\u003c/returns\u003e public bool TryExportCerFile() { if (string.IsNullOrEmpty(m_BinaryExportPath) || string.IsNullOrEmpty(m_BinaryExportName)) { RunInfo = \"请输入参数信息\"; return false; } //find the certificate byte[] cerByte = selfCertificate.Export(X509ContentType.Cert); var filename = Path.Combine(m_BinaryExportPath, m_BinaryExportName); if (!filename.EndsWith(\".cer\")) { filename = filename + \".cer\"; } using (BinaryWriter binWriter = new BinaryWriter(File.Open(filename, FileMode.Create))) { binWriter.Write(cerByte); binWriter.Flush(); } RunInfo = \"导出成功\"; return true; } ","date":"2020-06-02","objectID":"/2020/06/dotnetbase12-certificate/:3:1","tags":["DotNet基础","证书加密签名"],"title":"DotNet基础 证书加密签名","uri":"/2020/06/dotnetbase12-certificate/"},{"categories":"DotNet基础","content":"证书加密\r/// \u003csummary\u003e /// 公钥加密 /// \u003c/summary\u003e public void PublicKeyEncryptionMethod() { if (string.IsNullOrEmpty(m_PlainText)) { RunInfo = \"请输入需要加密的信息\"; return; } //公钥加密 byte[] infos = Encoding.UTF8.GetBytes(m_PlainText); RSACryptoServiceProvider myRSACryptoServiceProvider = (RSACryptoServiceProvider) selfCertificate.PublicKey.Key; Byte[] Cryptograph = myRSACryptoServiceProvider.Encrypt(infos, false); //所以明文不能把128字节占满，实际测试，明文最多为117字节，留下的空间用来填充随机数。 publicKeyEncryption = Cryptograph; StringBuilder s =new StringBuilder(); foreach (var b in Cryptograph) { s.Append(b.ToString(\"X2\") + \" \"); } s.Append(\"总字节数:\" + Cryptograph.Length); PublicKeyEncryption = s.ToString(); } /// \u003csummary\u003e /// 使用私钥解密 /// \u003c/summary\u003e public void PrivateKeyDecryptionMethod() { if (publicKeyEncryption == null) { RunInfo = \"请先进行公钥加密\"; return; } //私钥进行解密 RSACryptoServiceProvider myRSACryptoServiceProvider = (RSACryptoServiceProvider)selfCertificate.PrivateKey; byte[] plaintextByte = myRSACryptoServiceProvider.Decrypt(publicKeyEncryption, false); PrivateKeyDecryption = Encoding.UTF8.GetString(plaintextByte); } ","date":"2020-06-02","objectID":"/2020/06/dotnetbase12-certificate/:4:0","tags":["DotNet基础","证书加密签名"],"title":"DotNet基础 证书加密签名","uri":"/2020/06/dotnetbase12-certificate/"},{"categories":"DotNet基础","content":"证书电子签名\r/// \u003csummary\u003e /// 私钥签名 /// \u003c/summary\u003e public void PrivateKeyEnSignatureMethod() { if (string.IsNullOrEmpty(m_PlainText)) { RunInfo = \"请输入需要加密的信息\"; return; } //明文数据 byte[] infos = Encoding.UTF8.GetBytes(m_PlainText); //私钥进行摘要算法计算，并将计算值用私钥加密 RSACryptoServiceProvider myRSACryptoServiceProvider = (RSACryptoServiceProvider)selfCertificate.PrivateKey; byte[] signs= myRSACryptoServiceProvider.SignData(infos, \"MD5\"); string signdata = System.Convert.ToBase64String(signs); privateKeyEnSignature = signs; StringBuilder s = new StringBuilder(); foreach (var b in signs) { s.Append(b.ToString(\"X2\") + \" \"); } s.AppendLine(\"总字节数:\" + signs.Length); s.AppendLine(\"ConvertBase64:\" + signdata); PrivateKeyEnSignature = s.ToString(); } /// \u003csummary\u003e /// 验证签名方法 /// \u003c/summary\u003e public void PublicKeyDeSignatureMethod() { if (privateKeyEnSignature == null) { RunInfo = \"请先进行私钥加密\"; return; } //原始数据 byte[] infos = Encoding.UTF8.GetBytes(m_PlainText); //获取公钥 RSACryptoServiceProvider myRSACryptoServiceProvider = (RSACryptoServiceProvider)selfCertificate.PublicKey.Key; //验证数据,用公钥对加密的摘要值进行解密，并于原数据计算的摘要值进行比对 if (myRSACryptoServiceProvider.VerifyData(infos, \"MD5\", privateKeyEnSignature )) { PublicKeyDeSignature = \"验证成功\"; return; } PublicKeyDeSignature = \"验证失败\"; } ","date":"2020-06-02","objectID":"/2020/06/dotnetbase12-certificate/:5:0","tags":["DotNet基础","证书加密签名"],"title":"DotNet基础 证书加密签名","uri":"/2020/06/dotnetbase12-certificate/"},{"categories":"DotNet基础","content":"参考\rhttps://www.cnblogs.com/yank/p/DigitalCertification.html https://www.cnblogs.com/yank/p/3533998.html https://www.cnblogs.com/chnking/archive/2007/08/18/860983.html ","date":"2020-06-02","objectID":"/2020/06/dotnetbase12-certificate/:6:0","tags":["DotNet基础","证书加密签名"],"title":"DotNet基础 证书加密签名","uri":"/2020/06/dotnetbase12-certificate/"},{"categories":"DotNet基础","content":"最近和Socket干上了，连续肝了2个星期了，目前自己连抄带写的Socket已完成60%。来讲讲我在肝的过程中所思所想。为啥这么和Socket过不去，因为我想面向服务编程，每个组件都做成服务，组件化，当基础组件足够多，足够稳定，那么新的项目开发就会变得异常简单。而Socket是任何服务的基础，一个优秀的服务组件其网络通讯必须简洁可靠稳定的。有这么多优秀的Socket框架直接拿来用不香吗？是很香，也可以直接用它们实现各个组件，但是如果仅仅会用而不知道他们是如何实现的，同时出现问题只会花费更多的时间，一个简单的小问题可能需要排查很长一段时间。如果已经知道它们是如何是实现的，那么为何不自己尝试写一个呢。既是学习也是锻炼。本篇将总结一下SuperSocket中一些功能的实现思路。 ","date":"2020-05-27","objectID":"/2020/05/dotnetbase10-socket/:0:0","tags":["DotNet基础","仿写Socket"],"title":"DotNet基础 仿写Socket","uri":"/2020/05/dotnetbase10-socket/"},{"categories":"DotNet基础","content":"架构\rSuperSocket主要这几个类，AppServer,SocketServer,Listener,SocketSession,AppSession,这几个类的职责分工不同，一起完成SuperSocket强大的功能，这几个类也充分解释了：任何软件工程遇到的问题都可以通过增加一个中间层来解决。 Socket编程主要有一下几个步骤： Build Socket Listener Accept ReceiveHandle SendingHandle Close 如果想做一个中央日志服务或者文件管理服务，哪些是变化的东西？ ReceiveHandle肯定是变化的，SendingHandle也是变化的，发送的数据内容可能是String也可能是Binary，日志服务可以用UDP，文件管理用TCP，Server的后台操作不一样，日志服务，有的新的连接时新建一个日志文件，文件管理服务有新的连接了访问文件目录结构。 哪些东西是不会改变的？ Socket的执行流程是不变的，必须要建立socket,listener,accept….. SuperSocket就是把这个变化的东西都单独抽出来分离一层，以应对变化。 AppServer:负责应对服务端的变化和基本设置，比如设置线程数量，设置接收缓存发小，发送队列大小，LoadConnectFilter,LoadReceiveFilter,CommandLoader，CommandFIlter,ReceiveFilter，创建SocketServer. SocketServer负责应对Socket层面的变化，TCP，还是UDP,建立ReceiveBuffer,SendingQueuePool,Listener。同时订阅Listener的一些事件以响应NewClientConnected。一旦响应事件，就创建SocketSession,AppSession. Listener：创建ListenSocekt，ListenSocketAsyncEventArgs,并执行监听 SocketSession最为核心，负责Socket底层的收发消息，负责使用ReceiveBuffer，SendingQueuePool，该层也最容易发生内存泄漏。 AppSession应对Receive和Send的变化，比如ConnectedFilter,ReceiverFilter，CommandFilter都是该层做的，同时还包括ReceiveParser，所有跟收发相关的业务都在这一层实现。 从这些职责分配可以看出如果想用SuperSocket做一个组件那么只需要继承AppServer和AppSession就可以，这两个类是面向业务层面的变化，开发者不需要管理Socket底层的任何东西，重写一些方法专注于业务逻辑就可以了。 ","date":"2020-05-27","objectID":"/2020/05/dotnetbase10-socket/:1:0","tags":["DotNet基础","仿写Socket"],"title":"DotNet基础 仿写Socket","uri":"/2020/05/dotnetbase10-socket/"},{"categories":"DotNet基础","content":"关键技术\r我主要关注了Socket相关的关键技术 ReceiveBuffer：SuperSocket的AsyncReceive使用SocketAsyncEventArgs，那每一个SocketAsyncEventArgs都需要设置一个Buffer，所以就构建了一个大的ReceiveBuffer,将其均分给每一个ReceiveSocketAsyncEventArgs.同时维护了一个ReceiveSocketAsyncEventArgsPool，当一个连接断开后会将ReceiveSocketAsyncEventArgs返回给Pool SendingQueuePool：最有意思，看完它想到一句话：任何性能问题都可以用队列来解决，一个Queue不够可以构建一个QueuePool，如果一个QueuePool不够可以构建多个甚至QueuePoolQueue，多线程执行多个的Queue提高性能。具体是如何是实现呢？每个SocektSession都有一个m_SendingQueue,线程1执行发送任务，将本次发送任务的所有数据压入当前的SendingQueue，从SendingQueuePool中获得一个新的NewSendingQueue给m_SendingQueue，然后异步让后台线程执行发送任务从OldSendingQueue中取出数据执行发送。这样即使OldSendingQueue没有发送完，也不影响NewSendingQueue发送数据。当OldSendingQueue中的数据发送完会将其返回给SendingQueuePool，当并发量超级多，SendingQueuePool中的SendingQueue都被用完，SendingQueuePool还会实现自动扩容，建一个新的SendingQueuePool一起组成BigSendingQueuePool。这是不是很棒的设计。 ReceiveData的Parser和Filter都是在AppSession中完成的。CommandExecute是在AppServer中完成的，ReceiveFilter使用了模板方法，并使用复杂的算法来标识数据中特定的Mark，从而完成Filter，这里Parser使用了解析模式。Filter使用了组合模式。如果在ReceiveBuffer是固定的，但是Client发送数据很快，server会等到ReceiveBuffer满了之后进入Completed，必然会出现某条数据被切割成了两部分，在两次Completed的事件中，那么做一个拼接算法是必要的，Supersocket是如何做的呢？在Filter中如果第一次Filter结尾没有找到标识，会将最后这部分数据保存起来，然后重新设置第二次的ReceiveBuffer范围，其范围为头去掉（MessageLenth-receiveSize）大小，在第二次Filter中，会将第一次接收的数据拼接起来组成完整数据。提高数据传输的效率 ","date":"2020-05-27","objectID":"/2020/05/dotnetbase10-socket/:2:0","tags":["DotNet基础","仿写Socket"],"title":"DotNet基础 仿写Socket","uri":"/2020/05/dotnetbase10-socket/"},{"categories":"DotNet基础","content":"感想\rSuperSocket没有实现数据压缩传输比较遗憾，但是其也足够优秀，设计思路真的让人开阔视野， 刚开始写Socket的时候并没有想太多，但真的开始做了才发现考虑的东西非常多，总结一些经验： 先做好基本的设计需求规划，想要实现什么功能等等。 做好类的责任划分，想清楚哪些有可能会变化，让其呆在架构的底层，在没有办法的情况才进行分层隔离。 根据类的职责套用合适的设计模式。 开始撸代码，写好注释和测试。 任何好的代码都是重构来的，不要一开始就面面俱到，够用就行。 ","date":"2020-05-27","objectID":"/2020/05/dotnetbase10-socket/:3:0","tags":["DotNet基础","仿写Socket"],"title":"DotNet基础 仿写Socket","uri":"/2020/05/dotnetbase10-socket/"},{"categories":"DotNet基础","content":"介绍\r近期一直在看开源社区的源码，看各种编程书籍，自己却没有实践，堪称身体力行了王者级输入，青铜级输出。这是一个非常不好的学习习惯，会导致知其然而不知其所以然，所以有一个声音一直在我脑袋里呐喊，你不能这样了，必须要进行实践了，所以我放下了书本，暂停学习新的东西，开始造我的第一个轮子日志组件。 ","date":"2020-05-01","objectID":"/2020/05/dotnetbase11-log/:1:0","tags":["DotNet基础","日志组件"],"title":"DotNet基础 日志组件","uri":"/2020/05/dotnetbase11-log/"},{"categories":"DotNet基础","content":"0 性能对比\r首先看一下性能对比，我选了两个Log4Net和EntLib的Log组件进行遍历和并行100W数据量的对比。 EntLib的日志组件，测试结果直接注释在代码下方，无线程竞争的情况下需要18S，并行线程竞争情况下写入需要14S。 Log4Net在无线程竞争的情况下需要9S，线程竞争并行写入的时候需要11S，多线程写入实践反而变长了 再来看看我造的轮子LogNet，遍历写入4S 不到，多线程并行写入只用了不到2S，在速度方面比Log4Net快了一倍都不止。但是在内存管理方面显然有很大差距，GC的1代2代3代的回收次数都显著多于其他组件。下面将讲一下，这个组件为什么块，内存为什么消耗这么多。 ","date":"2020-05-01","objectID":"/2020/05/dotnetbase11-log/:2:0","tags":["DotNet基础","日志组件"],"title":"DotNet基础 日志组件","uri":"/2020/05/dotnetbase11-log/"},{"categories":"DotNet基础","content":"1 性能解析\r","date":"2020-05-01","objectID":"/2020/05/dotnetbase11-log/:3:0","tags":["DotNet基础","日志组件"],"title":"DotNet基础 日志组件","uri":"/2020/05/dotnetbase11-log/"},{"categories":"DotNet基础","content":"1.1 高性能锁\r在说锁之前先说说日志的大体实现思路，当有写入请求的时候先将写入的消息放到一个缓存队列中，不管多少的消息过来统一进入队列，后台有一个线程不停从线程队列中取得消息写入文件中。 所以在整个组件中最主要的锁就两个，一个是操作缓存队列的锁，还有一个是操作文件的锁。 操作缓存队列的锁线程只占用很短的时间，因为消息写入队列的数据很快，写入队列之前获取锁，写完立刻释放锁。 文件锁线程占用的时间相对来说长很多。写入文件毕竟的一个昂贵的操作。 对于缓存队列锁，我改造了一个带自旋的同步混合锁，看一下核心实现 在第一个线程的进入的时候会直接使用基元用户模式，快速获得锁，如果有线程竞争，第二个线程会直接进入自旋，在自旋的过程中如果第一个线程释放了锁，第二个线程可以直接通过基元用户模式获得锁。避免获得基元内核模式锁，从而损坏性能。但是如果线程在自旋的过程中，其他线程一直没有释放锁，那么线程不能一直自旋占用CPU片段，直接进入内核模式锁。这个有点像乐观锁的实现思想，只不过乐观锁是一直自旋，不进入基元内核锁，我觉得在这边使用乐观锁也可以，但毕竟是一种激进的做法。 释放锁，在线程竞争的情况下只有第一个线程是获得基元用户锁，其他线程都是基元内核模式构造的。 为什么这边使用这个自旋锁，我认为操作缓存队列的时间都比较短，如果短时间自旋一下，线程竞争的时候大多数线程都不用基元内核锁损坏性能。结果也看到了，确实在竞争模式块了很多。同时这边为什么不增加递归锁的功能，我觉得没有必要，在操作队列的过程中不会存在同一个线程同时获得两次锁的情况。假设如果真的出现，将同一个线程第二次获得锁视为另一个线程获得锁也未尝不可。 操作文件，直接使用不带自旋的混合锁就可以了。 ","date":"2020-05-01","objectID":"/2020/05/dotnetbase11-log/:3:1","tags":["DotNet基础","日志组件"],"title":"DotNet基础 日志组件","uri":"/2020/05/dotnetbase11-log/"},{"categories":"DotNet基础","content":"1.2 自动扩容队列\r日志组件的缓存队列非常简单，不需要很多复杂的操作，只需要基本的先进先出就可以了,一个简单的扩容队列，这个队列在满的时候会将队列容量扩展一倍，在队列长度是容量的四分之一的时候，会将容量减少一半。内存管理方面的问题，我认为就是这个自动扩容队列导致的，当大量消息写入缓存，又快速弹出大量消息，造成队列头和尾一直向下偏移，同时很多空的小内存片段得以释放。内存空间中充斥着很多小片段内存。后面我打算打造写一个循环缓存队列看看内存的问题是否可以得到改善，同时也会看一下Log4Net是如何实现的。将会进一步改进。 internal class ResizingArrayQueue\u003cItem\u003e:IEnumerable\u003cItem\u003e, IResizingArrayQueue\u003cItem\u003e { private Item[] q; // queue elements private int n; // number of elements on queue private int first; // index of first element of queue private int last; // index of next available slot /// \u003csummary\u003e /// Initializes an empty queue. /// \u003c/summary\u003e public ResizingArrayQueue() { q = new Item[2]; n = 0; first = 0; last = 0; } /// 判断是否等于默认值 /// \u003c/summary\u003e /// \u003cparam name=\"value\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e private bool IsEqlDefault\u003cT\u003e(T value) { //引用类型 if (default(T) == null) { if (value == null) return true; } else//值类型 { if (value.Equals(default(T))) return true; } return false; } /// \u003csummary\u003e /// Is this queue empty? /// \u003c/summary\u003e /// \u003creturns\u003e\u003c/returns\u003e public bool IsEmpty() { return n == 0; } /// \u003csummary\u003e /// Returns the number of items in this queue. /// \u003c/summary\u003e /// \u003creturns\u003e\u003c/returns\u003e public int Count =\u003e n; /// \u003csummary\u003e /// 清除数组中元素 /// \u003c/summary\u003e public void Clear() { //弹出所有元素 if (!IsEmpty()) { Dequeue(); } } /// \u003csummary\u003e /// resize the underlying array /// \u003c/summary\u003e /// \u003cparam name=\"capacity\"\u003e\u003c/param\u003e private void Resize(int capacity) { if (capacity \u003c n) throw new ArgumentException(\"capacity is less count\"); Item[] copy =new Item[capacity]; for (int i = 0; i \u003c n; i++) { copy[i] = q[(first + i) % q.Length]; } q = copy; first = 0; last = n; } /// \u003csummary\u003e /// Adds the item to this queue. /// \u003c/summary\u003e /// \u003cparam name=\"item\"\u003e\u003c/param\u003e public void Enqueue(Item item) { // double size of array if necessary and recopy to front of array if (n == q.Length) Resize(2 * q.Length); // double size of array if necessary q[last++] = item; // add item if (last == q.Length) last = 0; // wrap-around n++; } /// \u003csummary\u003e /// Removes and returns the item on this queue that was least recently added. /// \u003c/summary\u003e /// \u003creturns\u003e\u003c/returns\u003e public Item Dequeue() { if (IsEmpty()) throw new StackOverflowException(\"Queue underflow\"); Item item = q[first]; q[first] = default(Item); // to avoid loitering n--; first++; if (first == q.Length) first = 0; // wrap-around // shrink size of array if necessary if (n \u003e 0 \u0026\u0026 n == q.Length / 4) Resize(q.Length / 2); return item; } /// \u003csummary\u003e /// Returns the item least recently added to this queue. /// \u003c/summary\u003e /// \u003creturns\u003e\u003c/returns\u003e public Item Peek() { if (IsEmpty()) throw new StackOverflowException(\"Queue underflow\"); return q[first]; } public override String ToString() { StringBuilder s = new StringBuilder(); foreach (var value in this) { s.Append(value.ToString() + \" \"); } return s.ToString(); } public IEnumerator\u003cItem\u003e GetEnumerator() { return new Enumerator\u003cItem\u003e(q, first, n); } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } public struct Enumerator\u003cT\u003e : IEnumerator\u003cT\u003e { private int i; private T[] q; private int first; private int n; public Enumerator(T[] seq,int first,int n) { i = 0; q = seq; this.n = n; this.first = first; } public void Dispose() { } public bool MoveNext() { return i \u003c n; } public void Reset() { throw new NotImplementedException(); } public T Current { get { if (!MoveNext()) throw new OverflowException(\"value is overflow\"); T item = q[(i + first) % q.Length]; i++; return item; } } object IEnumerator.Current =\u003e Current; } } ","date":"2020-05-01","objectID":"/2020/05/dotnetbase11-log/:3:2","tags":["DotNet基础","日志组件"],"title":"DotNet基础 日志组件","uri":"/2020/05/dotnetbase11-log/"},{"categories":"DotNet基础","content":"2 代码实现\r","date":"2020-05-01","objectID":"/2020/05/dotnetbase11-log/:4:0","tags":["DotNet基础","日志组件"],"title":"DotNet基础 日志组件","uri":"/2020/05/dotnetbase11-log/"},{"categories":"DotNet基础","content":"消息添加到缓存\r在多线程消息添加换缓存的时候，会将消息添加到队列，然后调用保存到文件方法，但只有一个线程进行文件保存，其他线程直接返回。 ","date":"2020-05-01","objectID":"/2020/05/dotnetbase11-log/:4:1","tags":["DotNet基础","日志组件"],"title":"DotNet基础 日志组件","uri":"/2020/05/dotnetbase11-log/"},{"categories":"DotNet基础","content":"写入文件\r文件操作就先获得锁，然后不停从队列中获取消息写入文件，当队列中没有消息就释放锁。 ","date":"2020-05-01","objectID":"/2020/05/dotnetbase11-log/:4:2","tags":["DotNet基础","日志组件"],"title":"DotNet基础 日志组件","uri":"/2020/05/dotnetbase11-log/"},{"categories":"DotNet基础","content":"3 总结\r该日志组件功能相对简单，但也基本够用，胜在速度很快，内存管理方面有一些缺陷 ","date":"2020-05-01","objectID":"/2020/05/dotnetbase11-log/:5:0","tags":["DotNet基础","日志组件"],"title":"DotNet基础 日志组件","uri":"/2020/05/dotnetbase11-log/"},{"categories":"DotNet基础","content":"介绍\r一次简单的Socket探索之旅，分别对Socket服务端的两种方式进行了测试和解析。 ","date":"2020-04-12","objectID":"/2020/04/dotnetbase9-socket/:1:0","tags":["DotNet基础","Socket与完成端口模型"],"title":"DotNet基础 Socket与完成端口模型","uri":"/2020/04/dotnetbase9-socket/"},{"categories":"DotNet基础","content":"CommonSocket\r","date":"2020-04-12","objectID":"/2020/04/dotnetbase9-socket/:2:0","tags":["DotNet基础","Socket与完成端口模型"],"title":"DotNet基础 Socket与完成端口模型","uri":"/2020/04/dotnetbase9-socket/"},{"categories":"DotNet基础","content":"代码实现\r实现一个简单的Socket服务，基本功能就是接收消息然后加上结束消息时间返回给客户端。 /// \u003csummary\u003e /// 简单服务，收发消息 /// \u003c/summary\u003e class FirstSimpleServer { public static void Run(string m_ip, int m_port) { var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); var ip = IPAddress.Parse(m_ip); var endpoint = new IPEndPoint(ip, m_port); socket.Bind(endpoint); socket.Listen(0); socket.ReceiveTimeout = -1; Task.Run(() =\u003e { while (true) { var acceptSocket = socket.Accept(); if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { Task.Run(() =\u003e { byte[] receiveBuffer = new byte[256]; int result = 0; do { if (acceptSocket.Connected) { result = acceptSocket.Receive(receiveBuffer, 0, receiveBuffer.Length, SocketFlags.None, out SocketError error); if (error == SocketError.Success \u0026\u0026 result \u003e 0) { var recestr = Encoding.UTF8.GetString(receiveBuffer, 0, result); var Replaystr = $\"Server收到消息:{recestr};Server收到消息的时间:{DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss:fff\")}\"; Console.WriteLine(Replaystr); var strbytes = Encoding.UTF8.GetBytes(Replaystr); acceptSocket.Send(strbytes, 0, strbytes.Length, SocketFlags.None); if (recestr.Contains(\"stop\")) { break; } } } else { break; } } while (result \u003e 0); }).ContinueWith((t) =\u003e { System.Threading.Thread.Sleep(1000); acceptSocket.Disconnect(false); acceptSocket.Dispose(); }); } } }).Wait(); } ","date":"2020-04-12","objectID":"/2020/04/dotnetbase9-socket/:2:1","tags":["DotNet基础","Socket与完成端口模型"],"title":"DotNet基础 Socket与完成端口模型","uri":"/2020/04/dotnetbase9-socket/"},{"categories":"DotNet基础","content":"简单测试\r测试：一个客户端，发送10次数据，每次间隔50ms， 结果：客户端的显示如下，客户端发送消息，再接收到，十次中最长的耗时10ms。 ClientReceiceServer:{Server收到消息:{Client:1:MessageID:0;Client发送时间:2020-04-11 13:21:22:974};Server收到消息的时间:2020-04-11 13:21:22:981;ClientReceiceServer时间:2020-04-11 13:21:22:984} ClientReceiceServer:{Server收到消息:{Client:1:MessageID:1;Client发送时间:2020-04-11 13:21:23:032};Server收到消息的时间:2020-04-11 13:21:23:032;ClientReceiceServer时间:2020-04-11 13:21:23:032} ClientReceiceServer:{Server收到消息:{Client:1:MessageID:2;Client发送时间:2020-04-11 13:21:23:082};Server收到消息的时间:2020-04-11 13:21:23:082;ClientReceiceServer时间:2020-04-11 13:21:23:083} ClientReceiceServer:{Server收到消息:{Client:1:MessageID:3;Client发送时间:2020-04-11 13:21:23:133};Server收到消息的时间:2020-04-11 13:21:23:133;ClientReceiceServer时间:2020-04-11 13:21:23:133} ClientReceiceServer:{Server收到消息:{Client:1:MessageID:4;Client发送时间:2020-04-11 13:21:23:184};Server收到消息的时间:2020-04-11 13:21:23:184;ClientReceiceServer时间:2020-04-11 13:21:23:190} ClientReceiceServer:{Server收到消息:{Client:1:MessageID:5;Client发送时间:2020-04-11 13:21:23:235};Server收到消息的时间:2020-04-11 13:21:23:235;ClientReceiceServer时间:2020-04-11 13:21:23:235} ClientReceiceServer:{Server收到消息:{Client:1:MessageID:6;Client发送时间:2020-04-11 13:21:23:286};Server收到消息的时间:2020-04-11 13:21:23:286;ClientReceiceServer时间:2020-04-11 13:21:23:286} ClientReceiceServer:{Server收到消息:{Client:1:MessageID:7;Client发送时间:2020-04-11 13:21:23:336};Server收到消息的时间:2020-04-11 13:21:23:336;ClientReceiceServer时间:2020-04-11 13:21:23:336} ClientReceiceServer:{Server收到消息:{Client:1:MessageID:8;Client发送时间:2020-04-11 13:21:23:387};Server收到消息的时间:2020-04-11 13:21:23:387;ClientReceiceServer时间:2020-04-11 13:21:23:388} ClientReceiceServer:{Server收到消息:{Client:1:MessageID:9;Client发送时间:2020-04-11 13:21:23:438};Server收到消息的时间:2020-04-11 13:21:23:438;ClientReceiceServer时间:2020-04-11 13:21:23:438} 假如客户端发送消息速度加快，对服务端会有什么影响？测试将客户端发送消息的间隔修改为1ms System.Threading.Thread.Sleep(1); 结果如下,并没有发现问题。 ClientReceiceServer:{Server收到消息:{Client:1:MessageID:0;Client发送时间:2020-04-11 13:48:57:193};Server收到消息的时间:2020-04-11 13:48:57:196;ClientReceiceServer时间:2020-04-11 13:48:57:197} ClientReceiceServer:{Server收到消息:{Client:1:MessageID:1;Client发送时间:2020-04-11 13:48:57:198};Server收到消息的时间:2020-04-11 13:48:57:198;ClientReceiceServer时间:2020-04-11 13:48:57:201} ClientReceiceServer:{Server收到消息:{Client:1:MessageID:2;Client发送时间:2020-04-11 13:48:57:200};Server收到消息的时间:2020-04-11 13:48:57:201;ClientReceiceServer时间:2020-04-11 13:48:57:202} ClientReceiceServer:{Server收到消息:{Client:1:MessageID:3;Client发送时间:2020-04-11 13:48:57:202};Server收到消息的时间:2020-04-11 13:48:57:202;ClientReceiceServer时间:2020-04-11 13:48:57:203} ClientReceiceServer:{Server收到消息:{Client:1:MessageID:4;Client发送时间:2020-04-11 13:48:57:204};Server收到消息的时间:2020-04-11 13:48:57:204;ClientReceiceServer时间:2020-04-11 13:48:57:204} ClientReceiceServer:{Server收到消息:{Client:1:MessageID:5;Client发送时间:2020-04-11 13:48:57:206};Server收到消息的时间:2020-04-11 13:48:57:206;ClientReceiceServer时间:2020-04-11 13:48:57:207} ClientReceiceServer:{Server收到消息:{Client:1:MessageID:6;Client发送时间:2020-04-11 13:48:57:208};Server收到消息的时间:2020-04-11 13:48:57:208;ClientReceiceServer时间:2020-04-11 13:48:57:208} ClientReceiceServer:{Server收到消息:{Client:1:MessageID:7;Client发送时间:2020-04-11 13:48:57:209};Server收到消息的时间:2020-04-11 13:48:57:209;ClientReceiceServer时间:2020-04-11 13:48:57:211} ClientReceiceServer:{Server收到消息:{Client:1:MessageID:8;Client发送时间:2020-04-11 13:48:57:211};Server收到消息的时间:2020-04-11 13:48:57:211;ClientReceiceServer时间:2020-04-11 13:48:57:212} ClientReceiceServer:{Server收到消息:{Client:1:MessageID:9;Client发送时间:2020-04-11 13:48:57:213};Server收到消息的时间:2020-04-11 13:48:57:213;ClientReceiceServer时间:2020-04-11 13:48:57:213} 再极致一点，将客户端的发送间隔取消，循环发送。看到下面服务端接收消息的结果，可看到消息包很混乱。仔细分析一下，发现其实服务器其实就收到3次消息，前两次接受256个字节，最后一次接收138字节。这是由于设置服务端接收缓存的大小为256个字节。说明发送比较快或并行发送的时候，服务端会很快将接收的缓存块填满，一旦填满，Receive方法就会返回，不然就处于阻塞状态。 Server收到消息:{Client:1:MessageID:1;Client发送时间:2020-04-11 13:51:18:723}{Client:1:MessageID:2;Client发送时间:2020-04-11 13:51:18:724}{Client:1:MessageID:3;Client发","date":"2020-04-12","objectID":"/2020/04/dotnetbase9-socket/:2:2","tags":["DotNet基础","Socket与完成端口模型"],"title":"DotNet基础 Socket与完成端口模型","uri":"/2020/04/dotnetbase9-socket/"},{"categories":"DotNet基础","content":"并发消息测试\r如果并行发送消息，同时有两个消息到服务端，消息内容会混乱吗？客户端进行并行消息发送测试。下面为测试结果，发现并没有问题，说明一个消息可能没有被拆分，或则即使被拆分了在网络通讯底层也会恢复原来的消息结构。 Parallel.For(1, 10, (i) =\u003e { var Replaystr = $\"{{Client:1:MessageID:{i};Client发送时间:{DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss:fff\")}}}\"; var strbytes = Encoding.UTF8.GetBytes(Replaystr); socket.Send(strbytes, 0, strbytes.Length, SocketFlags.None); }); Server收到消息:{Client:1:MessageID:2;Client发送时间:2020-04-11 17:11:44:568};Server收到消息的时间:2020-04-11 17:11:44:572 Server收到消息:{Client:1:MessageID:1;Client发送时间:2020-04-11 17:11:44:568};Server收到消息的时间:2020-04-11 17:11:44:575 Server收到消息:{Client:1:MessageID:4;Client发送时间:2020-04-11 17:11:44:572};Server收到消息的时间:2020-04-11 17:11:44:576 Server收到消息:{Client:1:MessageID:5;Client发送时间:2020-04-11 17:11:44:572};Server收到消息的时间:2020-04-11 17:11:44:576 Server收到消息:{Client:1:MessageID:6;Client发送时间:2020-04-11 17:11:44:572};Server收到消息的时间:2020-04-11 17:11:44:576 Server收到消息:{Client:1:MessageID:7;Client发送时间:2020-04-11 17:11:44:572};Server收到消息的时间:2020-04-11 17:11:44:576 Server收到消息:{Client:1:MessageID:8;Client发送时间:2020-04-11 17:11:44:572};Server收到消息的时间:2020-04-11 17:11:44:577 Server收到消息:{Client:1:MessageID:9;Client发送时间:2020-04-11 17:11:44:572};Server收到消息的时间:2020-04-11 17:11:44:577 Server收到消息:{Client:1:MessageID:3;Client发送时间:2020-04-11 17:11:44:571};Server收到消息的时间:2020-04-11 17:11:44:577 ","date":"2020-04-12","objectID":"/2020/04/dotnetbase9-socket/:2:3","tags":["DotNet基础","Socket与完成端口模型"],"title":"DotNet基础 Socket与完成端口模型","uri":"/2020/04/dotnetbase9-socket/"},{"categories":"DotNet基础","content":"并发客户端测试\r再进一步测试，假设有多个客户端同时连接，并行发送消息。 Parallel.For(0, 9, (Clienti) =\u003e { var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); var ip = IPAddress.Parse(m_ip); var endpoint = new IPEndPoint(ip, m_port); socket.ReceiveTimeout = -1; Task.Run(() =\u003e { socket.Connect(endpoint); ... ... } }); 结果：这个测试是放在虚拟机中，使用的是NAT网络模式，同一个子网内客户端从发出消息接收服务端返回消息最长耗时有6秒，还是比较夸张的。 服务端结果： 客户端结果： ","date":"2020-04-12","objectID":"/2020/04/dotnetbase9-socket/:2:4","tags":["DotNet基础","Socket与完成端口模型"],"title":"DotNet基础 Socket与完成端口模型","uri":"/2020/04/dotnetbase9-socket/"},{"categories":"DotNet基础","content":"总结\r这个Socket服务在少量客户端连接的时候好像没什么问题，它能抗住大量客户端的连接并发测试吗？我想答案肯定是否定的，为什么呢？因为每个客户端连接都需要消耗1个线程，线程是很昂贵的资源，每个线程自生就要消耗1M内存，100客户端连接什么都不做就消耗了100M，更不用说线程之间的上下文切换需要消耗更宝贵的CPU资源，所以这个服务端根本应对不了大量客户端的连接。 那么最理想的Socket服务端是什么样子的呢？在我看来就是只有与CPU核数相同的线程量在运行，如果4核那么就4个线程在运行，然后每个线程处理超级多的客户端，最好没有阻塞，不休息。怎样才能实现这个目标呢？微软给了一个简单的例子，已经极大程度的实现了这个想法，一起来看看吧 ","date":"2020-04-12","objectID":"/2020/04/dotnetbase9-socket/:2:5","tags":["DotNet基础","Socket与完成端口模型"],"title":"DotNet基础 Socket与完成端口模型","uri":"/2020/04/dotnetbase9-socket/"},{"categories":"DotNet基础","content":"SocketAsyncEventArgs\rMSDN中SocketAsyncEventArgs ","date":"2020-04-12","objectID":"/2020/04/dotnetbase9-socket/:3:0","tags":["DotNet基础","Socket与完成端口模型"],"title":"DotNet基础 Socket与完成端口模型","uri":"/2020/04/dotnetbase9-socket/"},{"categories":"DotNet基础","content":"代码实现\r我仿照微软提供的这个实例撸了个简单的Socket服务端 public class SocketArgsServer { private static int m_numConnections; private static int m_receiveBufferSize; private static int m_sendBufferSize; private static byte[] m_receivebuffer; private static Stack\u003cint\u003e m_freeReceiveIndexPool; private static int m_currentReceiveIndex; private static byte[] m_sendbuffer; private static Stack\u003cint\u003e m_freeSendIndexPool; private static int m_currentSendIndex; private static Stack\u003cSocketAsyncEventArgs\u003e m_ReadPool; private static Stack\u003cSocketAsyncEventArgs\u003e m_WritePool; private static Semaphore m_maxNumberAcceptedClients; private static int m_numConnectedSockets; private static int m_totalBytesRead; private static Socket listenSocket; public static void Run(string m_ip, int m_port, int numConnections, int m_receiveBuffer, int m_sentBuffer) { m_numConnections = numConnections; m_receiveBufferSize = m_receiveBuffer; m_sendBufferSize = m_sentBuffer; m_receivebuffer = new byte[m_receiveBufferSize * m_numConnections]; m_freeReceiveIndexPool = new Stack\u003cint\u003e(); m_currentReceiveIndex = 0; m_sendbuffer = new byte[m_sendBufferSize * m_numConnections]; m_freeSendIndexPool = new Stack\u003cint\u003e(); m_currentSendIndex = 0; m_ReadPool = new Stack\u003cSocketAsyncEventArgs\u003e(m_numConnections); m_WritePool = new Stack\u003cSocketAsyncEventArgs\u003e(m_numConnections); m_maxNumberAcceptedClients = new Semaphore(m_numConnections, m_numConnections); m_numConnectedSockets = 0; m_totalBytesRead = 0; for (int i = 0; i \u003c m_numConnections; i++) { var readEventArg = new SocketAsyncEventArgs(); readEventArg.Completed += new EventHandler\u003cSocketAsyncEventArgs\u003e(ReadWriteIOComleted); readEventArg.UserToken = new AsyncUserToken(); if (m_freeReceiveIndexPool.Count \u003e 0) { readEventArg.SetBuffer(m_receivebuffer, m_freeReceiveIndexPool.Pop(), m_receiveBufferSize); } else { if ((m_receiveBufferSize * m_numConnections - m_receiveBufferSize) \u003c m_currentReceiveIndex) { new ArgumentException(\"接收缓存设置异常\"); } readEventArg.SetBuffer(m_receivebuffer, m_currentReceiveIndex, m_receiveBufferSize); m_currentReceiveIndex += m_receiveBufferSize; } m_ReadPool.Push(readEventArg); var writeEventArg = new SocketAsyncEventArgs(); writeEventArg.Completed += new EventHandler\u003cSocketAsyncEventArgs\u003e(ReadWriteIOComleted); writeEventArg.UserToken = new AsyncUserToken(); if (m_freeSendIndexPool.Count \u003e 0) { writeEventArg.SetBuffer(m_sendbuffer, m_freeSendIndexPool.Pop(), m_sendBufferSize); } else { if ((m_sendBufferSize * m_numConnections - m_sendBufferSize) \u003c m_currentSendIndex) { new ArgumentException(\"发送缓存设置异常\"); } writeEventArg.SetBuffer(m_sendbuffer, m_currentSendIndex, m_sendBufferSize); m_currentSendIndex += m_sendBufferSize; } m_WritePool.Push(writeEventArg); } listenSocket = new Socket(new IPEndPoint(IPAddress.Parse(m_ip), m_port).AddressFamily, SocketType.Stream, ProtocolType.Tcp); listenSocket.Bind(new IPEndPoint(IPAddress.Parse(m_ip), m_port)); listenSocket.Listen(100); StartAccept(null); Console.WriteLine(\"Press any key to terminate the server process....\"); Console.ReadKey(); } public static void ReadWriteIOComleted(object sender, SocketAsyncEventArgs e) { switch (e.LastOperation) { case SocketAsyncOperation.Receive: ProcessReceive(e); break; case SocketAsyncOperation.Send: ProcessSend(e); break; default: throw new ArgumentException(\"The last operation completed on the socket was not a receive or send\"); } } public static void ProcessSend(SocketAsyncEventArgs e) { if (e.SocketError == SocketError.Success) { AsyncUserToken token = (AsyncUserToken)e.UserToken; bool willRaiseEvent = token.Socket.ReceiveAsync(token.readEventArgs); if (!willRaiseEvent) { ProcessReceive(token.readEventArgs); } } else { CloseClientSocket(e); } } public static void CloseClientSocket(SocketAsyncEventArgs e) { AsyncUserToken token = e.UserToken as AsyncUserToken; try { token.Socket.Shutdown(SocketShutdown.Send); } catch (Exception exception) { Console.WriteLine(exception); } token.Socket.Close(); Interlocked.Decrement(ref m_numConnectedSockets); m_ReadPool","date":"2020-04-12","objectID":"/2020/04/dotnetbase9-socket/:3:1","tags":["DotNet基础","Socket与完成端口模型"],"title":"DotNet基础 Socket与完成端口模型","uri":"/2020/04/dotnetbase9-socket/"},{"categories":"DotNet基础","content":"并发测试\r先直接上测试结果，该测试环境还是在虚拟机中，忽略一下服务端收到消息时间，因为虚拟机时间和主机时间不是同步的。可以看到服务端发送消息到接收到消息最长耗时2s。 ","date":"2020-04-12","objectID":"/2020/04/dotnetbase9-socket/:3:2","tags":["DotNet基础","Socket与完成端口模型"],"title":"DotNet基础 Socket与完成端口模型","uri":"/2020/04/dotnetbase9-socket/"},{"categories":"DotNet基础","content":"总结\r这个Socket服务端直接丢弃了线程的概念，通过SocketAsyncEventArgs来实现了之前线程实现的所有功能。一个SocketAsyncEventArgs来监测连接，客户端连接的时候从SocketAsyncEventArgsPool中分配两个SocketAsyncEventArgs分别负责读写消息。读写消息的缓存块也进行了统一管理，共同组成一个大的缓存块进行重复使用。当客户端失去连接的时候将分配的读写SocketAsyncEventArgs返还给SocketAsyncEventArgsPool进行重复使用。 ","date":"2020-04-12","objectID":"/2020/04/dotnetbase9-socket/:3:3","tags":["DotNet基础","Socket与完成端口模型"],"title":"DotNet基础 Socket与完成端口模型","uri":"/2020/04/dotnetbase9-socket/"},{"categories":"DotNet基础","content":"最后\r在本文中探索了两种socket服务端的实现，并对这两种socket服务端进行了简单的剖析，我看了SuperSocket的底层实现思想采用的是第二种方式。 ","date":"2020-04-12","objectID":"/2020/04/dotnetbase9-socket/:4:0","tags":["DotNet基础","Socket与完成端口模型"],"title":"DotNet基础 Socket与完成端口模型","uri":"/2020/04/dotnetbase9-socket/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 ","date":"2020-04-08","objectID":"/2020/04/prism22-source/:0:0","tags":["Prism源码解析","RegionContext"],"title":"Prism源码解析 RegionContext","uri":"/2020/04/prism22-source/"},{"categories":"Prism","content":"介绍\r","date":"2020-04-08","objectID":"/2020/04/prism22-source/:1:0","tags":["Prism源码解析","RegionContext"],"title":"Prism源码解析 RegionContext","uri":"/2020/04/prism22-source/"},{"categories":"Prism","content":"0 RegionContext\rPrism为Region构造了一个RegionContext，其功能和DataContext差不多。看看怎么实现的吧 首先声明 在RegionManager中定义一个依赖属性RegionContext, 值改变的时候更新RegionContext中的依赖属性 这个RegionContext就保存一个依赖属性对象实例，这个依赖属性用ObserableObject包装了一下，提供了一个获取实例的方法。 同时注意到这里面有一个关键的地方 view.SetValue(RegionContext.ObservableRegionContextProperty, (object) observableObject); 其实在view中还保存了ObservableRegionContextProperty依赖属性实例。 看一下依赖属性值改变怎么触发的 在Reion的VIew中其实是绑定了RegionContext依赖属性的ValeChanged事件。 看到这我就好奇为啥RegionManager中要有一个依赖属性，看着很多余啊？ 我注意到有一个行为SyncRegionContextWithHostBehavior， 目前还没看出来怎么用。 我注意到Region的行为中有一个BindRegionContextToDependencyObjectBehavior 行为 当Region的View改变时， 这个context是哪里来的呢？在这个行为中 第一次载入的时候，只要View的RegionContext值变化就会将新值给Region.Context。 只要有新的View添加进来就将Region.Context的值给View的RegionContext.ObservableRegionContextProperty依赖属性。 ","date":"2020-04-08","objectID":"/2020/04/prism22-source/:2:0","tags":["Prism源码解析","RegionContext"],"title":"Prism源码解析 RegionContext","uri":"/2020/04/prism22-source/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 ","date":"2020-04-06","objectID":"/2020/04/prism21-source/:0:0","tags":["Prism源码解析","导航"],"title":"Prism源码解析 导航","uri":"/2020/04/prism21-source/"},{"categories":"Prism","content":"介绍\rPrism提供了一个非常强大的功能导航，导航的意思就是指定对应的View显示。这个导航的强大之处有： 可以设置导航前后的动作 可以指定View实例的生命周期，可以是否导航到新的View实例 提供了确认导航接口。 导航前后均有相应的事件通知 提供了回退前进的导航功能 ","date":"2020-04-06","objectID":"/2020/04/prism21-source/:1:0","tags":["Prism源码解析","导航"],"title":"Prism源码解析 导航","uri":"/2020/04/prism21-source/"},{"categories":"Prism","content":"导航\r直接看代码 可以看到直接通过RequstNavigate来请求，参数是View的TypeName 转到了Region.RequestNavigate里 这边出现了NavigationService，几乎所有的导航功能都是在这个服务中实现的， 这边将导航的一些信息封装成NavigationContext, 在这出现了第一个功能，实现ICon’firm’NavigationRequest接口，确认导航。 最后来到了最重要的函数ExecuteNavigation 这个函数每一行都很重要，每一行都是一个功能。 调用OnNavigateFrom,可以在导航前做一些操作 获取导航内容，先从Region的View中找，没找到就到容器中找，然后添加到Region的View。 激活界面 创建条目，保存条目，主要用来进行前进后退 触发导航完成事件。 整个导航功能的顺序： ","date":"2020-04-06","objectID":"/2020/04/prism21-source/:2:0","tags":["Prism源码解析","导航"],"title":"Prism源码解析 导航","uri":"/2020/04/prism21-source/"},{"categories":"Prism","content":"总结\r​ Prism提供的这个导航功能非常强大，但是代码却不复杂，通过一些简单的接口，实现了非常强大的功能。 ","date":"2020-04-06","objectID":"/2020/04/prism21-source/:3:0","tags":["Prism源码解析","导航"],"title":"Prism源码解析 导航","uri":"/2020/04/prism21-source/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 ","date":"2020-04-05","objectID":"/2020/04/prism20-source/:0:0","tags":["Prism源码解析","事件聚合"],"title":"Prism源码解析 事件聚合","uri":"/2020/04/prism20-source/"},{"categories":"Prism","content":"0 介绍\r事件提供的是1对多的绑定，通过委托链实现对订阅者的调用，事件必须要通过发布者调用。同时事件订阅是强引用，事件订阅者的生命周期总是大于等于事件发布者。如果代码中事件很多就会充斥着各种事件的订阅，不利于维护。 Prism提供了EventAggregator器，可以在任何地方进行订阅，任何地方进行调用/发布，实例只对EventAggregator和事件类型有依赖，使用了弱引用，可以过滤消息，并可以控制回调函数线程。感觉很强大，实现应该挺复杂，但看到实现时有一种恍然大悟的感觉，喜欢这种简单而强大的实现。开始一探究竟吧！ ","date":"2020-04-05","objectID":"/2020/04/prism20-source/:1:0","tags":["Prism源码解析","事件聚合"],"title":"Prism源码解析 事件聚合","uri":"/2020/04/prism20-source/"},{"categories":"Prism","content":"1 整体框架\r先从整体框架解析一下吧。EventAggregator 发现这只是一个集合类，保存着事件类型和事件实例，还有一个线程上下文保证线程同步。 看一下EventBase，看来所有的订阅委托都是在着保存着，因为有一个IEventSubscription列表。EventSubscription因该是订阅委托的包装器。 看到有SubscriptionToken和DelegateReference， 这边终于看到Delegate的真正存放地点了。这边存放了弱引用，委托类型和MethodInfo。 看到这边理解了，通过一个集合保存事件，这个事件内部存储着所有订阅委托。 当我们向订阅发布的时候，只要从这个集合中获取对应的事件进行订阅发布。相通了是不是觉得自己也能写一个简单的事件聚合器呢？ ","date":"2020-04-05","objectID":"/2020/04/prism20-source/:2:0","tags":["Prism源码解析","事件聚合"],"title":"Prism源码解析 事件聚合","uri":"/2020/04/prism20-source/"},{"categories":"Prism","content":"2 具体代码\r来具体看看代码吧。 看到EventAggregator通过依赖注入，获取MessageSentEvent进行订阅。 保存了UI线程上下文和将事件类型和事件类型实例放到集合中，加锁，线程安全。 事件可以啥都没有但必须继承PubSubEvent，功能都在这里实现了。 threadOption默认是PublisherTHread，这里是说回调函数在什么线程执行，BackgroundThread就是Task创建的线程池线程，Dispatcher就是UI线程 内部订阅进行了校验（主要是委托不为空）和Token 看完订阅再来看看调用 在任何地方调用，还是去EventAggregator获取事件实例，然后调用其Publish 从这边可以看出就是依次调用列表中的委托，DispatcherEventSubscription 调用 BackgroundEventSubscription 调用 到现在还没有讲到Filter，来看看怎么实现过滤消息 在订阅的时候值接受含有Brian的消息 使用了泛型的订阅 使用了prcidate\u003c\u003e保存了filter委托， 在Publish主要就是在GetExecutionStrategy方法中 filter返回true触发订阅委托。 ","date":"2020-04-05","objectID":"/2020/04/prism20-source/:3:0","tags":["Prism源码解析","事件聚合"],"title":"Prism源码解析 事件聚合","uri":"/2020/04/prism20-source/"},{"categories":"Prism","content":"总结\r事件聚合提供了一个很好的思路，我们甚至可以利用事件聚合的思想实现事件聚合微服务组件。 ","date":"2020-04-05","objectID":"/2020/04/prism20-source/:4:0","tags":["Prism源码解析","事件聚合"],"title":"Prism源码解析 事件聚合","uri":"/2020/04/prism20-source/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 ","date":"2020-04-03","objectID":"/2020/04/prism19-source/:0:0","tags":["Prism源码解析","数据绑定和命令"],"title":"Prism源码解析 数据绑定和命令","uri":"/2020/04/prism19-source/"},{"categories":"Prism","content":"介绍\rWPF本身就支持通知、绑定和命令，实现ViewModel和VIew之间的通讯，但相对来说功能比较少，Prism扩充了这些功能并提供更加强有力，简洁的数据绑定和命令。 ","date":"2020-04-03","objectID":"/2020/04/prism19-source/:1:0","tags":["Prism源码解析","数据绑定和命令"],"title":"Prism源码解析 数据绑定和命令","uri":"/2020/04/prism19-source/"},{"categories":"Prism","content":"0 绑定通知\rWPF的绑定通知需要实现INotifyPropertyChanged接口，也就是实现一个属性改变事件，用来通知UI属性改变了，让UI更新。该事件需要一个事件参数new PropertyChangedEventArgs(propertyName)传入属性的名字，这样的调用方式比较繁琐。 Prism扩充了WPF的绑定通知。提供了BindableBase 实现了 INotifyPropertyChanged接口，并使用CallerMemberName获取属性名字。这样就解决了属性改变事件调用繁琐的问题。同时在内部还是对相等值进行了过滤。 简单愉快的调用吧 只需要使用SetProperty方法就可以自动更新UI了。 值得注意的是OnPropertyChanged还提供了对Expression的支持 也就是主动调用OnPropertyChanged(()=\u003ethis.PropertyName),也可以触发UI响应。 ","date":"2020-04-03","objectID":"/2020/04/prism19-source/:2:0","tags":["Prism源码解析","数据绑定和命令"],"title":"Prism源码解析 数据绑定和命令","uri":"/2020/04/prism19-source/"},{"categories":"Prism","content":"1 命令\r","date":"2020-04-03","objectID":"/2020/04/prism19-source/:3:0","tags":["Prism源码解析","数据绑定和命令"],"title":"Prism源码解析 数据绑定和命令","uri":"/2020/04/prism19-source/"},{"categories":"Prism","content":"DelegateCommand\rWPF命令和通知有点类似，命令需要实现ICommand接口，实现Execute方法，命令状态CanExecute和命令状态改变事件。并且WPF只实现了一个RoutedCommand。Prism提供了一个DelegateCommandBase命令基类实现ICommand，并扩充了子类DelegateCommand，大大简化了命令调用方式 看到在基类中有_synchronizationContext线程同步上下文，用来保证命令执行的时候线程同步。 重点关注一下子类中的几个方法 1.ExecuteDelegateCommand = new DelegateCommand(Execute, CanExecute); 这个命令声明方式，如果命令状态发生变化的时候需要主动调用RaiseCanExecuteChanged方法来触发命令状态改变事件。 2.DelegateCommandObservesProperty = new DelegateCommand(Execute, CanExecute).ObservesProperty(() =\u003e IsEnabled); 可以看到这种声明方式，提供了一个ObservesProperty方法，不需要显示调用命令状态改变事件。 3.DelegateCommandObservesCanExecute = new DelegateCommand(Execute).ObservesCanExecute(() =\u003e IsEnabled); 这种声明方法提供ObservesCanExecute方法，直接观测命令状态改变事件和属性。 ExecuteGenericDelegateCommand = new DelegateCommand(ExecuteGeneric).ObservesCanExecute(() =\u003e IsEnabled); 这是一个使用泛型带参数的声明方式， 看一下内部怎么实现这种简单而强大的功能 通过Expression，内部调用PropertyObserver.Observes()方法并将RaiseCanExecuteChaned方法传入。 在PropertyObserver将Expression保存在一个链表，并每个节点都订阅OnPropertyChanged事件。 ","date":"2020-04-03","objectID":"/2020/04/prism19-source/:3:1","tags":["Prism源码解析","数据绑定和命令"],"title":"Prism源码解析 数据绑定和命令","uri":"/2020/04/prism19-source/"},{"categories":"Prism","content":"CompositeCommand\rPrism还提供了一个CompositeCommand命令 这个命令的功能跟其名字一样，就是复合命令，命令集合。 将DelegateCommand实例放到其中，每当调用CompositeCommand调用的时候会调用它保存的所有命令， 命令集合中任何一个命令状态改变，都会触发CompositeCommand命令状态的改变事件，导致CompositeCommand检查集合中所有的命令状态，首先会检查IActiveAware，再检查命令状态，如果任何一个命令状态是False，都会导致组合命令返回False 来看一下源码 注意到，聚合命令也是通过线程上下文保持线程同步，同时看到有检测IActiveAware接口，这个接口是什么意思呢？其实就是查看该命令是否激活。这个接口有一个激活状态属性和一个激活状态改变事件， 只要界面主动调用UpdateCommand.IsActive = true;命令就会被激活并触发复合命令的激活状态改变回调函数 在复合命令的ShouldExcute方法中检查其激活状态，命令集合中没有激活命令，那么复合命令的执行状态也会改变。 命令执行和激活状态都是差不多的接口，有状态和状态改变事件组成，感觉很多地方都有相似的模式，有点像订阅模式，也有点像状态机，包括一些Collection和Storage. ","date":"2020-04-03","objectID":"/2020/04/prism19-source/:3:2","tags":["Prism源码解析","数据绑定和命令"],"title":"Prism源码解析 数据绑定和命令","uri":"/2020/04/prism19-source/"},{"categories":"Prism","content":"总结\r主要讲了下Prism提供的绑定通知和命令，学习到如何在WPF框架基础上做一些封装，如果可能甚至可以自己重新封装一些功能更强大的命令来兼容Prism。 ","date":"2020-04-03","objectID":"/2020/04/prism19-source/:4:0","tags":["Prism源码解析","数据绑定和命令"],"title":"Prism源码解析 数据绑定和命令","uri":"/2020/04/prism19-source/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 ","date":"2020-04-02","objectID":"/2020/04/prism18-source/:0:0","tags":["Prism源码解析","ViewModel注入"],"title":"Prism源码解析 ViewModel注入","uri":"/2020/04/prism18-source/"},{"categories":"Prism","content":"介绍\r介绍一个Prism的MVVM实现，主要介绍Prism如何在WPF上进行的一些封装，以实现MVVM。MVVM到底是什么呢？看一下这一幅经典的图 以前没有ViewModel这个概念，就是将Model传递到View显示，这样软件也可以工作，但却很混乱，一旦VIew要改动，一点点的改动都会造成很多代码需要改动，不利于维护。再者VIew层充斥着各种解析Model的代码，这些代码完全不属于View啊。平白无故的给View增加了很多职责。这是坏代码的味道。所以就有了ViewModel。ViewModel负责干什么，必须要干什么，其实ViewModel的职责就是将自己的数据绑定到View显示，同时数据变化需要通知View，View上客户的操作及时响应，至于数据怎么解析，从哪里获取，View的响应都应该方法后一层，可以是Controller，可以是Servicer,可以是Presenter。也就是业务逻辑尽量推到后一层。 试想一下，系统里的Model有很多，有数据库对应的数据库模型，有业务于对应的领域模型，有用于数据交互的DTO也是模型，那么对应的View有一个ViewModel也不觉得奇怪。 ","date":"2020-04-02","objectID":"/2020/04/prism18-source/:1:0","tags":["Prism源码解析","ViewModel注入"],"title":"Prism源码解析 ViewModel注入","uri":"/2020/04/prism18-source/"},{"categories":"Prism","content":"0 ViewModel定位\rMVVM的第一步就是要解决ViewModel的依赖注入问题，框架如何不着痕迹的将View对应的VIewModel注入到依赖属性DataContext。 还记得PrismApplicationBase类吗，就是继承Application，将整个Prism框架组件注入到Unity的那个类， 看到第一步是啥?ConfigureViewModelLocator,配置ViewModelLocator,急人之所急，Prism框架的第一步配置ViewModelLocator， 好吧，第一步就是设置ViewModelFactory，这个工厂就是通过View的类型和实例从Unity容器中获取ViewModel实例。 噢！这个View参数还没用上。 再来看看这个包含ViewModelFactory的ViewModelLocationProvider。 从这个名字我们可以大胆猜测，这个类应该是负责真正解析ViewModel的位置的，看到这个类的方法，有ViewModelFactory，有Register，有GetViewModelByXXX。 这个类中一个委托字段_defaultViewTypeToViewModelTypeResolver，从这个字段我们可以看出是默认VIewModel解析方式，可以看出就是把View完整类型名中的Views替换成ViewModels，然后返回Type，从这里面我们知道View的名字一定要含有Views，ViewModel一定要含有ViewModels。 好吧，知道了哪里解析的再来看看哪里调用的。 prism:ViewModelLocator.AutoWireViewModel=“True”，看到了，将ViewModelLocator的依赖属性AutoWireViewModel至为True，可以进一步推测ViewModelLocator里面肯定调用了ViewModelLocationProvider的相关方法以获得ViewModel的类型或实例。 依赖属性改变触发了AutoWireViewModelChanged方法，然后调用ViewModelLocationProvider.AutoWireViewModelChanged 先去查看两个字典，一个字典key是View是实例，另一个字典key是View的Type，都没有调用，然后调用ViewModelLocationProvider._defaultViewTypeToViewModelTypeResolver，也就是默认解析，在这边解析获得VIewModel的类型，然后通过默认工厂获得ViewModel实例。并绑定到VIew的DataContext。 至此，知道了整个默认VIewModel解析的全部过程，梳理一下 在程序开始向ViewModelLocationProvider中设置ViewModel类型工厂，也就是Unity。 ViewModelLocationProvider就是ViewModel获取的地方有两个字典都应该是存放viewmodel，有一个默认解析是通过View的type解析出ViewModel的type。 在Xaml中通过ViewModelLocator的依赖属性AutoWireViewModel调用ViewModelLocationProvider的AutoWireViewModelChanged来实现绑定。 ","date":"2020-04-02","objectID":"/2020/04/prism18-source/:2:0","tags":["Prism源码解析","ViewModel注入"],"title":"Prism源码解析 ViewModel注入","uri":"/2020/04/prism18-source/"},{"categories":"Prism","content":"1 自定义ViewModel定位\r通过0的介绍，想一下怎么自定义实现VIewModel定位，有几种方法， 提前向ViewModelLocationProvider的字典中添加ViewModel的类型 改变_defaultViewTypeToViewModelTypeResolver解析方式 修改工厂。这个不能从根本上改变。 这个例子用的是第二种。 在程序的开始重写ConfigureViewModelLocator方法，除了向ViewModelLocationProvider中添加ViewModelFactory外，还修改了_defaultViewTypeToViewModelTypeResolver解析方式。直接就通过View的type后面家长ViewModel，简单粗暴。 ","date":"2020-04-02","objectID":"/2020/04/prism18-source/:3:0","tags":["Prism源码解析","ViewModel注入"],"title":"Prism源码解析 ViewModel注入","uri":"/2020/04/prism18-source/"},{"categories":"Prism","content":"2 自定义ViewModel解析\r这种方法就是上面提到的1方法 提前向ViewModelLocationProvider的字典中添加ViewModel的类型 这张方法显然有很大的弊端，当程序中有很多View时怎么能手动添加呢，只能适用与特殊的View和ViewModel的解析，如Shell的VIewModel的解析。 这种解析方法也不用在意View和ViewModel的名字了。 ","date":"2020-04-02","objectID":"/2020/04/prism18-source/:4:0","tags":["Prism源码解析","ViewModel注入"],"title":"Prism源码解析 ViewModel注入","uri":"/2020/04/prism18-source/"},{"categories":"Prism","content":"总结\r从ViewModel的解析中，我们看到一种设计模式，View依赖ViewModelLocator，ViewModelLocator依赖ViewModelLocationProvider，ViewModelLocationProvider负责具体解析出对应的实例，相当于ViewModelRegistry，其中当然以有对工厂的依赖。 ","date":"2020-04-02","objectID":"/2020/04/prism18-source/:5:0","tags":["Prism源码解析","ViewModel注入"],"title":"Prism源码解析 ViewModel注入","uri":"/2020/04/prism18-source/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 ","date":"2020-04-01","objectID":"/2020/04/prism17-source/:0:0","tags":["Prism源码解析","Modules加载"],"title":"Prism源码解析 Modules加载","uri":"/2020/04/prism17-source/"},{"categories":"Prism","content":"介绍\r在软件开发过程中，总想组件式的开发方式，各个组件之间最好互不影响，独立测试。Prism的Modules很好的满足了这一点。 这个架构图很好了讲解了Prism的Modules的概念 Prism支持通过配置文件，文件夹，手动载入Module的方式，并且对Module的载入进行验证，包括重复和循环依赖验证 Prism加载模块的顺序 直接看源码吧 ","date":"2020-04-01","objectID":"/2020/04/prism17-source/:1:0","tags":["Prism源码解析","Modules加载"],"title":"Prism源码解析 Modules加载","uri":"/2020/04/prism17-source/"},{"categories":"Prism","content":"0、Modules加载\rModules的加载主要依靠ModuleCatalog来发现模块， 通过ModuleManager来加载模块并对模块进行验证以确保模块的加载顺序， ModuleInitializer负责模块的初始化，包括加载模块所必须的类和显示UI Elements等等。 在Prism.PrismApplicationBase 的Initialize方法中调用 创建目录 RegisterRequiredTypes方法中向容器注入ModuleManager，ModuleInitializer， 最后调用了InitializeModules方法，并在其中调用了ModuleManager的Run方法 看着两个名字就明白了，第一个是发现模块并验证模块，第二个是加载模块并初始化。 看一下ModuleCatalogBase的Initialize方法，果然 而验证就更加有意思了 重复性验证 通过模块名字ModuleNames来判断是否被加载过，，如果存在就抛出异常 加载顺序验证 同时看一下ModuleCatalogBase 每当items发生变化都会进行验证 发现验证完了来看一下ModuleManage的LoadModulesWhenAvailable方法 看到最终使用了ModuleInitializer来初始化Module。其过程通过Linq实现延迟加载技术。 在这个方法中发现Module必须实现IModle接口。并在这儿调用了RegisterTypes和OnInitialized方法。 模块的加载看完了，下面来看例子吧 ","date":"2020-04-01","objectID":"/2020/04/prism17-source/:2:0","tags":["Prism源码解析","Modules加载"],"title":"Prism源码解析 Modules加载","uri":"/2020/04/prism17-source/"},{"categories":"Prism","content":"1、通过AppSetting加载\r先看一下配置文件 在初始化时 看到重写了CreateModuleCatalog，前面已经介绍过ModuleCatalog就是控制Module发现和验证的。 可以看到section的名称必须是modules。 先解析Module依赖逻辑，最后调用AddModule方法 再ModuleAModule中载入相关的UIElement。 ","date":"2020-04-01","objectID":"/2020/04/prism17-source/:3:0","tags":["Prism源码解析","Modules加载"],"title":"Prism源码解析 Modules加载","uri":"/2020/04/prism17-source/"},{"categories":"Prism","content":"2、通过代码加载\r通过代码加载就更简单了，直接在ConfigureModuleCatalog方法中调用默认的ModuleCatalog加载相关的Module就可以了。 在ModuleAModule中代码不变 这其中的逻辑在0节中已经解释清楚了，就不在叙述。 ","date":"2020-04-01","objectID":"/2020/04/prism17-source/:4:0","tags":["Prism源码解析","Modules加载"],"title":"Prism源码解析 Modules加载","uri":"/2020/04/prism17-source/"},{"categories":"Prism","content":"3、通过目录加载\r通过目录加载，如果不看源码怎么设计，需要创建一个ModuleCatalog，在创建的时候将目录地址传入。在内部InnerLoad方法中找到对应目录，然后通过遍历程序集找到实现IModule接口的类，加载这个类就可以了。 看了下源码也正是这么做的 看了源码发现官方考虑了更多的问题，比如创建了AppDoamin来加载程序集以保证隔离和数据安全。甚至还为其创建了一个InnerModuleInfoLoader类来反射程序集 这样的指责分配非常好，我们甚至可以写一个通过网络来加载Module的ModuleCatalog类。 ","date":"2020-04-01","objectID":"/2020/04/prism17-source/:5:0","tags":["Prism源码解析","Modules加载"],"title":"Prism源码解析 Modules加载","uri":"/2020/04/prism17-source/"},{"categories":"Prism","content":"4、通过手动方式加载\r先在ConfigureModuleCatalog中将所有的Module加载进来，并将InitializationMode的方式设置为按需， 那么就可以在需要的时候利用LoadModule方法载入之前加载的Module 值得注意的是并没有提供卸载Module的接口。 ","date":"2020-04-01","objectID":"/2020/04/prism17-source/:6:0","tags":["Prism源码解析","Modules加载"],"title":"Prism源码解析 Modules加载","uri":"/2020/04/prism17-source/"},{"categories":"Prism","content":"总结\r这一篇介绍了下Modules加载的原理，其实就是 ModuleCatalog负责发现Module。 通过ModuleManager来加载模块并对模块进行验证以确保模块的加载顺序， ModuleInitializer负责模块的初始化，包括加载模块所必须的类和显示UI Elements等等。 下一篇开始将介绍MVVM的实现。 ","date":"2020-04-01","objectID":"/2020/04/prism17-source/:7:0","tags":["Prism源码解析","Modules加载"],"title":"Prism源码解析 Modules加载","uri":"/2020/04/prism17-source/"},{"categories":"Prism","content":"添加\rModuleManager负责对ModuleCatalog和ModuleInitializer的引用。 ModuleCatalog维护一个ModuleCatalogItemCollection和ModuleInfo的集合 ","date":"2020-04-01","objectID":"/2020/04/prism17-source/:8:0","tags":["Prism源码解析","Modules加载"],"title":"Prism源码解析 Modules加载","uri":"/2020/04/prism17-source/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 ","date":"2020-03-30","objectID":"/2020/03/prism16-source/:0:0","tags":["Prism源码解析","View的加载和控制"],"title":"Prism源码解析 View的加载和控制","uri":"/2020/03/prism16-source/"},{"categories":"Prism","content":"介绍\r上一篇讲了入了门，这一篇，让我们不多BB直接开始 ","date":"2020-03-30","objectID":"/2020/03/prism16-source/:1:0","tags":["Prism源码解析","View的加载和控制"],"title":"Prism源码解析 View的加载和控制","uri":"/2020/03/prism16-source/"},{"categories":"Prism","content":"4、ViewDiscovery\r在创建好Region后需要将View添加到Region中。先补充几个概念 在上一篇将了如何创建Region，现在让我们看看Region类是什么 private ViewsCollection views; private ViewsCollection activeViews; 这是一个View集合，集合改变会触发CollectionChanged事件 其完全依赖ObservableCollection对象 this.Behaviors = (IRegionBehaviorCollection) new RegionBehaviorCollection((IRegion) this); 这是一个行为集合，每当添加进行为的时候，会主动调用Attach（） PropertyChanged事件，每当Context,Name, RegionManager，会触发该事件 下面来看一个好玩的行为AutoPopulateRegionBehavior 可以看到这个行为对RegionViewRegistry有依赖，这个是通过构造注入的方式注入的。 该RegionViewRegistry保存着所有的View，是名副其实的Registry. 该Registry有一个事件ContentRegistered, 每当调用这个方法的时候就会触发这个事件。 不能跑偏了，回到AutoPopulateRegionBehavior 在行为Attach的时候，已经对RegionViewRegistry进行了订阅。 看看this.Region.Add() 这个ItemMetadataCollection的改变会影响Views和ActiveViews 首先它是一个ObservableCollection， 其次ViewCollection就是依赖ItemMetadataCollection创建的，所以改变自然会影响ViewCollection 那这个VIewCollection是怎么来影响界面的呢，这就要看看另一个行为RegionActiveAwareBehavior 至此可能会一头雾水，这讲了什么啊，一会是Region，一会是Behavior，到底想说什么啊？其实就是讲了View是如何被自动注入到对应的Region。 下面让我们跟着Samples中的ViewDiscovery并结合刚刚讲的源码梳理一下。 在程序开始的时候向行为工厂中注入了相应的行为 在创建Region的时候RegionAdapter向其添加了所有的行为 现在只需调用RegionManager.RegisterViewWithRegion方法就可以自动向Region中添加VIew并显现出来 可以看到就是调用RegionViewRegistry中Register’VIew’With’Region方法 下面就等着AutoPopulateRegionBehavior和RegionActiveAwareBehavior按照上面的方式工作就可以了。 可以看出为什么Region有这么强大的功能就是因为Prism给Region提供了很多的行为，行为作为WPF的一个特性，其作用是非常强大的。后面的View生命周期管理也是通过行为来完成的 ","date":"2020-03-30","objectID":"/2020/03/prism16-source/:2:0","tags":["Prism源码解析","View的加载和控制"],"title":"Prism源码解析 View的加载和控制","uri":"/2020/03/prism16-source/"},{"categories":"Prism","content":"5、ViewInjection\rView手动加载到Region，通过一个点击事件，通过RegionManager的Regions属性添加View 这个就更简单了，因为没有走RegionVIewRegistry，而是直接通过Region添加View，会直接添加到对应的RegionView上,然后通过RegionActiveAwareBehavior显示，上面有就不再详尽叙述了。 ","date":"2020-03-30","objectID":"/2020/03/prism16-source/:3:0","tags":["Prism源码解析","View的加载和控制"],"title":"Prism源码解析 View的加载和控制","uri":"/2020/03/prism16-source/"},{"categories":"Prism","content":"6、ViewActivationDeactivation\r激活或停用View 这个也不多BB直接看怎么调用 首先先用手动的方式向Region中添加两个View 就是两个方法Activate和Deactivate 这实现也太巧妙了吧，通过ItemMetadata直接影响了View和ActiveView，然后通过RegionActiveAwareBehavior行为实现。真帅 就不再叙述了。 ","date":"2020-03-30","objectID":"/2020/03/prism16-source/:4:0","tags":["Prism源码解析","View的加载和控制"],"title":"Prism源码解析 View的加载和控制","uri":"/2020/03/prism16-source/"},{"categories":"Prism","content":"总结\r本章主要讲了View的加载方式，可以手动加载，可以自动加载，并可以控制View的Activate和DeActivate。其主要实现都是依靠行为，也从侧面反映出行为的强大，行为能做的事情实在太多了。下一章会对Modules的实现进行介绍。 ","date":"2020-03-30","objectID":"/2020/03/prism16-source/:5:0","tags":["Prism源码解析","View的加载和控制"],"title":"Prism源码解析 View的加载和控制","uri":"/2020/03/prism16-source/"},{"categories":"Prism","content":"补充\r在创建Shell的时候，已经调用RegionManager.SetRegionName方法，然后触发RegionManager.OnSetRegionNameCallback方法 ","date":"2020-03-30","objectID":"/2020/03/prism16-source/:6:0","tags":["Prism源码解析","View的加载和控制"],"title":"Prism源码解析 View的加载和控制","uri":"/2020/03/prism16-source/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 ","date":"2020-03-29","objectID":"/2020/03/prism15-source/:0:0","tags":["Prism源码解析","Bootstrapper和Region的创建"],"title":"Prism源码解析 Bootstrapper和Region的创建","uri":"/2020/03/prism15-source/"},{"categories":"Prism","content":"介绍\r之前也研究过Prism框架但是一直没有深入理解，现在项目上想把一个Winform的桌面应用程序改造成WPF程序，同时我希望程序是可测试可维护架构良好的，Prism的这些设计理念正好符合我的需求，其主要用于WPF和Xamarin，用于构建松耦合，可维护，可测试的应用程序框架，在我看到源码后也深受启发，欢迎大家一起交流探讨。 Prism的整体架构 ","date":"2020-03-29","objectID":"/2020/03/prism15-source/:1:0","tags":["Prism源码解析","Bootstrapper和Region的创建"],"title":"Prism源码解析 Bootstrapper和Region的创建","uri":"/2020/03/prism15-source/"},{"categories":"Prism","content":"开始\r我将从官方的Samples的顺序，看介绍中的每个功能是怎么实现的。 Github地址 ","date":"2020-03-29","objectID":"/2020/03/prism15-source/:2:0","tags":["Prism源码解析","Bootstrapper和Region的创建"],"title":"Prism源码解析 Bootstrapper和Region的创建","uri":"/2020/03/prism15-source/"},{"categories":"Prism","content":"0、PrismApplicationBase\r首先介绍一下这个类，这是Startup，这个类中构建了所有的Prism功能和整体的框架。这个类中大多数的方法都是虚方法，可以重载加入自定义的一些功能，Prism也希望我们如此进行设计。 在整个Prism中，UnityContainer无处不再，它就是一个大的容器，保存着所有类，在需要的时候Resolver出来。 有两个字段，ContainerExtension就UnityContainer,当然也可以自定义其他的容器，在文章中都默认为UnityContainer容器，关于容器也给一个官方说明 ModuleCatalog是定义了加载Module的方式，模块是Prism的一大优势，给一张官方说明，意图胜千言 所有的一切都是从一个类开始PrismApplicationBase，在这个类中加载了Prism的所有功能。 看一下最重要的一个方法，正是在这个方法中完成了大部分功能，其主要工作就是将基础架构模块，RequireTypes，RegionAdapterMappings,RegionBehaviors,注入到相应的容器中。 下面几个方法感受一下 在PrismApplicationBase的子类中看一下 正如我前面所说，重写某个方法，先调用Base.Method,然后再加入自己功能 对于开发者来说必须重写的就两个方法 这个Shell就是主窗体，窗体的构成Prism的窗体都是由一个个Region构成，每个Region中都包含若干个View 创建主窗体和RegisterTypes方法，在第二个方法里可以加入我们所必须的一些基础构建，ContainerRegistry其实就是注册的Unity容器 下面让我们愉快的看例子吧。例子都在Prism-Samples-Wpf-master中一共29个，https://github.com/PrismLibrary/Prism-Samples-Wpf ","date":"2020-03-29","objectID":"/2020/03/prism15-source/:3:0","tags":["Prism源码解析","Bootstrapper和Region的创建"],"title":"Prism源码解析 Bootstrapper和Region的创建","uri":"/2020/03/prism15-source/"},{"categories":"Prism","content":"1、BootstrapperShell\r看着就是创建了一个Bootstraper然后Run了一下，通过容器创建了主窗体，Show了一下。 看一下如何实现的，其实文章都是在Bootstrapper中 看到这两个类是不是有一种恍然大悟的感觉，原来Bootstrapper是啥？就是将PrismApplicationBase中的方法全部从Application中抽出来，在这重新实现了一下，难道这就是单一职责原则？ 来看一下Run，这些方法太熟悉了吧。 日志怎么用，当然是创建然后记录了，所有的信息都放到资源里，创建的方式有很多种，选择最简单的一种new， BootStrapper的主要职责 ","date":"2020-03-29","objectID":"/2020/03/prism15-source/:4:0","tags":["Prism源码解析","Bootstrapper和Region的创建"],"title":"Prism源码解析 Bootstrapper和Region的创建","uri":"/2020/03/prism15-source/"},{"categories":"Prism","content":"2、Regions\r这个就是简单的创建一个Region 一目了然啊，就是在ContentControl中用RegionManager的依赖属性创建的一个Region。 用经典的三个问题来看看RegionManager，你是谁，你从哪里来，要到哪里去。 哦！小伙子你很张狂啊，很强大。看一眼把关了就可以了。 看一眼知道了有一个RegionName依赖属性，当这个属性变化的时候调用 IsInDesignMode就是判断是否在VS的设计模式，调用 哦，还是用了延迟加载，还是用容器创建的，Prism里几乎所有的类都是通过容器创建的 Behavior？WPF里面的行为就是服务啊，就是先把一个依赖属性存着，需要的时候盘它。去看看 很标准的服务。 使用了弱引用，很棒的设计，想想也是如此， 通过Load事件实现延迟加载，嗯，很棒，在界面载入的时候创建Region。 载入触发一次就好。很喜欢这个单词WireUp，缠绕，UnWire， 通过名字创建，到RegionAdapterMapping中找到RegionAdapter然后通过Adapter的Initialize创建。 RegionAdapterMapping就是RegionAdapter的集合 先创建Region，然后添加行为 都有哪些行为呢？ 创建Region工作完成啦。 看看官方文档关于Region ","date":"2020-03-29","objectID":"/2020/03/prism15-source/:5:0","tags":["Prism源码解析","Bootstrapper和Region的创建"],"title":"Prism源码解析 Bootstrapper和Region的创建","uri":"/2020/03/prism15-source/"},{"categories":"Prism","content":"3、CustomRegions\r想要自定义一个Regin，那肯定要创建一个RegionAdapter，自定义一个StackPanelRegionAdapter 通过刚刚的源码解读这些理解起来好像都不困难了。 ","date":"2020-03-29","objectID":"/2020/03/prism15-source/:6:0","tags":["Prism源码解析","Bootstrapper和Region的创建"],"title":"Prism源码解析 Bootstrapper和Region的创建","uri":"/2020/03/prism15-source/"},{"categories":"Prism","content":"总结\r通过源码探索了下Bootstapper，Region的创建及如何自定义一个RegionAdapter，轻轻揭开了Prism一点点面纱。后面还有很多的功能和想法，欢迎大家和我一起探讨学习。 ","date":"2020-03-29","objectID":"/2020/03/prism15-source/:7:0","tags":["Prism源码解析","Bootstrapper和Region的创建"],"title":"Prism源码解析 Bootstrapper和Region的创建","uri":"/2020/03/prism15-source/"},{"categories":"NetCLRVia","content":"基元线程同步构造\r构建可伸缩的，响应灵敏的应用程序，关键在于不要阻塞线程， 多个线程同时访问共享数据，获取并释放一个线程同步锁。锁会损害性能，获取和释放锁是需要时间的。只允许一个线程访问共享资源，可以使用值类型，多个线程对共享数据进行只读访问是没有任何问题的。 ","date":"2020-03-01","objectID":"/2020/03/dotnetbase8-netclrvia/:1:0","tags":["NetCLRVia","同步与竞争"],"title":"NetCLRVia 同步与竞争","uri":"/2020/03/dotnetbase8-netclrvia/"},{"categories":"NetCLRVia","content":"类库和线程安全\rFCL保证所有静态方法都是线程安全的。多个线程调用同一个静态方法，并不是说方法内部会获取一个同步锁，也可能内部数据是值类型。 FCL没有保证实例方法是线程安全的。 所有的静态方法都是线程安全的，所有实例方法都是非线程安全。 ","date":"2020-03-01","objectID":"/2020/03/dotnetbase8-netclrvia/:1:1","tags":["NetCLRVia","同步与竞争"],"title":"NetCLRVia 同步与竞争","uri":"/2020/03/dotnetbase8-netclrvia/"},{"categories":"NetCLRVia","content":"基元用户模式和内核模式构造\r基元：primitive, 基元用户模式的速度要显著高于基元内核模式，因为其使用特殊的CPU指令来协调线程，缺点是操作系统用还不会察觉线程在基元用户模式的构造上阻塞了，也就永远不会创建新线程来替换阻塞线程。 基元用户模式中操作系统内核才能停止一个线程的运行，用户模式中线程可能被系统抢占(preempted)，但会以最快的速度被调用，如果暂时取不到的线程会一直处于自旋状态，这可能浪费大量CPU时间。 从上面可以看出基元用户模式跟CPU有关，是CPU提供的 基元内核模式是由操作系统提供的。在应用程序的线程中调用操作系统内核实现函数。用户模式切换为内核模式会造成巨大的损失。但内核模式的优点是：线程获取其他线程拥有的资源时，Windows会阻塞线程避免它浪费CPU时间。当资源可用时，Windows恢复线程，允许它访问资源。 在构造上等待的线程，如果是用户模式，线程将一直在CPU上运行，称为\"活锁“。如果是内核模式，线程将一直阻塞，称为\"死锁\"(deadlock)，但比较而言，死锁总是由于活锁，因为活锁既浪费CPU也浪费内存。 所以最好的构造方式应该是混合构造(hybrid construct)，在大多数时间运行的很快，偶尔运行的比较慢。 CLR中的线程同步构造实际是”Win32线程同步构造“的包装器，CLR线程就是Windows线程，Windows调度线程和控制线程同步。 ","date":"2020-03-01","objectID":"/2020/03/dotnetbase8-netclrvia/:1:2","tags":["NetCLRVia","同步与竞争"],"title":"NetCLRVia 同步与竞争","uri":"/2020/03/dotnetbase8-netclrvia/"},{"categories":"NetCLRVia","content":"用户模式构造\rCLR可以保证对Boolean,Char,(S)Byte,(U)Int16,(U)Int32,(U)IntPtr,Single以及引用类型的读写是原子性的，也就是一次性读写。 internal static class SomeType { public static Int32 x=0; } //线程执行这一行代码， SomeType.x=0x01234567; x变量会一次性从0x000000变成0x12345，另一个线程不可能看到中间状态的值，也不可能有别的线程访问。如果该类型是Int64，别的线程就有可能获得中间状态的值，其实是分为两个Move指令才能读完。 两种基元用户模式线程同步构造： 易变构造(volatile construct):在特定时间，在一个简单数据类型的变量上执行原子读或写操作。 互锁构造(interlocked construct)：和上面相同 易变和互锁构造都要求传递包含简单数据类型的内存地址。 易变构造(Volatile Construct)\rC#编译器将C#代码转换成IL，JIT将IL转换成CPU指令，C#编译器，JIT编译器，CPU都有可能优化代码。 private static void OptimizedAway() { // An expression of constants is computed at compile time then put into a local variable that is never used Int32 value = 1 * 100 + 0 / 1 % 2; if (value \u003e= 0) Console.WriteLine(\"Jeff\"); for (Int32 x = 0; x \u003c 1000; x++) ; // A loop that does nothing } 下面代码编译后会优化掉很多东西。 internal static class StrangeBehavior { // Compile with \"/platform:x86 /o\" and run it NOT under the debugger (Ctrl+F5) private static Boolean s_stopWorker = false; public static void Go() { Console.WriteLine(\"Main: letting worker run for 5 seconds\"); Thread t = new Thread(Worker); t.Start(); Thread.Sleep(5000); s_stopWorker = true; Console.WriteLine(\"Main: waiting for worker to stop\"); t.Join(); Environment.Exit(0); } private static void Worker(Object o) { Int32 x = 0; while (!s_stopWorker) x++; Console.WriteLine(\"Worker: stopped when x={0}\", x); } } Main中创建一个新线程来执行Worker方法，在/platform:x86和/optimize+开关编译(x86 JIT编译器比x64编译器更程数，所以它执行优化的时候更大胆)，会对代码进行优化，当编译器发现worker中s_stopWorker永远不发生变化，编译器会生成代码检查s_stopWorker。如果为false，就进入无线循环，一直递增x，优化后，s_stopWorker检查只在循环前发生一次，不会每次迭代都检查。 针对编译器和CPU的优化，FCL提供了两个静态方法，禁止一些优化，System.Threading.Volatile类提供了两个静态方法 internal static class ThreadsSharingData { internal sealed class ThreadsSharingDataV1 { private Int32 m_flag = 0; private Int32 m_value = 0; // 这个方法由一个线程执行 public void Thread1() { // Note: 以下两行代码可以按相反的顺序执行 m_value = 5; m_flag = 1; } // 这个方法由另一个线程执行 public void Thread2() { // Note: m_value 可能先于 m_flag 读取 if (m_flag == 1) Console.WriteLine(m_value); } } } 编译器和CPU解释优化代码的时候可能会反转Thread1()方法中的两行代码，在单线程顺序执行的时候，Thread1()，Thread2()优化并不会产生问题，但是多线程的时候，如果允许多线线程同时读写数据就会产生很多问题，针对Thread1方法必须要保证m_value和m_flag，同时执行写入，在写入的时候，所有读取线程停止，写完再允许读，针对Thread2方法必须要保证先读取m_flag值在读取m_value值，在2个变量读取的时候禁止所有写入操作。 System.Threading.Volatile是如何解决这些问题的，静态方法，原子操作： public static class Volatile { public static void Write(ref Int32 location,Int32 value); public static Int32 Read(ref Int32 location); } Volatile.Write方法强迫location中的值在调用时写入，按照编码顺序，之前加载和存储操作必须在调用Volatile.Write之前发生。 Volatile.Read方法强迫location中的值在调用时读取，按照编码顺序，之后加载和存储操作必须在调用Volatile.Read之后发生。 总结：当线程通过共享内存相互通信时，调用Volatile.Write来写入最后一个值，调用Volatile.Read读取第一个值。 internal sealed class ThreadsSharingDataV2 { private Int32 m_flag = 0; private Int32 m_value = 0; // 这个方法由一个线程执行 public void Thread1() { // Note: 在将1写入m_flag之前，必须先将5写入m_value. m_value = 5; Volatile.Write(ref m_flag, 1); } // 这个方法由另一个线程执行 public void Thread2() { // Note: m_value必然在读取 m_flag 之后读取 if (Volatile.Read(ref m_flag) == 1) Console.WriteLine(m_value); } } C#对Volatile的支持，为了简化编程，c#提供了volatile关键字，可应用于以下类型，Boolean,(S)Byte,(U)Int16，(U)Int32,(U)IntPtr,Single,Char和引用类型。Volatile关键字高速C#和JIT编译器不讲字段缓存到CPU寄存器，确保字段所有读写操作都是在RAM中执行。 internal sealed class ThreadsSharingDataV3 { //非常重要 private volatile Int32 m_flag = 0; private Int32 m_value = 0; // This method is executed by one thread public void Thread1() { // Note: 5 must be written to m_value before 1 is written to m_flag m_value = 5; m_flag = 1; } // This method is executed by another thread public void Thread2() { // Note: m_value must be read after m_flag is read if (m_flag == 1) Console.WriteLine(m_value); } } 这种优化的方式也有一些缺陷。 m_amount = m_amout + m_amout;//假定m_amout是类定义的一个volatile字段 如果优化，m_amout左移1位就可以了，如果不允许这个优化，会对性能造成很大影响，同时一旦使用了m_amount就不允许其值传递自己的引用。 互锁构造\rVolatile的方法都是原子性操作。而System.Threading.Interlocked类提供的方法也是执行原子操作，同时建立了完整的内存栅栏(memory fence),Volatile有的都有。 简单来说就是：调用某个Interlocked方法之前的任何变量写入都在这个Interlocked方法调用前执行，调用之后的任何变量读取都在这个调用之后读取。静态方法，原子操作 public static class Interlocked { //ret","date":"2020-03-01","objectID":"/2020/03/dotnetbase8-netclrvia/:1:3","tags":["NetCLRVia","同步与竞争"],"title":"NetCLRVia 同步与竞争","uri":"/2020/03/dotnetbase8-netclrvia/"},{"categories":"NetCLRVia","content":"内核模式构造\r内核模式构造比用户模式构造慢的多，有两个原因：1、需要Windows操作系统配合，2、内核对象上调用每个方法都会使线程从托管代码转换成本机用户模式代码，再转换成本机内核模式代码。 优点: 资源竞争的时候阻塞掉新城，不会浪费CPU资源。 实现本机(native)和托管(managed)线程之间的同步。 可同步在同一台机器中不同进程的线程 可应用安全性设置，防止未授权的账户访问 线程阻塞，直到所有内核模式可用，或集合中内核模式可用 阻塞的线程可以被时间值，在规定时间内获取不到资源就解除阻塞执行其他操作。 事件和信号量（Semaphores）是基元内核模式同步构造，其他都是在这两个构造上派生的 System.Threading.WaitHandle抽象基类，唯一的作用就是包装一个Windows内核对象句柄 WaitHandle EventWaitEvent AutoResetEvent ManualResetEvent Semaphore Mutex WaitHandle内部有一个SafeWaitHandle字段，容纳一个Win32内核对象句柄。内核模式调用每个方法都代码一个完整的内存栅栏。 WaitOne：让调用线程等待底层内核对象接收信号，内部调用Win32 WaitForSignleObjectEx函数，如果对象收到信号返回true，超时返回false。内部元素不能超过64 WaitAll:让调用线程等待WaitHandle[]中指定所有内核对象收到信息，如果所有对象收到信号，返回true，超时返回false，内部调用Win32 WaitForMultipleObjectsEx函数，bWaitAll参数传递TRUE，内部元素不能超过64 WaitAny:让调用线程等待WaitHandle[]指定任何内核对象收到信号。返回Int32内核对象对应的数组索引，如果一直没有收到，返回WaitHandle.WaitTimeout,内部调用Win32 WaitForMultipleObjectsEx Dispose:关闭底层内核对象句柄，内部调用Win32 CloseHandle，只有在确定没有别的线程使用内核线程对象才能显式调用 AutoResetEvent、ManualResetEvent、Semaphore和Mutex类都派生WaitHandle 内部调用Win32 CreateEvent、CreateSemaphore或CreateMutex函数，函数句柄保存在私有的SafeWaitHandle字段中。 EventWaitHandle、Semaphore和Mutex都提供静态OpenExisting方法，内部调用win32 OpenEvent、OpenSemaphire或OpenMutex函数， 内核模式常用的方法是创建任何时刻只允许它运行的应用程序。 using System; using System.Threading; public static class Program { public static void Main() { Boolean createNew; //尝试创建一个具有指定名称的内核对象 using(new Semaphore(0,1,\"SomeUniqueStringIdentifyingMyApp\",out createdNew)) { if(createdNew) { //这个线程创建了内核对象，所以肯定没有这个应用程序的其他实例正在运行 } else { 有其他实例在运行 } } } } 将Semaphore替换成EventWaitHandle或Mutex一样的。两个线程同时创建Semaphore,windows内核确保只有一个能成功创建 Event\rEvent内部维护内核Boolean变量，false：事件在等待线程阻塞，true解除阻塞。 false，阻塞 true,不阻塞。 有两种事件，自动重置事件（AutoResetEvent）和手动重置事件(ManualResetEvent)。 AutoResetEvent:true的时候，唤起一个阻塞线程，然后自动为false，其余线程阻塞。 ManualResetEvent:true的时候，解除正在等待的所有线程阻塞，内核不会重置为false，必须手动进行。 public class EventWaitHandle:WaitHandle { public Boolean Set();//将内核Boolean设置为true，总是返回true public Boolean Reset();//将内核Boolean设为false,总是返回true } public sealed class AutoResetEvent:EventWaitHandle { public AutoResetEvent(Boolean initialState); } public sealed class ManualReserEvent:EventWaitHandle { public ManualReserEvent(Boolean initialState); } 事件锁 private sealed class SimpleWaitLock : IDisposable { private readonly AutoResetEvent m_available; public SimpleWaitLock() { m_available = new AutoResetEvent(true); // Initially free } public void Enter() { // Block in kernel until resource available m_available.WaitOne(); } public void Leave() { // Let another thread access the resource m_available.Set(); } public void Dispose() { m_available.Dispose(); } } private sealed class SimpleWaitLock : IDisposable { private readonly AutoResetEvent m_available; public SimpleWaitLock() { m_available = new AutoResetEvent(true); // 最开始可以自由使用 } public void Enter() { // 在内核中阻塞，直到资源可用，直到一个内核对象变为true，获取对象后自动变成false m_available.WaitOne(); } public void Leave() { // 让另一个线程访问资源,置true m_available.Set(); } public void Dispose() { m_available.Dispose(); } } 性能比较 //调用go internal static class LockComparison { public static void Go() { Int32 x = 0; const Int32 iterations = 10000000; // 10 million // How long does it take to increment x 10 million times? Stopwatch sw = Stopwatch.StartNew(); for (Int32 i = 0; i \u003c iterations; i++) { x++; } Console.WriteLine(\"Incrementing x: {0:N0}\", sw.ElapsedMilliseconds); // How long does it take to increment x 10 million times // adding the overhead of calling a method that does nothing? sw.Restart(); for (Int32 i = 0; i \u003c iterations; i++) { M(); x++; M(); } Console.WriteLine(\"Incrementing x in M: {0:N0}\", sw.ElapsedMilliseconds); // How long does it take to increment x 10 million times // adding the overhead of calling an uncontended SimpleSpinLock? SimpleSpinLock ssl = new SimpleSpinLock(); sw.Restart(); for (Int32 i = 0; i \u003c iterations; i++) { ssl.Enter(); x++; ssl.Leave(); } Console.WriteLine(\"Incrementing x in SimpleSpinLock: {0:N0}\", sw.ElapsedMilliseconds); // How long does it take to increment x 10 million times // adding the overhead of c","date":"2020-03-01","objectID":"/2020/03/dotnetbase8-netclrvia/:1:4","tags":["NetCLRVia","同步与竞争"],"title":"NetCLRVia 同步与竞争","uri":"/2020/03/dotnetbase8-netclrvia/"},{"categories":"NetCLRVia","content":"混合线程同步构造\r","date":"2020-03-01","objectID":"/2020/03/dotnetbase8-netclrvia/:2:0","tags":["NetCLRVia","同步与竞争"],"title":"NetCLRVia 同步与竞争","uri":"/2020/03/dotnetbase8-netclrvia/"},{"categories":"NetCLRVia","content":"一个简单混合锁\rpublic sealed class SimpleHybridLock : IDisposable { // The Int32 is used by the primitive user-mode constructs (Interlocked mehtods) private Int32 m_waiters = 0; // The AutoResetEvent is the primitive kernel-mode construct private readonly AutoResetEvent m_waiterLock = new AutoResetEvent(false); public void Enter() { // 多个线程获得锁 if (Interlocked.Increment(ref m_waiters) == 1) return; //无竞争直接返回 //多个线程获得锁发生竞争，阻塞线程， m_waiterLock.WaitOne(); // 性能影响较大 // WaitOnef返回一个线程获得锁。 } public void Leave() { // 无竞争的时候释放原子锁 if (Interlocked.Decrement(ref m_waiters) == 0) return; // 没有其他线程等待，直接返回 // 唤醒一个阻塞的线程 m_waiterLock.Set(); // 这里产生较大影响 } public void Dispose() { m_waiterLock.Dispose(); } } ","date":"2020-03-01","objectID":"/2020/03/dotnetbase8-netclrvia/:2:1","tags":["NetCLRVia","同步与竞争"],"title":"NetCLRVia 同步与竞争","uri":"/2020/03/dotnetbase8-netclrvia/"},{"categories":"NetCLRVia","content":"自旋、线程所有权和递归\r使用内核模式非常影响性能，所以就有了自旋锁，即使线程什么也不干，自旋一定时间也不使用内核模式。 public sealed class AnotherHybridLock : IDisposable { // The Int32 is used by the primitive user-mode constructs (Interlocked methods) private Int32 m_waiters = 0; // The AutoResetEvent is the primitive kernel-mode construct private AutoResetEvent m_waiterLock = new AutoResetEvent(false); // This field controls spinning in an effort to improve performance private Int32 m_spincount = 4000; // Arbitrarily chosen count // 字段指出哪个线程拥有锁，以及拥有了多少次，以支持递归锁 private Int32 m_owningThreadId = 0, m_recursion = 0; public void Enter() { // If the calling thread already owns this lock, increment the recursion count and return Int32 threadId = Thread.CurrentThread.ManagedThreadId; if (threadId == m_owningThreadId) { m_recursion++; return; } // SpinWait值类型 SpinWait spinwait = new SpinWait(); for (Int32 spinCount = 0; spinCount \u003c m_spincount; spinCount++) { // If the lock was free, this thread got it; set some state and return if (Interlocked.CompareExchange(ref m_waiters, 1, 0) == 0) goto GotLock; // 发生线程竞争后线程等待 spinwait.SpinOnce(); } // 自旋结束，锁还没获得，再试一次 if (Interlocked.Increment(ref m_waiters) \u003e 1) { // 如果仍在竞争进入内核模式 m_waiterLock.WaitOne(); // Wait for the lock; performance hit // When this thread wakes, it owns the lock; set some state and return } GotLock: // When a thread gets the lock, we record its ID and // indicate that the thread owns the lock once m_owningThreadId = threadId; m_recursion = 1; } public void Leave() { // 如果调用线程不拥有锁，抛出异常 Int32 threadId = Thread.CurrentThread.ManagedThreadId; if (threadId != m_owningThreadId) throw new SynchronizationLockException(\"Lock not owned by calling thread\"); // 递归锁减去次数 if (--m_recursion \u003e 0) return; m_owningThreadId = 0; // No thread owns the lock now // 没有其他线程在等待 if (Interlocked.Decrement(ref m_waiters) == 0) return; // 有其他线程等待，唤起一个 m_waiterLock.Set(); // Bad performance hit here } public void Dispose() { m_waiterLock.Dispose(); } } ","date":"2020-03-01","objectID":"/2020/03/dotnetbase8-netclrvia/:2:2","tags":["NetCLRVia","同步与竞争"],"title":"NetCLRVia 同步与竞争","uri":"/2020/03/dotnetbase8-netclrvia/"},{"categories":"NetCLRVia","content":"FCL中的混合构造\rFCL也提供了很多的混合构造锁，一起研究以下。 ManualResetEventSlim和SemaphoreSlim\rManualResetEventSlim和SemaphoreSlim类，这两个构造的工作方式和内核模式构造都是瓦全一样的。都在用户模式自旋，在第一次竞争使才创建内核模式，wait方法允许传递一个超时值和一个CancellationToken。 Monitor和同步块\r最常用的混合同步构造就是Monitor，它提供自旋、线程所有权和递归的互斥锁。 堆中每个对象都可以关联一个同步块的数据结构，该数据结构的字段：内核对象字段，拥有线程的ID字段，递归计数字段，等待线程计数字段。 Monitor是静态类，拥有的方法可以接受任何堆对象的引用，然后操作对象的同步块。 public static class Monitor { public static void Enter(Object obj); public static void Exit(Object obj); //尝试进入锁时超时值 public static Boolean TryEnter(Object obj,Int32 millisecondsTimeOut); public static void Enter(Object obj,ref Boolean lockTaken); public static void TryEnter(Object obj,Int32 millisecondsTimeout,ref Boolean lockTaken)； } 如果每个对象都关联一个同步块数据就非常浪费内存，所以CLR进行了改进:CLR初始化时在堆中分配一个同步块数组。在堆中创建对象的实例，都有两个额外的开销：类型对象指针(指向类型对象的内存地址)，同步块索引：同步块数组中的整数索引。 对象实例在构造时，同步块索引初始化为-1，调用Monitor.Enter时，CLR找到一个空白同步块，并设置对象实例的同步块，在调用Exit时，检查是否有其他线程等待对象实例的同步块，如果没有同步块就自由了，对象实例同步块被设为-1. 三个对象实例通过类型对象指针，指向类型T，说明他们都是同一个类型,可以看出每个对象的同步块索引都隐式为公共的。这会造成问题。先看一下正常调用的情况。 internal sealed class Transaction { private DateTime m_timeOfLastTrans; public void PerformTransaction() { Monitor.Enter(this); //以下代码拥有对数据的独占访问权 m_timeOfLastTrans=DateTime.Now; Monitor.Exit(this); } public DateTime LastTransaction { get{ Monitor.Enter(this); //以下线程拥有对数据的独占访问 DateTime temp=m_timeOfLastTrans; Monitor.Exit(this); return temp; } } } 有问题调用的情况 public static void SomeMethod() { var t=new Transaction(); Monitor.Enter(t);//获取锁 ThreadPool.QueueUserWorkItem(o=\u003eConsole.WriteLine(t.LastTransaction))；//如果在LastTransaction内部也是用Monitor.Enter(this)，线程会阻塞，因为在外部以及调用了Monitor.Enter(t)，获取了t的同步锁。 } 所以在使用Monitro的时候最好构造一个字段，也称私有锁。 internal sealed class Transaction { private readonlu Object m_lock=new Object(); private DateTIe m_timeOfLastTrans; public void PerformTransaction() { Monitor.Enter(m_lock); m_timeOfLastTrans=DateTime.Now; Monitor.Exit(m_lock); } public DateTime LastTransaction { get { Monitor.Enter(m_lock); DateTime temp=m_timeOfLastTrans; Monitor.Exit(m_lock); return temp } } } Monitor被设置为静态的还有一些其他的问题。所以尽量不要使用Monitor和lock ReadWriteLockSlim类\r读写锁： 一个线程写入，所有访问线程阻塞 读取时，所有写入线程阻塞 写入线程结束，要么解除一个写入线程，要么解除所有读取线程阻塞。 private sealed class Transactions : IDisposable { private readonly ReaderWriterLockSlim m_lock = new ReaderWriterLockSlim(LockRecursionPolicy.NoRecursion); private DateTime m_timeOfLastTrans; public void PerformTransaction() { m_lock.EnterWriteLock(); // This code has exclusive access to the data... m_timeOfLastTrans = DateTime.Now; m_lock.ExitWriteLock(); } public DateTime LastTransaction { get { m_lock.EnterReadLock(); // This code has shared access to the data... DateTime temp = m_timeOfLastTrans; m_lock.ExitReadLock(); return temp; } } public void Dispose() { m_lock.Dispose(); } } ReadWriteLockSlim构造器允许传递一个LockRecurionsPolicy标志， public enum LockRecursionPolicy {NoRecursion,SupportsRecursion} SupportsRecursion标志，允许传递线程所有权和递归。建议使用NoRecursion，因为SupportsRecursion代价很大，在内部使用了一个互斥的自旋锁来实现线程所有权和递归。 ReadWriteLockSlim运行权限升级，读取锁升级为写入锁。 存在的问题 即使不存在线程竞争，速度也非常慢。 线程所有权和递归行为是加强的取消不了。 OneManyLock类\rJeffreyRicher提供的读写锁， /// \u003csummary\u003e /// Implements a ResourceLock by way of a high-speed reader/writer lock. /// \u003c/summary\u003e public sealed class OneManyLock : IDisposable { #region Lock State Management #if false private struct BitField { private Int32 m_mask, m_1, m_startBit; public BitField(Int32 startBit, Int32 numBits) { m_startBit = startBit; m_mask = unchecked((Int32)((1 \u003c\u003c numBits) - 1) \u003c\u003c startBit); m_1 = unchecked((Int32)1 \u003c\u003c startBit); } public void Increment(ref Int32 value) { value += m_1; } public void Decrement(ref Int32 value) { value -= m_1; } public void Decrement(ref Int32 value, Int32 amount) { value -= m_1 * amount; } public Int32 Get(Int32 value) { return (value \u0026 m_mask) \u003e\u003e m_startBit; } public Int32 Set(Int32 value, Int32 fieldValue) { return (value \u0026 ~m_mask) | (fieldValue \u003c\u003c m_startBit); } } private static BitField s_state = new BitField(0, 3); private static BitField s_readersReading = new BitField(3, 9); private static BitField s_readersWait","date":"2020-03-01","objectID":"/2020/03/dotnetbase8-netclrvia/:2:3","tags":["NetCLRVia","同步与竞争"],"title":"NetCLRVia 同步与竞争","uri":"/2020/03/dotnetbase8-netclrvia/"},{"categories":"NetCLRVia","content":"著名的双检锁技术\r单实例， public sealed class Singleton { // s_lock is required for thread safety and having this object assumes that creating // the singleton object is more expensive than creating a System.Object object and that // creating the singleton object may not be necessary at all. Otherwise, it is more // efficient and easier to just create the singleton object in a class constructor private static readonly Object s_lock = new Object(); // This field will refer to the one Singleton object private static Singleton s_value = null; // Private constructor prevents any code outside this class from creating an instance private Singleton() { /* ... */ } // Public, static method that returns the Singleton object (creating it if necessary) public static Singleton GetSingleton() { // If the Singleton was already created, just return it (this is fast) if (s_value != null) return s_value; Monitor.Enter(s_lock); // Not created, let 1 thread create it if (s_value == null) { // Still not created, create it Singleton temp = new Singleton(); // Save the reference in s_value (see discussion for details) Volatile.Write(ref s_value, temp); } Monitor.Exit(s_lock); // Return a reference to the one Singleton object return s_value; } } 简单版本相同效果，缺点在于访问任何成员都会调用类型构造器 public sealed class Singleton { private static Singleton s_value = new Singleton(); // Private constructor prevents any code outside this class from creating an instance private Singleton() { } // Public, static method that returns the Singleton object (creating it if necessary) public static Singleton GetSingleton() { return s_value; } } 第三种方法，这个版本有可能创建多个s_value；很小的几率 public sealed class Singleton { private static Singleton s_value = null; // Private constructor prevents any code outside this class from creating an instance private Singleton() { } // Public, static method that returns the Singleton object (creating it if necessary) public static Singleton GetSingleton() { if (s_value != null) return s_value; // Create a new Singleton and root it if another thread didn’t do it first Singleton temp = new Singleton(); Interlocked.CompareExchange(ref s_value, temp, null); // If this thread lost, then the second Singleton object gets GC’d return s_value; // Return reference to the single object } } ","date":"2020-03-01","objectID":"/2020/03/dotnetbase8-netclrvia/:2:4","tags":["NetCLRVia","同步与竞争"],"title":"NetCLRVia 同步与竞争","uri":"/2020/03/dotnetbase8-netclrvia/"},{"categories":"NetCLRVia","content":"线程基础\r","date":"2020-02-29","objectID":"/2020/02/dotnetbase7-netclrvia/:1:0","tags":["NetCLRVia","线程"],"title":"NetCLRVia 线程","uri":"/2020/02/dotnetbase7-netclrvia/"},{"categories":"NetCLRVia","content":"Windows为什么要支持线程\r在单核单线程系统中有两个问题：1. 如果系统需要执行某些长时间任务或死循环，就没办法响应其他任何，造成系统“假死”；2.当系统重启或任务崩溃的时候所有的数据都丢失。 针对第一个问题：多线程解决，线程的职责是对CPU进行虚拟化。所有线程共享物理CPU，Windows在某个一个时刻只将一个线程分配给CPU，一个时刻称为时间片quantum,时间一到，Windows就进行上下文切换到另一个线程。 针对第二个问题：进程解决，每个进程都被赋予一个虚拟地址控件，一个进程中使用的代码和数据不能被另一个进程使用。 Windows只能调度线程， 不能调度进程。 ","date":"2020-02-29","objectID":"/2020/02/dotnetbase7-netclrvia/:1:1","tags":["NetCLRVia","线程"],"title":"NetCLRVia 线程","uri":"/2020/02/dotnetbase7-netclrvia/"},{"categories":"NetCLRVia","content":"线程开销\r线程有以下几个要素： 线程内核对象(thread kernel object)：这是一个数据结构，包含：1.线程描述；2.线程上下文：存储CPU寄存器数据的内存块，不同CPU架构大小不一样，X64大概1240字节。 线程环境块(thread environment block,TEB)：存储线程环境相关的块：包括异常处理链首，线程本地数据以及GDI和OpenGL图形相关的数据，不同CPU架构大概都4KB。 用户模式栈(User-mode stack)：存储局部变量和实参，方法返回时线程的线程的执行地址，这个结构占用内存最大为1M。 内核模式栈(kernel-mode stack)：操作系统内核模式函数时，需要将用户模式栈的实参，局部变量和返回地址复制到内核模式栈，用户不能访问内核模式也就不能修改实参了。不同架构CPU内存不一样，X64为24KB DLL线程链接(attach)和分离(detach):在创建线程，会向进程中所有加载的非托管dll的DllMain方法传递一个DLL_THREAD_ATTACH标志。线程终止时也会向该方法传递一个DLL_THREAD_DETACH标志。 所有线程共享物理CPU，Windows在某个一个时刻只将一个线程分配给CPU，一个时刻称为时间片quantum(大概30ms，取决于CPU架构),时间一到，Windows就进行上下文切换到另一个线程。 上下文切换时Windows的操作： 将CPU寄存器中的值复制到线程内核对象的线程上下文结构中。 在现有线程集合中调度一个线程执行，如果该线程在另一个进程中，就切换进程的虚拟空间地址。 将选中线程的线程内核对象上下文结构中的数据加载到CPU寄存器。 上下文切换还有一个操作是：CPU高速缓存的中的数据存到RAM中，新线程执行前从RAM中将数据存储到CPU高速缓存中。 线程可以提前终止时间片，什么也不做。如等待用户输入。只有用户输入的时候，CPU才会调用该线程。 垃圾回收的时候CLR会挂起所有线程。 结论：尽量少使用线程，线程上下文切换和其他的一些操作消耗了大量时间和内存。但有的时候又必须使用线程。 ","date":"2020-02-29","objectID":"/2020/02/dotnetbase7-netclrvia/:1:2","tags":["NetCLRVia","线程"],"title":"NetCLRVia 线程","uri":"/2020/02/dotnetbase7-netclrvia/"},{"categories":"NetCLRVia","content":"CPU发展趋势\r可以查看windows的进程和线程情况：任务选项卡-性能；详细信息。 CPU的发展正在面临着：多个CPU,超线程芯片，多核芯片。 ","date":"2020-02-29","objectID":"/2020/02/dotnetbase7-netclrvia/:1:3","tags":["NetCLRVia","线程"],"title":"NetCLRVia 线程","uri":"/2020/02/dotnetbase7-netclrvia/"},{"categories":"NetCLRVia","content":"CLR线程和Windows线程\rCLR线程就是映射的Windows线程的逻辑线程，完全等价。在以前Microsoft做过一些努力使得CLR线程做一些额外的操作，但是失败了。 ","date":"2020-02-29","objectID":"/2020/02/dotnetbase7-netclrvia/:1:4","tags":["NetCLRVia","线程"],"title":"NetCLRVia 线程","uri":"/2020/02/dotnetbase7-netclrvia/"},{"categories":"NetCLRVia","content":"使用专用线程执行异步的计算限制操作\r必须要避免创建线程来执行异步的操作，相反需要使用线程池执行异步的操作。 有一些特殊情况需要创建线程： 线程需要以非普通优先级运行。线程池都以普通优先级运行。 线程需要表现为前台线程。 执行长时间的任务。 启动线程并可能调用Thread的Abort来终止它。 using System; using System.Threading; public static class ThreadBasics { public static void Main() { FirstThread.Go(); BackgroundDemo.Go(true); BackgroundDemo.Go(false); } } internal static class FirstThread { public static void Go() { Console.WriteLine(\"Main thread: starting a dedicated thread \" + \"to do an asynchronous operation\"); Thread dedicatedThread = new Thread(ComputeBoundOp); dedicatedThread.Start(5); Console.WriteLine(\"Main thread: Doing other work here...\"); Thread.Sleep(10000); // Simulating other work (10 seconds) dedicatedThread.Join(); // Wait for thread to terminate等待线程终止 Console.ReadLine(); } // This method's signature must match the ParametizedThreadStart delegate private static void ComputeBoundOp(Object state) { // This method is executed by another thread Console.WriteLine(\"In ComputeBoundOp: state={0}\", state); Thread.Sleep(1000); // Simulates other work (1 second) // When this method returns, the dedicated thread dies } } internal static class BackgroundDemo { public static void Go(Boolean background) { // Create a new thread (defaults to Foreground) Thread t = new Thread(new ThreadStart(ThreadMethod)); // Make the thread a background thread if desired if (background) t.IsBackground = true; t.Start(); // Start the thread return; // NOTE: the application won't actually die for about 10 seconds } private static void ThreadMethod() { Thread.Sleep(10000); // Simulate 10 seconds of work Console.WriteLine(\"ThreadMethod is exiting\"); } } ","date":"2020-02-29","objectID":"/2020/02/dotnetbase7-netclrvia/:1:5","tags":["NetCLRVia","线程"],"title":"NetCLRVia 线程","uri":"/2020/02/dotnetbase7-netclrvia/"},{"categories":"NetCLRVia","content":"线程调度和优先级\r可以使用Microsoft Spy++工具查看线程的调度情况。在vs开发人员命名提示里输入spyxx就可以启动 Windows系统又称为抢占式多线程操作系统(preemptive multithreaded)。同时Windows不是实时操作系统。 每个线程都分配了从0（最低）到31（最高）的优先级。Windows先以轮流(round-robin)方法调用所有高优先级线程，直到该优先级所有线程不需要运行，才会调度下一层优先级中的线程。如果在执行低优先级线程的时候，有高优先级的线程需要运行，系统会立刻挂起(暂停）低优先级然后调度高优先级。 系统有一个零页线程(zero page thread)，在系统没有线程需要运行的时候，零页线程负责将系统的RAM所有空闲页清零。 为了更好的规划优先级，Microsoft将进程和线程都划分了优先级类：进程：Idle,Below Normal,Normal,Above Normal,High,Realtime;线程：Idle,Lowest,Below Normal,Normal,Above Normal,Highest,Time-Critical。 优先级类与优先级的对应关系： CLR终结器以线程Time-Critical优先级运行。 设置Thread的Priority属性向其传递ThreadPriority枚举类型定义的5个值来控制线程优先级。 大多数进程都是再Normal优先级，大多数线程也是Normal，所有系统中大多数线程的优先级是8 ","date":"2020-02-29","objectID":"/2020/02/dotnetbase7-netclrvia/:1:6","tags":["NetCLRVia","线程"],"title":"NetCLRVia 线程","uri":"/2020/02/dotnetbase7-netclrvia/"},{"categories":"NetCLRVia","content":"前台线程和后台线程\r一个进程中所有的前台线程停止时，所有的后台线程会立刻被终止。 每个AppDomain都可以运行一个单独应用程序，该应用程序有自己前台线程。所有前台线程都停止的时候，进程才会退出销毁。 线程可以从前台线程编程后台线程或则反向。应用程序主线程以及通过构造一个Thread对象显式创建的任何线程都默认为前台线程。线程池的线程都默认为后台线程。进入托管环境的本机代码创建的线程都是后台线程。 ","date":"2020-02-29","objectID":"/2020/02/dotnetbase7-netclrvia/:1:7","tags":["NetCLRVia","线程"],"title":"NetCLRVia 线程","uri":"/2020/02/dotnetbase7-netclrvia/"},{"categories":"NetCLRVia","content":"计算限制的异步操作\r","date":"2020-02-29","objectID":"/2020/02/dotnetbase7-netclrvia/:2:0","tags":["NetCLRVia","线程"],"title":"NetCLRVia 线程","uri":"/2020/02/dotnetbase7-netclrvia/"},{"categories":"NetCLRVia","content":"CLR线程池基础\r每个CLR拥有一个线程池，也就是一个线程池为该CLR控制的所有AppDomain共享。 CLR的工作模式： CLR初始化时，线程池没有线程 当有异步操作时，将一个记录项(entry)追加到线程池队列中。 线程池代码将获得记录项将其派发(dispatch)给一个线程。 如果没有线程就创建一个线程。 完成任务后，线程回到线程池，进入空闲状态(不进行销毁)。 如果线程一直空闲，一段时间后会醒来释放自己。 ","date":"2020-02-29","objectID":"/2020/02/dotnetbase7-netclrvia/:2:1","tags":["NetCLRVia","线程"],"title":"NetCLRVia 线程","uri":"/2020/02/dotnetbase7-netclrvia/"},{"categories":"NetCLRVia","content":"执行简单的计算限制操作\rThreadPool定义的异步方法和回调委托： static Boolean QueueUserWorkItem(WaitCallback callBack); static Boolean QueueUserWorkItem(WaitCallback callBack,Object state); delegate void WaitCallback(Object state); //执行 ExecutionContexts.Go(); internal static class ThreadPoolDemo { public static void Go() { Console.WriteLine(\"Main thread: queuing an asynchronous operation\"); ThreadPool.QueueUserWorkItem(ComputeBoundOp, 5); Console.WriteLine(\"Main thread: Doing other work here...\"); Thread.Sleep(10000); // Simulating other work (10 seconds) Console.ReadLine(); } // This method's signature must match the WaitCallback delegate private static void ComputeBoundOp(Object state) { // This method is executed by a thread pool thread Console.WriteLine(\"In ComputeBoundOp: state={0}\", state); Thread.Sleep(1000); // Simulates other work (1 second) // When this method returns, the thread goes back // to the pool and waits for another task } } //结果 Main thread: queuing an asynchronous operation Main thread: Doing other work here... In ComputeBoundOp: state=5 ","date":"2020-02-29","objectID":"/2020/02/dotnetbase7-netclrvia/:2:2","tags":["NetCLRVia","线程"],"title":"NetCLRVia 线程","uri":"/2020/02/dotnetbase7-netclrvia/"},{"categories":"NetCLRVia","content":"执行上下文Execution context\r每个线程都关联一个执行上下文（Execution context）,执行上下文包括很多东西：安全设置，宿主设置，上下文数据。 每当初始线程使用辅助线程执行任务时，初始线程的执行上下文会复制到辅助线程，保证辅助线程使用相同的安全设置和宿主设置，但这一操作会影响性能。 System.Threading.ExecutionContext类可以对执行上下文的复制功能进行控制： public sealed class ExecutionContext:IDisposable, ISerializabel { [SecurityCritical] public static AsyncFlowControl SuppressFlow(); public static void RestoreFlow(); public static Boolean IsFlowSuppressed(); // 未列出不常用的方法 } 阻止执行上下文可以显著提升服务器应用程序，而客户端应用程序提升不明显。 //调用 ExecutionContexts.Go(); internal static class ExecutionContexts { public static void Go() { // Put some data into the Main thread’s logical call context CallContext.LogicalSetData(\"Name\", \"Jeffrey\"); // Initiate some work to be done by a thread pool thread // The thread pool thread can access the logical call context data ThreadPool.QueueUserWorkItem( state =\u003e Console.WriteLine(\"Name={0}\", CallContext.LogicalGetData(\"Name\"))); // Suppress the flowing of the Main thread’s execution context ExecutionContext.SuppressFlow(); // Initiate some work to be done by a thread pool thread // The thread pool thread can NOT access the logical call context data ThreadPool.QueueUserWorkItem( state =\u003e Console.WriteLine(\"Name={0}\", CallContext.LogicalGetData(\"Name\"))); // Restore the flowing of the Main thread’s execution context in case // it employs more thread pool threads in the future ExecutionContext.RestoreFlow(); SecurityExample(); } private static void SecurityExample() { ProxyType highSecurityObject = new ProxyType(); highSecurityObject.AttemptAccess(\"High\"); // Works OK PermissionSet grantSet = new PermissionSet(PermissionState.None); grantSet.AddPermission(new SecurityPermission(SecurityPermissionFlag.Execution)); AppDomain lowSecurityAppDomain = AppDomain.CreateDomain(\"LowSecurity\", null, new AppDomainSetup() { ApplicationBase = AppDomain.CurrentDomain.BaseDirectory }, grantSet, null); ProxyType lowSecurityObject = (ProxyType)lowSecurityAppDomain.CreateInstanceAndUnwrap(typeof(ProxyType).Assembly.ToString(), typeof(ProxyType).FullName); lowSecurityObject.DoSomething(highSecurityObject); Console.ReadLine(); } public sealed class ProxyType : MarshalByRefObject { // This method executes in the low-security AppDomain public void DoSomething(ProxyType highSecurityObject) { AttemptAccess(\"High-\u003eLow\"); // Throws // Attempt access from the high-security AppDomain via the low-security AppDomain: Throws highSecurityObject.AttemptAccess(\"High-\u003eLow-\u003eHigh\"); // Have the high-security AppDomain via the low-security AppDomain queue a work item to // the thread pool normally (without suppressing the execution context): Throws highSecurityObject.AttemptAccessViaThreadPool(false, \"TP (with EC)-\u003eHigh\"); // Wait a bit for the work item to complete writing to the console before starting the next work item Thread.Sleep(1000); // Have the high-security AppDomain via the low-security AppDomain queue a work item to // the thread pool suppressing the execution context: Works OK highSecurityObject.AttemptAccessViaThreadPool(true, \"TP (no EC)-\u003eHigh\"); } public void AttemptAccessViaThreadPool(Boolean suppressExecutionContext, String stack) { // Since the work item is queued from the high-security AppDomain, the thread pool // thread will start in the High-security AppDomain with the low-security AppDomain's // ExecutionContext (unless it is suppressed when queuing the work item) using (suppressExecutionContext ? (IDisposable)ExecutionContext.SuppressFlow() : null) { ThreadPool.QueueUserWorkItem(AttemptAccess, stack); } } public void AttemptAccess(Object stack) { String domain = AppDomain.CurrentDomain.IsDefaultAppDomain() ? \"HighSecurity\" : \"LowSecurity\"; Console.Write(\"Stack={0}, AppDomain={1}, Username=\", stack, domain); try { Console.WriteLine(Environment.GetEnvironmentVariable(\"USERNAME\")); } catch (SecurityException) { Console.WriteLine(\"(SecurityException)\"); } } } } //结果 Name=Jeffrey Name= Stack=High, AppDomain=HighSecurity, Username=dujinfeng Stack=High-\u003eLow, AppDomain=LowSecurity, Userna","date":"2020-02-29","objectID":"/2020/02/dotnetbase7-netclrvia/:2:3","tags":["NetCLRVia","线程"],"title":"NetCLRVia 线程","uri":"/2020/02/dotnetbase7-netclrvia/"},{"categories":"NetCLRVia","content":"协作式取消和超时\r协作式取消就是需要显式调用取消。 怎样显式调用取消： System.Threading.CancellationTokenSource包含了取消有关的所有状态，其为引用类型，可以利用它的Token属性获得CancellationToken值类型来进行取消操作。 public sealed class CancellationTokenSource:IDisposable //引用类型 { public CancellationTokenSource(); public void Dispose();//释放资源比如WaitHandle public Boolean IsCancellationRequested {get;} public void Cancel(); public void Cancel(Boolean throwOnFirstException); } CancellationToken轻量级值类型，有一个字段包含对CancellationTokenSource对象的引用 public struct CancellationToken //一个值类型 { public static CancellationToken None {get;} //很好用 public Boolean IsCancellationRequested {get;} //通过非Task调用的操作调用 public void ThrowIfCancellationRequested()；//通过Task调用的操作调用 // CancellationTokenSource取消时，WaitHandIe会收到信号 public WaitHandle WaitHandle {get;} //GetHashCode,Equals,operator==和operaor!=成员未列出 public Boolean CanBeCanceLed {get;}／／很少使用 public CancellationTokenRegistration Register(Action\u003cObject\u003e callback, Object state, Boolean useSynchromzatronContext);//未列出更简单的重载版本 } TaskDemo.Go(); internal static class CancellationDemo { public static void Go() { CancellingAWorkItem(); Register(); Linking(); } private static void CancellingAWorkItem() { CancellationTokenSource cts = new CancellationTokenSource(); // Pass the CancellationToken and the number-to-count-to into the operation //将CancellationToken和值转换为操作 ThreadPool.QueueUserWorkItem(o =\u003e Count(cts.Token, 1000)); Console.WriteLine(\"Press \u003cEnter\u003e to cancel the operation.\"); Console.ReadLine(); cts.Cancel(); // If Count returned already, Cancel has no effect on it //如果已经返回了Count，则Cancel对其无效 // Cancel returns immediately, and the method continues running here... //取消立即返回，该方法在此处继续运行... Console.ReadLine(); // For testing purposes } private static void Count(CancellationToken token, Int32 countTo) { for (Int32 count = 0; count \u003c countTo; count++) { if (token.IsCancellationRequested) {//必须手动在代码中监测取消，这个比较烦 Console.WriteLine(\"Count is cancelled\"); break; // Exit the loop to stop the operation } Console.WriteLine(count); Thread.Sleep(200); // For demo, waste some time } Console.WriteLine(\"Count is done\"); } private static void Register() { var cts = new CancellationTokenSource(); cts.Token.Register(() =\u003e Console.WriteLine(\"Canceled 1\")); cts.Token.Register(() =\u003e Console.WriteLine(\"Canceled 2\")); // To test, let's just cancel it now and have the 2 callbacks execute //为了测试，让我们现在就取消它并执行2个回调 cts.Cancel(); } private static void Linking() { // Create a CancellationTokenSource var cts1 = new CancellationTokenSource(); cts1.Token.Register(() =\u003e Console.WriteLine(\"cts1 canceled\")); // Create another CancellationTokenSource var cts2 = new CancellationTokenSource(); cts2.Token.Register(() =\u003e Console.WriteLine(\"cts2 canceled\")); // Create a new CancellationTokenSource that is canceled when cts1 or ct2 is canceled //创建一个新的CancellationTokenSource，该对象在cts1或ct2被取消时被取消 /* Basically, Constructs a new CTS and registers callbacks with all he passed-in tokens. Each callback calls Cancel(false) on the new CTS */ /*基本上，构造一个新的CTS并使用他传入的所有令牌注册回调。 每个回调在新的CTS上调用Cancel（false）*/ var ctsLinked = CancellationTokenSource.CreateLinkedTokenSource(cts1.Token, cts2.Token); ctsLinked.Token.Register(() =\u003e Console.WriteLine(\"linkedCts canceled\")); // Cancel one of the CancellationTokenSource objects (I chose cts2) cts2.Cancel(); // Display which CancellationTokenSource objects are canceled Console.WriteLine(\"cts1 canceled={0}, cts2 canceled={1}, ctsLinked canceled={2}\", cts1.IsCancellationRequested, cts2.IsCancellationRequested, ctsLinked.IsCancellationRequested); } } //结果 不可取消操作可以使用CancellationToken的静态None属性。该属性返回一个特殊的CancellationToken对象，该对象的IsCancellationRequest总是返回false。 可调用CancellationTokenSource的Register方法注册一个在线程取消时调用的方法。向该方法传递一个Action\u003cObject\u003e委托和一个bool值（名为useSynchronizationContext），bool值用来控制是否使用调用线程（false:调用register的线程）的SynchronizationContext（回调方法会被**send(同步调用)**给它，而不是post（异步调用））来调用委托，使用为true，不使用为false，如果不使用回调方法会被顺序执行。 Rigister中注册多个回调方法发生异常，要看一下CancellationTokenSource的Cancel方法，如果向该方法传递true，那么异常会阻塞回调方法的调用，如果是false，回调方法不会被阻塞，所有","date":"2020-02-29","objectID":"/2020/02/dotnetbase7-netclrvia/:2:4","tags":["NetCLRVia","线程"],"title":"NetCLRVia 线程","uri":"/2020/02/dotnetbase7-netclrvia/"},{"categories":"NetCLRVia","content":"任务\rThreadPool的QueueUserWorkItem方法的弊端 不知道线程什么时候完成 不能获得线程返回值 System.Threading.Tasks可以解决这些问题。 private static void UsingTaskInsteadOfQueueUserWorkItem() { ThreadPool.QueueUserWorkItem(ComputeBoundOp, 5); new Task(ComputeBoundOp, 5).Start(); Task.Run(() =\u003e ComputeBoundOp(5)); } Task构造函数接收一个Action或Action\u003cObject\u003e委托，静态方法Run需要传递一个Action或Func\u003cTResult\u003e委托。 还可以使用TaskCreationOptions标志来控制Task的执行。 等待任务完成并获取结果\rprivate static void WaitForResult() { // Create and start a Task Task\u003cInt32\u003e t = new Task\u003cInt32\u003e(n =\u003e Sum((Int32)n), 10000); // You can start the task sometime later t.Start(); // Optionally, you can explicitly wait for the task to complete //（可选）您可以显式等待任务完成 t.Wait(); // FYI(for you information): Overloads exist accepting a timeout/CancellationToken //存在过载，接受超时/ CancellationToken // Get the result (the Result property internally calls Wait) Console.WriteLine(\"The sum is: \" + t.Result); // An Int32 value } Task\u003cTResult\u003e对象可以获得Task返回的结果。 Wait会使调用Wait的线程阻塞，等待Task结束，如果Task没有开始就用调用Wait线程执行Task。 如果Task任务抛出异常，不会被阻塞，直接存储到异常集合中，在t.Wait或t.Result会抛出System.AggregateException异常。该异常的InnerExceptions（返回ReadOnlyCollection\u003cException\u003e）和InnerException(从Exception集成) System.AggregateException的一些功能： GetBaseException方法，返回最内层AggregateException Flatten属性，新建一个AggregateException，其InnerExceptions属性包含一个异常列表 Handle方法，使AggregateException中每个异常都调用一个回调方法 如果不调用Wait或Result方法或不查询task的Exception属性，就不会注意到异常，可以向TaskSchedule的静态UnobservedTaskException事件登记一个回调方法，如果在task被垃圾回收时发现有没有被注意的异常，会触发这个事件，并传递一个UnobservedTaskException对象，其包含一个AggregateException对象。 private static void UnobservedException() { TaskScheduler.UnobservedTaskException += (sender, e) =\u003e { //e.SetObserved(); Console.WriteLine(\"Unobserved exception {0}\", e.Exception, e.Observed); }; Task parent = Task.Factory.StartNew(() =\u003e { Task child = Task.Factory.StartNew(() =\u003e { throw new InvalidOperationException(); }, TaskCreationOptions.AttachedToParent); // Child’s exception is observed, but not from its parent child.ContinueWith((task) =\u003e { var _error = task.Exception; }, TaskContinuationOptions.OnlyOnFaulted); }); // If we do not Wait, the finalizer thread will throw an unhandled exception terminating the process //parent.Wait(); // throws AggregateException(AggregateException(InvalidOperationException)) parent = null; Console.ReadLine(); // Wait for the tasks to finish running GC.Collect(); Console.ReadLine(); } //结果 /* Unobserved exception System.AggregateException: 未通过等待任务或访问任务的 Exception 属性观察到任务的异常。因此，终结器 线程重新引发了未观察到的异常。 ---\u003e System.AggregateException: 发生一个或多个错误。 ---\u003e System.InvalidOperationException: 对象的当前状态使该操作无效。 在 TaskDemo.\u003c\u003ec.\u003cUnobservedException\u003eb__8_2() 位置 C:\\Users\\dujinfeng\\Desktop\\NetCLRVia\\CLR-via-C-4th-Edition-Code\\Ch27-1-ComputeOps.cs:行号 355 在 System.Threading.Tasks.Task.InnerInvoke() 在 System.Threading.Tasks.Task.Execute() --- 内部异常堆栈跟踪的结尾 --- --- 内部异常堆栈跟踪的结尾 --- ---\u003e (内部异常 #0) System.AggregateException: 发生一个或多个错误。 ---\u003e System.InvalidOperationException: 对象的当前状态使该操作无效。 在 TaskDemo.\u003c\u003ec.\u003cUnobservedException\u003eb__8_2() 位置 C:\\Users\\dujinfeng\\Desktop\\NetCLRVia\\CLR-via-C-4th-Edition-Code\\Ch27-1-ComputeOps.cs:行号 355 在 System.Threading.Tasks.Task.InnerInvoke() 在 System.Threading.Tasks.Task.Execute() --- 内部异常堆栈跟踪的结尾 --- ---\u003e (内部异常 #0) System.InvalidOperationException: 对象的当前状态使该操作无效。 在 TaskDemo.\u003c\u003ec.\u003cUnobservedException\u003eb__8_2() 位置 C:\\Users\\dujinfeng\\Desktop\\NetCLRVia\\CLR-via-C-4th-Edition-Code\\Ch27-1-ComputeOps.cs:行号 355 在 System.Threading.Tasks.Task.InnerInvoke() 在 System.Threading.Tasks.Task.Execute()\u003c--- \u003c--- */ 请按任意键继续. . . Task还提供了两个静态方法，允许等待一个Task对象数组 WaitAny，阻塞调用线程，等待任何一个Task完成，返回一个Int32的task数组索引，超时返回-1，通过CancellationToken取消会抛出Operation’Cancel’Exception异常。 WaitAll，阻塞调用线程，等待所有Task完成。其他和WaitAny一样。 取消任务\rprivate static void Cancel() { CancellationTokenSource cts = new CancellationTokenSource(); Task\u003cInt32\u003e t = Task.Run(() =\u003e Sum(cts.Token, 10000), cts.Token); // Sometime later, cancel the CancellationTokenSource to cancel the Task cts.Cancel();//这是一个异步请求 try { // If the task got canceled, Result will throw an AggregateExc","date":"2020-02-29","objectID":"/2020/02/dotnetbase7-netclrvia/:2:5","tags":["NetCLRVia","线程"],"title":"NetCLRVia 线程","uri":"/2020/02/dotnetbase7-netclrvia/"},{"categories":"NetCLRVia","content":"Parallel的静态For,ForEach,和Invoke方法\r多个方法并行或顺序执行,使用线程池，内部使用Task。同时调用线程会将自己挂起，直到所有工作完成。任何一个Task出现异常，都会抛出AggregateException异常。多个线程需要添加线程同步锁保护共享数据。 private static void SimpleUsage() { // One thread performs all this work sequentially for (Int32 i = 0; i \u003c 1000; i++) DoWork(i); // The thread pool’s threads process the work in parallel Parallel.For(0, 1000, i =\u003e DoWork(i)); var collection = new Int32[0]; // One thread performs all this work sequentially foreach (var item in collection) DoWork(item); // The thread pool’s threads process the work in parallel Parallel.ForEach(collection, item =\u003e DoWork(item)); // One thread executes all the methods sequentially Method1(); Method2(); Method3(); // The thread pool’s threads execute the methods in parallel Parallel.Invoke( () =\u003e Method1(), () =\u003e Method2(), () =\u003e Method3()); } private static void DoWork(Int32 i) { } private static void Method1() { } private static void Method2() { } private static void Method3() { } ParallelOptions对象用于控制Parallel public class ParallelOptions { public ParallelOptions(); //允许取消操作 public CancellationToken CancellationToken{get;set;}//默认为CancellationToken.None //允许指定可以并发操作的最大工作项数目 public Int32MaxDegreeOfParallelism {get;set;}//默认为-1(可用CPU数) //允许指定要使用哪个TaskScheduler public TaskSchedulerTaskScheduler {get;set;}//默认为TaskScheduler.Default } 有一些For和Foreach的重载版本允许3个委托 Task初始化委托(localInit):每个任务被处理前调用 Task主体委托(body):每个任务处理时调用 Task总结委托(localFinally):每个任务结束的时候调用 计算一个目录中所有文件字节的长度. String path = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments); Console.WriteLine(\"The total bytes of all files in {0} is {1:N0}.\", path, DirectoryBytes(@path, \"*.*\", SearchOption.TopDirectoryOnly)); private static Int64 DirectoryBytes(String path, String searchPattern, SearchOption searchOption) { var files = Directory.EnumerateFiles(path, searchPattern, searchOption); Int64 masterTotal = 0; ParallelLoopResult result = Parallel.ForEach\u003cString, Int64\u003e(files, () =\u003e { // localInit: 每个任务开始之前调用一次 // 每个任务开始之前,总计值都初始化为0 return 0; // 将taskLocalTotal初始值为 0 }, (file, parallelLoopState, index, taskLocalTotal) =\u003e { // body: 每个工作项调用一次 // 获得这个文件的大小,把它添加到这个任务的累加值上 Int64 fileLength = 0; FileStream fs = null; try { fs = File.OpenRead(file); fileLength = fs.Length; } catch (IOException) { /* Ignore any files we can't access */ } finally { if (fs != null) fs.Dispose(); } return taskLocalTotal + fileLength; }, taskLocalTotal =\u003e { // 每个任务完成时调用 //将这个任务的总计值taskLocalTotal添加到总的总计值mastertotal上 Interlocked.Add(ref masterTotal, taskLocalTotal); }); return masterTotal; } //结果 The total bytes of all files in C:\\Users\\dujinfeng\\Documents is 2,698. 请按任意键继续. . . 委托主体传递了一个ParallelLoopState对象,可以通过该对象与参与工作的其他任务进行交互,Stop方法使得循环停止,Break方法使得循环不再处理当前项之后的项.LoweatBreakIteration属性返回处理过程中调用过Break方法的最低项,如果没有break过,就返回null. public calss ParallelLoopState { public void Stop(); public Boolean IsStopped{ get; } public void Break(); public Int64? LowestBreakIteration{ get; } public Boolean IsExceptional{ get; } public Boolean ShouldExitCurrentIteration{ get; } } 在处理任何一项任务造成了异常，IsException属性会返回true,如果调用过Stop,Break,CancellationTokenSource,查询ShouldExitCurrentIteration就会返回true。 For和ForEach会返回ParalleLoopResult实例， public struct ParallelLoopResult { //如果操作提提前终止，以下方法返回false public Boolean IsCompleted{get;} public INt64? LowestBreakIteration{get;} } 如果正常运行完IsCompleted返回true。 ","date":"2020-02-29","objectID":"/2020/02/dotnetbase7-netclrvia/:2:6","tags":["NetCLRVia","线程"],"title":"NetCLRVia 线程","uri":"/2020/02/dotnetbase7-netclrvia/"},{"categories":"NetCLRVia","content":"并行语言集成查询\r顺序查询和并行查询（Parallel LINQ），System.Linq.ParallelEnumerable类实现了PLINQ的所有功能。PatallelEnumerable的AsParallel扩展方法可以将顺序查询(基于IEnumerable或者IEnumerable\u003cT\u003e)转换成并行查询(基于ParallelQuery或ParallelQuery\u003cT\u003e) public static ParallelQuery\u003cTSource\u003e AsParallel\u003cTSource\u003e(this IEnumerable\u003cTSource\u003e source); public static ParallelQuery AsParallel(this IEnumerable source); 例子返回一个程序集所有过时(obsolete)方法 //调用 ObsoleteMethods(typeof(Object).Assembly); private static void ObsoleteMethods(Assembly assembly) { var query = from type in assembly.GetExportedTypes().AsParallel() from method in type.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static) let obsoleteAttrType = typeof(ObsoleteAttribute) where Attribute.IsDefined(method, obsoleteAttrType) orderby type.FullName let obsoleteAttrObj = (ObsoleteAttribute) Attribute.GetCustomAttribute(method, obsoleteAttrType) select String.Format(\"Type={0}\\nMethod={1}\\nMessage={2}\\n\", type.FullName, method.ToString(), obsoleteAttrObj.Message); // Display the results foreach (var result in query) Console.WriteLine(result); // Alternate (not as fast): query.ForAll(Console.WriteLine); } //结果 Type=Microsoft.Win32.RegistryHive Method=System.String ToString(System.IFormatProvider) Message=The provider argument is not used. Please use ToString(). Type=Microsoft.Win32.RegistryHive Method=System.String ToString(System.String, System.IFormatProvider) Message=The provider argument is not used. Please use ToString(String). Type=Microsoft.Win32.RegistryKeyPermissionCheck Method=System.String ToString(System.String, System.IFormatProvider) Message=The provider argument is not used. Please use ToString(String). Type=Microsoft.Win32.RegistryKeyPermissionCheck Method=System.String ToString(System.IFormatProvider) Message=The provider argument is not used. Please use ToString(). Type=Microsoft.Win32.RegistryOptions Method=System.String ToString(System.IFormatProvider) Message=The provider argument is not used. Please use ToString(). ParallelEnumerable的AsSequential方法可以将并行查询转换成顺序查询。 public static IEnumerable\u003cTSource\u003e AsSequential\u003cTSource\u003e (this ParallelQuery\u003cTSource\u003e source) 顺序查询中处理结果方法foreach在并行中可以用ParallelEnumerable的ForAll方法处理查询： static void ForAll\u003cTSource\u003e (this ParallelQuery\u003cTSource\u003e source,Action\u003cTSource\u003e action); //上面例子的最后foreach可以被替换为： query.ForAll(Console.WriteLine); 但调用Console.WriteLine并行执行没有意义，其内部让线程同步，同时只有一个线程能访问控制台。 如果需要并行执行并保持顺序可以使用ParallelEnumerable的AsOrdered方法，排序方法Orderby,OrderbyDescending,ThenBy,ThenByDescending。不排序的方法Distinct,Except,Intersect,Union,Join,GroupBy,GroupJoin,ToLookup。 并行用来控制查询的方法WithCancellation\u003cTSource\u003e，WithDegreeOfParallelism\u003cTSource\u003e，WithExecutionMode\u003cTSource\u003e,WithMergeOptions\u003cTSource\u003e方法。 调用Concat,ElementAt,FIrst,Last,Skip，Take,Zip,Select等可以调用WithExecutionMode,向其传递ParallelExecutionMode标志，强迫以并行执行。 public enum ParallelExceptionMode { Default=0;//让并行Linq决定处理查询的最佳方式 ForceParallelism=1//强迫查询以其并行方式处理 } 并行处理，结果必须合并，可调用WithMergeOptions，向其传递ParallelMergeOptions标志，从而控制缓冲与合并方式 public enum ParallelMergeOptions { Default=0,//目前和AutoBuffered一样 NotBuffered=1,//结果一旦就绪就开始处理,最省内存，速度比较慢 AutoBuffered=2,//每个线程在处理前缓冲一些结果，介于之间 FullyBuffered=3//每个线程在处理前缓冲所有结果，运行速度最快，内存使用多 } ","date":"2020-02-29","objectID":"/2020/02/dotnetbase7-netclrvia/:2:7","tags":["NetCLRVia","线程"],"title":"NetCLRVia 线程","uri":"/2020/02/dotnetbase7-netclrvia/"},{"categories":"NetCLRVia","content":"执行定时的计算限制操作\rSystem.Threading.Timer定时器构造函数 puniic sealed class Timer：MarshalByRefObject,IDisposable{ public Timer(TimerCa11back callback,0bject stater,Int32 dueTime,Int32 period); public Timer(TimerCallback callback,0bject state,UInt32 dueTime,UInt32 period); public Timer(TimerCallback callback,Object state,Int64 dueTime,Int64 period); public Timer(TimerCa1lback callback,0bject state,Timespan dueTime,TimeSpan Period); } //System.Threading.TimerCallback delegate void TimerCallback(Object state); 在内部：所有Timer对象只使用一个线程，该线程知道Timer对象下一次什么时候到期，如果到期就会唤醒，调用ThreadPool的QueueUserWorkItem， 如果回调函数执行时间长，定时器有可能再次触发，造成多线程执行回调方法，针对这个问题，建以在构造Timer时，将period指定为Timeout.Infinite，这样只执行一次回调，在回调中使用Change指定新的dueTimer,并再次将Period执行Timeout.Infinite。 public sealed class Timer：MarshalByRefObject,IDisposabie { public Boolean Change(Int32 dueTime,Int32 period); public Boolean Change(UInt32 dueTime,UInt32 period); public Boo1eam Change(Int64 dueTime,Int64 period); public Boolean Change(TimeSpan dueTime,Timespan period); } Timer类的Dispose方法完全取消计时器，在完成回调之后，向notifyObject参数标识的内核对象发出信号， internal static class TimerDemo { private static Timer s_timer; public static void Go() { Console.WriteLine(\"Checking status every 2 seconds\"); // Create the Timer ensuring that it never fires. This ensures that // s_timer refers to it BEFORE Status is invoked by a thread pool thread s_timer = new Timer(Status, null, Timeout.Infinite, Timeout.Infinite); // Now that s_timer is assigned to, we can let the timer fire knowing // that calling Change in Status will not throw a NullReferenceException s_timer.Change(0, Timeout.Infinite); Console.ReadLine(); // Prevent the process from terminating } // This method's signature must match the TimerCallback delegate private static void Status(Object state) { // This method is executed by a thread pool thread Console.WriteLine(\"In Status at {0}\", DateTime.Now); Thread.Sleep(1000); // Simulates other work (1 second) // Just before returning, have the Timer fire again in 2 seconds s_timer.Change(2000, Timeout.Infinite); // When this method returns, the thread goes back // to the pool and waits for another work item } } //结果 Checking status every 2 seconds In Status at 2020-02-22 06:57:32 In Status at 2020-02-22 06:57:35 In Status at 2020-02-22 06:57:38 In Status at 2020-02-22 06:57:41 In Status at 2020-02-22 06:57:44 还可以使用Task的Delay和async和await关键字来编码 internal static class DelayDemo { public static void Go() { Console.WriteLine(\"Checking status every 2 seconds\"); Status(); Console.ReadLine(); // Prevent the process from terminating } // This method can take whatever parameters you desire private static async void Status() { while (true) { Console.WriteLine(\"Checking status at {0}\", DateTime.Now); // Put code to check status here... // At end of loop, delay 2 seconds without blocking a thread await Task.Delay(2000); // await allows thread to return // After 2 seconds, some thread will continue after await to loop around } } } 定时器类别 System.Threading.Timer类：最好的计时器，线程池上执行定时后台任务 System.Windows.Forms.Timer类：将计时器与调用线程关联，这个计时器触发，Windows将一条计时器消息(WM_TIMER)注入线程消息队列，线程执行消息泵提取消息进行回调函数，所有这些工作都是一个线程完成，不会并发执行 System.Windows.Threading.DispatcherTimer类：是Form.Timer类在Silverlight和WPF上的等价物 Windows.UI.Xaml.DispatcherTimer类，Form.Timer在WindowsStore应用中的等价物 SYstem.Timers.Timer类，本质上是Threading.Timer的包装类，是VS工具箱中的定时器允许放在设计器上，强烈建以不需要这个类，而改用System.Threading.Timer ","date":"2020-02-29","objectID":"/2020/02/dotnetbase7-netclrvia/:2:8","tags":["NetCLRVia","线程"],"title":"NetCLRVia 线程","uri":"/2020/02/dotnetbase7-netclrvia/"},{"categories":"NetCLRVia","content":"线程池如何管理线程\r微软的线程池技术相当的好，工作情况非常理想，很难搞出一个比CLR更好的线程池。 设置线程池限制\r设置最大线程数，最好不要设置上限，如果发生饥饿或死锁，那么这些线程都会被阻塞，如果设置上限，就会导致没有新的空闲线程执行任务。 System.Threading.ThreadPool类提供了一些静态方法：GetMaxThreads,SetMaxThreads,GetMinThreads,SetMinThreads和GetAvailableThreads方法，可以设置和查询线程数，强烈建以不要使用上诉的任何方法。 管理工作者线程\r线程池的线程都是工作者线程，主要讲解一下ThreadPool.QueueUserWorkItem，Timer类和Task异步执行时线程池操作的异同点： ThreadPool.QueueUserWorkItem，Timer类执行异步时，所有的工作项（回调函数）都被放到全局队列中，工作者线程采用先入先出(first in first out)算法将工作项从全局队列中取出，这使得所有工作者线程竞争一个线程同步锁，在某些应用程序中成为瓶颈。 使用TaskScheduler调度的Task对象。非工作者线程调度Task时，该Task被添加到全局队列。工作者线程调度一个Task时，该Task被添加到调用线程的本地队列(每个工作者线程都有自己的本地队列)。//任务不代表线程 工作者线程准备工作项，先检查本地队列，如果存在Task，就取出Task采用后入先出（LIFO）算法取出Task，注意的是工作者线程是唯一允许访问它自己本地队列头的线程，所以无需同步锁。 如果工作者线程本地队列为空，会尝试从另一个工作者队列的本地队列尾取一个Task，并要求获取同步锁。如果所有工作队列都空了，工作线程会使用FIFO算法从全局队列中提取工作项。如果全局队列也空了，工作者线程进入睡眠状态，如果睡眠时间太长，会自己醒来，销毁自身，并允许系统回收资源。 线程池默认创建CPU数量的工作线程，如果设置ThreadPool.SetMinThreads,则会创建设置值。 ","date":"2020-02-29","objectID":"/2020/02/dotnetbase7-netclrvia/:2:9","tags":["NetCLRVia","线程"],"title":"NetCLRVia 线程","uri":"/2020/02/dotnetbase7-netclrvia/"},{"categories":"NetCLRVia","content":"高速缓存区\rcpu 一般拥有多个核心和一个cpu内的缓存(一般是L2)，缓存一般位于cpu芯片内, 他的速度远远高于主板上的内存,一般来说cpu会把数据从内存加载到缓存中 ,这样可以获得更好的性能(特别是频繁使用的数据)，高速缓存默认划分64 Byte为一个区域(这个数字可能在不同的平台上不一样, 可以通过 ﻿win32 api 函数 GetProcessorInformation 修改)，一个区域在一个时间点只允许一个核心操作，那么完全可能一个线程在操作field1 的时候 , 运行于另外一个cpu上的另外一个线程想操作field2,就必须等待线程1完成以后才能获取这个缓存区域的访问. 例子：显式布局，性能提高了80% internal static class FalseSharing { #if true private class Data { // These two fields are right next to each other in // memory; most-likely in the same cache line public Int32 field1; public Int32 field2; } #else [StructLayout(LayoutKind.Explicit)] private class Data { // These two fields are right next to each other in // memory; most-likely in the same cache line [FieldOffset(0)] public Int32 field1; [FieldOffset(64)] public Int32 field2; } #endif private const Int32 iterations = 100000000; private static Int32 s_operations = 2; private static Stopwatch s_stopwatch; public static void Go() { Data data = new Data(); s_stopwatch = Stopwatch.StartNew(); ThreadPool.QueueUserWorkItem(o =\u003e AccessData(data, 0)); ThreadPool.QueueUserWorkItem(o =\u003e AccessData(data, 1)); Console.ReadLine(); } private static void AccessData(Data data, Int32 field) { for (Int32 x = 0; x \u003c iterations; x++) if (field == 0) data.field1++; else data.field2++; if (Interlocked.Decrement(ref s_operations) == 0) Console.WriteLine(\"Access time: {0}\", s_stopwatch.Elapsed); } } //结果，可能共享缓存 Access time: 00:00:01.0554650 //显式指定内存布局 Access time: 00:00:00.2595376 ","date":"2020-02-29","objectID":"/2020/02/dotnetbase7-netclrvia/:2:10","tags":["NetCLRVia","线程"],"title":"NetCLRVia 线程","uri":"/2020/02/dotnetbase7-netclrvia/"},{"categories":"NetCLRVia","content":"CLR执行模型\r","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:1:0","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"1 将源码编译成托管模块\r在选择framework平台开发后，就面向CLR进行开发 CLR：一个程序，代码块，平台。可以使得多种编程语言使用运行。为了执行面向CLR的代码，电脑必须要安装CLR（目前作为framework的一部分提供） 核心功能：内存管理，程序集加载，安全性，异常处理，线程同步。 编译器：代码的语法检查器和分析器。将源码编译成托管模块。 本机编译器：生成面向特定CPU架构(比如x86,x64或ARM)的中间代码。 面向CLR的编译器： 微软开发：C++/CLI、C#、VB、F#、Iron Python、Iron Ruby、中间语言IL 其他编译器： 托管模块：标准的32位Microsoft Windows可移植执行体(PE32)文件。或者是标准64位Windows可移植执行体(PE32+)文件。这些文件都需要CLR才能执行。PE:Portable Executable,可移植执行体 托管模块各个部分：PE32或PE32+头、CLR头、元数据、IL中间语言代码 IL也称托管代码 元数据：实际上就是一个数据表集合，定义了类型及成员，还有描述引用类型及其成员，其总是和包含IL代码的文件关联（密不可分）；元数据也是老技术的超集，比如COM的类型库（type library）和接口定义语言（Interface definition language,IDL）文件 编译器总是同时生成元数据和中间代码，并将它们嵌入到生成的托管模块，这样元数据和IL永远不会失去同步。 元数据的用途： 避免编译时对C/C++头和库文件的需求，实现类型和成员的IL中已经含有引用成员类型和成员的全部信息，编译器直接从托管模块中读取元数据。 Visual studio用元数据帮助写代码。 CLR的代码验证过程使用元数据确保代码执行类型安全的操作。 元数据允许将对象的字段序列化到内存块，将其发送给另一台机器，然后反序列化。 元数据允许垃圾回收器跟踪对象生存期。 Microsoft的C++编译器的独一无二的，只有它可以允许开发人员同时些托管代码和非托管代码，并生成到同一个模块中。 托管程序集总是利用Windows的数据执行保护(Data Execution Prevention,DEP)和地址空间布局随机化(Address Space Layout Randomization,ASLR)增强系统的安全性。 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:1:1","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"2 将托管模块合并成程序集\r程序集：一个或多个模块/资源文件的逻辑性分组，是重用、安全性以及版本控制的最小单元。编译器可以生成单文件程序集，也可以生成多文件程序集。 CLR实际和程序集工作，在CLR中程序集相当于组件。 一些托管模块和资源(或数据)文件准备交由一个工具处理，工具生成代表文件逻辑分组的一个PE32(+)文件，PE32文件包含一个清单的数据块，该清单就是元数据表的集合，表描述了构成程序集的文件，公开导出类型，以及与程序集关联的资源或数据文件。 编译器默认将托管模块转换成程序集。程序集可以是可执行的应用程序，也可以是DLL（其中含有一组可执行程序使用的类型）。 程序集中还包含引用程序集有关的信息（包含版本号，直接依赖的对象），这些信息为自描述的信息。所以与非托管组件相比，不需要再注册表或Active Directory Domain Services(ADDS)中保存额外的信息。 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:1:2","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"3 加载公共语言运行时\rCLR现在是作为framework的一部分进行发布的。 检查是否安装Framework，需要检查%SystemRoot%\\System32目录中的MSCorEE.dll文件，存在该文件就说明已经安装成功，检查安装哪个版本请检查一下目录 %SystemRoot%\\Microsoft.NET\\Framework %SystemRoot%\\Microsoft.NET\\Framework64 .NET Framework SDK提供了CLRVer.exe的命令行使用程序，可以罗列出机器上所有的CLR版本。 如果程序集只包含类型安全的托管代码，再32位和64位都能运行。 如果需要在特定的CPU架构的非托管代码进行互操作。C#编译器提供了/platform命令行选项，这个选项的默认项是anycpu，表明最终生成的程序集能在任何版本的windows上运行。vs设置，程序集属性，生成，目标平台。 针对/platform选项内容，编译器编译的程序集是PE32开头（PE32文件在32或64位系统均可以运行）或PE32+开头（需要在64位地址空间）。最后windows还会检查嵌入的cpu架构信息，确保当前的CPU符合要求。 Windows检查EXE文件头，决定创建32还是64位进程，在进程地址空间加载MSCorEE.dll的x86,x64或ARM版本。 windows x86或Arm版本，MSCorEE.dll在%SystemRoot%/System32目录 Windows x64，MSCorEE.dll在%SystemRoot%System64目录。 进程的主线程调用MSCorEE.dll中定义的一个方法， 在这个方法初始化CLR，加载EXE程序集，在调用其入口方法Main，随即托管应用程序启动并运行。 如果非托管应用程序调用LoadLibrary加载托管程序集，Windows会自动加载初始化CLR处理程序集中的代码。 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:1:3","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"4 执行程序集的代码\rIL能够访问和操作对象类型，并提供指令来创建和初始化对象、调用对象上的虚方法以及直接操作数组元素，提供抛出和捕捉异常的指令来实现错误处理。可以将IL视为一种面向对象的机器语言。 IL可以不通过编译器生成，而是直接通过汇编语言编写，微软专门提供了ILAsm.exe的IL汇编器和名位ILDasm.exe的IL反汇编器。甚至来说，一般高级语言只公开了CLR的部分功能，IL汇编语言允许开发人员访问CLR的全部功能。 如何执行程序集代码： 把方法的IL转换本机(native)指令，这部分工作由CLR的JIT(Just-in-time)编译器完成。 在Main方法执行前，CLR监测Main代码中引用的所有类型，并分配一个内部数据结构来管理所有引用类型的访问。 一个例子： Main方法引用Console类型，导致CLR分配一个内部结构，在这个内部结构中，Console类型定义的每个方法都有一个对应的记录项。每个记录项都包含一个地址，根据这个地址可找到方法的实现IL。对这个结构初始化时，CLR将每个记录项都传进CLR内部一个未编档函数（即JITCompiler） 本书将entry翻译成记录项，还有其他译法为条目，入口。 Main方法首次调用WriteLine时，JITCompiler函数被调用，将该方法的IL代码编译成本机CPU指令，由于IL是实时编译，所以将该组件称为JIT实时编译器。 JITCompiler执行流程： JITCompiler函数被调用时，会在定义（该类型的）程序集的元数据中查找被调用的方法IL，然后验证IL代码，并将其编译成CPU指令。随后编译好的CPU指令被保存到动态分配的内存块中。 JITCompiler再次回到CLR为类型创建的内部数据结构，找到调用方法对应的记录，修改最初对JITCompiler的引用，使其指向动态内存块（编译好的本机CPU指令）的地址。 最后JITCompiler函数跳转到动态内存块中的代码。代码执行完毕并返回到Main中代码，继续执行。 当Main要第二次调用WriteLine时会直接执行内存块中代码，完全跳过JITCompiler函数。 JIT编译器的执行思路启示： 方法调用只有在第一次时才会由性能损失 将本机CPU指令存储到动态内存中，一旦程序终止，编译好的代码也会被丢弃。如果再次运行程序，或同时启动应用程序两个实例，JIT编译器都会再次编译IL代码。会增加内存损耗。 第一次调用的性能损失：第一次调用性能损失并不严重，方法内部时间比调用时间多的多。同时CLR的JIT编译器会对本机代码做优化。具体优化如下： 使用optimize-，将包含许多NOP（no operation,空操作）指令，还有许多跳转到下一行代码的指令。如果生成优化的IL代码，C#编译器会删除掉多余的NOP和分支指令。在控制流程被优化之后，就不能单步调试了。优化后的代码更小。优化后IL更易读。 指定/debug(+/full/pdbonly)，编译器会生成Program Database(PDB)文件，PDB文件帮助调试器查找局部变量并将IL指令映射到源代码。 指定/debug:full，告诉编译器打算调试程序集，JIT编译器会记录每条IL指令生成的本机代码 不指定/debug:full，不记录IL与本机代码的联系，使JIT编译器运行块内存消耗少。 如果进程用VS调试器启动，会强迫JIT编译器记录IL与本机代码的联系，无论设置说明。VS在项目-调试指定/optimize+和/debug:pdbonly开关。 托管程序的性能超过非托管应用程序： JIT编译器能判断应用程序运行在什么类型的CPU上，针对性生成对应CPU的代码，非托管程序不会对CPU有针对性。 JIT编译器会针对特定类型的CPU进行代码优化。 IL重新编译成本机代码时，会重新组织减少不正确的分支。 .NET Framework SDK配套提供NGen.exe工具，该工具可以将所有IL代码编译成本机代码，保存在磁盘文件中，在运行加载程序集时，CLR自动判断是否存在该程序集的预编译版本，如果是就直接加载预编译代码。 可以使用System.Runtime.ProfileOptimization类，该类导致CLR检查程序运行时哪些方法被JIT编译，结果被记录到一个文件。 4.1 IL和验证\rIL基于栈，所有的指令都要将操作数压入栈，并从栈弹出结果。 IL指令是无类型的，IL提供了add指令将压入栈的最后两个操作数加到一起，add指令不分32还是64，add指令执行时，它判断栈中的操作数的类型，并执行恰当操作。 IL最大优势不是对底层CPU的抽象，而是应用程序的健壮性和安全性。将IL编译成本机CPU指令，CLR执行一个名为验证的过程，验证会检查IL代码，会核实调用每个方法都有正确数量的参数和参数类型，返回值都正确。托管模块的元数据包含验证过程需要的所有方法及其类型信息。 Windows每个进程都有自己的虚拟地址空间，获得健壮性和稳定性，一个进程干扰不到另一个进程。 通过托管代码，可以确保代码不会不正确的访问内存，不会干扰另一个应用程序的代码，可以将多个托管应用程序放到同一个windows虚拟地址空间运行。 Windows进程需要大量操作系统资源，一个进程运行多个应用程序可以增强性能。 CLR提供了一个操作系统进程中执行多个托管应用程序的能力，每个应用程序都在一个AppDomain中执行，每个托管EXE文件默认在它自己的独立地址空间中运行，这个地址空间只有一个AppDomain。CLR宿主进程（IIS或Microsoft SQL Server）可决定一个进程运行多个AppDomain。 4.2 不安全的代码\rMicrosoft C#编译器默认生成可验证的安全代码，同时也允许开发不安全的代码，不安全的代码可以直接操作内存地址，操作这些地址处的字节。如果要编写不安全代码，C#编译器要求所有不安全代码都需要使用unsafe 关键字标记，同时还需要打开/unsafe编译器开关。 JIT编译器编译unsafe方法时，会检查程序集是否被授予System.Security.Permissions.SecurityPermission权限，而且System.Security.Permissions.SecurityPermissionFlag的SkipVerification标志是否设置，如果设置才会编译代码，允许代码执行，如果标志没有设置会抛出System.InvalidProgramException或System.Security.VerificationException异常，禁止执行方法。 从本地计算机或网络共享加载的程序集默认被授予完全信任，能做任何事情包括不安全代码。 从Internet执行的程序集默认不会被授予执行不安全代码的权限。 可以使用Microsoft提供的名为PEVerify.exe的实用程序，用它检查程序集的所有方法，并报告其中含有不安全方法。在引用未知程序集时可以先运行PEVerify.exe，验证是否出现问题。 PEVerify.exe验证程序集时，必须保证其能够定位并加载引用所有程序集。PEVerify.exe使用CLR来定位依赖的程序集，使用和执行其他程序集一样的绑定和探测规则来定位程序集。 IL的知识产权问题： 生成的IL可以被反汇编器逆向功能，还原应用程序源代码。 服务端代码，知识产权完全安全 客户端，使用混肴器，打乱程序集元数据中所有私有符号的名称。 使用加密算法，例用CLR的互操作功能来实现应用程序的托管与非托管部分之间的通信。 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:1:4","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"5 本机代码生成器：NGen.exe\rNGen.exe将IL编译成本机代码。编译好后就不需要JITCompiler实时编译，提升一部分性能。优势： 提高应用程序的启动速度。 减小应用程序的工作集。编译后的本机代码保存为单独文件。文件可以通过内存映射的方式，同时映射到多个进程地址空间中，使代码得到共享，避免每个进程都需要一份单独代码。 NGen.exe编译过程： NGen.exe新建一个程序集文件，只包含本机代码，不含任何IL，新文件会放到%SystemRoot%\\Assembly\\NativeImage_v4.0.#####_64这样一个目录下的一个文件夹，目录文件除了CLR版本号，还会描述本机代码一些信息，32位还是64位。 当CLR加载程序集文件，会检查是否存在有对应的NGen.exe生成的本机文件，找到就使用本机文件中编译好的代码。没有找到就调用JITCompiler实时编译。 NGen.exe存在的问题： 没有知识产权保护，在运行时CLR还是要求访问程序集的元数据(用于反射和序列化功能)，这就要求发布包含IL和元数据的程序集。如果本地代码不能执行，则CLR还是会启动JITCompiler 失去文件同步，任何不匹配的特性都可能使得本地文件不可用。 CLR版本改变 CPU类型改变 Windows操作系统改变，安装补丁 程序集的标识模块版本 引用程序集版本 安全性改变 较差的执行时性能：NGen不能优化使用特定的CPU指令。 最好不要使用NGen，那么怎么解决客户端启动慢的问题，小型程序不需要，大型程序可以使用Microsoft提供的Managed Profile Guided Optimization工具（MPGO.exe）。该工具分析程序执行，检查在启动时哪些需要启动。 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:1:5","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"6 Framework类库入门\r.NET Framework包含Framework类库(Framework Class Library,FCL)，微软还有其他库Windows Azure SDK 和Direct SDK, Web 服务(Web service):Microsoft的Asp.net xml web service 和windows communication foundation (WCF)技术，处理Internet发送的消息 基于Html的web窗体/MVC应用程序：Asp.net查询数据库并调用Web服务，合并和筛选返回的消息。 Windows GUI应用程序：不用网页创建UI，用Window Store,Windows Presentation Foundation（WPF）或者Windows Forms Windows控制台应用程序：控制台应用程序提供了一种快速简单的方式来生成应用程序 Windows服务：通过Windows服务控制管理器(Service Control Manager,SCM)控制这些服务。 数据库存储过程：Microsoft的SQLserver,IBM的DB2以及Oracle的数据库服务器 组件库：.NetFramework 允许生成独立程序集 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:1:6","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"7 通用类型系统\rCLR一切都是围绕着类型，Microsoft定制了一套正式规范来描述类型的定义和行为，称为通用类型系统(Common Type System,CTS) CTS规范规定，一个类型可以包含成员。 字段Field 方法Method 属性Property 事件Event CTS规范规定类型可见性属性和访问规则。这样就定义了一个类型的可视边界。 Private:只能在同一类中访问。 Family：也叫Protected，成员只能由派生类访问。 family and assembly：成员可有派生类型访问，但是派生类型必须在同一个程序集中定义。 assembly：也叫internal，同一个程序集中任何代码访问。 family or assembly : 也叫protected internal ,成员可由任何程序集中的派生类型访问。 public: 成员可由任何程序集中的任何代码访问。 CTS还为类型集成、虚方法、对象生存期等定义了规则。学习某一类型的编程语言后，该编程语言会将自动将语法映射到IL ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:1:7","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"8 公共语言规范CLS\r微软提供了一个最小功能集合，任何语言只要支持这个功能集，生成的类型就能兼容其他符合CLS的组件。最小的语言功能集合称为公共语言规范(Common Language Specification ,CLS) #if !DEBUG #pragma warning disable 3002, 3005 #endif using System; // Tell compiler to check for CLS compliance [assembly: CLSCompliant(true)] namespace SomeLibrary { // Warnings appear because the class is public public sealed class SomeLibraryType { // Warning: Return type of 'SomeLibrary.SomeLibraryType.Abc()' // is not CLS-compliant public UInt32 Abc() { return 0; } // Warning: Identifier 'SomeLibrary.SomeLibraryType.abc()' // differing only in case is not CLS-compliant public void abc() { } // No warning: Method is private private UInt32 ABC() { return 0; } } } [assembly: CLSCompliant(true)]特性应用于程序集，编译器会检查其中任何公开类型，判断是否存在任何不合适的构造阻止了其他编程语言中访问该类型。 在CLR中，类型的每个成员要么是方法（行为），要么是字段（数据） #pragma warning disable 660, 661, 67 using System; internal sealed class Test { // Constructor public Test() { } // Finalizer ~Test() { } // Operator overload public static Boolean operator ==(Test t1, Test t2) { return true; } public static Boolean operator !=(Test t1, Test t2) { return false; } // An operator overload public static Test operator +(Test t1, Test t2) { return null; } // A property public String AProperty { get { return null; } set { } } // An indexer public String this[Int32 x] { get { return null; } set { } } // An event #pragma warning disable 67 public event EventHandler AnEvent; #pragma warning restore 67 } 上述代码包含一个构造器，终结器，操作符，属性，索引器，事件。 .NetFrameworkSDK提供IL反汇编器工具（ILDasm.exe）检查最终生成的托管模块： Test类型还有一些节点未列出，包括.class，.custom，AnEvent，AProperty 以及Item,它们标识了类型的其他元数据。这些节点不映射到字段或方法，只是提供了类型的一些额外信息，供CLR、编程语言或者工具访问。例如，工具可以检测到Test类型提供了一个名为AnEvent的事件，该事件借山两个方法(add_AnEvent和remove-AnEvent)公开。 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:1:8","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"9 与非托管代码的互操作性\rCLR支持三种互操作情形 托管代码能调用DLL中非托管函数：托管代码通过P/Invoke（PlatformInvoke）机制调用DLL中的函数。FCL中许多类型都要从内部调用Kernel32.dll和User32.dll导出的函数。 托管diamagnetic可以使用现有COM组件(服务器)：许多公司实现大量非托管的COM组件，利用这些组件的可以创建一个托管程序集来描述COM组件。托管代码可以像访问其他任何托管类型一样访问托管程序集中的类型。参考.Net Framework SDK提供的Tlblmp.exe工具。 非托管代码可以使用托管类型(服务器)：非托管代码要求提供COM组件来确保代码工作，使用托管代码可以简单实现这些组件，避免所有代码不得不和引用计数以及接口打交道。使用C#创建ActiveX控件或shell扩展。 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:1:9","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"生成、打包、部署和管理应用程序及类型\r","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:2:0","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"1 NET Framework部署目标\rWindows多年来一直因为不稳定和过于复杂而口碑不佳。有以下几个原因。 所有的应用程序都使用动态链接库(Dynamic Library,DLL)，不同的厂商更新DLL会影响其他应用程序。 安装的复杂性，大多数应用程序在安装时都会影响系统的全部组件。 安全性，安装时会有各种各样的文件，其中许多是由不同公司开发的。web应用程序进场会悄悄下载一些代码，这些代码能执行任何操作，包括删除文件或发送电子邮件。 微软面对这些问题在做很多的努力： Windows安全性基于用户身份，而代码访问安全性允许宿主设置权限。控制加载的组件能做的事情。.NET Framework允许用户灵活地控制哪些东西能够安装，哪些东西能够运行，对自己及其的控制上升了一定高度。 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:2:1","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"2 将类型生成到模块中\r例子： public sealed class Program { public static void Main() { System.Console.WriteLine(\"Hi\"); } } 该程序定义Program类型，有一个名为Main的Public static方法，Main中引用了另一个类型System.Console。System.Console是Microsoft实现好的类型，实现这个类型的各个方法的IL都存储在MSCorLib.dll文件中。 将上面的源代码放到一个源代码文件中，假设是Program.cs，然后执行命令行命令 csc.exe /out:Program.exe /t:exe /r:MSCorLib.dll Program.cs 这个命令指示编译器生成Program.exe可执行文件(/out:Program.exe)。生成的文件是Win32控制台应用程序类型(/t[arget]:exe) 编译器编译时发现引用System.Console类型的WriteLine方法，编译器首先核实该类型确实存在，确实有WriteLine方法，而且方法传递的实参和方法形参匹配。然后告诉编译器外部引用，添加了/r[eference]：MSCorLib.dll开关， MSCorLib.dll是特殊文件，它包含核心类型包括Byte,Char,String,Int32等等，编译器其实会自动引用MSCorLib.dll程序集。简化命令 csc.exe /out:Program.exe /t:exe Program.cs 此外/out:Program.exe和/t:exe开关是编译器默认的，可以继续简化 csc.exe Program.cs 生成的Program.exe文件是标准的PE(可移植执行体，Portable Executable)文件。运行32或64位Windows的计算机可以加载，并执行某些动作。Windows支持三种应用程序 控制台用户界面：Console User Interface， CUI使用 /t:exe开关 图形用户界面:Graphical User Interface,GUI使用/t:winexe开关 Windows Store应用/t:appcontainerexe开关 响应文件：是包含一组编译器命令行开关的文本文件。响应文件以.rsp结尾 使用CSC.exe传递响应文件执行命令，在@符号之后指定响应文件的名称。 假设响应文件MyProject.rsp： /out:MyProject.exe /target:winexe 调用： csc.exe @MyProject.rsp CodeFile1.cs CodeFile2.cs C#编译器支持多个响应文件，同时还会自动查找名位CSC.rsp的文件，查找CSC.exe所有目录下全局查找CSC.rsp的文件，本地和全局响应文件中的设置冲突，将以本地设置为准，命令行上显示指定设置将覆盖本地响应文件中的设置。 .NET Framework 安装时会在%SystemRoot%\\Microsoft.NET\\Framework(64)\\vX.X.X目录中安装默认全局CSC.rsp文件，文件如下:C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319： # This file contains command-line options that the C# # command line compiler (CSC) will process as part # of every compilation, unless the \"/noconfig\" option # is specified. # Reference the common Framework libraries /r:Accessibility.dll /r:Microsoft.CSharp.dll /r:System.Configuration.dll /r:System.Configuration.Install.dll /r:System.Core.dll /r:System.Data.dll /r:System.Data.DataSetExtensions.dll /r:System.Data.Linq.dll /r:System.Data.OracleClient.dll /r:System.Deployment.dll /r:System.Design.dll /r:System.DirectoryServices.dll /r:System.dll /r:System.Drawing.Design.dll /r:System.Drawing.dll /r:System.EnterpriseServices.dll /r:System.Management.dll /r:System.Messaging.dll /r:System.Runtime.Remoting.dll /r:System.Runtime.Serialization.dll /r:System.Runtime.Serialization.Formatters.Soap.dll /r:System.Security.dll /r:System.ServiceModel.dll /r:System.ServiceModel.Web.dll /r:System.ServiceProcess.dll /r:System.Transactions.dll /r:System.Web.dll /r:System.Web.Extensions.Design.dll /r:System.Web.Extensions.dll /r:System.Web.Mobile.dll /r:System.Web.RegularExpressions.dll /r:System.Web.Services.dll /r:System.Windows.Forms.Dll /r:System.Workflow.Activities.dll /r:System.Workflow.ComponentModel.dll /r:System.Workflow.Runtime.dll /r:System.Xml.dll /r:System.Xml.Linq.dll 全局CSC.rsp可以带来极大便利，不需要再每次编译都指定。可以使用/noconfig命令行开关，编译器忽略本地和全局CSC.rsp ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:2:2","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"3 元数据概览\r托管PE文件由4部门构成：PE32(+)头，CLR头，元素据以及IL. PE32(+)头：Windows要求的标准信息 CLR头：一个小的信息块，需要CLR的模块(托管模块)特有的。包含面向CLR的major(主)和minor(次)版本号；一些标志(flag)；一个MethodDef token(稍后详述),该token指定了模块的入口方法(这个模块是CUI,GUI,或WIndowsStore执行体)；一个可选的强名称数字签名，还包含模块的一些元数据表的大小和偏移量。可以查看CorHdr.h头文件定义的IMAGE_COR20_HEADER了解CLR头的具体格式。 元数据：几个表构成的二进制数据块。由三种表：定义表definition table，引用表reference table，清单表manifest table。 定义表列举一些： 源代码的任何改变都会导致上面列出表中创建一个记录项，编译器还会检查源代码引用类型、字段、方法、属性和事件，并创建相应的元数据表记录项。 引用表列举一些： 微软提供了很多工具检查托管PE文件中的元数据。推荐ILDasm.exe,IL Diasaaembler(IL反汇编器)，执行命令行：ILDasm Program.exe ILDasm中选择视图、统计 可以看到文件大小即字节数以及文件各部分大小（字节数和百分比） ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:2:3","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"4 将模块合并成程序集\r程序集:是一个或多个类型定义文件及资源文件的集合。 在这些文件中，有一个文件中容纳了清单(manifest)。清单是一个元数据表集合，主要包含作为程序集组成部分的那些文件名称。清单还描述了程序集的版本、语言文化、发布者、公开导出类型及构成程序集的所有文件。 CLR操作程序集，首先要加载元数据表中清单文件，根据清单来获取程序集中其他文件的名称。 程序集的清单表重要特征： 定义了可重用的类型 用一个版本号标记 可以关联安全信息 程序集大多数情况下只有一个文件，有些情况下还有多个文件构成：一些是含有元数据的PE文件，另一些是.GIF或.JPG这样的资源文件。程序集视为逻辑EXE或DLL 为什么引入程序集概念，因为使用程序集可以便于重用和物理标识分开。可以将常用的类型放到一个文件中，不常用的放到另一个文件中。 为了配置应用程序载入程序集文件，可在应用程序配置文件中指定codeBase元素，codeBase定义了URL指向的未知，找到程序集的所有文件。例如：加载程序集的一个文件时，CLR获取codeBase元素的URL，检查机器的下载缓存，判断文件是否存在。如果是直接加载文件，不是，CLR去URL指向的位置将文件下载到缓存中，如果找不到抛出FileNotFoundException异常。 使用多文件程序集的理由： 不同的类型用不同的文件，使文件能以增量方式下载。可以进行部分或分批打包部署。 可以在程序集中添加资源或数据文件。 程序集包含的各个类型可以用不同的编程语言来实现。 生成程序集要么选择现有PE文件作为清单的宿主，要么创建单独的PE文件。 将托管模块转换成程序集清单元数据表： 有了清单，程序集用户不必关心程序集的划分细节。清单也使程序集具有自描述性。 程序集文件中还有一个AssemblyRef表，程序集全部文件引用的每个程序集在这个表中都有一个记录项，工具只需打开程序集的清单，就可知道它引用的全部程序集，而不必打开程序集的其他文件。同样地，AssemblvRef的存在加强了程序集的自描述性 使用以下命令行，C#编译器会生成程序集 /t[arget]:exe生成CUI执行体 /t[arget]:winexe生成GUI执行体 /t[arget]:appcontainer生成windows store执行体 /t[arget]:library生成类库 /t[arget]:winmdobj生成WINMD库 /t[arget]:module生成不包含清单元数据表的PE文件。 VS集成开发环境不能直接创建多文件程序集，只能用命令行工具创建多文件程序集。 怎么向程序集中添加模块： 含清单的PE文件可以使用/addmodule开发。生成多文件程序集，假设两个源码文件RUT.cs含有不常用类型和FUT.cs含有常用类型 csc /t:module RUT.cs，创建含有不常用类型的托管模块。生成RUT.netmodule文件。这是一个标准DLL PE文件，但是CLR不能加载 同样的方式编译另一个模块，这个模块作为程序集清单的宿主。将程序集命名为MultiFileLibrary.dll,而不是FUT.dll csc /out:MultiFileLIbrary.dll /t:library /addmodule:RUT.netmodule FUT.cs C#编译器编译FUT.cs生成MultiFileLibrary.dll。/t:library：生成含有清单元数据表的DLL PE文件。/addmodule:RUT.netmodule告诉编译器RUT**.netmodule**文件是程序集的一部分，其实就是将文件添加到FileDef清单元数据表，并将RUT.netmodule的公开导出类型添加到ExportedTYpesDef清单元数据表。 生成MultiFileLibrary.dll程序集后，可用ILDasm.exe检查元数据的清单表。 FileDef和ExportedTypesDef元数据表的内容： 客户端代码必须使用/r[eference]:MultiFileLibrary.dll编译器开关生成，才能使用MultiFileLibrary.dll程序集类型。该开关指示程序集搜索外部类型时加载MultiFIleLibrary.dll程序集以及FileDef表中列出的所有文件。如果删除RUT.netmodule文件C#编译器会报告一下错误：fatal error CS0009：未能打开元数据文件“C:\\MultiFileLibrary.dll”-“导入程序集” “C:\\MultiFileLibrary.dll”的模块“RUT.netmodule”时出错-系统找不到指定文件 当一个方法首次调用时，CLR检测作为参数，返回值，局部变量而被方法引用的类型。如果文件存在直接执行，不存在执行内部登记并允许使用该类型。只有方法被调用确实引用了未加载程序集时才会加载程序集。 Vs添加引用：添加引用-引用管理器。COM选项允许从托管代码中访问非托管COM服务器。 使用程序集链接器\r除了C#编译器还可以使用程序集连接器的使用程序AL.exe来创建程序集 程序集包含不同编译器生成的模块 生成程序集时不清楚打包要求， AL.exe生成只包含资源的程序集，也就是附属程序集。 使用AL.exe生成MultiFileLibrary.dll csc /t:module RUT.cs csc /t:module FUT.cs al /out:MultiFileLibrary.dll /t:library FUT.netmodule RUT.netmodule 这个程序集由三个文件构成：MultiFileLibrary.dll,RUT.netmodule和FUT.netmodule,程序链接器不能将多个文件合并成一个文件。 csc /t:module /r:MultiFileLibrary.dll Program.cs 将Program.cs生成Program.netmodule文件。 al /out:Program.exe /t:exe /main:Program.Main Program.netmodule 生成包含清单元数据表的Program.exe PE文件。 由于使用了/main:Program.Main命令行开关，AL.exe生成一个小的全局函数，名为_EntryPoint。 @echo off Rem %1=\"$(DevEnvDir)\", %2=\"$(SolutionDir)\", %3=\"$(OutDir)\" rem Set all the VS environment variables pushd %1 call ..\\Tools\\VSVars32.bat popd rem Change to the solution directory cd %2 REM There are two ways to build this multi-file assembly REM The line below picks one of those ways Goto Way1 :Way1 csc /t:module /debug:full /out:Ch02-3-RUT.netmodule Ch02-3-RUT.cs csc /t:library /debug:full /out:Ch02-3-MultiFileLibrary.dll /addmodule:Ch02-3-RUT.netmodule Ch02-3-FUT.cs Ch02-3-AssemblyVersionInfo.cs md %3 move /Y Ch02-3-RUT.netmodule %3 move /Y Ch02-3-RUT.pdb %3 move /Y Ch02-3-MultiFileLibrary.dll %3 move /Y Ch02-3-MultiFileLibrary.pdb %3 goto Exit :Way2 csc /t:module /debug:full /out:Ch02-3-RUT.netmodule Ch02-3-RUT.cs csc /t:module /debug:full /out:Ch02-3-FUT.netmodule Ch02-3-FUT.cs Ch02-3-AssemblyVersionInfo.cs al /out:Ch02-3-MultiFileLibrary.dll /t:library Ch02-3-RUT.netmodule Ch02-3-FUT.netmodule md %3 move /Y Ch02-3-RUT.netmodule %3 move /Y Ch02-3-RUT.pdb %3 move /Y Ch02-3-FUT.netmodule %3 move /Y Ch02-3-FUT.pdb %3 move /Y Ch02-3-MultiFileLibrary.dll %3 move /Y Ch02-3-MultiFileLibrary.pdb %3 goto Exit :Exit 为程序集添加资源文件\rAL.exe创建程序集可用/embed[resource]开关将文件作为资源添加到程序集。将文件内容嵌入最终的PE文件。清单的ManofestResourceDef表会更新反映资源存在。 AL.exe支持/link[resource]开关，同样获取包含资源的文件，但只更新ManifestResourceDef和FileDef表以反映资源存在。资源文件","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:2:4","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"5 程序集版本资源信息\rAL.exe或CSC.exe生成PE文件程序集，还可能在PE文件中嵌入标准Win32版本资源。可以查看文件属性来检查该资源。在源代码中调用System.Diagnostics.FileVersionInfo的静态方法GetVersionInfo方法，传递程序集的路径， using System.Reflection; // FileDescription version information: [assembly: AssemblyTitle(\"MultiFileLibrary.dll\")] // Comments version information: [assembly: AssemblyDescription(\"This assembly contains MultiFileLibrary's types\")] // CompanyName version information: [assembly: AssemblyCompany(\"Wintellect\")] // ProductName version information: [assembly: AssemblyProduct(\"Wintellect (R) MultiFileLibrary's Type Library\")] // LegalCopyright version information: [assembly: AssemblyCopyright(\"Copyright (c) Wintellect 2013\")] // LegalTrademarks version information: [assembly:AssemblyTrademark(\"MultiFileLibrary is a registered trademark of Wintellect\")] // AssemblyVersion version information: [assembly: AssemblyVersion(\"3.0.0.0\")] // FILEVERSION/FileVersion version information: [assembly: AssemblyFileVersion(\"1.0.0.0\")] // PRODUCTVERSION/ProductVersion version information: [assembly: AssemblyInformationalVersion(\"2.0.0.0\")] // Set the Language field (discussed later in the \"Culture\" section) [assembly:AssemblyCulture(\"\")] VS中新建C#项目会在Properties文件夹中自动创建AssemblyInfo.cs文件。 版本号\r前两个编号构成公众对版本的理解。 第三个编号是程序集的build号，如果公司每天更新程序集，需要更新build号， 最后一个指出当前build修订次数。如果某天必须生成2次程序集，revision就递增。 程序集由三个版本号 AssemblyFileVersion 该版本号存储在Win32版本资源中，CLR即不检查也不关心这个版本号，先设置好版本的major/minor部分，然后每次生成就递增build和revision号。资源管理器中能看到这个版本号. AssemblyInformanceVersion 该版本号也存储在Win32中，CLR不检查也不关心，其作用是指出该程序集的产品的版本。 AssemblyVersion 该版本号存储在AssemblyDef清单数据表中，CLR在绑定到强命名程序集时会用到它。这个版本号唯一标识了程序集。开始开发程序集时，应该设置号major/minor/build/revision部分。除非开发下一个版本，否则不要变动。 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:2:5","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"6 语言文化\r程序集还将语言文化Culture作为身份标识的一部分。 含有代码的程序集一般不指定具体语言文化。未指定具体语言文化的程序集称为语言文化中性。 如果包含语言文化特有的资源，微软强烈建以专门创建一个程序集来包含代码和应用程序的默认资源。生成程序集时不要指定具体的语言文化，其他程序集通过引用该程序集来创建和操纵它公开的类型。 只包含语言文化特有的资源，标记语言文化的程序集称为附属程序集。 AL.exe生成附属程序集，使用其/c[ultrue]:text开关指定语言文化。其中text是语言文化字符串。en-US代表英语。部署附属程序集时，应该把它保存到专门的子目录中，子目录名称和语言文化的文本匹配。 假设应用程序的基础目录是C:\\MyApp,与美国英语对应的附属程序集就应该放到C:\\MyApp\\en-US子目录，在运行时，使用System.Resources.ResourceManager类访问附属程序集的资源 可以使用定制特性System.Reflection.AssemblyCultureAttribute代替AL.exe的/culture开关 [assembly:AssemblyCulture(“de-CH”)] 一般不要引用附属程序集。程序集的AssemblyRef记录向只引用语言文化中性的程序集。 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:2:6","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"7 简单应用程序部署(私有部署程序集)\rWindowsStore应用程序集打包有一套严格的规则，VS将应用程序所有必要的程序集打包成一个.appx文件。其中包含的所有程序集都进入一个目录，CLR从该目录加载程序集， 桌面应用，没有任何特殊要求， 其他机制的打包和安装程序集文件。使用.cab文件(从Internet下载使用，压缩文件并缩短下载事件)，MSI文件(由windows的Installer服务MSIExec.exe使用)。使用MSI文件可实现程序集的按需安装。CLR首次尝试加载一个程序集时才安装它。 VS内建的机制发布应用程序，打开项目属性页点击发布标签，利用其中的选项将VS生成的MSI文件复制到网站、FTP服务器或文件路径。MSI安装必备组件，比如.NET Framework或Microsoft SQL Server Express Edition。利用ClickOnce技术，可以自动检查更新。 私有部署程序集：应用程序基于目录或者子目录部署的程序集。程序集为念不和其他应用程序共享。这样可以带来诸多便利，移动复制文件夹就可以。 实现这种间件的部署，是因为每个程序集都用元数据注明了自己引用的程序集，不需要注册表设置。同时引用程序集限定了每个类型的作用域。应用程序总会和它生成和测试时的类型绑定。在COM中，类型是在注册表中登记的，造成机器上运行的任何应用程序都能使用那些类型。 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:2:7","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"8 简单管理控制(配置)\r实现对应用程序控制在应用程序目录放入一个配置文件，安装程序会将配置文件安装到应用程序的基目录，CLR会解析文件内容来更改程序集文件的定位和加载策略；同时计算机管理员或最终用户能创建或修改该文件。 配置文件包含XML代码，既能和应用程序关联，也和机器关联。 例子：假设应用程序的发布者想把MultiFileLibrary程序集文件部署到不同的目录，要求目录结构如下： 不再同一目录下，CLR无法定位这些文件会抛出System.IO.FileNotFoundException异常。为解决这个为题需要创建XML配置文件，并将其部署到应用程序基目录，文件名必须是应用程序主程序集文件名，并加.config扩展名，也就是Program.exe.config，配置文件： CLR定位策略：定位程序集时，先在应用程序基目录查找，如果没有，就查找AuxFiles子目录。可为probing元素的privatePath特性指定多个以分号分隔的路径。每个路径都要相对应用程序基目录，不能使用绝对或相对路径指定应用程序基目录外的目录。这个设计的出发点是应用程序只能控制它的目录及子目录 XML配置文件名称和位置取决于应用程序类型 exe程序，配置文件必须在应用程序基目录，必须采用exe文件全名作为文件名，再附加.config扩展名 对于Microsoft ASP.NET Web窗体应用程序，文件必须再Web应用程序的虚拟根目录中，而且总是命名为Web.config。此外子目录可以包含自己的Web.config，配置设置会得到继承。例如http://Wintellect.com/Training的web应用程序既使用虚拟根目录Web.config设置，也会使用Training子目录。 配置应用机器，.NetFramework安装创建Machine.config，每个版本的CLR都有对应的Machine.config Machine.config所在目录：%SystemRoot%\\Microsoft.NET\\Framework\\version\\CONFIG CLR定位程序集会扫描几个子目录，例子：加载一个语言文化中性的程序集的目录扫描顺序（firstPrivatePath和secondPrivatePath通过配置为念privatePath特性指定） 如果MultiFileLibrary程序集文件部署到MultiFileLibrary子目录，就无需配置文件，因为CLR会自动扫描与目标程序名称符合的子目录。 如果上述的任何子目录都找不到目标应用程序，CLR会从头再来，用.exe扩展名替换.dll扩展名，再找不到就抛出FileNotFoundException异常。 附属程序集遵循的规则，CLR会再应用程序基目录下的一个子目录中查找，子目录名称与语言文化相符，假如AsmName.dll应用了“en-US”语言文化，会探测以下目录 CLR会扫描具有.exe或.dll扩展名的文件，这个是比较耗时的，所以最好在XML配置文件中指定一个或多个culture元素。限制CLR查找附属程序集的扫描。 Machine.config文件的设置是机器上运行的所有应用程序的默认设置。最好不要修改。 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:2:8","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"共享程序集和强命名程序集\r进行私有部署，程序集放在应用程序的基目录或子目录，可以保证对程序集的命名版本和行为进行全面控制。 共享程序集：由多个应用程序共享的程序集。Microsoft .NET Framework 携带程序集就是典型的全局部署程序集。所有托管程序都需要使用Microsoft中的.Net Framework Class Library（FCL） Windows稳定性很差，是因为共享程序集出现问题，在出现问题的时候修复BUG同时添加新功能，是完全不可能的。退而求其次，在出现问题的时候，有一种简单的方式将应用程序恢复到上一次已知的良好状态。 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:3:0","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"1 两种程序集、两种部署\rCLR支持两种程序集：弱命名程序和强命令程序集。 弱命名和强命名程序集在结构上完全相同，真正的区别在于使用发布者的公钥/私钥进行了签名。这一对密钥允许对程序集进行唯一性的标识，保护和版本控制，并允许程序集部署到任何地方。 程序集一旦被唯一性标识，CLR可以应用一些已知的安全策略。 弱命名程序集只能私有部署，强命令程序集可以私有可以公有 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:3:1","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"2 为程序集分配强名称\r两个相同名的程序集放到一个目录下就以最后安装的程序集为准。 只根据为念名来区分程序集显然不够，CLR支持对程序集进行唯一性标识机制。 强命名程序集：共同对程序集进行唯一性标识：文件名(不计扩展名)、版本号、语言文化和公钥。公钥数字很大，所以经常使用从公钥派生的最小哈希值，称为公钥标记。例如下面标识了四个不同的程序集 必须有一种技术能够区分相同特征的程序集。Microsoft选择了标准的公钥/私钥加密技术，没有采用唯一性标识（GUID:全球唯一标识符，URL：同一资源定位，URN：统一资源名） 使用加密技术，不仅能在程序集安装到机器时检查二进制数据的完整性，还可以允许每个发布者授予一套不同的权限。 如果公司想要唯一性标识自己的程序集，必须创建一对公钥/私钥，公钥可以和程序集关联。 辅助类System.Reflection.AssemblyName轻松构造程序集名称，并获取程序集的各个组成部分，几个公共实例属性：CultureInfo,FullName,KeyPair,Name和Version.方法：GetPublicKey,GetPublicKeyToken,SetPublicKey和SetPublicKeyToken. 创建强命名程序集： 用.NET Framewrk SDK和Microsoft Visual Studio带的Strong Name实用程序(SN.exe)获取密钥。SN.exe允许通过多个命令行开关来使用一整套功能。 SN -k MyCompany.snk 使用SN.exe创建MyCompany.snk文件，文件中包含二进制形式的公钥和私钥。 公钥数字很大，可以使用SN.exe查看实际公钥。执行两次SN.exe。使用-p开关可以创建只含公钥的文件(MyCompany.PublicKey) SN -p MyCompany.snk MyCompany.PublicKey sha256 第二次使用-tp开关就行 SN -tp MyCompany.PublicKey SN.exe未提供任何显示私钥的途径。 可以发现公钥非常大，简化开发又设计了公钥标记，公钥标记是公钥64位哈希值，SN.exe的-tp开关输出结果显示了公钥标记。 创建含有公钥/私钥对的程序集，使用/keyfile:\u003cfile\u003e编译开关。 csc /keyfile:MyCompany.snk Program.cs C#编译器查到/keyfile:\u003cfile\u003e开关会指定打开文件MyCompany.snk，用私钥对程序集进行签名，并将公钥嵌入清单。注意只能对含清单的程序集文件进行签名，程序集其他文件不能被显示签名。 VS中创建公钥私钥，项目属性-签名-为程序集签名-选择强名称密钥文件，新建。 对文件签名的准确含义是：生成强命名程序集时，程序集的FileDef清单元数据表列出构成程序集的所有文件。每将一个文件名添加到清单，都会对文件内容进行哈希处理，哈希值和文件名一并存储到FileDef表。 如果想覆盖默认哈希算法，可使用AL.exe的/algid开关，在程序集源代码文件中使用特性，System.Reflection.AssemblyAlgorithmIdAttribute.默认使用SHA-1算法。 对PE文件的完整内容进行哈希处理。哈希值用发布者的私钥进行签名。得到RSA数字签名存储到PE文件的保留区域。PE文件的CLR进行更新。 发布者公钥也嵌入PE文件的AssemblyDef清单元数据表。文件名、程序集版本号、语言文化和公钥的组合保证程序集是强名称，唯一性。 托管模块的AssemblyRef元数据表，每个记录项都被指明引用程序集的名称、版本号、语言文化和公钥信息 简单类库DLL文件的AssemblyRef元数据信息 这个DLL引用了以下特性的程序集类型 检查程序集的AssemblyDef元数据表 等价于 没有公钥标记，就是弱命名程序集， 用SN.exe创建密钥文件，再用/keyfile编译器进行编译， 使用ILDasm.exe查看新程序集的元数据，AssemblyDef记录项就会在PublicKey字段之后显示相应字节。AssemblyDef记录项总是存储完整公钥，而不是公钥标记。 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:3:2","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"3 全局程序集缓存\r程序集放到公认的目录，而且CLR在检测到对该程序集引用时，必须知道检查该目录。这个公认位置就是全局程序集缓存（Global Assembly Cache,GAC）， %SystemRoot%\\Microsoft.NET\\Assembly GAC目录结构化：包含子目录，子目录名称用算法生成。永远不要将程序集文件手动复制到GAC目录，用工具完成这项任务，工具知道GAC内部结构，并知道如何生成正确的子目录名。 开发和测试GAC中安装强命名程序集工具是GACUtil.exe，直接启动会显示语法。 GACUtil.exe的/i开关将程序集安装到GAC，/u开关从GAC卸载程序集。不能将弱命名程序集放到GAC中。如果放入会报错。 GAC默认只能由Windows Administrators用户组成员操作。 .NetFramework不携带GACUtil.exe工具，应该使用Windows Installer（MSI） 程序集安装到GAC破坏了一个基本目标，简单安装，备份还原移动和卸载应用程序，程序集尽量私有。 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:3:3","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"4 在生成的程序集中引用强命名程序集\r任何程序集都包含对其他强命名程序集的引用，System.Object在MSCorLib.dll中定义。 使用CSC.exe的/reference编译器开关指定想引用的程序集。CSC.exe会加载指定文件，根据元数据生成程序集。如果没有指定文件路径，CSC.exe会尝试以下目录查找程序集。 工作目录 CSC.exe所在的目录，目录中还包含CLR的各种DLL文件。 使用/lib编译器开关指定任何目录 使用LIB环境变量指定的任何目录。 生成的程序集引用了Microsoft的System.Drawing.dll，执行CSC.exe使用/reference:System.Drawing.dll开关。依次检查上述目录，并在CSC.exe所在的目录找到System.Drawing.dll文件（运行时不会从这个目录查找程序集）。 安装.net framework时，安装Microsoft程序集文件两套拷贝。一套安装带编译器/CLR目录方便生成程序集，一套安装GAC子目录，方便运行时加载。 CSC.exe编译器之所以不再GAC中查找引用程序集。是因为代码者必须知道程序集路径，GAC也没有正式公开，还有一种方案是指定一个很长的字符串，比如“System.Drawing,Version=v4.0.0.0,Culture=neutral,PublicKeyToken=b03f5f7f11d50a3a”,两个方案都没有在用户硬盘上安装两套一样的程序集方便。 编译器/CLR目录中程序集不依赖机器，也就是说这些程序集只包含元数据。由于编译时不需要IL代码，GAC中程序集同时包含元数据和IL代码， ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:3:4","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"5 强命名程序集能防篡改\r用私钥对程序集签名，同时将公钥和签名嵌入到程序集，CLR可验证程序集未被修改或破坏。 程序集安装到GAC时，系统对包含清单的每个文件的内容进行哈希处理，将哈希值与PE文件中嵌入的RSA数字签名进行比较（在用公钥接触签名之后）。如果两个值完全一致，说明文件内容没有被篡改。系统还对程序集中的其他文件进行哈希处理，并将哈希值与清单文件FileDef表中存储的哈希值进行比较，任何一处哈希值不匹配，表明至少有一个文件被篡改，程序集无法安装GAC。 应用程序需要定位程序集，CLR根据引用程序集的属性(名称，版本，语言文化和公钥)，在GAC中定位程序集，找到引用程序集就返回包含它的子目录，并加载清单所在的文件，这种方式查找程序集，可以保证运行时加载程序集和最初编译时生成的程序集来自同一个发布者。引用程序集的AssemblyRef表中公钥标记与被引用程序集的AssemblyRef表的公钥匹配。如果被引用程序集不在GAC中，CLR会查找应用程序的基目录，然后查找应用程序配置文件中标注的任何私有路径。如果应用程序是MSI安装，CLR要求MSI定位程序集，然后都找步到程序集，那么绑定失败，抛出System.IO.FileNotFoundException。 强命名程序集文件从GAC之外位置加载（应用程序基目录，配置文件codeBase元素），CLR在加载程序集后比较哈希值，也就是每次应用程序执行加载程序集，都会对文件进行哈希值，如果不匹配会抛出System.IO.FileLoadException异常。 强命名程序集安装到GAC时，系统会执行检查，确保清单的文件没有被篡改，该检查知会在安装时执行一次，同时强命名程序集完全被信息，并加载到完全信息的AppDomain中，CLR将不检查程序集是否被篡改。如果从非GAC的目录加载强命名程序集时，CLR会校验程序清单文件。 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:3:5","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"6 延迟签名\r在准备打包自己的强命名程序集时，必须使用私钥对其进行签名，但是在开发和测试程序集时，访问私钥保护的程序集比较繁琐，所以.NetFramework提供了延迟签名技术，也成为部分签名，就是暂不使用私钥，用公钥生成程序集。使用公钥，引用程序集的其他程序集在AssemblyRef元数据表的记录中嵌入公钥值。同时还使得程序集能能够正确存储到GAC的内部结构中。 如果不用私钥对文件进行签名就无法实现防篡改，因为无法对程序集文件进行哈希处理，无法在文件中嵌入数字签名。 C#编译器可以指定/delaysign编译器开关，如果vs就打开项目属性也，在签名选项卡中勾选仅延迟签名，如果AL.exe就指定/delay[sign]命名行开关。如果想实现延迟签名，获取存储在文件中的公钥，需要将公钥文件的文件名传给生成程序集的实用程序。 编译器一旦检测到对程序集进行延迟签名，就会生成程序集的AssemblyDef清单记录想，其中包含程序集的公钥，公钥使程序集能够正确存储到GAC中。同时也不影响引用该程序集的其他程序集的生成。进行引用程序集的AssemblyRef元数据记录项中，包含（被引用程序集的）正确公钥，创建程序集使，会在生成PE文件中为RSA数字签名预留空间。文件内容不会进行哈希处理。 目前程序集没有有效签名，安装GAC会失败。在需要安装到GAC的机器上，需要禁止系统验证程序集完整性，使用SN.exe并指定-Vr命令行开关。这个开关会使得程序集的任何文件在运行时加载，并且CLR会跳过对其哈希值的检查。在内部SN的-Vr开关会将及程序及的身份添加到注册表的子项中： HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\StrongName\\Verification 结束程序集开发和测试后，要正式对其进行签名，以便打包部署。再次使用SN.exe程序使用-R开关，指定包含私钥的文件。-R开关指示SN.exe对文件内容进行哈希处理，并用私钥对其签名，并将RSA数字签名嵌入文件中预留的空间。经过这一步之后，就可以部署完全签名号的程序集。同时不要忘记使用SN.exe的-Vu和-Vx命令行重新启动对程序集的验证。 延迟签名总结： 开发期间，获取公钥，使用/keyfile和/delaysign编译器开关 csc /keyfile:MyCompany.PublicKey /delaysign MyAssembly.cs 使用以下命令可以使CLR暂时信任程序集的内容，不对它进行哈希处理，也不对哈希值进行比较。这样程序集可以顺利安装到GAC。每台机器上都必须执行这一命令。 SN.exe -Ra MyAssembly.dll MyCompany.PrivateKey 准备打包和部署程序集时，使用私钥执行以下命令 SN.exe -Ra MyAssembly.dll MyCompany.PrivateKey 重新启动对程序集的验证 SN -Vu MyAssembly.dll 大公司会将自己的密钥存储到硬件设备(智能卡中)，确保密钥安全性，密钥值不能固定存储在磁盘上。“加密服务提供程序(Cryptographic Service Provider ,CSP)“提供对这些密钥位置进行抽象的容器。如果Microsoft使用CSP为例，一旦访问它提供的容器，就自动从一个硬件设备中获取私钥。 如果公钥/私钥在CSP容器中，必须为CSC.exe、AL.exe和SN.exe指定不同开关。 编译器（CSC.exe）指定/keycontainer开关而不是/keyfile开关 链接时Al.exe指定/keyname开关而不是/keyfile开关 强名称程序SN.exe对延迟签名的程序集重新签名指定-Rc开关而不是-R开关 在打包前，先进行混淆器程序再完全签名。 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:3:6","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"7 私有部署强命名程序集\rGAC安装程序集有几个方面优势： 能被多个应用程序共享，减少总的物理内存 很容易将新版本部署到GAC，让所有程序都通过发布者策略使用新版本。 实现了对程序集多个版本的并行管理 管理员才能安装到GAC，一旦安装到GAC就违反了简单部署的原则 多个应用程序共享的程序集才应部署到GAC。同时，GAC部署新的C:\\Window\\System32垃圾堆积场，因为新版本程序集不会相互覆盖，它们并行安装。 强命名程序集除了部署到GAC或进行私有部署，部署到私有目录，强命名程序集由三个应用程序共享，安装可创建三个目录，每个程序一个目录，再创建四个目录，专门存储共享程序集。每个应用程序安装到自己的目录时都同时安装一个XML配置文件，用codeBase元素指出共享程序集路径。运行时，CLR知道查找共享程序集。 codeBase元素实际标记了一个URL,这个URL可引用机器上的任何目录，也可引用Web地址。如果引用Web地址，CLR自动下载文件，存储到用户缓存（%UseProfile%\\Local Settings\\Application Data\\Assembly下的子目录）。 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:3:7","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"8 运行时如何解析类型引用\rpublic sealed class Program { public static void Main() { System.Console.WriteLine(\"Hi\"); } } 编译代码生成程序集Program.exe，运行应用程序，CLR加载并初始化自身，读取程序集CLR头，查找应用程序入口Main的MethodDefToken,检索MethodDef元数据表找到方法的IL代码载文件中的偏移量，将IL代码JIT编译成本机代码(编译时会对代码进行验证确保类型安全)，执行本机代码。Main方法的IL代码，可以对程序集运行ILDasm.exe并选择视图|显示字节 这些代码进行JIT编译，CLR会检查所有类型和成员的引用，加载它们程序集，上诉对System.Console.WriteLine引用，IL call指令引用元数据token 0A000003，该token标识MemberRef元数据表中(表0A)的记录项3。CLR检查该MemberRef记录项，发现字段引用了TypeRef被引导至一个AssemblyRef记录项：“mscorlib，Version=4.0.0.00,Culture=neutral,PublicKeyToken=b7a5c561934e089”。这时CLR就知道了它需要的是哪个程序集。CLR必须定位并加载该程序集。 解析引用类型时，CLR可能在三个地方找到类型 相同文件 编译时便能发项对相同文件中的类型的访问，这称为早期绑定，类型直接从文件中加载，执行并继续。 不同文件，相同程序集 运行时确保被引用的文件在当前程序元数据的FileDef表中。检查加载程序集清单文件的目录，加载被引用的文件，检查哈希值确保文件完整性。发现类型成员执行继续 不同文件，不同程序集。 引用类型在其他程序集中，运行时会加载被引用程序集的清单文件，如果需要的类型不在该文件中，就继续加载包含类型的文件，发现类型的成员，执行继续。 ModuleDef，FileDef元数据表在引用文件时使用了文件名和扩展名，但AssemblyRef元数据表只使用文件名，无扩展名。和程序集绑定时，系统通过他测目录来尝试定位文件，自动附加.dll和exe。 解析类型引用由任何错误都会抛出异常。 可以向System.AppDomain的AssemblyResolve，ReflectionOnlyAssemblyResolve和TypeResolve事件注册回调方法。 在例子中的过程： 对于CLR，所有程序集都根据名称，版本，语言文化和公钥来标识。但是GAC根据名称版本语言文件公钥和CPU架构来标识。 CLR提供了将类型（类，结构，枚举，接口或委托）从一个程序集移动到另一个程序集的功能。 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:3:8","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"9 高级管理控制(配置)\rXML配置文件的其他元素的作用 参数信息： probing元素：查找弱命名程序集时，检查应用程序基目录下的AuxFiles和bin\\subdir子目录。对于强命名程序集，CLR检查GAC或codeBase元素指定URL.只有未指定codeBase元素时，CLR才会在应用程序私有路径中检查强命名程序集。 第一个dependentAssembly,assemblyIdentity和bindingRedirect元素：查找由控制公钥标记32ab4ba45e0a69a1的组织发布是语言文化为中性的SomeClassLibrary程序集1.0.0.0版本，改为定位同一个程序集的2.0.0.0版本 codeBase元素：尝试查找控制着公钥标记32ab4ba45e0a69a1的组织发布的，语言文化为中性的SomeClassLibrary程序集2.0.0.0版本时，尝试在以下URL发现：www.Wintellect.com/SomeClassLibrary.dll。codeBase元素也能用于弱命名程序集，程序集版本号被据略，根本就不应该再XMLcodeBase元素中些版本号。codeBase定义的URL必须指向应用程序基目录下的子目录。 第二个dependentAssembly,assemblyIdentity和bindingRedirect元素：更改定位同一个程序集 publicsherPolicy元素：其apply的特性设为yes，CLR会在GAC中检查新的册灰姑娘续集版本，并进行程序集发布者认为有必要的任何版本号重定向操作。 发布者控制策略：当发布者创建新的程序集时，需要创建一个配置文件，这个配置文件告诉用户旧版本不用了，更新每台机器上的XML配置文件 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:3:9","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"NetCLRVia","content":"小节\r这样写笔记真是效率太低了，看书也太慢了，实在受不了。以后会尝试用思维导图的笔记方式，知识介绍一个大概，大部分知识点能回想起来，并讲出来就不写下来了，以后如果有遗忘就直接看书复习一下就好。 ","date":"2020-02-22","objectID":"/2020/02/dotnetbase6-netclrvia/:4:0","tags":["NetCLRVia","CLR"],"title":"NetCLRVia CLR","uri":"/2020/02/dotnetbase6-netclrvia/"},{"categories":"SuperSocket1.6","content":"注意：该版本为SuperSocket1.6,最新版已有较大改动 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:0:0","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"Normal Socket\rSystem.Net.Sockets.dll程序集中使用socket类： 服务器： 创建socket:_socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); 创建IP：IPAddress _ip = IPAddress.Parse(ip);_endPoint = new IPEndPoint(_ip, port); 绑定IP地址： _socket.Bind(_endPoint); //绑定端口 服务开启监听：_socket.Listen(BACKLOG); //开启监听，backlog是监听的最大数列 开启监听线程：创建新的监听线程，在监听线程中while调用Socket acceptSocket = _socket.Accept(); 一旦acceptSocket 不为空，说明有客户端连接成功，保存客户端socket，并查看该socket的isConnected属性是否连接socket.RemoteEndPoint.ToString(); 一旦连接创建接收线程，并启动线程，在该线程中创建whilewhile (sInfo.isConnected){sInfo.socket.BeginReceive(sInfo.buffer, 0, sInfo.buffer.Length, SocketFlags.None, ReceiveCallBack, sInfo.socket.RemoteEndPoint);}来接收客户端传来的消息。 **BeginReceive()**有一个回调函数ReceiveCallBack()通过读取byte[]buffer 向客户端发送信息socket.Send(Encoding.ASCII.GetBytes(text)); receivebuffer默认值8192 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:1:0","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"SocketAsyncEventArgs\r异步套接字操作 创建IPEndPoint 创建socketListenerSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); 绑定IP地址ListenerSocket.Bind(e); 开始监听ListenerSocket.Listen(10); 创建异步套接字,并绑定异步完成事件Args = new SocketAsyncEventArgs();Args.Completed += new EventHandler\u003cSocketAsyncEventArgs\u003e(ProcessAccept); 调用socket的AcceptAsync(Args)方法ListenerSocket.AcceptAsync(Args); 在异步套接字完成事件的回调函数中，创建新的异步套接字用于接收客户端传入消息的异步操作。var args = new SocketAsyncEventArgs();args.Completed += new EventHandler\u003cSocketAsyncEventArgs\u003e(OnIOCompleted);args.AcceptSocket = s;s.ReceiveAsync(args)s.ReceiveAsync(args)，s接收的socket的，新建一个异步套接字，并传入ReceiveAsync()方法。 switch (e.LastOperation)case SocketAsyncOperation.Receive: Socket.AcceptAsync(SocketAsyncEventArgs) 方法 返回：如果 I/O 操作挂起，则为 true。 操作完成时，将引发 Completed 参数的 e 事件。read和write是异步完成为true，如果过是同步完成则为false. 如果 I/O 操作同步完成，则为 false。 将不会引发 Completed 参数的 e 事件，并且可能在方法调用返回后立即检查作为参数传递的 e 对象以检索操作的结果。 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:2:0","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"SuperSocket Architecture\rSuperSocket 层次示意图\rReusable IO Buffer Pool：BufferManager类 SuperSocket 对象模型图示意图\rSuperSocket 请求处理模型示意图\rSuperSocket 隔离模型示意图\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:3:0","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"Config\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:3:1","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"Command Filters\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:3:2","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"Log/LogFactory\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:3:3","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"Command Loaders\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:3:4","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"ReceiveFilterFactory\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:3:5","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"ReceiveFilter\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:3:6","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"Connection Filters\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:3:7","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"SocketBase.dll\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:4:0","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"ISessionBase\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:4:1","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"AppSession\r对AppServer和SocketSession的包装 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:4:2","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"ServerConfig\r服务参数配置,在serverbase基类SetUp中创建 /// \u003csummary\u003e /// Setups with the specified ip and port. /// \u003c/summary\u003e /// \u003cparam name=\"ip\"\u003eThe ip.\u003c/param\u003e /// \u003cparam name=\"port\"\u003eThe port.\u003c/param\u003e /// \u003cparam name=\"socketServerFactory\"\u003eThe socket server factory.\u003c/param\u003e /// \u003cparam name=\"receiveFilterFactory\"\u003eThe Receive filter factory.\u003c/param\u003e /// \u003cparam name=\"logFactory\"\u003eThe log factory.\u003c/param\u003e /// \u003cparam name=\"connectionFilters\"\u003eThe connection filters.\u003c/param\u003e /// \u003cparam name=\"commandLoaders\"\u003eThe command loaders.\u003c/param\u003e /// \u003creturns\u003ereturn setup result\u003c/returns\u003e public bool Setup(string ip, int port, ISocketServerFactory socketServerFactory = null, IReceiveFilterFactory\u003cTRequestInfo\u003e receiveFilterFactory = null, ILogFactory logFactory = null, IEnumerable\u003cIConnectionFilter\u003e connectionFilters = null, IEnumerable\u003cICommandLoader\u003cICommand\u003cTAppSession, TRequestInfo\u003e\u003e\u003e commandLoaders = null) { return Setup(new ServerConfig { Ip = ip, Port = port }, socketServerFactory, receiveFilterFactory, logFactory, connectionFilters, commandLoaders); } ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:4:3","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"RootConfig\rMaxWorkingThreads：最大工作线程数量 MaxCompletionPortThreads：线程池中异步 I/O 线程的最大数目。 PerformanceDataCollectInterval：性能数据收集间隔 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:4:4","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"RequestInfo\r类图 基类是RequestInfo，提供了两个方法Key和Body,Body是模板，由子类确定具体类型 StringRequestInfo,在父类基础上提供了一个参数，String[] Parameters RequestInfo\u003cTRequestHeader, TRequestBody\u003e:提供了请求头和请求体类型的模板。 三个接口，key属性，body属性，heater属性 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:4:5","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"ListenerInfo\r监听节点 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:4:6","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"ListenerConfig\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:4:7","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"ReflectCommandLoader\rReflectCommandLoader:通过TryLoadCommands方法反射出程序集中的所有命令 /// \u003csummary\u003e /// Tries to load commands. /// \u003c/summary\u003e /// \u003cparam name=\"commands\"\u003eThe commands.\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public override bool TryLoadCommands(out IEnumerable\u003cTCommand\u003e commands) { commands = null; var commandAssemblies = new List\u003cAssembly\u003e(); if (m_AppServer.GetType().Assembly != this.GetType().Assembly) commandAssemblies.Add(m_AppServer.GetType().Assembly); string commandAssembly = m_AppServer.Config.Options.GetValue(\"commandAssembly\"); if (!string.IsNullOrEmpty(commandAssembly)) { OnError(\"The configuration attribute 'commandAssembly' is not in used, please try to use the child node 'commandAssemblies' instead!\"); return false; } if (m_AppServer.Config.CommandAssemblies != null \u0026\u0026 m_AppServer.Config.CommandAssemblies.Any()) { try { var definedAssemblies = AssemblyUtil.GetAssembliesFromStrings(m_AppServer.Config.CommandAssemblies.Select(a =\u003e a.Assembly).ToArray()); if (definedAssemblies.Any()) commandAssemblies.AddRange(definedAssemblies); } catch (Exception e) { OnError(new Exception(\"Failed to load defined command assemblies!\", e)); return false; } } if (!commandAssemblies.Any()) { commandAssemblies.Add(Assembly.GetEntryAssembly()); } var outputCommands = new List\u003cTCommand\u003e(); foreach (var assembly in commandAssemblies) { try { outputCommands.AddRange(assembly.GetImplementedObjectsByInterface\u003cTCommand\u003e()); } catch (Exception exc) { OnError(new Exception(string.Format(\"Failed to get commands from the assembly {0}!\", assembly.FullName), exc)); return false; } } commands = outputCommands; return true; } } ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:4:8","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"StatusInfoCollection\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:4:9","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"AppServerBase\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:4:10","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"AppSeverBase\u003cTAppSession,TRequestInfo\u003e\rm_CommandContainer：命令容器 m_CommandLoaders m_ConnectionFilters m_GlobalCommandFilters m_Listeners m_SocketServerFactory：在SetupBas ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:4:11","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"Facility.dll\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:5:0","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"PolicyReceiveFilterFactory\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:5:1","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"PolicyRecieveFilter\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:5:2","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"Protocol\rReceiveFilterBase 类图 在SuperSocket.SocketBase.Protocol程序集中 IReceiveFilter\u003cTRequestInfo\u003e接口，接收解析接口 Filter方法，解析会话请求的信息，参数包括，读取缓冲，偏移量，长度，是否copy，没有被解析的长度 LeftBufferSize属性：空余的缓冲区长度 NextReceiveFilter属性，下一个接收解析器 Reset方法，恢复初始化 State:解析器状态，正常和错误状态 ArraySegmentEx\u003cT\u003e数段类 T为数组模板 Array数组，count:数量，Offset偏移量，From从，To到 ArraySegmentList\u003cT\u003e数段列表 实现了一个数组段列表 m_PrevSegment：当前的数段 m_PrevSegmentIndex，数段所在的index ReceiveFilterBase\u003cTRequestInfo\u003e BufferSegments属性 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:5:3","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"SocketEngine.dll\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:6:0","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"PerformanceMonitor\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:6:1","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"SocketSession\r在初始化里对AppSession产生依赖，同时维护Socket和SmartPool(SendingQueue[])，因为维护着socket所以发送接收数据都是通过这个类。 设置状态：AddStateFlag（）TryAddStateFlag（）RemoveStateFlag（）,AddStateFlag：自旋设置m_State状态，线程安全的 m_Client:Socket SessionID:new guid LocalEndPoint:本地Id端 RemoteEndPoint：远程终结点 m_SendingQueuePool：实际是SmartPool类的实例，该实例维护者sendingQueue数组 m_SendingQueue：从SmarlPool中获取一个SendingQueue实例。 方法 Initialize()方法： 初始化m_SendingQueuePool和m_SendingQueue TrySend()方法：参数：IList\u003cArraySegment\u003cbyte\u003e\u003e segments：将segments压入sendingqueue队列并调用StartSend最终是调用SendAsync或SendSync，这个是由子类实现。 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:6:2","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"AsyncSocketSession\r在子类中维护SocketAsyncEventArgs SocketAsyncProxy：维护着SocketAsyncEventArgs m_SocketEventArgSend：发送的SocketAsyncEventArgs实例 在初始化中如果同步发送就使用m_SocketEventArgSend，并OnSendingCompleted方法绑定其Completed事件 在SendAsync()方法中将SendingQueue实例给m_SocketEventArgSend的UserToken属性，并调用m_SocketEventArgSend的SetBuffer和SendAsync方法，发送失败也调用OnSendingCompleted SocketAsyncProxy中的Completed事件中调用ProcessReceive方法，再调用this.AppSession.ProcessRequest(e.Buffer, e.Offset, e.BytesTransferred, true);方法 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:6:3","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"AsyncStreamSocketSession\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:6:4","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"SocketFactory\r/// \u003csummary\u003e /// Creates the socket server. /// \u003c/summary\u003e /// \u003ctypeparam name=\"TRequestInfo\"\u003eThe type of the request info.\u003c/typeparam\u003e /// \u003cparam name=\"appServer\"\u003eThe app server.\u003c/param\u003e /// \u003cparam name=\"listeners\"\u003eThe listeners.\u003c/param\u003e /// \u003cparam name=\"config\"\u003eThe config.\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public ISocketServer CreateSocketServer\u003cTRequestInfo\u003e(IAppServer appServer, ListenerInfo[] listeners, IServerConfig config) where TRequestInfo : IRequestInfo { if (appServer == null) throw new ArgumentNullException(\"appServer\"); if (listeners == null) throw new ArgumentNullException(\"listeners\"); if (config == null) throw new ArgumentNullException(\"config\"); switch(config.Mode) { case(SocketMode.Tcp): return new AsyncSocketServer(appServer, listeners); case(SocketMode.Udp): return new UdpSocketServer\u003cTRequestInfo\u003e(appServer, listeners); default: throw new NotSupportedException(\"Unsupported SocketMode:\" + config.Mode); } } ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:6:5","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"SocketServers\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:6:6","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"AsyncSocketServer\r缓存管理器m_BufferManager 线程安全的SocketAsyncEventArgsProxy栈 构造函数，父类 public TcpSocketServerBase(IAppServer appServer, ListenerInfo[] listeners) : base(appServer, listeners) { var config = appServer.Config; uint dummy = 0; m_KeepAliveOptionValues = new byte[Marshal.SizeOf(dummy) * 3]; m_KeepAliveOptionOutValues = new byte[m_KeepAliveOptionValues.Length]; //whether enable KeepAlive BitConverter.GetBytes((uint)1).CopyTo(m_KeepAliveOptionValues, 0); //how long will start first keep alive BitConverter.GetBytes((uint)(config.KeepAliveTime * 1000)).CopyTo(m_KeepAliveOptionValues, Marshal.SizeOf(dummy)); //keep alive interval BitConverter.GetBytes((uint)(config.KeepAliveInterval * 1000)).CopyTo(m_KeepAliveOptionValues, Marshal.SizeOf(dummy) * 2); m_SendTimeOut = config.SendTimeOut; m_ReceiveBufferSize = config.ReceiveBufferSize; m_SendBufferSize = config.SendBufferSize; } public override bool Start() { try { int bufferSize = AppServer.Config.ReceiveBufferSize; if (bufferSize \u003c= 0) bufferSize = 1024 * 4; m_BufferManager = new BufferManager(bufferSize * AppServer.Config.MaxConnectionNumber, bufferSize); try { m_BufferManager.InitBuffer(); } catch (Exception e) { AppServer.Logger.Error(\"Failed to allocate buffer for async socket communication, may because there is no enough memory, please decrease maxConnectionNumber in configuration!\", e); return false; } // preallocate pool of SocketAsyncEventArgs objects SocketAsyncEventArgs socketEventArg; var socketArgsProxyList = new List\u003cSocketAsyncEventArgsProxy\u003e(AppServer.Config.MaxConnectionNumber); for (int i = 0; i \u003c AppServer.Config.MaxConnectionNumber; i++) { //Pre-allocate a set of reusable SocketAsyncEventArgs socketEventArg = new SocketAsyncEventArgs(); m_BufferManager.SetBuffer(socketEventArg); socketArgsProxyList.Add(new SocketAsyncEventArgsProxy(socketEventArg)); } m_ReadWritePool = new ConcurrentStack\u003cSocketAsyncEventArgsProxy\u003e(socketArgsProxyList); if (!base.Start()) return false; IsRunning = true; return true; } catch (Exception e) { AppServer.Logger.Error(e); return false; } } ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:6:7","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"SocketAsyncEventArgsProxy\rSocketAsyncEventArgs的代理 维护着一个SocketAsyncEventArgs对象，并订阅了该对象的Completed事件(异步完成事件) IsRecyclable：是否可以循环使用 OrigOffset：原始偏移量 每当异步完成的时候调用SocketAsyncEventArgs实例中的UserToken属性，该属性实际上保存着SocketSession实例，并调用SocketSession的**ProcessReceive()和AsyncRun()**方法；socketSession.AsyncRun(() =\u003e socketSession.ProcessReceive(e)); UserToken属性是在SocketAsyncEventArgsProxy的初始化方法中定义的 public void Initialize(IAsyncSocketSession socketSession) { SocketEventArgs.UserToken = socketSession; } 代理模式 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:6:8","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"BootstrapFactory\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:6:9","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"DefaultBootStrap\r引导配置文件并通过配置实例化各个server和factory,在CreateWorkItemInstance方法通过Activator.CreateInstance(serviceType)实例化 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:6:10","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"ConfigurationWatcher\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:6:11","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"SocketListenerBase\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:6:12","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"TcpAsyncSocketListener\r监听类，由三个事件：监听错误，监听停止，新的客户端连接 m_ListrnSocket：监听Socket ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:6:13","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"WorkItemFactoryInfoLoader\r配置文件载入 LoadResult,载入配置的connectionFilter,logfactory,commandloaderfactory，将appserver转化成IworkItem接口， ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:6:14","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"Common.dll\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:7:0","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"BufferManager\r此类创建一个大缓冲区，该缓冲区可以分配给每个套接字I / O操作使用，并分配给SocketAsyncEventArgs对象。 这使得bufffer可以轻松地重用，并且可以防止堆内存碎片化。 BufferManager类上公开的操作不是线程安全的。我觉得这个类不需要线程安全，因为每个socket获得数据基本不会并发执行。 m_buffer:所有的字节缓存 m_bufferSize:单个片段的缓存大小 m_currentIndex：当前字节在总缓存中的索引 m_freeIndexPool:空闲索引池 m_numBytes：缓存片段的数目 主要提供两个方法：一个是SetBuffer和FreeBuffer SetBuffer： 检查空闲索引栈中是否有值，有值就直接使用空闲索引栈中的值，并将其值从栈中推出， 如果没有空闲栈的值就先检查剩余的缓存是否有一个片段大小，有的化就设置并改变m_currentIndex索引，没有返回false FreeBuffer： 将当前索引添加到空闲索引栈中，并释放SocketAsyncEventArgs中用的缓存片段。 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:7:1","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"ArraySegmentList\r方法： IndexOf：T在所有缓存中的索引 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:7:2","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"ArraySegmentEx\r数组，是保存着所有缓存，T[] 偏移，该片段在缓存中的位置 数量，该片段的长度 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:7:3","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"SendingQueue\r维护ArraySegment\u003cbyte\u003e[] globalQueue， globalQueue中包含着所有所有缓存 入栈，出战，开始入栈，开始出栈。 所有的发送队列内存片组成一个大的arraysegment，由SendingQueueSourceCreator创建，并由SmartPool维护 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:7:4","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"SendingQueueSourceCreator\r实际就是SmartPoolSourceCreator,发送队列创建者，默认有5个发送队列，其实每个连接一个发送队列，这边的所有sendingQueue组数是由SmartPool维护的 m_SendingQueueSize：发送队列大小，默认为5 /// \u003csummary\u003e /// Creates the specified size. /// \u003c/summary\u003e /// \u003cparam name=\"size\"\u003eThe size.\u003c/param\u003e /// \u003cparam name=\"poolItems\"\u003eThe pool items.\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public ISmartPoolSource Create(int size, out SendingQueue[] poolItems) { var source = new ArraySegment\u003cbyte\u003e[size * m_SendingQueueSize];//256*5 poolItems = new SendingQueue[size];//size=256 for (var i = 0; i \u003c size; i++) { poolItems[i] = new SendingQueue(source, i * m_SendingQueueSize, m_SendingQueueSize);//SendingQueue中的source是所有的队列缓存，发送队列偏移量和发送队列容量 } return new SmartPoolSource(source, size); } ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:7:5","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"SmartPool\r其中维护了一个T（实际是SendingQueue）线程安全栈(m_GlobalStack)。由此看出SmartPool就是SendingQueue的池 m_MinPoolSize：Math.Max(config.MaxConnectionNumber / 6, 256) m_MaxPoolSize：Math.Max(config.MaxConnectionNumber * 2, 256) m_SourceCreator：new SendingQueueSourceCreator(config.SendingQueueSize) m_ItemsSource：保存着SmartPoolSource[]对象,该对象实际上是所有的sendingqueue缓存。 m_GlobalStack：保存着单个SendingQueuep对象的数组 Initialize()：初始化函数，初始化上面的变量 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:7:6","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"SmartPoolSource\r维护所有的发送队列缓存，并保存sendingQueue的个数 Source：是object类型，实际上是ArraySegment\u003cbyte\u003e[]，实际上是所有的sendingqueue的缓存，大小为size*sendingqueuesize=256*5， Count:为默认值5 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:7:7","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"Other.dll\r","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:8:0","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"SocketAsyncEventArgs 类\r表示异步套接字操作。 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:8:1","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"设置IP和Port调用流程\r创建ServerConfig实例，RootConfig实例 设置m_State状态，线程安全的，通过Interlocked.CompareExchange方法设置 在setbasic中设置RootConfig,m_Name,Config，设置currentculture,设置线程池参数，设置m_socketfactory,设置textencoding, 设置logfactory 在setMedium中设置ReceiveFilterFactory，m_ConnectionFilters，m_CommandLoaders（add ReflectCommandLoader） 在SetupAdvanced中设置BaseSecurity和Certificate，设置listners(ListenerInfo) 设置CommandFilterAttribute，遍历m_CommandLoaders，订阅Error,Updated事件，调用Initialize方法，通过TryLoadCommands方法获取命令集合commands，遍历命令集合添加命令到discoveredCommands集合中 遍历discoveredCommands集合，将其添加到命令容器 m_CommandContainer中，使用Interlocked.Exchange方法保证线程安全 在SetupFinal中设置ReceiveFilterFactory=new CommandLineReceiveFilterFactory(TextEncoding)，设置m_ServerStatus,通过socketfactory获得serverfactory。 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:9:0","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"start调用流程\r调用SuperSocket.SocketBase.AppServer中start()方法，调用基类AppServerBase的start()方法，该方法中调用socketserver的start方法 在socketserver的start方法中设置BufferManager,创建SocketAsyncEventArg,并通过buffermanager设置其buffer,并创建SocketAsyncEventArgProxys, SocketAsyncEventArgProxys集合赋值给m_ReadWritePool。调用SocketServer基类中的start 在socketserver基类的start中创建SendingQueuePool并初始化,实际是初始化队列池中的sendingqueue队列；通过遍历ListenerInfo集合创建TcpAsyncSocketListener监听者，订阅监听者的stop，error,NewClientAccepted事件，并开始监听Listener.Start,也添加到容器中。 Listener.Start中创建一个监听Listen_socket和new异步套接字SocketAsyncEventArgs,并订阅Compeleted事件，启用socket监听，并调用AcceptAsync方法，异步完成触发compeleted事件，调用ProcessAccept方法，原来的方法异步已经触发重新调用一下AcceptAsync方法，通过函数递归实现while，判定acceptsocket是否正常，触发NewClientAccepted事件， 事件触发AsyncSocketServer 类中的ProcessNewClient方法，从m_ReadWritePool池中取一个空闲的SocketAsyncEventArgProxy，并通过代理，socket创建AsyncSocketSession，并通过socketsession创建Appsession，在创建过程中做连接过滤，初始化app’session，通过receivefactory创建receivefilter，同时初始化socketsession,主要是订阅SocketAsyncEventArgProxy中的compeleted事件。调用socketsession的start方法 在socketsession中调用startreceive方法,中调用socket.ReceiveAsync方法，当异步完成时调用socketProxy的SocketEventArgs_Completed方法，该方法调用SocketSession的ProcessReceive方法，在该方法中执行过滤FilterRequest,执行命令，再一次调用startReceive方法，如此不停通过异步直接实现接收循环 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:10:0","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"send调用流程\r在订阅了NewRequestReceived事件之后，该事件会有两个参数，一个是appsession，一个是requestinfo, appsession和socketsession完成， 在appsession的InteralSend函数中对sendtimeout进行限制。 在socketsession中将消息压入消息栈对消息进行校验，最终是通过socket.send和socket.sendasync两个方法将消息发送。 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:11:0","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"SuperSocket1.6","content":"Stop调用流程\r先调用stop再调用close socketserver的stop，释放m_ReadWritePool中所有SocketAsyncEventArgs，所有listener的stop，释放其SocketAsyncEventArgs socket’session的closed，回收所有sendingqqueue到pool中 ","date":"2020-01-28","objectID":"/2020/01/supersocket1-source/:12:0","tags":["SuperSocket1.6","源码解析"],"title":"SuperSocket1.6 源码解析","uri":"/2020/01/supersocket1-source/"},{"categories":"HeadFirst设计模式","content":"1 装饰者模式\r","date":"2019-11-25","objectID":"/2019/11/designpattern14-headfirst/:1:0","tags":["HeadFirst设计模式","装饰","适配器"],"title":"HeadFirst设计模式 装饰 适配器","uri":"/2019/11/designpattern14-headfirst/"},{"categories":"HeadFirst设计模式","content":"星巴克咖啡\r饮料 ","date":"2019-11-25","objectID":"/2019/11/designpattern14-headfirst/:1:1","tags":["HeadFirst设计模式","装饰","适配器"],"title":"HeadFirst设计模式 装饰 适配器","uri":"/2019/11/designpattern14-headfirst/"},{"categories":"HeadFirst设计模式","content":"总结\r如果说策略模式是通过组合实现弹性，那么装饰者模式就是通过继承来实现，在实现的同时，客户基本感觉不到使用了装饰者模式 ","date":"2019-11-25","objectID":"/2019/11/designpattern14-headfirst/:1:2","tags":["HeadFirst设计模式","装饰","适配器"],"title":"HeadFirst设计模式 装饰 适配器","uri":"/2019/11/designpattern14-headfirst/"},{"categories":"HeadFirst设计模式","content":"2 适配器模式\r对象适配器 类适配器 ","date":"2019-11-25","objectID":"/2019/11/designpattern14-headfirst/:2:0","tags":["HeadFirst设计模式","装饰","适配器"],"title":"HeadFirst设计模式 装饰 适配器","uri":"/2019/11/designpattern14-headfirst/"},{"categories":"HeadFirst设计模式","content":"火鸡\r","date":"2019-11-25","objectID":"/2019/11/designpattern14-headfirst/:2:1","tags":["HeadFirst设计模式","装饰","适配器"],"title":"HeadFirst设计模式 装饰 适配器","uri":"/2019/11/designpattern14-headfirst/"},{"categories":"HeadFirst设计模式","content":"总结\r适配器模式和装饰者模式非常像，适配器模式是适配对象接口，而装饰者模式不改变对象接口的情况下给对象新的职责。 ","date":"2019-11-25","objectID":"/2019/11/designpattern14-headfirst/:2:2","tags":["HeadFirst设计模式","装饰","适配器"],"title":"HeadFirst设计模式 装饰 适配器","uri":"/2019/11/designpattern14-headfirst/"},{"categories":"重构改善既有代码","content":"大型重构\r","date":"2019-11-15","objectID":"/2019/11/designpattern12-refactoring8/:1:0","tags":["重构改善既有代码","大型重构"],"title":"重构改善既有代码 大型重构","uri":"/2019/11/designpattern12-refactoring8/"},{"categories":"重构改善既有代码","content":"1、梳理并分解继承体系\rTease Apart Inheritance 就是让每个类的职责更明确更单一，当一个类的职责混乱时，通过绘制职责图来分离职责，并创建另一个超类，将相关的字段和方法都移动到另一个超类 动机 混乱的继承体系是一个严重的问题，会导致重复代码，而后者正是程序员生涯的致命毒药。还会使修改变得困难，因为特定问题的解决决策被坟山到了整个继承体系。 什么时候做 某个继承体系同时承担两项责任 怎么做 建立两个继承体系，并通过委托关系让其中一个可以调用另一个 首先识别出继承体系所承担的不同责任，然后建立一个二维表格（或则三位乃至四维表格），并以坐标轴标示不同的任务， 判断哪一项责任更重一些，并准备将它留在当前的继承体系中，准备将另一项责任移到另一个继承体系中。 使用抽象类方法从当前的超类提炼出一个新类，用以表示重要性稍低的责任，并在原超类中添加一个实例变量，用以保存新类的实例。 对应于原继承体系中的每个子类，创建上述新类的一个子类，在原继承体系的子类中，将前一步骤所添加的实例变量初始化为新建子类的实例。 针对原继承体系中的每个子类，使用搬移函数的方法迁移到与之对应的子类中。 ","date":"2019-11-15","objectID":"/2019/11/designpattern12-refactoring8/:1:1","tags":["重构改善既有代码","大型重构"],"title":"重构改善既有代码 大型重构","uri":"/2019/11/designpattern12-refactoring8/"},{"categories":"重构改善既有代码","content":"2、将过程化设计转化为对象设计\rConvert Procedural Design to Objects 动机 什么时候做 有一些传统过程化风格的代码 怎么做 将数据记录变成对象，将大块的行为分为小块，并将行为移入相关对象之中。 针对每一个记录类型，将其转变为只含访问函数的哑数据对象 针对每一处过程化风格，将该出的代码提炼到一个独立类中。 针对每一段长长的程序，试试提炼方法将长方法分解并将分解后的方法移动到相关的哑数据类。 ","date":"2019-11-15","objectID":"/2019/11/designpattern12-refactoring8/:1:2","tags":["重构改善既有代码","大型重构"],"title":"重构改善既有代码 大型重构","uri":"/2019/11/designpattern12-refactoring8/"},{"categories":"重构改善既有代码","content":"3、将领域和表诉/显示分离\rSeparate Domain from Presentation 动机 MVC模式最核心的价值在于，它将用户界面代码（即视图：亦即现今常说的展现层）和领域逻辑（即模型）分离了，展现类只含用以处理用户界面的逻辑：领域类包含任何与程序外观相关的代码，只含业务逻辑相关代码，将程序中这两块复杂的部分加以分离，程序未来的修改将变得更加容易，同时也使用同意业务逻辑的多种展现方式称为可能。 什么时候做 某些GUI类中包含了领域逻辑 怎么做 将领域逻辑分离出来，为它们建立独立的邻域类。 为每个窗口建立一个领域类， 如果窗口内含有一张表格，新建一个类来表示其中的行，再以窗口所对应之领域类中的一个集合来容纳所有行领域对象 检查窗口中的数据，如果数据只被用于UI，就把它留着，如果数据被领域逻辑使用，而且不显示与窗口上，我们就可以使用移动方法将它搬移到领域类中，如果数据同时被UI和领域逻辑使用，就对它实施复制被监视数据，使它同时存在于两处，并保持两处之间的同步。 展现类中的逻辑，实施提炼方法将展现逻辑从邻域逻辑中分开，一旦隔离了邻域逻辑，在运用搬移方法将它移到邻域类。 ","date":"2019-11-15","objectID":"/2019/11/designpattern12-refactoring8/:1:3","tags":["重构改善既有代码","大型重构"],"title":"重构改善既有代码 大型重构","uri":"/2019/11/designpattern12-refactoring8/"},{"categories":"重构改善既有代码","content":"4、提炼继承体系\rExtract Hierarchy 动机 一开始设计者只想以一个类实现一个概念，但随着设计方案的演化，最后可能一个类实现两个三乃至十个不同的概念。 什么时候做 有某个类做了太多的工作，其中一部分工作是以大量条件表达式完成的 怎么做 建立继承体系，以一个子类表示一种特殊情况。 有两种重构的手法 无法确定哪些地方会发生变化 不确定哪些地方会发生变化 鉴别出一中变化情况， 如果这种拜年话可能在对象声明周期的不同阶段而有不同体现就用提炼方法将它提炼为一个独立的类 针对这种变化情况，新建一个子类，并对原始类实施工厂方法替代构造函数，再次修改工厂方法，令它返回适当的子类实例。 将含有条件逻辑的函数，一个个复制到子类 有必要隔离函数中的条件逻辑和非条件逻辑。 删除超类中那些被所有子类覆写的函数本体，并将它们声明为抽象函数。 确定原始类中每一种变化 针对原始类中每一种变化情况，建立一个子类， 使用工厂方法替代构造函数将原始类的构造函数转变成工厂函数，并令它针对每一种变化情况返回适当的子类实例。 如果原始类中的各种变化情况是以类型码标示，使用子类替换类型码，如果那些变化情况在对象周期的不同阶段会有不同体现，使用状态和策略模式替换类型码 针对带有条件逻辑的函数，实施用多态替换条件如果非整个函数的行为有所变化，请先运行提炼方法将变化部分和不变部分分隔开来 ","date":"2019-11-15","objectID":"/2019/11/designpattern12-refactoring8/:1:4","tags":["重构改善既有代码","大型重构"],"title":"重构改善既有代码 大型重构","uri":"/2019/11/designpattern12-refactoring8/"},{"categories":"重构改善既有代码","content":"8 案例\r有一个影片商店客户端，需要计算每一个客户的消费，常客积分 客户customer 租赁rental 影片movie，普通Regular，儿童Children，新片Release Regular:2天内2元，大于2天1.5一天 Release:每天三元 Childrens:3天内1.5元，大于3天1.5一天 计费函数 ","date":"2019-11-15","objectID":"/2019/11/designpattern12-refactoring8/:2:0","tags":["重构改善既有代码","大型重构"],"title":"重构改善既有代码 大型重构","uri":"/2019/11/designpattern12-refactoring8/"},{"categories":"重构改善既有代码","content":"提炼方法\r这个计费函数太复杂 修改参数名 搬移方法 amountfor没有使用customer任何信息，只是使用了rental类的，将其搬移到rental类中 修改原customer中函数调用 ","date":"2019-11-15","objectID":"/2019/11/designpattern12-refactoring8/:2:1","tags":["重构改善既有代码","大型重构"],"title":"重构改善既有代码 大型重构","uri":"/2019/11/designpattern12-refactoring8/"},{"categories":"重构改善既有代码","content":"用查询替换临时变量\r用同样的方法来处理计算常客积分的部分 ","date":"2019-11-15","objectID":"/2019/11/designpattern12-refactoring8/:2:2","tags":["重构改善既有代码","大型重构"],"title":"重构改善既有代码 大型重构","uri":"/2019/11/designpattern12-refactoring8/"},{"categories":"重构改善既有代码","content":"使用多态替换Switch\r原来的switch,在rental类中 不要再另一个对象属性上使用switch，将其移动到方法中 移动过后 常客积分 继承机制 一个影片可以再生命周期内修改自己的分类，一个对象却不能再生命周期内修改自己所属的类，这里需要使用用状态或策略模式替换type，搬移方法到超类，用多态替换条件 提炼超类 修改原来movie中的getcharge方法， 首先getcharge移动方法 用多态替换getcharge方法 ","date":"2019-11-15","objectID":"/2019/11/designpattern12-refactoring8/:2:3","tags":["重构改善既有代码","大型重构"],"title":"重构改善既有代码 大型重构","uri":"/2019/11/designpattern12-refactoring8/"},{"categories":"重构改善既有代码","content":"1、字段上移\rPull Up Field 动机 减少重复 什么时候做 两个子类拥有相同的字段 怎么做 将该字段移至超类 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:1","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"2、函数上移\rPull Up Method 动机 滋生错误 避免重复 什么时候做 有些函数在各个子类中产生完全相同的结果 怎么做 将该函数移至超类 最烦的一点就是，被提升的函数可能会引用子类中出现的特性，如果被引用的是一个函数可以将这个函数一同提升至超类，或则在超类中建立一个抽象函数。 如果两个函数相似但不相同，可以先借助塑造模板函数。 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:2","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"3、构造函数本体上移\rPull Up Constructor Body 引用 如果重构过程过于复杂，可以考虑使用工厂方法。 什么时候做 在各个子类中拥有一些构造函数，它们的本体机会完全一致 怎么做 在超类中新建一个构造函数，并在子类构造函数中调用它。 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:3","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"4、函数下移\rPush Down Method 动机 把某些行为从超类移动到特定的子类中。 什么时候做 超类中某个函数只与部分子类有关 怎么做 将这个函数移到相关的那些子类中 如果移动的函数需要使用超类中的某个字段，则需要将超类中的字段的开放protected. ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:4","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"5、字段下移\rPush Down Field 动机 什么时候做 超类中的某个字段只被部分子类用到 怎么做 将这个字段移到需要它的那些子类去 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:5","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"6、提炼子类*？\rExtract Subclass 动机 类中的某些行为只被一部分实例用到，其他实例不需要，有时候这些行为上的差异是通过类型码分区的，可以使用子类替换类型码，或则使用状态或策略模式替代类型码。 抽象类和抽象子类则是委托和继承之间的抉择 抽象子类会更加容易，但是一旦对象建立完成，无法再改变与类型相关的行为。 什么时候做 类中的某些特性只被某些实例用到 怎么做 新建一个子类，将上面所说的那一部分特性移到子类中 为源类定一个新的子类 为这个新的子类提供构造函数 让子类构造函数接受与超类构造函数相同的参数，并通过super调用超类的构造函数。 用工厂替换构造函数 找出调用结果超类构造函数的所有地点，新建子类 下移方法和字段 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:6","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"7、提炼超类*？\rExtract Superclass 动机 什么时候做 两个类有相似特性 怎么做 为这两个类建立一个超类，将相同特性移至超类。 新建一个空白抽象类 上移字段和方法 先搬移字段 子类函数中有相同的签名，但函数体不同，可以抽象函数 如果方法中有相同算法，可以使用提炼算法，将其封装到同一个函数中。 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:7","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"8、提炼接口\rExtract Interface 动机 类之间彼此互用的方式有若干种，某一种客户只使用类责任区的一个特定子集。 某个类在不同环境下扮演截然不同的角色，使用接口就是一个好主意。 什么时候做 若干客户使用类接口中同一个子集，或者两个类的接口有部分相同 怎么做 将相同的子类提炼到一个独立接口中。 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:8","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"9、折叠继承关系\rCollapse Hierarchy 动机 什么时候做 超类和子类之间无太大区别 怎么做 将它们合为一体 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:9","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"10、塑造模板函数\rForm Template Method 动机 既避免重复也保持差异。 什么时候做 有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同。 怎么做 将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同的，然后将原函数上移至超类 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:10","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"11、以委托取代继承\rReplace Inheritance with Delegation 动机 超类中有许多操作并不真正适用于子类，这种情况下，你所拥有的接口并未真正反映出子类的功能。 什么时候做 某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据 怎么做 在子类中新建一个字段用以保存超类，调整子类函数，令它改而委托超类，然后去掉两者之间的继承关系。 在子类中新建一个字段，使其引用超类的实例 修改子类中的所有函数，让它们不再使用超类，转而使用上述那个受托字段。 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:11","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"12、以继承取代委托\rReplace Delegation with Inheritance 动机 如果并没有使用受托类的所有函数，就不应该使用用继承替换委托， 可以使用去除中间层的方法让客户端自己调用受托函数。 什么时候做 在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数。 怎么做 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:12","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"所有的数据都应该隐藏起来。 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:0","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"1、函数改名\rRename Method 动机 将复杂的处理过程分解成小函数。 什么时候做 函数名称未能揭示函数的用途 怎么做 修改函数名称 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:1","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"2、添加参数\rAdd Parameter 动机 什么时候做 某个函数需要从调用端得到更多信息 在添加参数外常常还有其他的选择，只要有可能，其他选择都比添加参数要好（查询），因为它们不会增加参数列的长度，过长的参数列是一个不好的味道。 怎么做 为此函数添加一个对象参数，让该对象带进函数所需信息。 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:2","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"3、移除参数\rRemove Parameter 动机 可能经常添加参数却很少去除参数，因为多余的参数不会引起任何问题，相反以后可能还会用到它。请去除这些想法。 什么时候做 函数本体不需要某个参数 怎么做 将该参数去除。 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:3","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"4、将查询函数和修改函数分离\rSeparate Query from Modifier 动机 在多线程系统中，查询和修改函数应该被声明为synchronized(已同步化) 什么时候做 某个函数既返回对象状态值，又修改对象状态 任何有返回值的函数，都不应该又看得到的副作用。 常见的优化是将某个查询结果放到某个字段或集合中，后面如何查询，总是获得相同的结果。 怎么做 建立两个不同的函数，其中一个负责查询，另一个负责修改。 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:4","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"5、令函数携带参数\rParameterize 动机 去除重复代码 什么时候做 若干函数做了类似的工作，但在函数本体中却饱含了不同的值 怎么做 建立单一函数，以参数表达那些不同的值 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:5","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"6、以明确函数取代参数\rReplace Parameter with Explicit Methods 动机 避免出现条件表达式，接口更清楚，编译期间就可以检查， 如果在同一个函数中，参数是否合法还需要考虑 但是参数值不会对函数的行为有太多影响的话就不应该使用本项重构，如果需要条件判断的行为，可以考虑使用多态。 什么时候做 有一个函数，其中完全取决于参数值不同而采取不同行为 怎么做 针对该参数的每一个可能值，建立一个独立函数 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:6","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"7、保持对象完整\rPreserve While Object 动机 不适用完整对象会造成重复代码 事物都是有两面性，如果你传的是数值，被调用函数就只依赖于这些数值，如果传的是对象，就要依赖于整个对象。如果依赖对象会造成结构恶化。那么就不应该使用保持对象完整。 如果这个函数使用了另一个对象的多项数据，这可能以为着这个函数实际上应该定义在那些数据所属的对象上，应该考虑移动方法。 什么时候做 从某个对象中取出若干值，将它们作为某一次函数调用时的参数 怎么做 改为传递整个对象 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:7","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"8、以函数取代参数\rReplace Parameter with Methods 动机 尽可能缩减参数长度 什么时候做 对象调用某个函数，并将所有结果作为参数传递给另一个函数，而接受该参数的函数本省也能够调用前一个函数。 怎么做 让参数接受者去除该项参数，并直接调用前一个函数。 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:8","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"9、引入参数对象\rIntroduce Parameter Object 动机 特定的一组参数总是一起被传递，可能有好几个函数都使用这一组参数，这些函数可能隶属于同一个类，也可能隶属于不同的类。这样的参数就是所谓的数据泥团，可以运用一个对象包装所有的这些数据，再以该对象取代它们。 什么时候做 某些参数总是很自然地同时出现 怎么做 以一个对象取代这些参数 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:9","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"10、移除设值函数\rRemove Setting Method 动机 使用了设值函数就暗示了这个字段值可以被改变。 什么时候做 类中某个字段应该在对象创建时被设值，然后就不再改变。 怎么做 去掉该字段的所有设值函数。 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:10","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"11、隐藏函数\rHide Method 动机 面对一个过于丰富、提供了过多行为的接口时，就值得将非必要的取值函数和设置函数隐藏起来 什么时候做 有一个函数，从来没有被其他任何类用到 怎么做 将这个函数修改为private ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:11","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"12、以工厂函数取代构造函数\rReplace Constructor with Factory Method 动机 使用以工厂函数取代构造函数最显而易见的动机就是在派生子类的过程中以工厂函数取代类型码。 工厂函数也是将值替换成引用的方法。 什么时候做 希望在创建对象时不仅仅是做简单的构建动作 怎么做 将构造函数替换为工厂函数 使用工厂模式就使得超类必须知晓子类，如果想避免这个可以用操盘手模式，为工厂类提供一个会话层，提供对工厂类的集合对工厂类进行控制。 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:12","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"13、封装向下转型\rEncapsulate Downcast 动机 能不向下转型就不要向下转型，但如果需要向下转型就必须在该函数中向下转型。 什么时候做 某个函数返回对象，需要由函数调用者执行 向下转型 怎么做 将向下转型动作移到函数中 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:13","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"14、以异常取代错误码\rReplace Error Code with Exception 动机 代码可以理解应该是我们虔诚最求的目标。 什么时候做 某个函数返回一个特定的代码，用以表示某种错误情况 怎么做 改用异常 决定应该抛出受控(checked)异常还是非受控(unchecked)异常 如果调用者有责任在调用前检查必要状态，就抛出非受控异常 如果想抛出受控异常，可以新建一个异常类，也可以使用现有的异常类。 找到该函数的所有调用者，对它们进行相应调整。 如果函数抛出非受控异常，那么就调整调用者，使其在调用函数前做适当检查， 如果函数抛出受控异常，那么就调整调用者，使其在try区段中调用该函数。 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:14","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"15、以测试取代异常\rReplace Exception with Test 动机 在异常被滥用的时候 什么时候做 面对一个调用者可以预先检查的体哦阿健，你抛出一个异常 怎么做 修改调用者，使它在调用函数之前先做检查 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:15","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"HeadFirst设计模式","content":"1 策略模式\r","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:1:0","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"鸭子飞行和嘎嘎叫策略\r","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:1:1","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"2 工厂模式\r","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:2:0","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"简单工厂简单的pizza工厂\r通过一个工厂类的方法，创建和返回对象实例 原来混乱的代码： 修改后 简单工厂类图 ","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:2:1","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"Pizza店变成加盟店\r在创建Pizza时将工厂传进去 想要多一些的质量控制，每个pizza店的工艺又不一样，有的先切再烤，有的先烤再切。 现在来看看Pizza店的多态。**将变化的东西移到低层（实现，子类），抽象的共性移到高层（超类或接口）**这边把Pizza的工艺流程移到子类中去 PizzaStore超类变成，将CreatePizza变成抽象方法，由子类实现方法。 工厂模式的工厂方法 Pizza本身，超类\rPizza的多态 ","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:2:2","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"最终的User调用\r对于pizza店和pizza通过工厂模式形成了一个pizza组件，这边对pizza的实现，就不会违反针对接口编程 ","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:2:3","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"简单工厂模式\r创建者和产品 所有的底层都依赖于高层，高层与高层之间相互依赖，相互解耦。 工厂UML ","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:2:4","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"Pizza店再次升级，Pizza原料升级\rIngredient（成分）超类： Dough（面团）Veggies(蔬菜)Pepperoni（意大利香肠）clam(蛤)子类： 改造Pizza类\r抽象方法prepare() cheesepizza 靠近一点工厂 商店如何使用工厂 ","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:2:5","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"抽象工厂模式类图\r抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 ","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:2:6","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"Pizza店的类图\r","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:2:7","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"3 命令模式\r命令封装，支持撤销，宏命令，队列请求。 ","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:3:0","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"餐厅案例\r餐馆点餐就是命令模式 ","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:3:1","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"回到遥控器\r动作请求者和动作执行者解耦， 命令接口： 具体命令： 命令调用者 简单测试 命令的调用者是遥控器 ，命令执行者是灯，如果不用命令模式应该是遥控器直接调用灯。 命令模式最重要变化的是命令的执行者，在执行者有多种多样的时候，就需要命令模式来实现。 ","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:3:2","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"命令模式类图\rreceiver:就是上文中的灯，action方法为light.on()方法。 ","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:3:3","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"支持撤销\r将每个命令支持撤销方法 ","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:3:4","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"使用状态的撤销\r","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:3:5","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"宏命令之激进的遥控器\r该遥控器要实现自动化功能，一键打开灯光，音响，电视和DVD，直接进入Party模式 ","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:3:6","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"队列请求\r命令可以在不同的线程中被调用，日程安排，线程池，工作队列等。 ","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:3:7","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"日志请求\r​ 某些应用需要我们将所有的动作都记录在日志中，并能在系统司机之后，重新调用这些动作恢复到之前的状态，通过新增两个方法（store()和load()），例用对象的序列化（serialization）实现这些方法，序列化最好只用在对象持久化（persistence）上。 ​ 怎么做：当我们执行命令的时候，将历史记录储存在磁盘中，一旦系统司机，我们就可以将命令对象重新加载，并成批地依次调用这些对的execute()方法。 ​ 许多调用大型数据结构的动作的应用我无法在每次改变发生时被快速的记录。通过使用记录日志，可以将上次检查点（checkpoint）之后的所有操作记录下来。如果系统出状况，从检查点开始应用这些操作。 ​ 比方说对于电子表格的应用：将电子表格的操作记录在日志中，而不是每次电子表格一有变化就记录整个电子表格。对于更高级的应用而言，这些技巧可以被扩展应用到事务（Transaction）中,也就是说一群操作必须全部进行完成。 ","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:3:8","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"4 状态模式\r策略模式和状态模式是双胞胎，在出生时才分开。 策略模式是通过互换算法来创建成功业务的，状态是通过改变对象内部的状态来帮助对象控制自己的行为。 ","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:4:0","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"糖果机\r这个一个状态图，每个圆圈都是一个状态。 测试： ","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:4:1","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"激进糖果机\r当曲柄转动时，有10%的几率会得到免费糖果。 将之前的状态都变成类创建state接口 类似的实现所有的状态类 糖果机改造 ","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:4:2","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"状态模式\r允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 状态模式和策略模式，状态模式是上下文根本不知道对象发生了改变 ","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:4:3","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"十次抽奖\r","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:4:4","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"HeadFirst设计模式","content":"总结\r跟策略模式很像，策略模式是将不同的算法（变化的地方）封装成类，实现弹性变化，而状态模式是将不同的状态封装成类，同时客户不会直接改变状态，最好由状态自己改变状态， ","date":"2019-11-12","objectID":"/2019/11/designpattern13-headfirst/:4:5","tags":["HeadFirst设计模式","策略","工厂","命令","状态"],"title":"重构改善既有代码 策略 工厂 命令 状态","uri":"/2019/11/designpattern13-headfirst/"},{"categories":"重构改善既有代码","content":"1、分解条件表达式\rDecompose Conditional 动机 复杂的条件逻辑是最常导致复杂度上升的地点之一， 什么时候做 有一个复杂的条件语句 怎么做 从if，then,else三个段落中分别提炼出独立函数 将其分解为多个独立函数，根据每个小块代码的用途分解而得的新函数命名。 很多人都不愿意去提炼分支条件，因为这些条件非常短，但是提炼之后函数的可读性很强，就像一段注释一样清楚明白。 ","date":"2019-11-12","objectID":"/2019/11/designpattern9-refactoring5/:0:1","tags":["重构改善既有代码","简化条件表达式"],"title":"重构改善既有代码 简化条件表达式","uri":"/2019/11/designpattern9-refactoring5/"},{"categories":"重构改善既有代码","content":"2、合并条件表达式\rConsolidate Conditional Expression 其实就是用一个小型函数封装一下，小型函数的名字可以作为注释。 动机 合并后的条件代码会使得检查的用意更加清晰，合并前和合并后的代码有着相同的效果。 什么时候做 有一系列条件测试，都得到相同结果 怎么做 将这些测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数。 ","date":"2019-11-12","objectID":"/2019/11/designpattern9-refactoring5/:0:2","tags":["重构改善既有代码","简化条件表达式"],"title":"重构改善既有代码 简化条件表达式","uri":"/2019/11/designpattern9-refactoring5/"},{"categories":"重构改善既有代码","content":"3、合并重复的条件片段\rConsolidate Duplicate Conditional Fragments 动机 什么时候做 在条件表达式的每个分支上都有着相同的一段代码 怎么做 将这段重复代码搬移到条件表达式之外。 ","date":"2019-11-12","objectID":"/2019/11/designpattern9-refactoring5/:0:3","tags":["重构改善既有代码","简化条件表达式"],"title":"重构改善既有代码 简化条件表达式","uri":"/2019/11/designpattern9-refactoring5/"},{"categories":"重构改善既有代码","content":"4、移除控制标记\rRemove Control Flag 动机 单一出口原则会迫使让妈中加入讨厌的控制标记，大大降低条件表达式的可读性， 什么时候做 在一系列布尔表达式中，某个变量带有\"控制标记\"(control flag)的作用 怎么做 以break语句或return语句取代控制标记 ","date":"2019-11-12","objectID":"/2019/11/designpattern9-refactoring5/:0:4","tags":["重构改善既有代码","简化条件表达式"],"title":"重构改善既有代码 简化条件表达式","uri":"/2019/11/designpattern9-refactoring5/"},{"categories":"重构改善既有代码","content":"5、以卫语句取代嵌套条件表达式\rReplace Nested Conditional with Guard Clauses 动机 单一出口的规则其实并不是那么有用，保持代码清晰才是最关键的。 什么时候做 函数中条件逻辑使人难以看清正常的执行路径 怎么做 使用卫语句表现所有特殊情况。 ","date":"2019-11-12","objectID":"/2019/11/designpattern9-refactoring5/:0:5","tags":["重构改善既有代码","简化条件表达式"],"title":"重构改善既有代码 简化条件表达式","uri":"/2019/11/designpattern9-refactoring5/"},{"categories":"重构改善既有代码","content":"6、以多态取代条件表达式\rReplace Conditional with Polymorphism 动机 如果需要根据对象的不同类型而采取不同的行为，多态使你不必编写明显的条件表达式。 同一组条件表达在程序许多地点出现，那么使用多态的收益是最大的。 什么时候做 有一个条件表达式，根据对象类型的不同而选择不同的行为 怎么做 将这个体哦阿健表示式的每个分支放进一个子类的覆写函数中，然后将原始函数声明为抽象函数。 ","date":"2019-11-12","objectID":"/2019/11/designpattern9-refactoring5/:0:6","tags":["重构改善既有代码","简化条件表达式"],"title":"重构改善既有代码 简化条件表达式","uri":"/2019/11/designpattern9-refactoring5/"},{"categories":"重构改善既有代码","content":"7、引入Null对象\rIntroduce Null Object 动机 多态的最根本好处就是不必要想对象询问你是什么类型而后根据得到的答案调用对象的某个行为，只管调用该行为就是了。 空对象一定是常量，它们的任何成分都不会发生变化，因此可以使用单例模式来实现它们。 什么时候做 需要再三检查对象是否为Null 怎么做 将null对象替换成null对象。 ","date":"2019-11-12","objectID":"/2019/11/designpattern9-refactoring5/:0:7","tags":["重构改善既有代码","简化条件表达式"],"title":"重构改善既有代码 简化条件表达式","uri":"/2019/11/designpattern9-refactoring5/"},{"categories":"重构改善既有代码","content":"8、引入断言\rIntroduce Assertion 动机 断言是一个条件表达式，应该总是为真，如果它失败，表示程序员犯了一个错误。因此断言的失败应该导致一个非受控异常（unchecked exception）。 加入断言永远不会影响程序的行为。 用它来检查一定必须为真的条件。 什么时候做 某一段代码需要对程序状态做出某种假设 怎么做 以断言明确表现这种假设 ","date":"2019-11-12","objectID":"/2019/11/designpattern9-refactoring5/:0:8","tags":["重构改善既有代码","简化条件表达式"],"title":"重构改善既有代码 简化条件表达式","uri":"/2019/11/designpattern9-refactoring5/"},{"categories":"重构改善既有代码","content":"**对于这个类的任何修改都应该通过该类的方法。类拥有一些数据却无所觉，拥有一些依赖无所觉是非常危险的。**所以才要封装字段，封装集合，监视数据，用对象替代数组，用对象替代集合，关联改动。 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:0","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"1、自封装字段\rSelf Encapsulate 动机 直接访问变量的好处：子类可以通过覆写一个函数而改变获取数据的途径，它还支持更灵活的数据管理方式，如延迟初始化等， 直接访问变量的好处：代码比较容易阅读， 优先选择直接访问的方式，直到这种访问方式带来麻烦位置。 什么时候需要自封装字段 直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。 怎么自封装 为这个字段建立取值/设值函数，并且只以这些函数来访问字段。 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:1","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"2、以对象取代数据值\rReplace Data Value with Object 动机 简单数据不再简单， 注意：原来的数据值是值对象，改成对象可能变成引用类型，这样面临的问题是多个实例就不是同一个对象。需要用将引用对象改成值对象方法， 什么时候需要对象取代 有一个数据项，需要与其他数据和行为一起使用才有意义。 怎么对象取代 为替换值新建一个新类，其中声明final字段，修改原字段的引用，都修改为对象。 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:2","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"3、将值对象改成引用对象\rChange Value to Reference 对于值类型来说，equals和==的功能是相等的都是比较变量的值、 对于引用类型来说，==是b比较两个引用是否相等，equals是比较的引用类型的内容是否相等，而使用equals是需要重写的，不然就是调用object中的equals 动机 值对象一般是基本数据类型，并不在意是否有副本的存在， 引用对象是否相等，直接使用==操作符 什么时候改引用 一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象 类的每个实例中的字段都是独立，就是值类型，每个实例都对应一个字段对象。 引用类型多个实例可以共用一个字段对象。不是所有 怎么改 创建简单工厂和注册表，工厂负责生产字段对象，注册表负责保存所有的字段对象 类实例通过工厂请求字段实例，工厂通过访问注册表返回字段实例引用。 例子 ​ 目前为止customer对象还是值对象，即使多个订单属于同一客户但每个order对象还是拥有自己的customer对象。 使用工厂方法替代构造函数 此时值对象才变成引用对象，多个实例间都共享同一个引用对象 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:3","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"4、将引用对象改成值对象\rChange Reference to value 这边引用对象改成值对象并不是说需要把引用类型改成基本类型，而是即使引用类型是不同副本，那么相同内容的引用内容也是相等（重写Equals()） 动机 如果引用对象开始变得难以使用，或许就应该将它改成值对象。 引用对象必须被某种方式控制，而且必须向其控制者请求适当的引用对象，会造成区域之间错综复杂的关联。 值对象应该是不可变的（无论何时，调用同一个对象的同一个查询函数都应该得到相同的结果），如果需要改变就需要重新创建一个所属类的实例，而不是在现有对象上修改。 什么时候更改 有一个引用对象，很小且不可变，而且不易管理。 怎么更改 检查重构目标是否为不可变对象，建立equals和hashcode方法 new Currency(“USD”).equals(new Currency(“USD”))；返回false。重写equal和hashcode使其返回true，这样对象就是值对象，不可变。 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:4","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"5、以对象取代数组\rReplace Array with Object 动机 数组是常见的组织数据的结构，只用于以某种顺序容纳一组相似对象。 什么时候需要取代 有一个数组，其中的元素各自代表不同的东西 怎么取代 将数组的每个不同意思都抽象称字段 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:5","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"6、复制被监视的数据\rDuplicate Observed Data 动机 一个分层良好的系统，用户界面和处理业务逻辑的代码分开 MVC模式 什么时候需要复制 有一些领域数据置身于GUI控件中，而邻域函数需要访问这些数据 怎么复制 将该数据复制到一个领域对象中，建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:6","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"7、将单向关联改成双向关联\rChange Unidirectional Association to Bidirectional 有点像观察者模式，控制者是订阅端，被控制者是主题，主题存在辅助函数，用于修改反向指针，订阅端调用辅助函数来修改反向指针。 动机 随着项目时间的推移需要双向关联 什么时候改动 两个类都需要使用对方特性，但其间中有一条单向连接 怎么实现 添加一个反向指针，并使修改函数能够同时更新两条连接。 在被引用的类中增加一个字段，保存反向指针。 控制端和被控制端 一对多的关系，可以使用**单一引用的一方(就是多的那一方)**承担控制者的角色。 对象是组成另一对象的部件，该部件负责控制关联关系。 如果两者都是引用对象，多对多，那么无所谓。 在被控端建立一个辅助函数，负责修改反向指针 如果既有的修改函数在控制端，让它负责控制修改反向指针 如果既有的修改函数在被控端，就在控制端建立一个控制函数，并让既有的修改函数调用这个新建的控制函数，来控制修改反向指针。 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:7","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"8、将双向关联改为单向关联\rChange Bidirectional Association to Unidirectional 动机 双向关联必须要符出代价，维护双向关联，确保对象被正确创建和删除而增加的复杂度。 双向关联还会造成僵尸对象，某个对象已经死亡却保留在系统中，因为它的引用还没有完全清楚。 双向关联也会迫使两个类之间有了依赖，对其中任一个类的修改，都可能引发另一个类的变化。 什么时候需要 两个类之间有双向关联，但其中一个类不再需要另一个的特性 怎么修改 去除不必要的关联 将私有字段去掉，需要依赖的函数，将依赖类作为参数传入，然后调用。 创建一个静态字典保存所有的依赖类，通过取值函数来获得字段遍历对比依赖的引用是否相同来获取依赖类。 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:8","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"9、以字面常量取代魔法数\rReplace Magic Number with Symbolic Constant 动机 什么时候取代 有一个字面数值，并带有特别含义 怎么取代 创造一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量。 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:9","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"10、封装字段\rEncapsulate Field 动机 数据声明为public被看做一种不好的做法，会降低模块化程度。 拥有该数据对象却毫无察觉，不是一件好事 什么时候封装 类中存在一个public字段 怎么封装 将原字段声明为private，并提供相应的访问函数 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:10","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"11、封装集合\rEncapsulate Collection 除非通过封装的集合类，不然没有任何实例能够修改这个集合。 动机 在一个类中使用集合并将集合给取值函数，但类不应该返回集合自身，因为这回让用户得以修改集合内容而对集合的使用者一无所知。 不应该为集合提供一个设值函数，但应该为集合添加/移除元素的函数，这样集合的拥有者就可以控制集合元素的添加和移除。 什么时候封装 有一个函数返回一个集合 怎么封装 让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:11","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"12、以数据类取代记录\rReplace Record with Data Class 动机 从数据库读取的记录，需要一个接口类，用来处理这些外来数据。 什么时候做 需要面对传统编程环境中的记录结构 怎么做 为该记录创建一个哑数据对象。 新建一个类，对于记录汇总的每一项数据，在新建的类中建立一个对应的private字段，并提供相应的取值和设值函数。 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:12","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"13、以类取代类型码\rReplace Type Code with Class 原来的类型码可能是int类型，建立一个类型码的类，所有的int转换成类型码的类，其实有点像创建一个枚举类型，然后用枚举类型取代int。 动机 类型码或枚举值很常见，但终究只是一个数值，如果是一个类就会进行类型检验，还可以为这个类提供工厂函数，保证只有合法的实例才会被创建出来。 如果有switch必须使用类型码，但任何switch都应该使用多态取代条件去掉。为了进行这样的重构还需要使用子类取代类型码，用状态或策略替换类型码。 什么时候做 类之中有一个数值类型码，但它并不影响类的行为 怎么做 以一个新的类替换该数值类型码 用以记录类型码的字段，其类型应该和类型码相同，还应该有对应的取值函数，还应该用一组静态变量保存允许被创建的实例，并以一个静态函数根据原本的类型码返回合适的实例。 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:13","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"14、以子类取代类型码\rReplace Type Code with Subclasses 动机 什么时候做 有一个不可变的类型码，它会影响类的行为 如果类型码会影响宿主类的行为，最好的做好就是用多态来处理变化行为。就是switch和if else结构。 类型码值在对象船舰之后发生变化，类型码宿主类已经拥有子类，这两种情况下就需要使用状态/策略设计模式 怎么做 以子类取代这个类型码 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:14","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"15、以State/Strategy取代类型码\rReplace Type Code with State/Strategy 每个状态有特定的数据和动作。 动机 什么时候做 有一个类型码，它会影响类的行为，但无法通过继承手法消除它 怎么做 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:15","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"16、以字段取代子类\rReplace Subclass with Fields 动机 什么时候做 各个子类的唯一差别只在返回常量数据的函数身上 直接用该字段的不同值表示子类就可以了。 怎么做 修改这些函数，使它们返回超类中某个(新增字段，然后销毁子类) ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:16","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"在面向对象的设计中，决定把责任放在哪里。 先使用移动字段，在移动方法 ","date":"2019-11-10","objectID":"/2019/11/designpattern7-refactoring3/:0:0","tags":["重构改善既有代码","在对象之间搬移特性"],"title":"重构改善既有代码 在对象之间搬移特性","uri":"/2019/11/designpattern7-refactoring3/"},{"categories":"重构改善既有代码","content":"1、搬移函数\rMove Method 动机 一个类与另一个类高度耦合，就会搬移函数，通过这种手段，可以使得类更加简单。 什么时候搬移 有个函数与其所属类之外的另一个类有更多的交流。 当不能肯定是否需要移动一个函数，需要继续观察其他函数，先移动其它函数就会使决定变得容易一些。 怎么搬移 检查所有字段，属性和函数，考虑是否应该被搬移 在该函数最常用引用中建立一个有类似行为的新函数 将旧函数变成一个单纯的委托函数，或是将旧函数完全移除。 有多个函数使用这个需要搬移的特性，应考虑使用该特性的所有函数被一起搬移。 检查所有子类和超类，看看是否有该函数其他声明 如果目标函数使用了源类中的特性，可以将源对象的引用当作参数（多个参数或则存在方法需要调用），传给新建立的目标函数。 如果目标函数需要太多源类特性，就得进一步重构，会将目标函数分解并将其中一部分移回源类。 ","date":"2019-11-10","objectID":"/2019/11/designpattern7-refactoring3/:0:1","tags":["重构改善既有代码","在对象之间搬移特性"],"title":"重构改善既有代码 在对象之间搬移特性","uri":"/2019/11/designpattern7-refactoring3/"},{"categories":"重构改善既有代码","content":"2、搬移字段\rMove Field 动机 随着项目类的增加和扩充，有一些字段放在原来的类中已经不太合适 什么时候搬移 某个字段在另一个类中被更多的用到 怎么搬移 修改源字段的所有用户，令它们改用新字段 决定如何在源对象中引用目标对象，方法，新建字段引用 新类中自我封装SetValue, GetValue。 ","date":"2019-11-10","objectID":"/2019/11/designpattern7-refactoring3/:0:2","tags":["重构改善既有代码","在对象之间搬移特性"],"title":"重构改善既有代码 在对象之间搬移特性","uri":"/2019/11/designpattern7-refactoring3/"},{"categories":"重构改善既有代码","content":"3、提炼类*？\rExtract Class 动机 将复合类的职责提炼出新的类 或者需要将类的子类化，分解原来的类 什么时候提炼 某个类做了应该由两个类做的事 怎么提炼 建立一个新类，将相关的字段和函数从旧类搬移到新类 有可能需要一个双向连接， 但是在真正需要它之前，不要建立从新类往旧类的连接，如果建立起双向连接，检查是否可以将它改为单向连接。 ","date":"2019-11-10","objectID":"/2019/11/designpattern7-refactoring3/:0:3","tags":["重构改善既有代码","在对象之间搬移特性"],"title":"重构改善既有代码 在对象之间搬移特性","uri":"/2019/11/designpattern7-refactoring3/"},{"categories":"重构改善既有代码","content":"4、将类内联化\rInline Class 动机 一个类不再承担足够责任，不再由单独存在的理由。 什么时候内联 某个类没有做太多的事情 怎么内联 将这个类是多有特性搬移到另一个类中，然后移除原类 修改所有源类引用点，改而引用目标类 ","date":"2019-11-10","objectID":"/2019/11/designpattern7-refactoring3/:0:4","tags":["重构改善既有代码","在对象之间搬移特性"],"title":"重构改善既有代码 在对象之间搬移特性","uri":"/2019/11/designpattern7-refactoring3/"},{"categories":"重构改善既有代码","content":"5、隐藏“委托关系”\rHide Delegate 局限性是每当客户要使用受托类的新特性时，就必须在服务段添加一个简单委托函数，受托类的特性越来越多，这一过程会越来越痛苦。 简单委托关系 动机 封装意味着每个对象都应该尽可能少的了解系统的其他部分， 如果客户调用对象字段得到另一个对象，然后再调用后者的函数，那么客户就必须知道这一层关系。将委托关系隐藏起来不会波及客户。 什么时候隐藏 客户通过一个委托类来调用另一个对象 怎么隐藏 在服务类上建立客户所需的所有函数，用以隐藏委托关系 manager=john.getDepartment().getManager();隐藏=\u003emanager=john.getManager();隐藏了调用关系。 ","date":"2019-11-10","objectID":"/2019/11/designpattern7-refactoring3/:0:5","tags":["重构改善既有代码","在对象之间搬移特性"],"title":"重构改善既有代码 在对象之间搬移特性","uri":"/2019/11/designpattern7-refactoring3/"},{"categories":"重构改善既有代码","content":"6、移除中间人\rRemove Middle Man 与隐藏委托关系相反 动机 针对隐藏委托的局限性，当委托的方法越来越多时，服务类就完全变成一个中间人，此时应该让客户直接调用受托类。 什么时候移除 某个类做了过多的简单委托动作 怎么移除 让客户直接调用受托类 ","date":"2019-11-10","objectID":"/2019/11/designpattern7-refactoring3/:0:6","tags":["重构改善既有代码","在对象之间搬移特性"],"title":"重构改善既有代码 在对象之间搬移特性","uri":"/2019/11/designpattern7-refactoring3/"},{"categories":"重构改善既有代码","content":"7、引入外加函数\rIntroduce Foreign Method 动机 发现一个好用的工具类不能修改工具类，添加方法 但外加函数终归是权益之计， 什么时候需要引入外加函数 需要为提供服务的类增加一个函数，但无法修改这个类。 怎么引入 在客户类中建立一个函数，并以第一参数形式传入一个服务类实例 ","date":"2019-11-10","objectID":"/2019/11/designpattern7-refactoring3/:0:7","tags":["重构改善既有代码","在对象之间搬移特性"],"title":"重构改善既有代码 在对象之间搬移特性","uri":"/2019/11/designpattern7-refactoring3/"},{"categories":"重构改善既有代码","content":"8、引入本地扩展\rIntroduce Local Extension 动机 在不能修改的类中添加方法，方法的数量超过2个的时候外加函数难以控制，需要将函数组织到一起，通过两种标准对象技术：子类化和包装，子类化和包装叫做本地扩展。 在子类化和包装中优先选择子类， 使用包装会造成A=B，B不等于A的逻辑，子类等于包装类，包装类不等于子类 什么时候引入 需要为服务类提供一些额外函数，但无法修改类。 怎么引入 建立一个新类，使它包含这些额外函数，让这个扩展品成为源类的子类或包装类。 子类化方案，转型构造函数应该调用适当的超类构造函数 包装类方案，转型构造函数应该传入参数以实例变量的形式保存起来，用作接受委托的原对象。 ","date":"2019-11-10","objectID":"/2019/11/designpattern7-refactoring3/:0:8","tags":["重构改善既有代码","在对象之间搬移特性"],"title":"重构改善既有代码 在对象之间搬移特性","uri":"/2019/11/designpattern7-refactoring3/"},{"categories":"重构改善既有代码","content":"对函数的重构方法 ","date":"2019-11-09","objectID":"/2019/11/designpattern6-refactoring2/:0:0","tags":["重构改善既有代码","重新组织函数"],"title":"重构改善既有代码 重新组织函数","uri":"/2019/11/designpattern6-refactoring2/"},{"categories":"重构改善既有代码","content":"1、提炼函数\rExtractMethod 动机 每个函数的颗粒度都比较小，高层函数读起来就像是注释 颗粒度比较小覆写也比较容易 什么时候需要提炼函数 当函数体的语义与函数名称偏离的时候就需要提取 怎么提取 将代码提取出来用函数的意图来命名（做什么） 如果该代码段中有读取或改变临时变量 该临时变量在原函数中有没有使用， 优先考虑用查询取代临时变量 没有直接将临时变量的声明移植到函数体中 在函数体之前使用，作为参数传入 在函数体之后使用，作为函数返回值返回 之前之后都使用，作为参数传入，在作为返回值返回 如果临时变量非常多， 需要考虑这个函数体是否真的属于这个类 以查询替代临时变量 ","date":"2019-11-09","objectID":"/2019/11/designpattern6-refactoring2/:0:1","tags":["重构改善既有代码","重新组织函数"],"title":"重构改善既有代码 重新组织函数","uri":"/2019/11/designpattern6-refactoring2/"},{"categories":"重构改善既有代码","content":"2、内联函数\rInline Method 什么时候需要内联 当函数的本体和名称同样清楚易懂的时候 当有一大群组织不太合理的函数，想重构的时候，将一大群函数内联然后重新提取 有太多的间接层，所有函数似乎都是对另一个函数的简单委托 怎么内联 检查函数，确定它不具有多态。 找出该函数的所有引用点，用函数体替换（最好用文本查找的方式找） ","date":"2019-11-09","objectID":"/2019/11/designpattern6-refactoring2/:0:2","tags":["重构改善既有代码","重新组织函数"],"title":"重构改善既有代码 重新组织函数","uri":"/2019/11/designpattern6-refactoring2/"},{"categories":"重构改善既有代码","content":"3、内联临时变量\rInline Temp 动机 什么时候做 有一个临时变量，只被简单表达式赋值一次，而它妨碍其他重构手法 怎么做 ","date":"2019-11-09","objectID":"/2019/11/designpattern6-refactoring2/:0:3","tags":["重构改善既有代码","重新组织函数"],"title":"重构改善既有代码 重新组织函数","uri":"/2019/11/designpattern6-refactoring2/"},{"categories":"重构改善既有代码","content":"4、以查询取代临时变量*\rReplace Temp with Query 动机 临时变量是暂时的，如果这个临时变量需要被使用多次就考虑需要用查询取代，这边的查询可以直接使用.net中的属性。 临时变量会驱使函数变长，如果变成查询，类中的其他成员也可以访问。 什么时候需要查询取代 用一个临时变量保存其某一表达式的运算结果，需要一个查询函数取代临时变量 怎么取代 需要分解临时变量（临时变量被赋值超过一次），以查询取代临时变量，然后再替换临时变量 首先应该将查询设置为私有的，当日后需要的时候再开放保护。 不用考虑细微的性能问题，因为首先需要良好的架构才能使得程序正常运行。然后再考虑性能问题。 ","date":"2019-11-09","objectID":"/2019/11/designpattern6-refactoring2/:0:4","tags":["重构改善既有代码","重新组织函数"],"title":"重构改善既有代码 重新组织函数","uri":"/2019/11/designpattern6-refactoring2/"},{"categories":"重构改善既有代码","content":"5、引入解释性变量\rIntroduce Explaining Variable 在引入解释性变量之后，可以使用导出方法或者用查询取代临时变量将临时变量替换掉。 动机 使得复杂表达式可以阅读和管理 什么时候需要引入 有一个复杂的表达式 怎么引入 讲一个复杂表达式（或一部分）的结果放进一个临时变量，以此变量名称来解释表达式的用途 与提炼函数的区别 再提炼函数需要花费更大的工作量的时候 ","date":"2019-11-09","objectID":"/2019/11/designpattern6-refactoring2/:0:5","tags":["重构改善既有代码","重新组织函数"],"title":"重构改善既有代码 重新组织函数","uri":"/2019/11/designpattern6-refactoring2/"},{"categories":"重构改善既有代码","content":"6、分解临时变量\rSplit Temporary Variable 动机 如果一个临时变量承担太多的职责，会使得阅读者糊涂 什么时候分解 程序中有某个临时变量被赋值超过一次，它既不是循环变量也不是收集计算结果。 怎么分解 修改临时变量的名称并声明为常量 ","date":"2019-11-09","objectID":"/2019/11/designpattern6-refactoring2/:0:6","tags":["重构改善既有代码","重新组织函数"],"title":"重构改善既有代码 重新组织函数","uri":"/2019/11/designpattern6-refactoring2/"},{"categories":"重构改善既有代码","content":"7、移除对参数的赋值*\rRemove Assignments to Parameters 这边的是针对函数参数体成员 对参数的赋值的想法是比较危险的，一旦为参数进行赋值如果混淆值类型和引用类型非常容易产生不易察觉的错误。 动机 因为面向对象的方式，所以数值类型的改变并不会改变原来传入的值，但是引用类型就会变化 导致混用按值传递和按引用传递 什么时候移除 代码对函数的一个参数进行赋值时 怎么移除 通过建立一个临时变量，对临时变量进行修改，然后返回临时变量。 如果需要返回一大堆函数，可以将返回的一大堆函数变成一个单一的对象，或者为每个返回值设置一个独立函数。 还可以在函数的每个参数中增加一个const，这个方法只是在函数体较长的时候才可以使用。 ","date":"2019-11-09","objectID":"/2019/11/designpattern6-refactoring2/:0:7","tags":["重构改善既有代码","重新组织函数"],"title":"重构改善既有代码 重新组织函数","uri":"/2019/11/designpattern6-refactoring2/"},{"categories":"重构改善既有代码","content":"8、以函数对象取代函数\rReplace Method with Method Object 动机 小型函数优美动人 什么时候取代 有一个大型函数，对其中的局部变量的使用无法采用提炼方法的手段 怎么提取 建立一个新类，将所有的局部变量变成字段，然后将原函数体中的逻辑变成方法。 ","date":"2019-11-09","objectID":"/2019/11/designpattern6-refactoring2/:0:8","tags":["重构改善既有代码","重新组织函数"],"title":"重构改善既有代码 重新组织函数","uri":"/2019/11/designpattern6-refactoring2/"},{"categories":"重构改善既有代码","content":"9、替换算法\rSubstitute Algorithm 动机 发现一个算法的效率更高的时候 什么时候替换 想法把某个算法换成另一个更为清晰的算法 ","date":"2019-11-09","objectID":"/2019/11/designpattern6-refactoring2/:0:9","tags":["重构改善既有代码","重新组织函数"],"title":"重构改善既有代码 重新组织函数","uri":"/2019/11/designpattern6-refactoring2/"},{"categories":"重构改善既有代码","content":" 第一次做某件事情的时候尽管去做，第二次做类似的事会产生反感，第三次再做类似的事，你就应该重构。 小型函数优美动人 一个类最好是常量类，任何的改变都是调用该类本身的接口实现。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:0:0","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"0 坏代码的味道\r","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:0","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"1、重复代码\rDuplicated Code 同一类中的两个函数含有相同的表达式，提取到方法 互为兄弟的子类含有相同表达式，将两个子类的相同代码提取方法推入超类 如果有相似代码，通过提炼方法将相似和差异部分分割开，并使用疏凿模板方法，并将模板方法上移到超类中。 如果两个毫不相关的类出现重复代码，将重复代码提炼到一个提炼类中，两个类都使用这个提炼类。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:1","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"2、过长函数\rLong Method 间接层所能带来的全部利益——解释能力、共享能力、选择能力 小函数的价值是巨大的 每当感觉需要注释来说明什么的时候，就需要把说明的东西写进一个独立函数中，并以其用途命名。 函数内有大量的临时变量和参数。需要运用提炼方法，可以将临时变量作为参数传入，也可以使用以查询替代临时变量，当方法参数特别多的时候可以提炼参数类，传递参数类实体。如果这么做还有很多的参数，那么就应该用方法对象来取代方法了。 选择提炼哪一段代码 寻找注释，有注释的地方都在提醒你需要提炼方法了，注释名称就是很好的方法名 条件表达式和循环也是型号，可以用 分解条件表达式，循环应该将循环中的代码提炼到独立函数中。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:2","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"3、过大的类\rLarge Class 如果单个类做太多是事情，往往会导致出现太多的实例变量，一旦如此，重复代码就接踵而至了。 可以使用提炼类将几个变量和方法提炼出来，如果数个变量存在着相同的前缀或字尾，就以为着有机会可以把它们提炼到某个组件中。如果这个组件适合一个子类，还可以使用提炼子类。 如果一个拥有太多代码，可以先确定客户端如何使用它们，然后运用提炼接口，为每一种使用方法提炼出一个接口，这可以看清楚如何分解这个类。 如果超大类是一个GUI类，可以把数据和行为移到一个独立的领域对象去，可能需要两边保留一些重复代码，并保持两边同步。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:3","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"4、过长的参数列\rLong Parameter List 如果向已有的对象发出一条请求就可以取代一个参数，那么就可以使用用方法取代参数方法。 还可以使用保持整个对象，传递整个对象， 提炼参数对象 造成函数关联需要慎重考虑 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:4","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"5、发散式变化\rDivergent Chane 软件再怎么说就应该是软的，一旦需要修改，希望能够跳到系统的某一点，只在该处做修改。如果不能的化就有一种刺鼻味道了。 某个类经常因为不同原因在不同不同方向上发生变化发散式变化就出现了， 一旦出现这种发散式变化那么就需要将对象分解成多个对象或者会更好，当出现多个类后还可以提炼超类等。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:5","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"6、霰弹式修改\rShotgun Surgery 正对某一项变化需要在许多不同类种做出需要小修改，所面临的味道就是霰弹式修改， 这种情况应该使用移动方法和移动字段，把所有修改的代码放进同一个类，如果没有现存的类可以按值这些代码就创造一个，使用内联类可以将一系列相关行为放进同一个类。 这也可能造成少量的发散式变化， ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:6","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"7、依恋情结\rFeature Envy 对象技术的全部要点在于：这是一种将数据和对数据的操作行为包装在一起的技术，有一中经典的气味是:函数对某个类的兴趣高于对自己所处类的兴趣。 使用移动方法把某些方法移动带它该去的地方，有的时候还需要提炼方法 如果某个函数需要需要几个类的功能，判断哪个类拥有最多被此函数使用的数据，然后就把这个函数和那些数据摆在一起，可以先将函数分解成多个较小函数分别置于不同地点。 将总是一起变化的东西放在一块，数据和引用这些数据的行为总是一起变化的。 策略和访问者模式可以轻松修改函数行为，付出了多一层的代价 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:7","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"8、数据泥团\rData Clumps 数据项会成群结队出现。 如果删除总舵数据中的一项，其他数据有没有失去意义，如果它们不再有意义，就是一个明确的信号，应该产生一个新对象。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:8","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"9、基本类型偏执\rPrimitive Obsession 结构类型允许你将数据组织成有意义的形式，对象的极大价值在于打破了横亘于基本数据和较大类之间的界限。 积极的使用使用对象替换数据值，用类替换类型码，用状态/策略模式替代类型码 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:9","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"10、swithc惊悚现身\rSwitch Statements 面向对象程序的最明显特征就是少用switch，使用switch的问题在于重复，在修改上，如果switch散布于不同地点，就要添加新的case子句 如果看到switch语句的时候需要考虑用多态来替换它，问题在于多态出现在哪儿 使用提炼函数将switch提炼到独立函数中，再用移动方法将它搬移到需要多态性的类中，用子类替代类型码或者使用state/strategy替代类型码，完成之后再用使用多态替代条件。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:10","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"11、平行继承体系\rParallel Inheritance Hierarchies 如果为某个类增加一个子类的时候必须要为另一类相应增加一个子类。 如果某个继承体系的类名称前缀和两一个继承体系的类的名称前缀完全相同 让一个继承体系的实例引用另一个继承体系的实例，再使用移动方法和字段，就可以将引用端的继承体系消除。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:11","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"12、冗赘类\rLazy Class 创建的每个类都有人去理解它维护它，如果一个类不值得其身价就应该消失。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:12","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"13、夸夸其谈的未来性\rSpeculative Generality 总有一天需要做这件事，企图以各式各样的勾子和特殊情况来处理一些非必要事情会造成程序难以理解。不需要 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:13","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"14、令人迷惑的暂时字段\rTemporary Field 某个实例变量仅为某种特定情况而设置。 使用提炼类给这些孤儿创造一个家，然后把所有和这个变量相关的代码都放进这个新家，还可以使用空对象方法创建一个空对象。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:14","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"15、过度耦合的消息链\rMessage Chains 一个对象请求一个对象，然后后者请求另一个对象，等等 使用隐藏委托。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:15","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"16、中间人\rMiddle Man 对象的基本特征之一就是封装，对外部世界隐藏内部细节，封装往往伴随着委托，但有可能过度使用委托，移除中间人 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:16","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"17、狎昵关系\rInappropriate Intimacy 两个类过于亲密，移动方法和字段让他们划清界限。如果划清不了就使用提炼类让他们融为一体吧 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:17","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"18、异曲同工类\rAlternative Classes with Different Interfaces 重命名方法，提炼子类 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:18","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"19、不完美的库类\rIncomplete Library Class 给库类加入新的方法，外部方法和本地扩展。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:19","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"20、纯稚的数据类\rData Class 不会说话的数据容器一定被其他类过分的操控着，运用封装字段封装，移动设置方法，移动方法，提炼方法。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:20","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"21、被拒绝的遗赠\rRefused Bequest 子类不愿全部继承，为这个子类创建一个兄弟类，在运用下移方法和字段把用不到的函数下推给那个兄弟，这样一来，超类就只持有所有子类共享的东西。 用委托替换继承 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:21","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"22、过多注释\rComments 提炼方法。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:22","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 要成功将Prism应用程序移植到生产环境中，您需要计划部署作为应用程序设计过程的一部分。本主题介绍了为部署准备组合或模块化应用程序所需执行的注意事项和操作，以及为将应用程序提供给用户所需执行的操作。 ","date":"2019-07-06","objectID":"/2019/07/prism14-deploying/:0:0","tags":["Prism","Deploying"],"title":"Prism Deploying","uri":"/2019/07/prism14-deploying/"},{"categories":"Prism","content":"部署应用程序\rWPF Prism应用程序可以由可执行文件和任意数量的附加DLL组成。主要的可执行文件是shell应用程序项目。一些额外的DLL将是应用程序的模块。可能有一些额外的DLL只是应用程序的shell和模块使用的共享程序集。此外，您可能拥有一组与应用程序一起部署的资源或内容文件。 要部署WPF Prism应用程序，您有三种选择： “XCopy部署” ClickOnce部署 Windows Installer部署 “XCopy部署”用作通过某种文件复制操作进行手动部署的通用术语，可能包括也可能不包括使用XCOPY命令行工具。如果选择以这种方式部署应用程序，则由您手动打包文件并将其移动到目标计算机。只要保持shell应用程序可执行文件，模块DLL和内容文件的预期文件夹结构和相对位置，应用程序就可以运行了。 通常，需要更自动的部署方式，以确保将事物放置在正确的位置，并且用户可以轻松访问以运行应用程序。为方便起见，您可以选择使用ClickOnce或Windows Installer（.msi文件），具体取决于应用程序存在哪些其他安装要求。 是否使用ClickOnce或Windows Installer的决定经常被误解。ClickOnce并非旨在成为一种通用的部署技术。它适用于需要在客户端计算机上进行低影响安装的应用程序。如果您的应用程序需要在安装时进行计算机范围的更改 - 例如安装驱动程序，与其他应用程序集成，安装服务以及超出仅运行可执行文件范围的其他内容，则ClickOnce可能不是适当的部署选择。但是，如果您在客户端计算机上进行了轻量级安装，并且希望从WPF应用程序的网络部署和更新中受益，则ClickOnce可能是一个很好的选择。 要为应用程序创建Windows Installer部署包（.msi文件），您有多种选择，包括Visual Studio安装项目，Windows Installer XML（WiX）项目或众多第三方安装程序创建产品。 ","date":"2019-07-06","objectID":"/2019/07/prism14-deploying/:0:1","tags":["Prism","Deploying"],"title":"Prism Deploying","uri":"/2019/07/prism14-deploying/"},{"categories":"Prism","content":"使用ClickOnce部署WPF Prism应用程序\rClickOnce是Windows Presentation Foundation（WPF）或Windows Forms部署机制，自2.0版以来一直是.NET Framework的一部分。ClickOnce支持从部署服务器通过网络自动部署和更新WPF应用程序。WPF Prism应用程序可以使用ClickOnce来获取部署到客户端计算机的shell，模块和任何其他依赖项。Prism应用程序的主要挑战是ClickOnce的Visual Studio发布过程不会自动在已发布的应用程序中包含动态加载的模块。 使用ClickOnce部署WPF应用程序需要两个步骤。首先，您必须从Visual Studio发布应用程序，然后才能将其部署到客户端计算机。发布应用程序会生成两个清单（部署清单和应用程序清单），并将应用程序文件复制到发布目录。然后可以将该发布文件夹移动到可能无法从开发者计算机直接访问的另一服务器，以使得已发布的应用程序可从已知位置和URL访问客户端计算机。将应用程序部署到客户端计算机只需要提供用户可以导航到的URL或链接。URL指向发布部署服务器上的部署清单。在浏览器中加载该URL时 客户端计算机上的ClickOnce下载清单指定的清单和应用程序文件。下载文件并将其存储在用户配置文件下后，ClickOnce然后启动该应用程序。如果将后续更新发布到部署服务器，ClickOnce可以自动检测这些更新，下载并应用它们，或者有一些设置允许您在应用程序启动后按需或在后台检测和应用更新。 当您发布具有动态加载模块的WPF Prism应用程序时，shell项目通常不会对动态加载的模块具有项目引用。因此，发布的ClickOnce应用程序清单也不包含这些模块文件，如果使用ClickOnce部署应用程序，则客户端计算机将无法获取模块文件。要解决此问题，您必须修改应用程序清单以包含shell应用程序项目未引用的模块文件。 ","date":"2019-07-06","objectID":"/2019/07/prism14-deploying/:0:2","tags":["Prism","Deploying"],"title":"Prism Deploying","uri":"/2019/07/prism14-deploying/"},{"categories":"Prism","content":"ClickOnce发布流程\r您可以使用名为Manifest Generating and Editing工具（Mage）的Windows软件开发工具包（SDK）工具或使用ClickOnce发布API的自定义工具从Visual Studio 2013发布ClickOnce应用程序。Visual Studio公开了ClickOnce发布所需的大部分功能。但是，对于管理服务器上的ClickOnce部署的IT管理员，可能无法使用或不需要Visual Studio。Mage旨在解决ClickOnce的大多数常见管理任务; 它是一个轻量级的.NET Framework基于Windows的应用程序，可以提供给您的管理员。但是，Mage需要太多详细步骤（按正确顺序执行）才能成功完成常见任务，例如修改应用程序清单中列出的应用程序文件。为了使这些任务更简单， Manifest Manager Utility示例实用程序演示了如何使用ClickOnce发布API以更简单的方式管理部署和应用程序清单。此实用程序用于在单个用户界面（UI）中更新应用程序清单文件列表和部署清单设置，本主题后面的部分将介绍其用法，以便初步部署和更新Prism应用程序。Manifest Manager Utility使用Microsoft.Build.Tasks.Deployment命名空间中公开的API 来加载，操作和保存ClickOnce部署的已修改清单文件。您可以下载Manifest Manager Utility来自Codeplex的Prism社区网站。要了解发布和更新使用动态模块加载的WPF Prism应用程序所涉及的具体步骤，请参阅WPF Prism部署动手实验：使用ClickOnce发布和更新。 下图显示了ClickOnce应用程序发布的典型结构，基于Visual Studio在使用ClickOnce发布应用程序时生成部署文件夹的方式。它包含应用程序的根文件夹，其中包含默认部署清单（.application文件）。默认部署清单通常指向Visual Studio生成的最近发布的版本，但可以将其更改为指向管理员选择的任何版本。根文件夹还包含Setup.exe引导程序，它允许您在使用ClickOnce部署应用程序之前部署可能需要运行安装程序或可执行文件的应用程序的先决条件。然后有一个特定于应用程序的文件的子文件夹，在其下为您发布的每个版本获取单独的子文件夹。发布版本是部署清单文件中的单独项目设置和条目，用于对部署作为整体进行版本控制，而不是包含的程序集的各个程序集版本。ClickOnce使用发布版本来确定何时可以从已安装ClickOnce应用程序的客户端获得更新。 ","date":"2019-07-06","objectID":"/2019/07/prism14-deploying/:0:3","tags":["Prism","Deploying"],"title":"Prism Deploying","uri":"/2019/07/prism14-deploying/"},{"categories":"Prism","content":"ClickOnce发布文件夹结构\r在每个发布版本的应用程序文件文件夹下，您拥有可用于将特定版本部署到客户端计算机的部署清单（.application文件）的另一个副本，或者可以将其复制到根文件夹以导致服务器端回滚到以前的版本。除了任何依赖库（例如Prism模块程序集）和资源文件之外，应用程序可执行文件也将位于此文件夹中，并且在由Visual Studio发布时将自动以.deploy文件扩展名为后缀。这样做是为了简化发布Web服务器上的文件扩展名映射，这样您就不必下载.dll，.exe以及组成应用程序的大量其他潜在文件类型。 应用程序清单（.exe.manifest）文件也包含在此文件夹中，并由部署清单引用。它包含应用程序组成的文件列表，每个文件都有哈希值，以帮助进行变更检测; 它还包含应用程序运行所需的权限列表，因为如果需要，ClickOnce可以在部分信任AppDomain中启动应用程序。 如果使用Mage或自定义工具手动生成或更新ClickOnce应用程序发布，则不限于此文件夹和文件结构。对于任何特定的ClickOnce发布，依赖链包括以下内容： 它包括一个部署清单，通过嵌入的代码库URL指向应用程序清单。 它包括一个应用程序清单，其中包含每个应用程序文件的相对路径。这些文件必须位于应用程序清单所在的同一文件夹或子文件夹中。 它包括应用程序文件本身，通常在文件名后附加.deploy文件扩展名，以简化将这些文件映射到部署服务器上的MIME类型。下载文件后，ClickOnce会自动剥离客户端上的.deploy文件扩展名。 ","date":"2019-07-06","objectID":"/2019/07/prism14-deploying/:0:4","tags":["Prism","Deploying"],"title":"Prism Deploying","uri":"/2019/07/prism14-deploying/"},{"categories":"Prism","content":"ClickOnce部署和更新过程\r通过ClickOnce将应用程序实际部署到用户几乎总是通过在部署服务器上提供已发布应用程序的部署清单的URL或超链接来启动。用户可以单击超链接或在浏览器中输入地址，并调用ClickOnce部署过程。将清单和应用程序文件下载到客户端计算机后，将启动该应用程序。有一些ClickOnce选项允许您在初始部署期间安装应用程序以供脱机使用，或者您可以要求用户每次都使用链接或URL启动应用程序。将新版本的应用程序发布到部署服务器时，ClickOnce可以自动或手动检查更新，并在下次启动应用程序时下载并应用更新。 ","date":"2019-07-06","objectID":"/2019/07/prism14-deploying/:0:5","tags":["Prism","Deploying"],"title":"Prism Deploying","uri":"/2019/07/prism14-deploying/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 在构建大型复杂WPF应用程序时，常见的方法是将功能划分为离散模块程序集。还希望最小化这些模块之间静态引用的使用，这可以通过使用委托命令，区域上下文，共享服务和事件聚合器来实现。这允许模块被独立地开发，测试，部署和更新，并且它迫使松散耦合的通信。本主题提供有关何时使用委托命令和路由命令以及何时使用事件聚合器和.NET框架事件的指导。 在模块之间进行通信时，了解方法之间的差异非常重要，这样您才能最好地确定在特定方案中使用哪种方法。Prism Library提供以下通信方法： 解决方案指挥。在期望用户交互立即采取行动时使用。 地区背景。使用此选项可在主机区域中的主机和视图之间提供上下文信息。这种方法有点类似于DataContext，但它不依赖于它。 共享服务。呼叫者可以在服务上调用一种方法，该方法将事件引发给消息的接收者。如果以上都不适用，请使用此选项。 事件聚合。用于在没有直接的动作反应期望的情况下跨视图模型，演示者或控制器进行通信。 ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:0","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"Solution Commanding\r如果您需要响应用户手势，例如单击命令调用程序（例如，按钮或菜单项），并且您希望基于业务逻辑启用调用程序，请使用命令。 Windows Presentation Foundation（WPF）提供RoutedCommand，它擅长将命令调用程序（如菜单项和按钮）与命令处理程序连接，命令处理程序与具有键盘焦点的可视树中的当前项相关联。 但是，在复合方案中，命令处理程序通常是视图模型，在可视树中没有任何关联元素，或者不是焦点元素。为了支持这种情况，Prism库提供了DelegateCommand，它允许您在执行命令时调用委托方法，而CompositeCommand允许您组合多个命令**。这些命令与内置的RoutedCommand不同**，后者将在可视树上上下路由命令执行和处理。这允许您在可视树中的某个点触发命令并在更高级别处理它。 该CompositeCommand是一个实现ICommand的，以便它可以被绑定到调用者。CompositeCommands可以连接到几个子命令; 调用CompositeCommand时，也会调用子命令。 CompositeCommands支持启用。CompositeCommands侦听每个连接命令的CanExecuteChanged事件。然后它会引发此事件通知其调用者。调用者通过在CompositeCommand上调用CanExecute来对此事件做出反应。然后，CompositeCommand通过在每个子命令上调用CanExecute来再次轮询其所有子命令。如果对CanExecute的任何调用返回false，则CompositeCommand将返回false，从而禁用调用者。 这对于跨模块通信有何帮助？基于Prism库的应用程序可能具有在shell中定义的全局CompositeCommands，它们具有跨模块的含义，例如Save，Save All和Cancel。然后，模块可以使用这些全局命令注册其本地命令并参与其执行。 注意： DelegateCommand和CompositeCommand*可以在Prism.Commands命名空间中找到，该命名空间位于Prism.Core NuGet包中。* 关于WPF路由事件和路由命令 路由事件是一种事件，可以在元素树中的多个侦听器上调用处理程序，而不是仅通知直接订阅该事件的对象。WPF路由命令通过可视树中的UI元素传递命令消息，但树外的元素将不会接收这些消息，因为它们仅从聚焦元素或明确声明的目标元素向上或向下冒泡。路由事件可用于通过元素树进行通信，因为事件的事件数据会持续到路由中的每个元素。一个元素可能会更改事件数据中的某些内容，并且该更改可用于路径中的下一个元素。 因此，您应该在以下方案中使用WPF路由事件：在公共根目录中定义公共处理程序或定义您自己的自定义控件类。 ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:1","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"创建委托命令\r要创建委托命令，请在视图模型的构造函数中实例化DelegateCommand字段，然后将其作为ICommand属性公开。 // ArticleViewModel.cs public class ArticleViewModel : BindableBase { private readonly ICommand showArticleListCommand; public ArticleViewModel(INewsFeedService newsFeedService, IRegionManager regionManager, IEventAggregator eventAggregator) { this.showArticleListCommand = new DelegateCommand(this.ShowArticleList); } public ICommand ShowArticleListCommand { get { return this.showArticleListCommand; } } } ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:2","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"创建复合命令\r要创建复合命令，请在构造函数中实例化CompositeCommand字段，向其中添加命令，然后将其作为ICommand属性公开。 public class MyViewModel : BindableBase { private readonly CompositeCommand saveAllCommand; public ArticleViewModel(INewsFeedService newsFeedService, IRegionManager regionManager, IEventAggregator eventAggregator) { this.saveAllCommand = new CompositeCommand(); this.saveAllCommand.RegisterCommand(new SaveProductsCommand()); this.saveAllCommand.RegisterCommand(new SaveOrdersCommand()); } public ICommand SaveAllCommand { get { return this.saveAllCommand; } } } ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:3","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"使命令在全球范围内可用\r通常，要创建全局可用命令，请创建DelegateCommand或CompositeCommand的实例，并通过静态类公开它。 public static class GlobalCommands { public static CompositeCommand MyCompositeCommand = new CompositeCommand(); } 在您的模块中，将子命令与全局可用命令相关联。 GlobalCommands.MyCompositeCommand.RegisterCommand(command1); GlobalCommands.MyCompositeCommand.RegisterCommand(command2); ***注意：*要提高代码的可测试性，可以使用代理类访问全局可用的命令并在测试中模拟该代理类。 ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:4","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"绑定到全局可用命令\r以下代码示例演示如何将按钮绑定到WPF中的命令。 \u003cButton Name=\"MyCompositeCommandButton\" Command=\"{x:Static local:GlobalCommands.MyCompositeCommand}\"\u003eExecute My Composite Command\u003c/Button\u003e 注意：另一种方法是将命令作为资源存储在Application.Resources部分的App.xaml文件中。然后，在视图中 - 必须在设置该资源后创建 - 您可以设置*Command =“{Binding MyCompositeCommand，Source = {StaticResource GlobalCommands}}”*以向命令添加调用者。 ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:5","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"Region Context\r在很多情况下，您可能希望在托管区域的视图和区域内的视图之间共享上下文信息。例如，类似主细节的视图显示业务实体并公开区域以显示该业务实体的其他详细信息。Prism Library使用名为RegionContext的概念来共享区域主机与区域内加载的任何视图之间的对象，如下图所示。 根据具体情况，您可以选择共享单条信息（例如标识符）或共享模型。视图可以检索RegionContext，然后注册更改通知。视图还可以更改RegionContext的值。有几种方法可以公开和使用RegionContext： 您可以将RegionContext公开给可扩展应用程序标记语言（XAML）中的区域。 您可以将RegionContext公开给代码中的区域。 您可以从区域内的视图中使用RegionContext。 注意：如果该视图是DependencyObject，则Prism Library当前仅支持从区域内的视图中使用RegionContext*。如果您的视图不是DependencyObject（例如，您正在使用WPF自动数据模板并直接在区域中添加视图模型），请考虑创建自定义RegionBehavior以将RegionContext转发到视图对象。* 关于数据上下文属性 数据上下文是一种允许元素从其父元素继承有关用于绑定的数据源的信息的概念。子元素自动继承其父元素的DataContext。数据沿着可视化树向下流动。 ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:6","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"共享服务\r跨模块通信的另一种方法是通过共享服务。加载模块后，模块会将其服务添加到服务定位器。通常，通过公共接口类型从服务定位器注册和检索服务。这允许模块使用其他模块提供的服务，而无需对模块进行静态引用。服务实例在模块之间共享，因此您可以共享数据并在模块之间传递消息。 在Stock Trader参考实施（Stock Trader RI）中，Market模块提供了IMarketFeedService的实现。Position模块通过使用shell应用程序的依赖注入容器来使用这些服务，该容器提供服务位置和解析。所述IMarketFeedService是指由其他模块被消耗，因此它可以在找到StockTraderRI.Infrastructure共同组装，但该接口的具体实现并不需要被共享的，所以它是市场模块中直接定义，并且可以是独立于其他模块更新。 要查看这些服务如何导出到MEF，请参阅MarketFeedService.cs和MarketHistoryService.cs文件，如以下代码示例所示。Position模块的ObservablePosition通过构造函数依赖注入接收IMarketFeedService服务。 // MarketFeedService.cs [Export(typeof(IMarketFeedService))] [PartCreationPolicy(CreationPolicy.Shared)] public class MarketFeedService : IMarketFeedService, IDisposable { ... } 这有助于跨模块通信，因为服务使用者不需要对提供服务的模块的静态引用。此服务可用于在模块之间发送或接收数据。 注意：某些依赖项注入容器允许使用属性注册依赖项，如此示例所示。其他容器可以使用显式注册。在这些情况下，注册通常在模块加载期间发生，此时Prism调用IModule.Initialize方法。有关更多信息，请参阅模块化应用程序开 ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:7","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"Event Aggregation\rPrism库提供了一种事件机制，可以在应用程序中松散耦合的组件之间进行通信。该机制基于事件聚合器服务，允许发布者和订阅者通过事件进行通信，但仍然没有彼此直接引用。 该EventAggregator提供组播发布/订阅功能。这意味着可以有多个发布者引发相同的事件，并且可以有多个订阅者收听同一事件。考虑使用EventAggregator跨模块发布事件，以及在业务逻辑代码（如控制器和演示者）之间发送消息时。 Stock Trader RI的一个例子就是点击Process Order按钮并顺序处理订单; 在这种情况下，其他模块需要知道订单已成功处理，以便他们可以更新他们的视图。 使用Prism Library创建的事件是键入的事件。这意味着您可以在运行应用程序之前利用编译时类型检查来检测错误。在Prism库中，EventAggregator允许订阅者或发布者定位特定的EventBase。事件聚合器还允许多个发布者和多个订阅者，如下图所示。 关于.NET Framework事件 如果不要求松散耦合，则使用.NET Framework事件是组件之间通信的最简单，最直接的方法。.NET Framework中的事件实现了Publish-Subscribe模式，但是要订阅对象，您需要直接引用该对象，在复合应用程序中，该对象通常驻留在另一个模块中。这导致紧密耦合的设计。因此，.NET Framework事件用于模块内的通信，而不是模块之间的通信。 如果使用.NET Framework事件，则必须非常小心内存泄漏，尤其是如果您有一个非静态或短期组件，它可以在静态或长寿命的事件上订阅事件。如果您没有取消订阅订阅者，则发布者将保留该订阅者，这将阻止第一个订阅者被垃圾收集。 ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:8","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"IEventAggregator\r所述EventAggregator类被提供作为在容器中的服务，并且可以通过检索IEventAggregator接口。事件聚合器负责定位或构建事件以及保留系统中事件的集合。 public interface IEventAggregator { TEventType GetEvent\u003cTEventType\u003e() where TEventType : EventBase; } 该EventAggregator构建事件在其第一次访问，如果它尚未建立。这使发布者或订阅者无需确定事件是否可用。 ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:9","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"PubSubEvent\r连接发布者和订阅者的真正工作是由PubSubEvent类完成的。这是Prism库中包含的EventBase类的唯一实现。此类维护订户列表并处理订阅者的事件调度。 所述PubSubEvent类是一个一般类，需要将其定义为一般类型的有效载荷类型。这有助于在编译时强制发布者和订阅者提供成功事件连接的正确方法。以下代码显示了PubSubEvent类的部分定义。 注意： PubSubEvent可以在Prism.Events命名空间中找到，该命名空间位于Prism.Core NuGet包中。 // PubSubEvent.cs public class PubSubEvent\u003cTPayload\u003e : EventBase { ... public SubscriptionToken Subscribe(Action\u003cTPayload\u003e action); public SubscriptionToken Subscribe(Action\u003cTPayload\u003e action, ThreadOption threadOption); public SubscriptionToken Subscribe(Action\u003cTPayload\u003e action, bool keepSubscriberReferenceAlive) public SubscriptionToken Subscribe(Action\u003cTPayload\u003e action, ThreadOption threadOption, bool keepSubscriberReferenceAlive) public virtual SubscriptionToken Subscribe(Action\u003cTPayload\u003e action, ThreadOption threadOption, bool keepSubscriberReferenceAlive); public virtual SubscriptionToken Subscribe(Action\u003cTPayload\u003e action, ThreadOption threadOption, bool keepSubscriberReferenceAlive, Predicate\u003cTPayload\u003e filter); public virtual void Publish(TPayload payload); public virtual void Unsubscribe(Action\u003cTPayload\u003e subscriber); public virtual bool Contains(Action\u003cTPayload\u003e subscriber) ... } ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:10","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"创建和发布事件\r以下各节介绍如何创建，发布和订阅PubSubEvent使用IEventAggregator接口。 创建一个事件\r所述**PubSubEvent **旨在是为应用程序或模块的特定事件的基类。TPayLoad是事件有效负载的类型。有效负载是在事件发布时将传递给订阅者的参数。 例如，以下代码显示了股票交易者参考实现（Stock Trader RI）中的TickerSymbolSelectedEvent。有效负载是包含公司符号的字符串。请注意此类的实现是如何为空。 public class TickerSymbolSelectedEvent : PubSubEvent\u003cstring\u003e{} 注意：在复合应用程序中，事件通常在多个模块之间共享，因此它们在公共位置定义。在Stock Trader RI中，这是在StockTraderRI.Infrastructure项目中完成的。 发布活动\r发布者通过从EventAggregator检索事件并调用Publish方法来引发事件。要访问EventAggregator，可以通过向类构造函数添加类型为IEventAggregator的参数来使用依赖项注入。 以下代码演示了如何发布TickerSymbolSelectedEvent。 this.eventAggregator.GetEvent\u003cTickerSymbolSelectedEvent\u003e().Publish(\"STOCK0\"); ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:11","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"订阅活动\r订阅者可以使用PubSubEvent类上提供的一个Subscribe方法重载来登记事件。有几种方法可以订阅PubSubEvents。使用以下标准来帮助确定最适合您需求的选项： 如果您需要能够在收到事件时更新UI元素，请订阅以在UI线程上接收事件。 如果您需要过滤事件，请在订阅时提供过滤器委托。 如果您对事件有性能问题，请考虑在订阅时使用强引用的委托，然后手动取消订阅PubSubEvent。 如果以上都不适用，请使用默认订阅。 以下部分描述了这些选项。 订阅UI线程\r订阅者通常需要更新UI元素以响应事件。在WPF中，只有UI线程可以更新UI元素。 默认情况下，订阅者在发布者的线程上接收事件。如果发布者从UI线程发送事件，则订阅者可以更新UI。但是，如果发布者的线程是后台线程，则订阅者可能无法直接更新UI元素。在这种情况下，订户需要使用Dispatcher类在UI线程上安排更新。 Prism Library提供的PubSubEvent可以通过允许订阅者在UI线程上自动接收事件来提供帮助。订阅者在订阅期间指示此信息，如以下代码示例所示。 public void Run() { ... this.eventAggregator.GetEvent\u003cTickerSymbolSelectedEvent\u003e().Subscribe(ShowNews, ThreadOption.UIThread); ); } public void ShowNews(string companySymbol) { this.articlePresentationModel.SetTickerSymbol(companySymbol); } ThreadOption有以下选项： PublisherThread。使用此设置可在发布商的主题上接收活动。这是默认设置。 BackgroundThread。使用此设置在.NET Framework线程池线程上异步接收事件。 UIThread。使用此设置可在UI线程上接收事件。 注意：为了让PubSubEvents在UI线程上发布给订阅者，必须首先在UI线程上构造EventAggregator*。* 订阅过滤\r订阅者可能不需要处理已发布事件的每个实例。在这些情况下，订户可以使用过滤器参数。的滤波器参数的类型的**System.Predicate **和是当事件被发布，以确定是否已发布的事件的有效载荷的一组具有调用的回调订户要求的标准相匹配的被执行的委托。如果有效负载不满足指定的条件，则不执行订户回调。 通常，此过滤器作为lambda表达式提供，如以下代码示例所示。 FundAddedEvent fundAddedEvent = this.eventAggregator.GetEvent\u003cFundAddedEvent\u003e(); fundAddedEvent.Subscribe(FundAddedEventHandler, ThreadOption.UIThread, false, fundOrder =\u003e fundOrder.CustomerId == this.customerId); 注：该订阅方法返回类型的订阅令牌Prism.Events.SubscriptionToken*可用于以后删除订阅的事件。当您使用匿名委托或lambda表达式作为回调委托时，或者使用不同的过滤器订阅相同的事件处理程序时，此标记特别有用。* ***注意：*建议不要在回调委托中修改有效负载对象，因为多个线程可能同时访问有效负载对象。您可以使有效负载不可变，以避免并发错误。 订阅使用强引用\r如果您在短时间内提出多个事件并注意到它们的性能问题，则可能需要使用强委托引用进行订阅。如果您这样做，则需要在处置订户时手动取消订阅该事件。 默认情况下，PubSubEvent维护对订阅者处理程序的弱委托引用，并对订阅进行过滤。这意味着PubSubEvent所持有的引用不会阻止订阅者的垃圾收集。使用弱委托引用可以使订户免于取消订阅并允许正确的垃圾收集。 但是，维护此弱委托引用比相应的强引用要慢。对于大多数应用程序，此性能不会很明显，但如果您的应用程序在短时间内发布大量事件，则可能需要对PubSubEvent使用强引用。如果您确实使用了强委托引用，则订阅者应该取消订阅，以便在不再使用订阅对象时启用正确的垃圾回收。 要使用强引用进行订阅，请在Subscribe方法上使用keepSubscriberReferenceAlive参数，如以下代码示例所示。 FundAddedEvent fundAddedEvent = eventAggregator.GetEvent\u003cFundAddedEvent\u003e(); bool keepSubscriberReferenceAlive = true; fundAddedEvent.Subscribe(FundAddedEventHandler, ThreadOption.UIThread, keepSubscriberReferenceAlive, fundOrder =\u003e fundOrder.CustomerId == _customerId); 所述keepSubscriberReferenceAlive参数的类型的布尔： 设置为true时，事件实例会保留对订户实例的强引用，从而不允许它进行垃圾回收。有关如何取消订阅的信息，请参阅本主题后面的“ 取消订阅事件 ”一节。 当设置为false（省略此参数时的默认值）时，事件维护对订户实例的弱引用，从而允许垃圾收集器在没有其他引用时配置订阅者实例。收集订户实例后，将自动取消订阅该事件。 默认订阅\r对于最小订阅或默认订阅，订阅者必须提供具有接收事件通知的适当签名的回调方法。例如，TickerSymbolSelectedEvent的处理程序要求该方法采用字符串参数，如以下代码示例所示。 public TrendLineViewModel(IMarketHistoryService marketHistoryService, IEventAggregator eventAggregator) { ... eventAggregator.GetEvent\u003cTickerSymbolSelectedEvent\u003e().Subscribe(this.TickerSymbolChanged); } public void TickerSymbolChanged(string newTickerSymbol) { MarketHistoryCollection newHistoryCollection = this.marketHistoryService.GetPriceHistory(newTickerSymbol); this.TickerSymbol = newTickerSymbol; this.HistoryCollection = newHistoryCollection; } 取消订阅活动\r如果您的订户不再想要接收活动，您可以使用订阅者的处理程序取消订阅，也可以使用订阅令牌取消订阅。 以下代码示例演示如何直接取消订阅处理程序。 FundAddedEvent fundAddedEvent = this.eventAggregator.GetEvent\u003cFundAddedEvent\u003e(); fundAddedEvent.Subscribe(FundAddedEventHandler, ThreadOption.PublisherThread); fundAddedEvent.Unsubscribe(FundAddedEventHandler); 以下代码示例演示如何取消订阅订阅令牌。令牌作为Subscribe方法的返回值提供。 FundAddedEvent fundAddedEvent = this.eventAggregator.GetEvent\u003cFundAddedEvent\u003e(); subscriptionToken = fundAddedEvent.Subscribe(FundAddedEventHandler, ThreadOption.UIThread, false, fundOrder =\u003e fundOrder.CustomerId == this.customerId); fundAddedEvent.Unsubscribe(subscriptionToken); ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:12","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 当用户与富客户端应用程序交互时，其用户界面（UI）将不断更新以反映用户正在处理的当前任务和数据。随着用户与应用程序内的各种任务交互并完成各种任务，UI可能会随着时间发生相当大的变化。应用程序协调这些UI更改的过程通常称为导航。本主题描述如何使用Prism库实现复合Model-View-ViewModel（MVVM）应用程序的导航。 通常，导航意味着删除UI中的某些控件，同时添加其他控件。在其他情况下，导航可以意味着更新一个或多个现有控件的视觉状态 - 例如，一些控件可以被简单地隐藏或折叠，而其他控件被显示或扩展。类似地，导航可能意味着控件显示的数据被更新以反映应用程序的当前状态 - 例如，在主 - 细节场景中，详细视图中显示的数据将基于当前选择的项目进行更新在主视图中。所有这些场景都可以被视为导航，因为更新了用户界面以反映用户的当前任务和应用程序的当前状态。 应用程序内的导航可以由用户与UI的交互（通过鼠标事件或其他UI手势）或由于内部逻辑驱动的状态改变而从应用程序本身引起。在某些情况下，导航可能涉及非常简单的UI更新，不需要自定义应用程序逻辑。在其他情况下，应用程序可以实现复杂的逻辑以编程方式控制导航以确保强制执行某些业务规则 - 例如，应用程序可能不允许用户离开某个表单而不首先确保输入的数据是正确的。 在Windows Presentation Foundation（WPF）应用程序中实现所需的导航行为通常可以相对简单，因为它提供了对导航的直接支持。但是，在使用Model-View-ViewModel（MVVM）模式的应用程序中或在使用多个松散耦合模块的复合应用程序中实现导航可能更复杂。棱镜提供了在这些情况下实施导航的指导。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:0","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"prism Navigation\r导航定义为应用程序通过其与应用程序或内部应用程序状态更改进行交互而更改其UI的过程。 UI更新可以通过在应用程序的可视树中添加或删除元素，或者通过对可视树中的现有元素应用状态更改来完成。WPF是一个非常灵活的平台，通常可以使用这种方法实现特定的导航场景。但是，最适合您应用的方法取决于多种因素。 Prism区分了前面描述的两种导航方式。通过对可视树中的现有控件的状态更改完成的导航被称为基于状态的导航。通过从可视树中添加或移除元素来完成的导航被称为基于视图的导航。Prism提供了实现两种导航样式的指导，重点关注应用程序使用Model-View-ViewModel（MVVM）模式将UI（封装在视图中）与表示逻辑和数据（封装在视图中）分开的情况模型）。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:1","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"基于状态的导航\rState-Based Navigation 在基于状态的导航中，表示UI的视图可以通过视图模型中的状态更改或通过视图本身内的用户交互来更新。在这种导航方式中，不是用另一个视图替换视图，而是更改视图的状态。根据视图状态的更改方式，更新的UI可能会让用户感觉像导航一样。 这种导航方式适用于以下情况： 视图需要以不同的样式或格式显示相同的数据或功能。 视图需要根据视图模型的基础状态更改其布局或样式。 视图需要在视图的上下文中启动与用户的有限模态或非模态交互。 这种导航方式不适用于UI必须向用户呈现不同数据或用户必须执行不同任务的情况。在这些情况下，最好实现单独的视图（和视图模型）来表示数据或任务，然后使用基于视图的导航在它们之间导航，如本主题后面所述。类似地，如果实现导航所需的UI状态更改的数量过于复杂，则这种导航方式不适合，因为视图的定义可能变得很大并且难以维护。在这种情况下，最好通过使用基于视图的导航在不同的视图中实现导航。 以下部分描述了可以使用基于状态的导航的典型情况。这些部分中的每一部分都涉及基于状态的导航快速入门，它实现了即时消息传递式应用程序，允许用户管理和与其联系人聊天。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:2","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"以不同的格式或样式显示数据\rDisplaying Data in Different Formats or Styles 您的应用程序可能经常需要向用户显示相同的数据，但格式或样式不同。在这种情况下，您可以在视图中使用基于状态的导航在不同样式之间切换，可能使用它们之间的动画过渡。例如，基于状态的导航快速入门允许用户选择联系人的显示方式 - 简单文本列表或头像（图标）。用户可以通过单击“列表”按钮或“头像”按钮在这些可视表示之间切换。该视图提供了两个表示之间的动画过渡，如下图所示。 联系基于状态的导航快速入门中的视图导航\rContact view navigation in the State-Based Navigation QuickStart 由于视图呈现的是相同的数据，但是在不同的可视化表示中，视图模型不需要参与表示之间的导航。在这种情况下，导航完全在视图本身内处理。这种方法为UI设计人员提供了很大的灵活性，可以设计出引人注目的用户体验，而无需更改应用程序的代码。 混合行为提供了在视图中实现此导航样式的好方法。基于状态的导航QuickStart应用程序使用Blend的DataStateBehavior数据绑定到单选按钮，在使用可视状态管理器定义的两个可视状态之间切换，一个按钮将联系人显示为列表，一个按钮将联系人显示为图标。 \u003cei:DataStateBehavior Binding=\"{Binding IsChecked, ElementName=ShowAsListButton}\" Value=\"True\" TrueState=\"ShowAsList\" FalseState=\"ShowAsIcons\"/\u003e 当用户单击“ 联系人”或“ 头像”单选按钮时，可视状态在ShowAsList可视状态和ShowAsIcons可视状态之间切换。还使用可视状态管理器定义这些状态之间的翻转过渡动画。 当用户切换到当前所选联系人的详细信息视图时，基于状态的导航快速入门应用程序会显示此类导航的另一个示例。下图显示了此示例。 基于状态的导航快速入门中的“联系人详细信息”视图\r同样，这可以使用Blend DataStateBehavior轻松实现; 但是，这次它被绑定到视图模型上的ShowDetails属性，该属性使用翻转过渡动画在ShowDetails和ShowContacts视觉状态之间切换。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:3","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"Reflecting Application State\r类似地，应用程序中的视图有时可能需要根据对内部应用程序状态的更改来更改其布局或样式，而内部应用程序状态又由视图模型上的属性表示。基于状态的导航快速入门中显示了此方案的示例，其中使用ConnectionStatus属性在Chat视图模型类上表示用户的连接状态。当用户的连接状态发生变化时，将通知视图（通过属性更改通知事件），允许视图在适当的位置直观地表示当前连接状态，如下图所示。 基于状态的导航快速入门中的连接状态表示\rConnection state representation in the State-Based Navigation QuickStart 为实现此目的，视图定义绑定到视图模型的ConnectionStatus属性的DataStateBehavior数据，以在适当的可视状态之间切换。 \u003cei:DataStateBehavior Binding=\"{Binding ConnectionStatus}\" Value=\"Available\" TrueState=\"Available\" FalseState=\"Unavailable\"/\u003e 请注意，用户可以通过UI或应用程序根据某些内部逻辑或事件更改连接状态。例如，如果用户在特定时间段内没有与视图交互或者当用户的日历指示他或她在会议中时，应用程序可以移动到“不可用”状态。基于状态的导航快速入门通过使用计时器随机切换连接状态来模拟此场景。更改连接状态后，将更新视图模型上的属性，并通过属性更改事件通知视图。然后更新UI以反映当前连接状态。 前面的所有示例都涉及在视图中定义视觉状态，以及由于用户与视图的交互或视图模型定义的属性更改而在视图之间切换。此方法允许UI设计器在视图中实现类似导航的可视行为，而无需替换视图或要求对应用程序代码进行任何代码更改。当需要视图以不同的样式或布局呈现相同的数据时，此方法是合适的。它不适用于向用户呈现不同数据或应用程序功能或导航到应用程序的不同部分的情况。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:4","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"与用户交互\r通常，应用程序需要以有限的方式与用户交互。在这些情况下，通常更适合在当前视图的上下文中与用户交互，而不是导航到新视图。例如，在基于状态的导航快速入门中，用户可以通过单击“ 发送消息”按钮向联系人发送消息。然后，视图将显示一个弹出窗口，允许用户键入消息，如下图所示。因为与用户的这种交互是有限的并且逻辑上发生在父视图的上下文中，所以它可以容易地实现为基于状态的导航。 使用弹出窗口与用户交互\r使用基于状态的导航快速入门中的弹出窗口与用户交互要实现此行为，基于状态的导航快速入门实现SendMessage命令，该命令绑定到“ **发送消息”**按钮。调用此命令时，视图模型将与视图交互以显示弹出窗口。这是使用实现MVVM模式中描述的交互请求模式实现的。 以下代码示例显示了基于状态的导航QuickStart应用程序中的视图如何响应视图模型提供的SendMessageRequest交互请求对象。收到请求事件后，SendMessageChildWindow将显示为弹出窗口。 \u003cprism:InteractionRequestTrigger SourceObject=\"{Binding SendMessageRequest}\"\u003e \u003cprism:PopupWindowAction IsModal=\"True\"\u003e \u003cprism:PopupWindowAction.WindowContent\u003e \u003cvs:SendMessagePopupView /\u003e \u003c/prism:PopupWindowAction.WindowContent\u003e \u003c/prism:PopupWindowAction\u003e \u003c/prism:InteractionRequestTrigger\u003e ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:5","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"基于视图的导航\r虽然基于状态的导航对于前面概述的场景可能很有用，但是应用程序中的导航通常通过将应用程序UI中的一个视图替换为另一个视图来实现。在Prism中，这种导航方式称为基于视图的导航。 根据应用程序的要求，此过程可能相当复杂，需要仔细协调。以下是在实现基于视图的导航时经常需要解决的常见挑战： 导航的目标 - 要添加或移除的视图的容器或主机控件 - 可以在添加或移除视图时以不同方式处理导航，或者它们可以以不同方式可视地表示导航。在许多情况下，导航目标将是简单的Frame或ContentControl，导航视图将简单地显示在这些控件中。但是，在许多情况下，导航操作的目标是不同类型的容器控件，例如TabControl或ListBox控件。在这些情况下，导航可能需要激活或选择现有视图，或者添加新视图是一种特定方式。 应用程序还经常必须定义如何识别要导航到的视图。例如，在Web应用程序中，要导航到的页面通常由统一资源标识符（URI）直接标识。在客户端应用程序中，可以通过类型名称，资源位置或以各种不同方式来标识视图。此外，在由松散耦合的模块组成的复合应用程序中，视图通常将在单独的模块中定义。需要以不会在模块之间引入紧密耦合和依赖关系的方式识别单个视图。 在识别视图之后，必须仔细协调实例化和初始化新视图的过程。在使用MVVM模式时，这尤其重要。在这种情况下，视图和视图模型可能需要在导航操作期间通过视图的数据上下文进行实例化并相互关联。在应用程序利用依赖注入容器（例如Unity应用程序块（Unity）或托管可扩展性框架（MEF））的情况下，视图和/或视图模型（以及其他依赖类）的实例化可能必须使用特定的构造机制来实现。 MVVM模式提供了应用程序的UI与其表示和业务逻辑之间的分离。但是，应用程序的导航行为通常会跨越应用程序的UI和表示逻辑部分。用户通常会在视图中启动导航，并且视图将作为导航的结果进行更新，但通常还需要从视图模型中启动或协调导航。在整个视图和视图模型中清晰地分离应用程序的导航行为的能力是一个需要考虑的重要方面。 应用程序通常还需要将参数或上下文传递给视图，以便可以正确初始化它。例如，如果用户导航到视图以更新特定客户的详细信息，则必须将客户的ID或数据传递给视图，以便它可以显示正确的信息。 许多应用程序还必须仔细协调导航，以确保遵守某些业务规则。例如，在远离视图导航之前可能会提示用户，以便他们可以纠正任何无效数据，或者提示他们提交或放弃他们在该视图中所做的任何数据更改。此过程需要在先前视图和新视图之间进行仔细协调。 最后，大多数现代应用程序允许用户轻松地向后（或向前）导航到先前显示的视图。类似地，一些应用程序使用一系列视图或表单实现其工作流，并允许用户向前或向后导航，在完成任务并一次提交所有更改之前添加或更新数据。这些场景需要某种日记（或历史）机制，以便可以存储，重放或预定义导航序列。 Prism通过扩展Prism的区域机制来支持导航，为这些挑战提供支持和指导。以下部分提供了Prism区域的简要概述，并描述了它们如何扩展以支持基于视图的导航。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:6","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"Prism Region概述\rPrism Region旨在通过允许应用程序的整体UI以松散耦合的方式构建来支持复合应用程序（即，由多个模块组成的应用程序）的开发。区域允许在模块中定义的视图显示在应用程序的UI中，而无需模块明确了解应用程序的整体UI结构。它们允许轻松更改应用程序UI的布局，从而允许UI设计人员为应用程序选择最合适的UI设计和布局，而无需更改模块本身。 Prism Region基本上named placeholders，在其中可以显示视图。通过简单地向其添加RegionName附加属性，应用程序UI中的任何控件都可以声明为区域，如此处所示。 \u003cContentControl prism:RegionManager.RegionName=\"MainRegion\" ... /\u003e 对于指定为区域的每个控件，Prism创建一个Region对象来表示区域，并创建一个RegionAdapter对象，该对象管理视图在指定控件中的放置和激活。Prism Library 为大多数常见的WPF控件提供RegionAdapter实现。您可以创建自定义RegionAdapter以支持其他控件，或者在需要定义自定义行为时。该RegionManager类提供给接入地区的应用程序中的对象。 在许多情况下，区域控件将是一个简单的控件，例如ContentControl，它可以一次显示一个视图。在其他情况下，Region控件将是一个能够同时显示多个视图的控件，例如TabControl或ListBox控件。 区域适配器管理关联区域内的视图列表。这些视图中的一个或多个将根据其定义的布局策略显示在区域控件中。可以为视图分配一个名称，该名称可用于稍后检索该视图。区域适配器管理区域内视图的活动状态。活动视图是选定视图或最顶视图 - 例如，在TabControl中，活动视图是显示在所选选项卡中的视图; 在ContentControl中，活动视图是当前显示为控件内容的视图。 **注意：**在导航期间，视图的活动状态很重要。通常，您希望活动视图参与导航，以便它可以在用户导航之前保存数据，或者可以确认或取消导航操作。 先前版本的Prism允许以两种方式在区域中显示视图。第一种称为视图注入，允许以编程方式在区域中显示视图。此方法对于动态内容很有用，根据应用程序的表示逻辑，要在区域中显示的视图会频繁更改。 通过Region类的Add方法支持视图注入。下面的代码示例演示如何通过RegionManager类获取对Region对象的引用，并以编程方式向其添加视图。在此示例中，使用依赖项注入容器创建视图。 IRegionManager regionManager = ...; IRegion mainRegion = regionManager.Regions[\"MainRegion\"]; InboxView view = this.container.Resolve\u003cInboxView\u003e(); mainRegion.Add(view); 第二种方法称为视图发现，它允许模块针对区域名称注册视图类型。每当显示具有指定名称的区域时，将自动创建指定视图的实例并在该区域中显示。此方法对于相对静态的内容很有用，其中要在区域中显示的视图不会更改。 通过RegionManager类上的RegisterViewWithRegion方法支持视图发现。此方法允许您指定在显示命名区域时将调用的回调方法。以下代码示例显示了在首次显示主区域时如何创建视图（通过依赖项注入容器）。 IRegionManager regionManager = ...; regionManager.RegisterViewWithRegion(\"MainRegion\", () =\u003e container.Resolve\u003cInboxView\u003e()); 有关Prism区域支持的详细概述以及有关如何利用视图注入和发现来利用区域组成应用程序UI的信息，请参阅编写用户界面。本主题的其余部分描述了如何扩展区域以支持基于视图的导航，以及如何解决前面描述的各种挑战。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:7","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"基本区域导航\r视图注入和视图发现都可以被认为是有限形式的导航 - 视图注入是一种显式的，程序化的导航形式，而视图发现是一种隐式或延迟导航的形式。但是，在Prism 4.0中，基于URI和可扩展的导航机制，区域已经扩展到支持更一般的导航概念。 区域内的导航意味着将在该区域内显示新视图。要显示的视图通过URI标识，默认情况下，URI指的是要创建的视图的名称。您可以使用INavigateAsync接口定义的RequestNavigate方法以编程方式启动导航。 注意：尽管名称如此，但INavigateAsync接口并不代表在单独的后台线程上执行的异步导航。相反，INavigateAsync接口表示执行伪异步导航的能力。该RequestNavigate方法可以返回同步导航操作完成之后，或者它可以返回而导航操作仍悬而未决，如在用户需要确认导航的情况。通过允许您在导航期间指定回调和延续，Prism提供了一种机制来启用这些方案，而无需在后台线程上导航的复杂性。 INavigateAsync接口由Region类实现，允许您在该区域内启动导航。 IRegion mainRegion = ...; mainRegion.RequestNavigate(new Uri(\"InboxView\", UriKind.Relative)); 您也可以拨打RequestNavigate的方法RegionManager，它允许你指定要驾驶的区域的名称。这个方便的方法获取对指定区域的引用，然后调用RequestNavigate方法，如上面的代码示例所示。 IRegionManager regionManager = ...; regionManager.RequestNavigate(\"MainRegion\", new Uri(\"InboxView\", UriKind.Relative)); 默认情况下，导航URI指定在容器中注册的视图的名称。 使用MEF，您只需导出具有指定名称的视图类型即可。 [Export(\"InboxView\")] public partial class InboxView : UserControl { ... } 在导航期间，指定视图通过容器或MEF以及其对应的视图模型和其他相关服务和组件进行实例化。在实例化视图之后，将其添加到指定区域并激活（本主题后面将更详细地描述激活）。 **注意：**前面的描述说明了视图优先导航，其中URI指的是视图类型的名称，因为它是随容器导出或注册的。使用视图优先导航，依赖视图模型将创建为视图的依赖项。另一种方法是使用视图模型优先导航，其中导航URI指的是视图模型类型的名称，因为它是随容器导出或注册的。当视图定义为数据模板时，或者您希望独立于视图定义导航方案时，查看模型优先导航非常有用。 该RequestNavigate方法还允许您指定一个回调方法，或委托，当导航完成后，将被调用。 private void SelectedEmployeeChanged(object sender, EventArgs e) { ... regionManager.RequestNavigate(RegionNames.TabRegion, \"EmployeeDetails\", NavigationCompleted); } private void NavigationCompleted(NavigationResult result) { ... } 所述NavigationResult类定义了提供有关导航操作信息的属性。该结果属性指示导航是否成功。如果导航成功，则Result属性为true。如果导航失败，通常是因为在IConfirmNavigationResult.ConfirmNavigationRequest方法中返回’continuationCallBack（false）’ ，则Result属性将为false。如果由于异常导致导航失败，则Result属性将为false并且为Errorproperty提供对导航期间抛出的任何异常的引用。的语境属性提供给导航URI，它包含任何参数，并且向协调导航操作导航服务的引用。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:8","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"查看和查看模型参与导航\r通常，应用程序中的视图和视图模型将要参与导航。该INavigationAware接口支持这个。您可以在视图上或（更常见地）视图模型上实现此接口。通过实现此界面，您的视图或视图模型可以选择参与导航过程。 注意：在下面的描述中，尽管在视图之间导航期间引用了对此接口的调用，但应注意，无论是由视图还是视图模型实现，都将在导航期间调用INavigationAware接口。在导航过程中，Prism会检查视图是否实现了INavigationAware接口; 如果是，它会在导航期间调用所需的方法。Prism还会检查设置为视图的DataContext的对象是否实现了此接口; 如果是，它会在导航期间调用所需的方法。 此界面允许视图或视图模型参与导航操作。所述INavigationAware接口定义了三个方法。 public interface INavigationAware { bool IsNavigationTarget(NavigationContext navigationContext); void OnNavigatedTo(NavigationContext navigationContext); void OnNavigatedFrom(NavigationContext navigationContext); } 该IsNavigationTarget方法允许现有的（显示的）视图或视图模型，以指示它是否能够处理所述导航请求。在您可以重复使用现有视图来处理导航操作或导航到已存在的视图时，这非常有用。例如，可以更新显示客户信息的视图以显示不同的客户信息。有关使用此方法的详细信息，请参阅本主题后面的“ 导航到现有视图 ”一节。 该OnNavigatedFrom和的OnNavigatedTo方法是导航操作期间调用。如果区域中当前活动的视图实现此接口（或其视图模型），则在导航发生之前调用其OnNavigatedFrom方法。该OnNavigatedFrom方法允许一个视图保存任何状态，或为它的失活或去除从UI制备，例如，以保存用户已经到web服务或数据库所作的任何更改。 如果新创建的视图实现此接口（或其视图模型），则在导航完成后调用其OnNavigatedTo方法。所述的OnNavigatedTo方法允许新显示的视图初始化自身，可能使用传递给它上的导航URI任何参数。有关详细信息，请参阅下一节“ 导航期间传递参数”。 在实例化，初始化并添加到目标区域之后，它将成为活动视图，并且停用先前视图。有时您会希望从区域中删除已停用的视图。Prism提供IRegionMemberLifetime接口，允许您指定是否要从区域中删除已停用的视图或仅将其标记为已停用，从而控制区域内视图的生命周期。 public class EmployeeDetailsViewModel : IRegionMemberLifetime { public bool KeepAlive { get { return true; } } } 所述IRegionMemberLifetime接口定义的单个只读属性，的KeepAlive。如果此属性返回false，则在停用视图时将从该区域中删除该视图。由于该区域不再具有对视图的引用，因此它有资格进行垃圾回收（除非应用程序中的某些其他组件维护对它的引用）。您可以在视图或视图模型类上实现此接口。虽然IRegionMemberLifetime接口主要用于在激活和取消激活期间管理区域内视图的生命周期，但在目标区域中激活新视图后，还会在导航期间考虑KeepAlive属性。 注意：可以显示多个视图的区域（例如使用ItemsControl或TabControl的区域）将同时显示非活动视图和活动视图。从这些类型的区域中删除非活动视图将导致视图从UI中移除。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:9","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"导航期间传递参数\r要在应用程序中实现所需的导航行为，通常需要在导航请求期间指定其他数据，而不仅仅是目标视图名称。所述NavigationContext对象提供对导航URI，并在其内被指定的或外部的任何参数。您可以从IsNavigationTarget，OnNavigatedFrom和OnNavigatedTo方法中访问NavigationContext。 Prism提供NavigationParameters类以帮助指定和检索导航参数。该NavigationParameters类维护名称-值对，每个参数列表。您可以使用此类将参数作为导航URI的一部分传递或传递对象参数。 以下代码示例演示如何将单个字符串参数添加到NavigationParameters实例，以便将其附加到导航URI。 Employee employee = Employees.CurrentItem as Employee; if (employee != null) { var navigationParameters = new NavigationParameters(); navigationParameters.Add(\"ID\", employee.Id); _regionManager.RequestNavigate(RegionNames.TabRegion, new Uri(\"EmployeeDetailsView\" + navigationParameters.ToString(), UriKind.Relative)); } 此外，您可以通过将对象参数添加到NavigationParameters实例并将其作为RequestNavigate方法的参数传递来传递对象参数。这在以下代码中显示。 Employee employee = Employees.CurrentItem as Employee; if (employee != null) { var parameters = new NavigationParameters(); parameters.Add(\"ID\", employee.Id); parameters.Add(\"myObjectParameter\", new ObjectParameter()); regionManager.RequestNavigate(RegionNames.TabRegion, new Uri(\"EmployeeDetailsView\", UriKind.Relative), parameters); } 您可以使用NavigationContext对象上的Parameters属性检索导航参数。此属性返回NavigationParameters类的实例，该类提供索引器属性以允许轻松访问各个参数，而不管它们是通过查询还是通过RequestNavigate方法传递。 public void OnNavigatedTo(NavigationContext navigationContext) { string id = navigationContext.Parameters[\"ID\"]; ObjectParameter myParameter = navigationContext.Parameters[\"myObjectParameter\"]; } ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:10","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"导航到现有视图\r通常，在导航期间重复使用，更新或激活应用程序中的视图更合适，而不是由新视图替换。这通常是您导航到相同类型的视图但需要向用户显示不同信息或状态的情况，或者当UI中已有适当视图但需要激活（即，选择或制作）时最顶部）。 对于第一个场景的示例，假设您的应用程序允许用户使用EditCustomer视图编辑客户记录，并且用户当前正在使用该视图编辑客户ID 123.如果客户决定编辑客户的客户记录ID 456，用户可以直接导航到EditCustomer视图并输入新的客户ID。然后，EditCustomer视图可以检索新客户的数据并相应地更新其UI。 第二种情况的示例是应用程序允许用户一次编辑多个客户记录。在这种情况下，应用程序在选项卡控件中显示多个EditCustomer视图实例 - 例如，一个用于客户ID 123，另一个用于客户ID 456.当用户导航到EditCustomer视图并输入客户ID 456时，相应的视图将是激活（即，将选择其相应的选项卡）。如果用户导航到EditCustomer视图并输入客户ID 789，则将创建一个新实例并显示在选项卡控件中。 由于各种原因，导航到现有视图的能力很有用。更新现有视图通常更有效，而不是使用相同类型的新实例替换它。同样，激活现有视图而不是创建重复视图可提供更一致的用户体验。此外，无需多少自定义代码即可无缝处理这些情况，这意味着应用程序更易于开发和维护。 棱镜支持通过前面描述的两种方案IsNavigationTarget on方法INavigationAware接口。在导航期间，在与目标视图类型相同的区域中的所有视图上调用此方法。在前面的示例中，视图的目标类型是EditCustomer视图，因此将在当前位于该区域中的所有现有EditCustomer视图实例上调用IsNavigationTarget方法。Prism从视图URI确定目标类型，它假定它是目标类型的短类型名称。 注意：要使Prism确定目标视图的类型，导航URI中的视图名称应与实际目标类型的短类型名称相同。例如，如果您的视图由MyApp.Views.EmployeeDetailsView类实现，则导航URI中指定的视图名称应为EmployeeDetailsView。这是Prism提供的默认行为。您可以通过实现自定义内容加载器类来自定义此行为; 您可以通过实现IRegionNavigationContentLoader接口或从RegionNavigationContentLoader类派生来实现此目的。 IsNavigationTarget方法的实现可以使用NavigationContext参数来确定它是否可以处理导航请求。所述NavigationContext对象提供对导航URI和导航参数。在前面的示例中，EditCustomer视图模型中此方法的实现将当前客户ID与导航请求中指定的ID进行比较，如果匹配则返回true。 public bool IsNavigationTarget(NavigationContext navigationContext) { string id = navigationContext.Parameters[\"ID\"]; return _currentCustomer.Id.Equals(id); } 如果IsNavigationTarget方法始终返回true，则无论导航参数如何，都将始终重用该视图实例。这允许您确保在特定区域中仅显示特定类型的一个视图。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:11","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"确认或取消导航\r您经常会发现在导航操作期间需要与用户进行交互，以便用户可以确认或取消它。例如，在许多应用中，用户可以在输入或编辑数据的过程中尝试导航。在这些情况下，您可能想要询问用户是否要在继续离开页面之前保存或丢弃已输入的数据，或者用户是否想要完全取消导航操作。Prism通过IConfirmNavigationRequest接口支持这些场景。 所述IConfirmNavigationRequest接口从所述派生INavigationAware接口并添加ConfirmNavigationRequest方法。通过在视图或视图模型类上实现此接口，您允许它们以允许用户与用户交互的方式参与导航序列，以便用户可以确认或取消导航。您将经常使用交互请求对象（如高级MVVM方案中所述）来显示确认弹出窗口。 注意：该ConfirmNavigationRequest方法称为活动视图或视图模型，类似于OnNavigatedFrom前面描述的方法。 该ConfirmNavigationRequest方法提供了两个参数，如前文所述当前导航背景下，当你想要导航，继续，你可以调用回调方法的参考。因此，回调称为延续回调。您可以存储对continuation回调的引用，以便应用程序在完成与用户交互后调用它。如果您的应用程序通过交互请求对象与用户交互，您可以将调用链接到交互请求中的回调的连续回调。下图说明了整个过程。 以下步骤总结了使用InteractionRequest对象确认导航的过程： 导航操作通过RequestNavigate调用启动。 如果视图或视图模型实现IConfirmNavigation，则调用ConfirmNavigationRequest。 视图模型引发交互请求事件。 视图显示确认弹出窗口并等待用户的响应。 当用户关闭弹出窗口时，将调用交互请求回调。 调用继续回调以继续或取消挂起的导航操作。 导航操作已完成或取消。 为了说明这一点，请查看View-Switching Navigation Quick Start。此应用程序使用户能够使用ComposeEmailView和ComposeEmailViewModel类撰写新电子邮件。视图模型类实现IConfirmNavigation接口。如果用户导航（例如通过单击“ 日历”按钮），则在编写电子邮件时，将调用ConfirmNavigationRequest方法，以便视图模型可以确认与用户的导航。为了支持这一点，视图模型类定义了交互请求，如以下代码示例所示。 public class ComposeEmailViewModel : NotificationObject, IConfirmNavigationRequest { . . . private readonly InteractionRequest\u003cConfirmation\u003e confirmExitInteractionRequest; public ComposeEmailViewModel(IEmailService emailService) { . . . this.confirmExitInteractionRequest = new InteractionRequest\u003cConfirmation\u003e(); } public IInteractionRequest ConfirmExitInteractionRequest { get { return this.confirmExitInteractionRequest; } } } 在ComposeEmailView类中，定义了交互请求触发器，并将数据绑定到视图模型上的ConfirmExitInteractionRequest属性。当进行交互请求时，将向用户显示简单的弹出窗口。 \u003cUserControl.Resources\u003e \u003cDataTemplate x:Key=\"ConfirmExitDialogTemplate\"\u003e \u003cTextBlock HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" Text=\"{Binding}\"/\u003e \u003c/DataTemplate\u003e \u003c/UserControl.Resources\u003e \u003cGrid x:Name=\"LayoutRoot\" Background=\"White\"\u003e \u003cei:Interaction.Triggers\u003e \u003cprism:InteractionRequestTrigger SourceObject=\"{Binding ConfirmExitInteractionRequest}\"\u003e \u003cprism:PopupWindowAction IsModal=\"True\" CenterOverAssociatedObject=\"True\"/\u003e \u003c/prism:InteractionRequestTrigger\u003e \u003c/ei:Interaction.Triggers\u003e ... 在ConfirmNavigationRequest对方法ComposeEmailVewModel类，如果用户尝试导航而电子邮件正在被由被调用。此方法的实现调用先前定义的交互请求，以便用户可以确认或取消导航操作。 void IConfirmNavigationRequest.ConfirmNavigationRequest( NavigationContext navigationContext, Action\u003cbool\u003e continuationCallback) { . . . this.confirmExitInteractionRequest.Raise( new Confirmation {Content = \"...\", Title = \"...\"}, c =\u003e {continuationCallback(c.Confirmed);}); } 当用户单击确认弹出窗口中的按钮以确认或取消操作时，将调用交互请求的回调。此回调只调用continuation回调，传入Confirmed标志的值，并导致导航继续或被取消。 注意：应该注意，在引发交互请求事件之后，立即返回ConfirmNavigationRequest方法，以便用户可以继续与应用程序的UI交互。当用户单击弹出窗口上的“ **确定”**或“ **取消”**按钮时，将生成交互请求的回调方法，该方法又调用继续回调以完成导航操作。在UI线程上调用所有方法。使用此技术，不需要后台线程。 使用此机制，您可以控制导航请求是立即执行还是延迟执行，等待与用户的交互或某些其他异步交互（例如，作为Web服务请求的结果）。要启用导航，您只需调用continuation回调方法，传递true即表示它可以继续。同样，您可以传递false以指示应取消导航。 void IConfirmNavigationRequest.ConfirmNavigationRequest( NavigationContext navigationContext, Action\u003cbool\u003e continuationCallback) { continuationCallback(true); } 如果要延迟导航，可以存储对继续回调的引用，然后在与用户（或Web服务）的交互完成时调用。在您调用continuation回调之前，导航操作将处于暂挂状态。 如果用户同时启动另一个导航操作，则导航请求将被取消。在这种情况下，调用continuation回调没有任何效果，因为它所涉及的导航操作不再是最新的。同样，如果您决定不调用延续回调，则导航操作将处于暂挂状态，直到将其替换为新的导航操作。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:12","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"使用导航日志\r所述NavigationContext类提供进入该地区导航服务，它负责的区域内导航期间协调操作的序列。它提供对正在进行导航的区域以及与该区域相关联的导航日志的访问。区域导航服务实现IRegionNavigationService，其定义如下。 public interface IRegionNavigationService : INavigateAsync { IRegion Region {get; set;} IRegionNavigationJournal Journal {get;} event EventHandler\u003cRegionNavigationEventArgs\u003e Navigating; event EventHandler\u003cRegionNavigationEventArgs\u003e Navigated; event EventHandler\u003cRegionNavigationFailedEventArgs\u003e NavigationFailed; } 由于区域导航服务实现了INavigateAsync接口，因此您可以通过调用其RequestNavigate方法在父区域内启动导航。在Navigated 开始导航操作时引发事件。在导航中的区域内的导航结束时引发事件。该NavigationFailed如果导航过程中遇到的错误引发。 该Journal 属性提供与该区域相关的导航日记。导航日志实现IRegionNavigationJournal接口，其定义如下。 public interface IRegionNavigationJournal { bool CanGoBack { get; } bool CanGoForward { get; } IRegionNavigationJournalEntry CurrentEntry { get; } INavigateAsync NavigationTarget { get; set; } void Clear(); void GoBack(); void GoForward(); void RecordNavigation(IRegionNavigationJournalEntry entry); } 您可以在导航期间通过OnNavigatedTo方法调用获取并存储对视图中区域导航服务的引用。默认情况下，Prism提供了一个简单的基于堆栈的日志，允许您在区域内向前或向后导航。 您可以使用导航日志允许用户从视图本身进行导航。在以下示例中，视图模型实现了GoBack命令，该命令使用主机区域中的导航日志。因此，视图可以显示“ 后退”按钮，允许用户轻松导航回区域内的上一个视图。同样，您可以实现GoForward命令来实现向导样式工作流。 public class EmployeeDetailsViewModel : INavigationAware { ... private IRegionNavigationService navigationService; public void OnNavigatedTo(NavigationContext navigationContext) { navigationService = navigationContext.NavigationService; } public DelegateCommand\u003cobject\u003e GoBackCommand { get; private set; } private void GoBack(object commandArg) { if (navigationService.Journal.CanGoBack) { navigationService.Journal.GoBack(); } } private bool CanGoBack(object commandArg) { return navigationService.Journal.CanGoBack; } } 如果需要在该区域内实现特定的工作流模式，则可以为区域实现自定义日记。 **注意：**导航日志只能用于由区域导航服务协调的基于区域的导航操作。如果使用视图发现或视图注入来实现区域内的导航，则导航日志将不会在导航期间更新，也不能用于在该区域内向前或向后导航。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:13","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"选择退出导航日志\r使用“导航日志”时，显示中间页面（如启动画面，加载页面或对话框）非常有用。希望通过调用IRegionNavigationJournal.GoForward（）或IRegionNavigationJournal.GoBack（）来重新访问这些页面。通过实现IJournalAware接口可以实现此行为。 public interface IJournalAware { bool PersistInHistory(); } 通过在View或View Model上实现IJournalAware并从**PersistInHistory（）**返回false，Pages可以选择不添加到日志历史记录中。 public class IntermediaryPage : IJournalAware { public bool PersistInHistory() =\u003e false; } ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:14","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"使用WPF导航框架\rPrism区域导航旨在解决在使用MVVM模式和依赖注入容器（如Unity）或Managed Extensibility Framework的松散耦合的模块化应用程序中实现导航时可能遇到的各种常见场景和挑战。 （MEF）。它还旨在支持导航确认和取消，导航到现有视图，导航参数和导航日志。 通过支持Prism区域内的导航，它还支持在各种布局控件中进行导航，并支持在不影响其导航结构的情况下更改应用程序UI的布局。它还支持伪同步导航，允许在导航期间进行丰富的用户交互。 但是，棱镜区域导航并非旨在取代WPF的导航框架。相反，Prism区域导航被设计为与WPF导航框架并排使用。 WPF导航框架很难用于支持MVVM模式和依赖注入。它还基于Frame控件，在日记和导航UI方面提供类似的功能。您可以将WPF导航框架与Prism区域导航一起使用，但仅使用Prism区域实现导航可能更容易，也更灵活。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:15","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"区域导航序列\rThe Region Navigation Sequence 下图提供了导航操作期间操作顺序的概述。它仅供参考，以便您可以在导航请求期间查看棱镜区域导航的各种元素如何协同工作。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:16","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 复合应用程序用户界面（UI）由松散耦合的可视组件组成，这些组件称为View，通常包含在应用程序模块中，但它们并非必须如此。如果将应用程序划分为模块，则需要一些方法来松散地组合UI，但即使视图不在模块中，您也可以选择使用此方法。对用户而言，该应用程序提供了无缝的用户体验，并提供了完全集成的应用程序。 要构建UI，您需要一个体系结构，允许您创建由在运行时生成的松散耦合的可视元素组成的布局。此外，该体系结构应该为这些可视元素提供以松散耦合方式进行通信的策略。 可以使用以下范例之一构建应用程序UI： 表单的所有必需控件都包含在单个可扩展应用程序标记语言（XAML）文件中，在设计时组成表单。 表单的逻辑区域被分成不同的部分，通常是用户控件。部件由表单引用，表单在设计时组成。 表单的逻辑区域被分成不同的部分，通常是用户控件。表单中的部分未知，并在运行时动态添加到表单中。使用此方法的应用程序称为使用UI组合模式的复合应用程序。 股票交易者参考实施（股票交易者RI）是通过将来自不同模块的多个视图加载到由shell公开的区域组成的，如下图所示。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:0","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"UI布局概念\r复合应用程序中的根对象称为shell。shell充当应用程序的母版页。shell包含一个或多个regions。regions是将在运行时加载的内容的占位符。区域附加到UI元素，例如ContentControl，ItemsControl，TabControl或自定义控件，并管理UI元素的内容。区域内容可以自动或按需加载，具体取决于应用程序要求。 通常，区域的内容是视图。视图将您希望保留的UI的一部分封装为尽可能与应用程序的其他部分分离。您可以将视图定义为用户控件，数据模板甚至自定义控件。 区域管理视图的显示和布局。区域可以通过其名称以分离的方式访问，并支持动态添加或删除视图。区域附加到主机控件。将区域视为动态加载视图的容器。 以下部分介绍了复合应用程序开发的高级核心概念。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:1","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"shell\rshell是包含主UI内容的应用程序根对象。在Windows Presentation Foundation（WPF）应用程序中，shell是Window对象。 shell扮演master page的角色，为应用程序提供布局结构。shell包含一个或多个named regions，其中模块可以指定将显示的视图。它还可以定义某些顶级UI元素，例如背景，主菜单和工具栏。 shell定义了应用程序的整体外观。它可以定义在shell布局本身中存在和可见的样式和边框，还可以定义将应用于插入到shell中的视图的样式，模板和主题。 通常，shell是WPF应用程序项目的一部分。包含shell的程序集可能引用也可能不引用包含要在shell的区域中加载的视图的程序集。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:2","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"Views\rView是复合应用程序中UI构造的主要单元。您可以将视图定义为 user control，page，data template或custom control。视图将您希望保留的UI的一部分封装为尽可能与应用程序的其他部分分离。您可以根据封装或功能选择视图中的内容，也可以选择将某些内容定义为视图，因为您的应用程序中将包含该视图的多个实例。 由于WPF的内容模型，定义视图所需的Prism库没有特定的内容。定义视图的最简单方法是定义用户控件。要向UI添加视图，您只需要一种方法来构建它并将其添加到容器中。WPF提供了执行此操作的机制。Prism Library添加了定义可在运行时动态添加视图的区域的功能。 Composite Views\r支持特定功能的视图可能会变得复杂。在这种情况下，您可能希望将视图划分为多个子视图，并让父视图句柄通过将子视图用作部件来构建自身。应用程序可能会在设计时静态地执行此操作，或者它可能支持让模块在运行时通过包含的区域添加子视图。如果某个视图未在单个视图类中完全定义，则可以将其称为复合视图。在许多情况下，复合视图负责构建子视图和协调它们之间的交互。您可以使用Prism Library命令和事件聚合器设计从其兄弟视图及其父组合视图中更松散耦合的子视图。 视图和设计模式\r虽然Prism Library不要求您使用它们，但在实现视图时应考虑使用多种UI设计模式之一。Stock Trader RI和QuickStart演示了Model-View-ViewModel（MVVM）模式，作为在视图布局和视图逻辑之间实现清晰分离的一种方式。 建议使用MVVM UI设计模式，因为它非常适合Microsoft XAML平台。这些平台的依赖属性系统和富数据绑定堆栈使视图和视图模型能够以松散耦合的方式进行通信。 将逻辑与视图分离对于可测试性和可维护性非常重要，并且它改进了开发人员 - 设计人员的工作流程。 如果使用用户控件或自定义控件创建视图并将所有逻辑放在代码隐藏文件中，则您的视图可能难以测试，因为您必须创建视图实例以对逻辑进行单元测试。如果视图派生或依赖于将WPF组件作为其执行上下文的一部分运行，则这是一个问题。为了确保您可以在没有这些依赖关系的情况下单独测试视图逻辑，您需要能够创建视图的模型以删除执行上下文的依赖关系，这需要视图和逻辑的单独类。 如果将视图定义为数据模板，则没有与视图本身关联的代码。因此，您必须将关联逻辑放在其他位置。逻辑与可测试性所需的布局清晰分离也有助于使视图更易于维护。 注意：单元测试和UI自动化测试是两种不同类型的测试，具有不同的覆盖范围。* 单元测试最佳实践建议单独测试对象。要实现对象隔离，每个外部依赖项都需要一个模型或存根。然后针对该对象运行粒度单元测试。 UI自动化测试运行应用程序，将手势应用于UI，然后测试预期结果。此类测试验证UI元素是否正确连接到应用程序逻辑。 将逻辑与视图分开可以清晰地分离关注点。除了可测试性考虑因素之外，这种分离使设计人员能够独立于开发人员在UI上工作。有关MVVM的更多信息，请参阅实现MVVM模式。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:3","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"Commands, UI Triggers, Actions, and Behaviors\r在代码隐藏文件中使用其逻辑实现视图时，可以向服务UI交互添加事件处理程序。但是，使用MVVM时，视图模型无法直接处理UI引发的事件。要将UI手势事件路由到视图模型，您可以使用命令或UI触发器，操作和行为。 命令\r命令将语义和从执行命令的逻辑调用命令的对象分开。内置命令是指示操作是否可用的能力。UI中的命令是绑定到视图模型上的ICommand属性的数据。有关命令的详细信息，请参阅命令在实现MVVM模式。 UI Triggers, Actions, and Behaviors\r触发器，操作和行为是Microsoft.Expression.Interactivity命名空间的一部分，随Blend for Visual Studio 2013一起提供。它们也是Blend SDK的一部分。触发器，操作和行为提供了一个用于处理UI事件或命令的综合API，然后将它们路由到DataContext公开的ICommand属性方法。有关UI触发器，操作和行为的更多信息，请参阅在高级MVVM方案中实现MVVM模式和交互触发器和事件到命令的部分。 用户交互\r用户交互是应用程序向用户呈现的交互。这些交互通常是呈现给用户的弹出窗口。在MVVM场景中，可以从视图或视图模型生成这些用户交互。Prism为视图模型需要请求用户交互时的情况提供InteractionRequests和InteractionRequestTriggers，为触发指定事件时视图需要调用命令时提供InvokeCommandAction操作。 有关用户交互，示例以及如何使用它们的更多信息，请参阅Interactivity QuickStart。 数据绑定\r数据绑定是XAML平台最重要的框架功能之一。要在XAML平台上成功开发应用程序，您需要充分了解数据绑定。 数据绑定充分利用了依赖属性系统提供的内在更改通知。当与INotifyPropertyChanged接口的公共语言运行时（CLR）类实现结合使用时，更改通知将启用参与数据绑定的目标和源对象之间的无代码交互。 通过使用值转换器将一种类型转换为另一种类型，数据绑定可以使不同的目标和源类型与数据绑定。数据绑定在其管道中有多个验证挂钩，可用于验证用户输入。 强烈建议您阅读MSDN上的依赖项属性概述和数据绑定概述主题。完全了解这两个主题对于在Microsoft XAML平台上成功开发应用程序至关重要。有关数据绑定的更多信息，请参阅数据绑定在实现MVVM模式。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:4","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"Regions\r通过区域管理器，区域和区域适配器在Prism库中启用区域。接下来的部分将介绍它们如何协同工作。 Region Manager\r该RegionManager类负责创建和维护区域的集合主机控制。该RegionManager使用一个新的区域与主机控制相关联的特定控制适配器。下图显示了RegionManager设置的区域，控件和适配器之间的关系。 该RegionManager可以在代码中创建或XAML地区。所述RegionManager.RegionName附加属性是用来通过将附加属性到主机控制以在XAML的区域。 应用程序可以包含RegionManager的一个或多个实例。您可以指定要在其中注册区域的RegionManager实例。如果要在可视树中移动控件并且不希望在删除附加属性值时清除区域，则此选项非常有用。 所述RegionManager提供RegionContext附加属性，允许其区域共享数据。 Region Implementation\r区域是实现IRegion接口的类。术语区域表示可以保存UI中呈现的动态数据的容器。区域允许Prism库将包含在模块中的动态内容放置在UI容器中的预定义占位符中。 区域可以包含任何类型的UI内容。模块可以包含作为用户控件呈现的UI内容，与数据模板相关联的数据类型，自定义控件或这些的任何组合。这使您可以定义UI区域的外观，然后让模块将内容放在这些预定区域中。 区域可以包含零个或多个项目。根据区域管理的主机控件的类型，可以看到一个或多个项目。例如，ContentControl只能显示单个对象。但是，它所在的区域可以包含许多项目，ItemsControl可以显示多个项目。这允许区域中的每个项目在UI中可见。 在下图中，Stock Trader RI shell包含四个区域：MainRegion，MainToolbarRegion，ResearchRegion和ActionRegion。这些区域由应用程序中的各种模块填充 - 内容可以随时更改。 模块用户控制到区域映射\rModule User Control to Region Mapping 要演示模块和内容如何与区域关联，请参阅下图。它显示了WatchModule和NewsModule与shell中相应区域的关联。 所述MainRegion包含WatchListView用户控制，这被包含在WatchModule。所述ResearchRegion还包含ArticleView用户控制，这被包含在NewsModule。 在使用Prism Library创建的应用程序中，这样的映射将成为设计过程的一部分，因为设计人员和开发人员使用它们来确定在特定区域中建议的内容。这允许设计人员确定所需的总空间以及必须添加的任何其他项目，以确保内容在可允许的空间中可见。 Default Region Functionality\r虽然您不需要完全理解区域实现以使用它们，但了解控件和区域如何关联以及默认区域功能可能很有用：例如，区域如何定位和实例化视图，以及如何在视图时通知视图是活动视图，还是视图生命周期如何与激活相关联。 以下部分描述了区域适配器和区域行为。 Region Adapter\r要将UI控件公开为区域，它必须具有区域适配器。区域适配器负责创建区域并将其与控件相关联。这允许您使用IRegion接口以一致的方式管理UI控件内容。每个区域适配器都适应特定类型的UI控件。Prism库提供以下三种区域适配器： ContentControlRegionAdapter。此适配器适应System.Windows.Controls.ContentControl类型和派生类的控件。 SelectorRegionAdapter。此适配器适应从System.Windows.Controls.Primitives.Selector类派生的控件，例如System.Windows.Controls.TabControl控件。 ItemsControlRegionAdapter。此适配器适应System.Windows.Controls.ItemsControl类型和派生类的控件。 Region Behaviors\rPrismLibrary介绍了区域行为的概念。这些是可插拔(pluggable )组件，为区域提供了大部分功能。引入了区域行为以支持视图发现和区域上下文（在本主题后面描述），并创建在WPF和Silverlight中一致的API。此外，行为提供了扩展区域实施的有效方式。 区域行为是附加到区域的类，以为该区域提供附加功能。此行为附加到该区域，并在该区域的生命周期内保持活动状态。例如，当AutoPopulateRegionBehavior附加到某个区域时，它会自动实例化并添加针对具有该名称的区域注册的任何ViewType。对于该区域的生命周期，它会持续监视RegionViewRegistry以进行新注册。可以在系统范围或每个区域的基础上轻松添加自定义区域行为或替换现有行为。 下一节将介绍自动添加到所有区域的默认行为。一种行为SelectorItemsSourceSyncBehavior仅附加到从Selector派生的控件。 注册行为\r该RegionManagerRegistrationBehavior是负责确保该区域被注册到正确的RegionManager。当视图或控件作为另一个控件或区域的子项添加到可视树中时，控件中定义的任何区域都应该在父控件的RegionManager中注册。删除子控件后，注册的区域将取消注册。 Auto-Population Behavior\r有两个类负责实现视图发现。其中之一是AutoPopulateRegionBehavior。当它附加到某个区域时，它会检索在该区域名称下注册的所有视图类型。然后，它创建这些视图的实例并将它们添加到该区域。创建区域后，AutoPopulateRegionBehavior将监视RegionViewRegistry以查找该区域名称的任何新注册的视图类型。 如果您想要更多地控制视图发现过程，请考虑创建自己的IRegionViewRegistry实现和AutoPopulateRegionBehavior。 Region Context Behaviors\r区域上下文功能包含在两个行为中：SyncRegionContextWithHostBehavior和BindRegionContextToDependencyObjectBehavior。这些行为负责监视对区域所做的上下文的更改，然后将上下文与附加到视图的上下文依赖项属性同步。 Activation Behavior\r所述RegionActiveAwareBehavior负责通知的图，如果它是有效或无效。视图必须实现IActiveAware才能接收这些更改通知。此主动感知通知是单向的（它从行为传播到视图）。通过更改IActiveAware接口上的活动属性，视图不会影响其活动状态。 Region Lifetime Behavior\r所述RegionMemberLifetimeBehavior负责确定如果一个项目应该从区域时被去激活被移除。该RegionMemberLifetimeBehavior监控区域的ActiveViews收集发现的项目，过渡到非激活状态。该行为检查已删除的项目是否为IRegionMemberLifetime或RegionMemberLifetimeAttribute（按此顺序），以确定它是否应在删除时保持活动状态。 如果集合中的项是System.Windows.FrameworkElement，它还将检查其DataContext的IRegionMemberLifetime或RegionMemberLifetimeAttribute。 按以下顺序检查区域项： IRegionMemberLifetime.KeepAlive值 DataContext的IRegionMemberLifetime.KeepAlive值 RegionMemberLifetimeAttribute.KeepAlive值 DataContext的RegionMemberLifetimeAttribute.KeepAlive值 Control-Specific Behaviors\r所述SelectorItemsSourceSyncBehavior仅用于从导出的控制选择器，例如在一个WPF标签控制。它负责将区域中的视图与选择器的项同步，然后将区域中的活动视图与选择器的选定项同步。 Extending the Region Implementation\rPrism Library提供了扩展点，允许您自定义或扩展所提供API的默认行为。例如，您可以编写自己的区域适配器，区域行为或更改Navigation API分析URI的方式。有关扩展棱镜库的更多信息，请参阅扩展棱镜库。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:5","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"View Composition\r视图合成是视图的构建。在复合应用程序中，必须在运行时在应用程序UI中的特定位置显示来自多个模块的视图。要实现此目的，您需要定义视图的显示位置以及在这些位置创建和显示视图的方式。 可以通过视图发现自动创建和显示视图，也可以通过视图注入以编程方式显示视图。这两种技术决定了各个视图如何映射到应用程序UI中的命名位置。 View Discovery\r在视图发现中，您可以在RegionViewRegistry中在区域名称和视图类型之间建立关系。创建区域时，该区域将查找与该区域关联的所有ViewType，并自动实例化并加载相应的视图。因此，使用视图发现时，您无法明确控制何时加载和显示与区域对应的视图。 View Injection\r在视图注入中，您的代码获取对区域的引用，然后以编程方式向其中添加视图。通常，这在模块初始化或作为用户操作的结果时完成。您的代码将按名称查询RegionManager中的特定区域，然后将视图注入其中。通过视图注入，您可以更好地控制何时加载和显示视图。您还可以从该地区删除视图。但是，使用视图注入时，无法将视图添加到尚未创建的区域。 View Injection\rPrism Library 4.0包含导航API。Navigation API允许您将区域导航到URI，从而简化了视图注入过程。Navigation API实例化视图，将其添加到区域，然后激活它。此外，Navigation API允许导航回包含在区域中的先前创建的视图。有关导航API的更多信息，请参阅导航。 使用View Discovery与View Injection\r选择要用于区域的视图加载策略取决于应用程序要求和区域的功能。 在以下情况下使用视图发现： 需要或需要自动加载视图。 视图的单个实例将加载到该区域中。 在以下情况下使用视图注入： 您的应用程序使用导航API。 您需要对创建和显示视图的时间进行显式或程序控制，或者需要从区域中删除视图; 例如，作为应用程序逻辑或导航的结果。 您需要在区域中显示相同视图的多个实例，其中每个视图实例都绑定到不同的数据。 您需要控制添加视图的区域的哪个实例。例如，您要将客户详细信息视图添加到特定客户详细信息区域。（此方案需要实现作用域，如本主题后面所述。） ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:6","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"UI布局方案\r在复合应用程序中，来自多个模块的视图在运行时显示在应用程序UI中的特定位置。要实现此目的，您需要定义视图的显示位置以及在这些位置创建和显示视图的方式。 视图和将在其中显示的UI中的位置的分离允许应用程序的外观和布局独立于区域内出现的视图而发展。 下一节将介绍开发复合应用程序时将遇到的核心方案。适当时，Stock Trader RI的示例将用于演示该场景的解决方案。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:7","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"实现Shell\rshell是应用程序根对象，其中包含主UI内容。在Windows Presentation Foundation（WPF）应用程序中，shell是Window对象。 shell可以包含命名区域，其中模块可以指定将出现的视图。它还可以定义某些顶级UI元素，例如主菜单和工具栏。shell定义应用程序的整体结构和外观，类似于ASP.NET母版页控件。它可以定义在shell布局本身中存在和可见的样式和边框，还可以定义应用于插入到shell中的视图的样式，模板和主题。 作为应用程序体系结构的一部分，您不需要使用独特的shell来使用Prism库。如果要构建一个全新的复合应用程序，实现一个shell提供了一个定义良好的根和初始化模式，用于设置应用程序的主UI。但是，如果要将Prism Library功能添加到现有应用程序，则无需更改应用程序的基本体系结构即可添加shell。相反，您可以更改现有的窗口定义或控件，以添加可根据需要提取视图的区域。 您的应用程序中也可以有多个shell。如果您的应用程序旨在为用户打开多个顶级窗口，则每个顶级窗口都充当其包含的内容的shell。 股票交易员RI Shell\rWPF Stock Trader RI有一个shell作为主窗口。在下图中，将突出显示shell和视图。shell是Stock Trader RI启动时显示的主窗口，其中包含所有视图。它定义了模块添加其视图的区域以及一些顶级UI项目，包括CFI Stock Trader标题和Watch List撕下横幅。 Stock Trader RI中的shell实现由Shell.xaml及其代码隐藏文件Shell.xaml.cs及其视图模型ShellViewModel.cs提供。Shell.xaml包括作为shell一部分的布局和UI元素，包括模块添加其视图的区域的定义。 以下XAML显示了定义shell的结构和主要XAML元素。请注意，RegionName附加属性用于定义四个区域，窗口背景图像为shell提供背景。 \u003c!--Shell.xaml (WPF) --\u003e \u003cWindow x:Class=\"StockTraderRI.Shell\"\u003e \u003c!--shell background --\u003e \u003cWindow.Background\u003e \u003cImageBrush ImageSource=\"Resources/background.png\" Stretch=\"UniformToFill\"/\u003e \u003c/Window.Background\u003e \u003cGrid\u003e \u003c!-- logo --\u003e \u003cCanvas x:Name=\"Logo\" ...\u003e \u003cTextBlock Text=\"CFI\" ... /\u003e \u003cTextBlock Text=\"STOCKTRADER\" .../\u003e \u003c/Canvas\u003e \u003c!-- main bar --\u003e \u003cItemsControl x:Name=\"MainToolbar\" prism:RegionManager.RegionName=\"{x:Static inf:RegionNames.MainToolBarRegion}\"/\u003e \u003c!-- content --\u003e \u003cGrid\u003e \u003cControls:AnimatedTabControl x:Name=\"PositionBuySellTab\" prism:RegionManager.RegionName=\"{x:Static inf:RegionNames.MainRegion}\"/\u003e \u003c/Grid\u003e \u003c!-- details --\u003e \u003cGrid\u003e \u003cContentControl x:Name=\"ActionContent\" prism:RegionManager.RegionName=\"{x:Static inf:RegionNames.ActionRegion}\"/\u003e \u003c/Grid\u003e \u003c!-- sidebar --\u003e \u003cGrid x:Name=\"SideGrid\"\u003e \u003cControls:ResearchControl prism:RegionManager.RegionName=\"{x:Static inf:RegionNames.ResearchRegion}\" /\u003e \u003c/Grid\u003e \u003c/Grid\u003e \u003c/Window\u003e 在实施Shell代码隐藏文件是非常简单的。当引导程序创建Shell，它的依赖将被托管扩展框架（MEF）解决。shell具有单一依赖关系 - ShellViewModel -在构造期间注入，如以下示例所示。 // Shell.xaml.cs [Export] public partial class Shell : Window { public Shell() { InitializeComponent(); } [Import] ShellViewModel ViewModel { set { this.DataContext = value; } } } // ShellViewModel.cs [Export] public class ShellViewModel : BindableBase { // This is where any view model logic for the shell would go. } 代码隐藏文件中的最小代码说明了复合应用程序体系结构的强大功能和简单性以及shell与其组成视图之间的松散耦合。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:8","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"定义区域\r您可以通过定义具有命名位置的布局（称为区域）来定义视图的显示位置。区域充当将在运行时显示的一个或多个视图的占位符。模块可以在布局中的区域中定位和添加内容，而无需知道区域的显示方式和位置。这允许更改布局而不影响将内容添加到布局的模块。 通过将区域名称分配给WPF控件（在上一个Shell.xaml文件中显示的XAML中或代码中）来定义区域。可以通过区域名称访问区域。在运行时，视图将添加到命名的Region控件，然后根据视图实现的布局策略显示视图。例如，选项卡控件区域将以选项卡式排列其子视图。区域支持添加或删除视图。可以通过编程方式或自动方式在区域中创建和显示视图。在Prism Library中，前者通过视图注入实现，后者通过视图发现实现。这两种技术决定了各个视图如何映射到应用程序UI中的命名区域。 应用程序的shell定义了最高级别的应用程序布局; 例如，通过指定主要内容和导航内容的位置，如下图所示。这些高级视图中的布局类似地定义，允许以递归方式组合整个UI。 区域有时用于定义逻辑上相关的多个视图的位置。在这种情况下，区域控件通常是一个ItemsControl派生的控件，它将根据它实现的布局策略显示视图，例如以堆叠或选项卡式布局排列。 区域也可用于定义单个视图的位置; 例如，通过使用ContentControl。在这种情况下，区域控件一次只显示一个视图，即使多个视图映射到该区域位置也是如此。 股票交易者RI shell Regions\r当应用程序购买或出售股票时，股票交易者RI也会演示多视图布局。买/卖区域是一个列表样式区域，显示多个买入/卖出视图（OrderCompositeView）作为其列表的一部分，如下图所示。 shell的ActionRegion包含OrdersView。该OrdersView包含提交所有和取消所有按钮还有OrdersRegion。所述OrdersRegion附着到列表框，其显示多个控制OrderCompositeViews。 IRegion\r区域是实现IRegion接口的类。该区域是容纳控件显示内容的容器。以下代码显示了IRegion接口。 public interface IRegion : INavigateAsync, INotifyPropertyChanged { IViewsCollection Views { get; } IViewsCollection ActiveViews { get; } object Context { get; set; } string Name { get; set; } Comparison\u003cobject\u003e SortComparison { get; set; } IRegionManager Add(object view); IRegionManager Add(object view, string viewName); IRegionManager Add(object view, string viewName, bool createRegionManagerScope); void Remove(object view); void Deactivate(object view); object GetView(string viewName); IRegionManager RegionManager { get; set; } IRegionBehaviorCollection Behaviors { get; } IRegionNavigationService NavigationService { get; set; } } Adding a Region in XAML\r该RegionManager提供一个附加属性，您可以使用在XAML简单的区域生成。要使用附加属性，必须将Prism Library命名空间加载到XAML中，然后使用RegionName附加属性。以下示例显示如何在具有AnimatedTabControl的窗口中使用附加属性。 注意使用x：Static标记扩展来引用MainRegion字符串常量。这种做法消除了XAML中的魔术字符串。 \u003c!-- (WPF) --\u003e \u003cControls:AnimatedTabControl x:Name=\"PositionBuySellTab\" prism:RegionManager.RegionName=\"{x:Static inf:RegionNames.MainRegion}\"/\u003e Adding a Region by Using Code\r所述RegionManager可以直接在不使用XAML寄存器区域。以下代码示例演示如何从代码隐藏文件向控件添加区域。首先，获得对区域管理者的引用。然后，使用RegionManager静态方法SetRegionManager和SetRegionName，将该区域附加到UI的ActionContent控件，然后将该区域命名为ActionRegion。 IRegionManager regionManager = ServiceLocator.Current.GetInstance\u003cIRegionManager\u003e(); RegionManager.SetRegionManager(this.ActionContent, regionManager); RegionManager.SetRegionName(this.ActionContent, \"ActionRegion\"); ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:9","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"Displaying Views in a Region When the Region Loads\r使用视图发现方法，模块可以为特定的命名位置注册视图（视图模型或表示模型）。在运行时显示该位置时，将自动创建并在其中显示已为该位置注册的所有视图。 模块使用注册表注册视图。父视图查询此注册表以发现为命名位置注册的视图。发现它们之后，父视图会将这些视图添加到占位符控件中，从而将这些视图放在屏幕上。 加载应用程序后，将通知组合视图以处理已添加到注册表的新视图的放置。 下图显示了视图发现方法。 Prism Library定义了一个标准注册表RegionViewRegistry，用于注册这些命名位置的视图。 要显示区域中的视图，请使用区域管理器注册视图，如以下代码示例所示。您可以直接向区域注册视图类型，在这种情况下，视图将由依赖项注入容器构造，并在加载托管区域的控件时添加到区域。 // View discovery this.regionManager.RegisterViewWithRegion(\"MainRegion\", typeof(EmployeeView)); （可选）您可以提供一个返回要显示的视图的委托，如下一个示例所示。区域管理器将在创建区域时显示视图。 // View discovery this.regionManager.RegisterViewWithRegion(\"MainRegion\", () =\u003e this.container.Resolve\u003cEmployeeView\u003e()); UI Composition QuickStart在EmployeeModule ModuleInit.cs文件中有一个演练，演示了如何使用RegisterViewWithRegion方法。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:10","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"Displaying Views in a Region Programmatically\r在视图注入方法中，视图以编程方式添加或由管理它们的模块从命名位置删除。要启用此功能，应用程序将在UI中包含命名位置的注册表。模块可以使用注册表查找其中一个位置，然后以编程方式将视图注入其中。为了确保可以类似地访问注册表中的位置，每个命名位置都遵循用于注入视图的公共接口。下图显示了视图注入方法。 Prism库定义了一个标准注册表RegionManager和一个标准接口IRegion，用于访问这些位置。 要使用视图注入向区域添加视图，请从区域管理器中获取区域，然后调用Add方法，如以下代码所示。使用视图注入时，仅在将视图添加到区域后才会显示视图，这可能在加载模块或用户操作完成预定义操作时发生。 // View injection IRegion region = regionManager.Regions[\"MainRegion\"]; var ordersView = container.Resolve\u003cOrdersView\u003e(); region.Add(ordersView, \"OrdersView\"); region.Activate(ordersView); 除了Stock Trader RI之外，UI Composition QuickStart还有一个实现视图注入的演练。 Region Navigation\rPrism Library 5.0包含导航API，它提供了丰富且一致的API，用于在WPF应用程序中实现导航。 区域导航是视图注入的一种形式。处理导航请求时，它将尝试在可以满足请求的区域中查找视图。如果找不到匹配的视图，它会调用应用程序容器来创建对象，然后将对象注入目标区域并激活它。 Stock Trader RI ArticleViewModel的以下代码示例说明了如何发起导航请求。 this.regionManager.RequestNavigate(RegionNames.SecondaryRegion, new Uri(\"/NewsReaderView\", UriKind.Relative)); 有关区域导航的更多信息，请参阅导航。视图切换导航快速入门和基于状态的导航快速入门也是实现应用程序导航的示例。 Ordering Views in a Region\r无论是使用视图发现还是查看注入，应用程序都可能需要命令视图在TabControl，ItemsControl或显示多个活动视图的任何其他控件中的显示方式。默认情况下，视图按其注册顺序显示并添加到区域中。 构建复合应用程序时，通常会从不同的模块注册视图。声明模块之间的依赖关系有助于缓解问题，但是当模块和视图没有任何真正的相互依赖关系时，声明人工依赖会不必要地耦合模块。 为了允许视图参与自己的排序，Prism库提供了ViewSortHint属性。此属性包含字符串Hint属性，该属性允许视图声明在区域中如何排序的提示。 显示视图时，Region类使用默认视图排序例程，该例程使用提示对视图进行排序。这是一个简单的区分大小写的排序。具有sort hint属性的视图在没有排序的视图之前排序。此外，没有属性的那些按照添加到区域的顺序显示。 如果要更改视图的排序方式，Region类提供了一个SortComparison属性，您可以使用自己的Comparison \u003c object \u003e委托方法设置该属性。值得注意的是，区域的Views和ActiveViews属性的顺序会反映在UI中，因为诸如ItemsControlRegionAdapter之类的适配器直接绑定到这些属性。自定义区域适配器可以实现自己的排序和过滤器，它将覆盖区域命令视图的方式。 View Switching QuickStart演示了一种简单的编号方案，用于对左侧导航区域中的视图进行排序。以下代码示例显示应用于每个导航项视图的ViewSortHint。 [Export] [ViewSortHint(\"01\")] public partial class EmailNavigationItemView { ... } [Export] [ViewSortHint(\"02\")] public partial class CalendarNavigationItemView { ... } [Export] [ViewSortHint(\"03\")] public partial class ContactsDetailNavigationItemView { ... } [Export] [ViewSortHint(\"04\")] public partial class ContactsAvatarNavigationItemView { ... } ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:11","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"在多个区域之间共享数据\rPrism Library提供了多种方法来在视图之间进行通信，具体取决于您的方案。区域管理器提供RegionContext属性作为这些方法之一。 当您想要共享父视图和区域中托管的子视图之间的上下文时，RegionContext非常有用。RegionContext是附加属性。您可以在区域控件上设置上下文的值，以便可以使该区域控件中显示的所有子视图都可以使用它。区域上下文可以是任何简单或复杂的对象，也可以是数据绑定值。该RegionContext可以与任一视图中发现或视图注射使用。 注意： WPF中的DataContext属性用于设置视图的本地数据上下文。它允许视图使用数据绑定与视图模型，本地演示者或模型进行通信。RegionContext用于在多个视图之间共享上下文，而不是单个视图的本地视图。它提供了一种在多个视图之间共享上下文的简单机制。 以下代码显示了如何在XAML中使用RegionContext附加属性。 \u003cTabControl AutomationProperties.AutomationId=\"DetailsTabControl\" prism:RegionManager.RegionName=\"{x:Static local:RegionNames.TabRegion}\" prism:RegionManager.RegionContext=\"{Binding Path=SelectedEmployee.EmployeeId}\" ...\u003e 您还可以在代码中设置RegionContext，如以下示例所示。 RegionManager.Regions[\"Region1\"].Context = employeeId; 要在视图中检索RegionContext，请使用RegionContext类的GetObservableContext静态方法。它将视图作为参数传递，然后访问其Value属性，如以下代码示例所示。 private void GetRegionContext() { this.Model.EmployeeId = (int)RegionContext.GetObservableContext(this).Value; } 所述的值RegionContext可以从视图中通过简单地分配一个新的值到它的改变值属性。通过订阅GetObservableContext方法返回的ObservableObject上的PropertyChanged事件，可以选择通过视图通知RegionContext的更改。这允许在更改RegionContext时保持多个视图同步。以下代码示例演示了订阅PropertyChanged事件。 ObservableObject\u003cobject\u003e viewRegionContext = RegionContext.GetObservableContext(this); viewRegionContext.PropertyChanged += this.ViewRegionContext_OnPropertyChangedEvent; private void ViewRegionContext_OnPropertyChangedEvent(object sender, PropertyChangedEventArgs args) { if (args.PropertyName == \"Value\") { var context = (ObservableObject\u003cobject\u003e) sender; int newValue = (int)context.Value; } } 注意：该RegionContext被设置为在该区域托管内容对象上附加属性。这意味着内容对象必须从DependencyObject派生。在前面的示例中，视图是一个可视控件，最终从DependencyObject派生。 如果选择使用WPF数据模板来定义视图，则内容对象将表示ViewModel或PresentationModel。如果视图模型或表示模型需要检索RegionContext，则需要从DependencyObject基类派生。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:12","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"创建区域的多个实例\r只有视图注入才能使用范围区域。如果您需要视图以拥有自己的区域实例，则应使用它们。定义具有附加属性的区域的视图会自动继承其父级的RegionManager。通常，这是在shell窗口中注册的全局RegionManager。如果应用程序创建该视图的多个实例，则每个实例都会尝试使用父RegionManager注册其区域。RegionManager只允许唯一命名的区域; 因此，第二次注册会产生错误。 相反，使用作用域区域，以便每个视图都有自己的RegionManager，其区域将使用该RegionManager而不是父RegionManager注册，如下图所示。 要为视图创建本地RegionManager，请指定在将视图添加到区域时应创建新的RegionManager，如以下代码示例所示。 IRegion detailsRegion = this.regionManager.Regions[\"DetailsRegion\"]; View view = new View(); bool createRegionManagerScope = true; IRegionManager detailsRegionManager = detailsRegion.Add(view, null, createRegionManagerScope); 该添加方法将返回新RegionManager该视图可以保留进一步访问本地范围。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:13","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"创建视图\r应用程序的可视化表示形式可以采用多种形式，包括用户控件，自定义控件和数据模板等。对于Stock Trader RI，用户控件通常用于表示主窗口上的不同部分，但这不是标准。在您的应用程序中，您应该使用您最熟悉的方法，这种方法适合您作为设计师的工作方式。无论应用程序中的主要可视化表示如何，您都将不可避免地在整体设计中使用用户控件，自定义控件和数据模板的组合。下图显示了Stock Trader RI使用这些不同项目的位置。此图还可作为以下部分的参考，这些部分描述了每个项目。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:14","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"用户控件\rBlend for Visual Studio 2013和Visual Studio 2013都为创建用户控件提供了丰富的支持。因此，建议使用这些工具创建的用户控件使用Prism Library创建UI内容。如本主题前面所述，Stock Trader RI广泛使用它们来创建将插入区域的内容。所述WatchListView.xaml用户控制是包含内部的简单的用户界面表示的一个很好的例子WatchModule。此控件是一个非常简单的控件，使用此模型可以直接创建。 自定义控件\r在某些情况下，用户控制太有限。在这些情况下，自定义布局或可扩展性比创建的简便性更重要。这是自定义控件有用的地方。在Stock Trader RI中，饼图控件就是一个很好的例子。该控制由来自头寸的数据组成，并显示整个投资组合的图表。与用户控件相比，这种类型的控件比创建用户控件更具挑战性，与用户控件相比，它在Blend for Visual Studio 2013和Visual Studio 2013中的视觉设计支持有限。 数据模板\r数据模板是大多数类型的数据驱动应用程序的重要组成部分。基于列表的控件的数据模板的使用在整个股票交易者RI中很普遍。在许多情况下，您可以使用数据模板来创建完整的可视化表示，而无需创建任何类型的控件。该ResearchRegion使用数据模板显示的文章，并与一个联合项目的风格，提供了的选择项目的指示。 Visual Studio 2013和Visual Studio 2013的Blend具有对数据模板的完全可视化设计支持。 资源\r样式，资源字典和控件模板等资源可以分散在整个应用程序中。复合应用程序尤其如此。在考虑放置资源的位置时，请特别注意UI元素与所需资源之间的依赖关系。Stock Trader RI解决方案（如下图所示）包含指示资源可以存在的各个区域的标签。 Application Resources\r通常，应用程序资源是整个应用程序可用的资源。这些资源往往集中在根应用程序上，但它们也可以在模型或控件的类型基础上提供默认样式。例如，文本框样式应用于根应用程序中的文本框类型。除非在模块或控件级别覆盖样式，否则此样式将可用于应用程序中的所有文本框。 Module Resources\r模块资源与根应用程序资源的作用相同，因为它们可以应用于模块中的所有项目。使用此级别的资源可以在整个模块中提供一致的外观，并且还允许在跨越一个或多个可视组件的更具体实例中重用。模块级别的资源使用应包含在单个模块中。在UI元素显示不正确时，创建模块之间的依赖关系可能导致难以找到的问题。 Control Resources\r控制资源通常包含在控制库中，可供控制库中的所有控件使用。这些资源往往具有最有限的范围，因为控制库通常包含非常特定的控件，并且不包含用户控件。（在使用Prism Library创建的应用程序中，用户控件通常放在使用它们的模块中。） ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:15","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"UI设计指南\r本主题的目标是为正在使用Prism Library和WPF构建应用程序的XAML设计人员和开发人员提供一些高级指导。本主题描述UI布局，可视化表示，数据绑定，资源和表示模型。阅读本主题后，您应该高度了解如何基于Prism库设计应用程序的UI，以及一些可以帮助您在复合应用程序中创建可维护UI的技术。 设计用户界面的指南\r使用Prism Library创建的复合应用程序的布局建立在WPF的标准主体上 - 布局使用包含相关项的面板的概念。但是，对于复合应用程序，各种面板内的内容是动态的，在设计时不知道。这迫使设计人员和开发人员创建可以包含布局内容的页面结构，然后分别设计适合布局的每个元素。作为设计人员或开发人员，这意味着您必须考虑Prism库中的两个主要布局概念：容器组合和区域。 容器组成\r容器组合实际上只是WPF本身提供的包含模型的扩展。术语容器可以表示任何元素，包括窗口，页面，用户控件，面板，自定义控件，控件模板或数据模板，它们可以包含其他元素。 您可视化UI的方式因实现而异，但您会发现突出的重复主题。您将创建包含固定内容和动态内容的窗口，页面或用户控件。固定内容将包含包含UI元素的整体结构，动态内容将放置在区域内。 例如，WPF Stock Trader RI有一个名为Shell.xaml的启动窗口，其中包含应用程序的整体结构。下图显示了Blend for Visual Studio 2013中加载的shell。请注意，只有UI的固定部分可见。当应用程序加载时，shell的其余部分由模块动态插入到各个区域中。 在这种类型的应用程序中，设计时体验有点受限，但是您知道内容将在运行时放置在不同区域这一事实是您需要设计的。要查看此示例，请将下一个插图中主页面的设计器视图与其后的插图中的运行时视图进行比较。在设计器视图中，页面大多是空的。与运行时视图对比，其中存在包含具有位置数据的选项卡控件的位置区域，以及与所选股票相关的趋势线，饼图和新闻区域。设计器视图和运行时视图之间的差异表明了设计人员和开发人员在创建使用Prism Library构建的应用程序时所面临的挑战。 在设计时间内无法看到物品; 因此，确定它们的大小以及它们如何适应应用程序的整体外观有点困难。在为容器创建布局时，请考虑以下事项： 是否有任何大小限制会限制内容的大小？如果有，请考虑使用支持滚动的容器。 考虑使用扩展器和ScrollViewer组合，以适应大量动态内容需要适应受限区域的情况。 密切关注内容随着屏幕内容的增长而扩大的程度，以确保应用程序的外观在任何分辨率下都具有吸引力。 股票交易者RI主窗口在Blend for Visual Studio 2013 在运行时间的股票交易商RI主窗口 在设计时查看复合应用程序\r前面的两个图说明了使用在运行时组成的高级视图的挑战之一。复合应用程序中的每个UI元素必须单独设计。这使得很难直观地看出复合页面或窗口在运行时的外观。要在组合状态下可视化组合视图，可以使用包含要测试的视图的所有UI元素的页面或窗口创建测试项目。 此外，请考虑在Blend for Visual Studio 2013和Visual Studio 2013中使用设计时样本数据功能，以使用数据填充UI元素。使用数据模板，列表控件，图表或图形时，设计时数据非常有用。有关更多信息，请参阅设计时样本数据指南部分。 布局\r在设计复合应用程序的布局时，请考虑以下事项： shell定义了应用程序的主要布局。布局的每个区域都是一个区域，应保留为空容器。不要在设计时将内容放在区域内，因为内容将在运行时加载到那里。 shell应包含背景，标题和页脚。将shell视为ASP.NET母版页。 充当区域的控制容器与它们包含的视图分离。因此，您应该能够在不修改控件的情况下更改视图的大小，并且应该能够在不修改视图的情况下更改控件的大小。定义视图大小时应考虑以下事项： 如果视图将在多个区域中使用，或者如果不确定将在何处使用，请使用动态宽度和高度进行设计。 如果视图具有固定大小，则shell的区域应使用动态大小。 如果shell区域具有固定大小，则视图应使用动态大小。 视图可能需要固定的高度和动态宽度。这方面的一个例子是位于Stock Trader RI侧栏的PositionPieChart视图。 其他视图可能需要动态高度和宽度**。例如，StockTrader RI侧栏中的NewsReader视图。高度本身取决于标题的长度，宽度应始终适应区域的大小（侧边栏宽度）。这同样适用于PositionSummaryView**视图，其中网格的宽度应适应屏幕大小，高度应适应网格中的行数。 视图通常应具有透明背景，允许shell背景提供应用程序视觉背景。 始终使用命名资源来分配颜色，画笔，字体和字体大小，而不是直接在XAML中分配属性值。这使得应用程序维护更容易。它还允许应用程序在运行时响应资源字典中的更改。 动画\r在shell或视图中使用动画时，请考虑以下事项： 您可以为shell的布局设置动画，但您必须单独为其内容和视图设置动画。 分别设计和动画每个视图。 使用柔和或温和的动画来提供UI元素被带入视图或从视图中移除的视觉线索。这为应用程序提供了抛光的外观和感觉。 Blend for Visual Studio 2013提供了丰富的行为，简化功能，以及基于可视状态更改或事件动画和转换UI元素的出色编辑体验。有关更多信息，请参阅MSDN上的VisualStateManager类。 运行时优化\r请考虑以下有关性能优化的提示： 将任何公共资源放在App.xaml文件或合并字典中以避免重复样式。 设计时优化\r以下部分描述了设计时方案，并提供了充分利用设计时体验的解决方案。 Large Solutions with Many XAML Resources\r在具有许多XAML资源的大型应用程序中，可视化设计器的加载时间可能会受到影响，有时会显着影响。这种性能下降的存在是因为可视化设计器必须解析所有合并的XAML资源。此问题的解决方案是将所有XAML资源移动到另一个解决方案，编译该解决方案，然后从大型解决方案引用新的XAML资源DLL。由于XAML资源位于二进制引用的程序集中，因此可视化设计器不会解析XAML资源，从而提高了设计时性能。将XAML资源移动到外部程序集时，您可能需要考虑为您的资源公开ComponentResourceKeys。有关更多信息，请参阅MSDN上的ComponentResourceKey标记扩展。 XAMLAssets\rXAML是一种功能强大且富有表现力的语言，用于创建图像，图表，绘图和三维场景等资源。一些开发人员和设计人员更喜欢创建XAML资产，而不是使用.ico，.jpg或.png图像文件。他们更喜欢XAML方法的一个原因是利用XAML渲染的分辨率独立性。另一个是他们可以使用一个工具集Blend for Visual Studio 2013来创建所有必需的资产并设计他们的应用程序。 如果解决方案具有许多这些资产，则可能会影响设计时可视化设计器的加载。将资产移动到单独的DLL可以解决性能问题。移动资产还可以跨多个解决方案重用。 Visual Designers and Referenced Assemblies\r将XAML资源和资产移动到二进制引用程序集的一个令人遗憾的副作用是，Blend for 2013和Visual Studio 2013属性编辑器不会列出位于二进制引用程序集中的资源。这意味着您将无法从工具提供的其中一个资源选择器中选择命名资源。相反，您需要输入资源的名称。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:16","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"创建设计友好视图的指南\r以下是设计人员友好（也称为可混合或可**工具）应用程序的一些特征： 它通过使用Visual Studio和Blend设计器提供了高效的编辑体验。 它是启用工具的。例如，它允许您使用绑定构建器。 它在需要时提供设计时样本数据。 它允许在设计时执行代码，而不会导致未处理的异常。 在编辑会话期间多次执行以下操作。非设计友好的用户代码将导致这些操作中的一个或多个失败，从而降低开发人员或设计人员的工作效率和创造力。 设计表面动作： 构造对象 加载对象 设置属性值 执行设计表面手势 使用控件作为根元素 在另一个控件内部托管控件 重复打开，关闭和重新打开XAML文件 重建项目 重塑设计师 绑定构建器操作： 发现DataContext 列出可用的数据源 列出数据源类型属性 设计时样本数据操作： 使用设计图面上的控件正确显示样本数据 编码设计时间\r为了给您丰富的设计时体验，Visual Studio和Blend设计人员在设计时实例化对象并运行代码。但是，在实例化之前尝试访问引用类型的代码导致的空引用异常会导致高百分比的加载失败和不必要的设计时异常。 下表列出了设计时体验不佳的主要原因。通过避免以下问题并使用这些技术来缓解这些问题，您的设计时体验和生产力将大大提高，开发人员到设计人员的工作流程将更加顺畅。 用户代码中避免使用此功能 Visual Studio 2013 混合Visual Studio 2013 在设计时旋转多个线程。例如，在构造函数中实例化和启动Timer或在设计时启动Loaded事件。 使用在设计时导致堆栈溢出的控件。 使用尝试递归加载自身的控件。 在转换器或数据模板选择器中抛出空引用异常。 在构造函数中抛出null引用或其他异常。这些是由：使用调用业务或数据层的代码在设计时从数据库或网络返回数据。在引导或容器初始化代码运行之前，尝试使用MEF，控制反转（IoC）或服务定位器来解决依赖关系。 在控件或用户控件的Loaded事件中抛出空引用或其他异常。当您对运行时可能为真的控件状态进行假设但在设计时不正确时会发生这种情况。 尝试在设计时访问Application或Application.Current对象。 创建非常大的项目。 减少设计时用户代码中的问题\r一些防御性编码实践将消除上表中描述的大多数问题。但是，在您可以缓解设计时用户代码中的问题之前，您必须了解您的应用程序控件和代码是由设计人员在未初始化的应用程序域中单独执行的。在这种情况下，未初始化意味着通常的启动，引导或初始化代码尚未运行。 当您的应用程序在运行时执行时，将运行App.xaml.cs或App.xaml.vb中的启动代码。如果您的应用程序的其余部分依赖于此代码，则此代码将不会在设计时执行。如果您在代码中没有预料到这一点，则会发生不必要的异常。（这就是为什么在设计时尝试在用户代码中访问Application或Application.Current对象会导致异常。）为了缓解这些问题： 永远不要假设引用的对象将在设计时代码中实例化。在可以在设计时执行的代码中，始终在访问任何引用对象之前执行空检查。 如果您的代码访问Application或Application.Current对象，请在访问对象之前执行空引用检查。 如果构造函数或Loaded事件处理程序需要运行访问数据库或调用网络的复杂代码或代码，请考虑以下解决方案之一： 将代码包装在一个检查中，该检查通过调用System.ComponentModel DesignerProperties方法DesignerProperties.GetIsInDesignMode来确定代码是否在设计时运行。 而不是直接在构造函数或Loaded事件处理程序中运行代码，抽象调用接口后面的类，然后使用许多技术之一在设计时，运行时和测试时以不同方式解析该依赖项。 例如，不是直接调用数据服务来检索数据，而是将数据服务调用包装在通过接口公开方法的类中。然后，在设计时，使用模拟或设计时对象解析接口。 了解用户控制代码何时在设计时执行\rBlend和Visual Studio都使用设计器窗格中显示的根对象的模型。这对于提供所需的设计体验是必要的。因为根对象是模拟的，所以它的构造函数和Loaded事件代码不会在设计时执行。但是，场景中的其余控件正常构造，并且它们的Loaded事件就像在运行时一样被引发。 在下图中，将不执行根Windows构造函数和已加载事件代码。子用户控件构造函数和Loaded事件代码将被执行。 这些概念很重要，尤其是在构建在运行时动态构建的复合应用程序或应用程序时。 大多数应用程序视图都是独立编码和设计 因为它们是独立设计的，所以它们通常是设计器中的根对象。因此，它们的构造函数和Loaded事件代码永远不会执行。 但是，如果您使用相同的用户控件并将其作为另一个控件的子项放置在设计图面上，则曾经隔离的用户控件代码现在正在设计时执行。如果您没有遵循上述减轻设计时代码问题的做法，那么现在托管的用户控件可能会变得不友好并导致设计器加载问题。 设计时属性\r内置的“d：”设计时属性为成功的设计时工具体验提供了平稳的道路。 我们需要解决的问题是如何在设计时为Binding Builder工具提供形状。在这种情况下，形状是Binding Builder可以反映的实例化类型，然后在构建绑定时列出这些属性以供选择。 形状也由设计时样本数据提供。样本数据包含在“设计时样本数据指南”一节中。 以下部分描述了如何使用d：DataContext属性和d：DesignInstance标记扩展。 属性和标记扩展中的“d：”是设计属性所属的设计命名空间的别名。有关更多信息，请参阅WPDN主题，WPF设计器中的设计时属性。 无法在用户代码中创建或扩展“d：”属性和标记扩展; 它们只能在XAML中使用。“d：”属性和标记扩展名未编译到您的应用程序中; 它们仅由Visual Studio和Blend工具使用。 d：DataContext属性\rd：DataContext，为控件及其子控件指定设计时数据上下文。指定d：DataContext时，应始终为设计时DataContext提供与运行时DataContext相同的形状。 如果为控件指定了DataContext和d：DataContext，则工具将使用d：DataContext。 d：DesignInstance标记扩展\r如果标记扩展对您来说是新手，请在MSDN上阅读标记扩展和WPF XAML。 d：DesignInstance返回一个实例化的Type（“shape”），您希望将其指定为绑定到设计器中控件的数据源。该类型不需要是可创建的以用于建立形状。下表说明了d：DesignInstance标记扩展属性。 标记扩展属性 定义 类型 要创建的类型的名称。Type是构造函数中的默认参数。 IsDesignTimeCreatable Can the specified Type be created? If false, a faux Type will be created rather than the real Type. The default is false. CreateList If true, returns a generic list of the specified Type. The default is false. Typical d:DataContext Scenario\rThe following three code examples demonstrate a repeatable pattern for wiring up views and view models and enabling the designer’s tooling. The PersonViewModel is a dependency that the PersonView has at run time. While the view model in the example is incredibly simple, real-world view models typically have one or more external dependencies that must be resolved, and those dependencies are typically injected into their constructor. 当PersonView被构造，其依赖PersonViewModel将建及其依赖由MEF或依赖注入容器解决。 注意：如果视图模型没有需要解析的外部依赖项，则可以在视图的XAML中实例化视图模型，并且不需要其DataContext和d：DataContext。 // PersonViewModel.cs [Export] public class PersonViewModel { public String FirstName { get; set; } public String LasName { get; set; } } // PersonView.xaml.cs [Export] public partial class PersonView : UserControl { public PersonView() { InitializeComponent(); } [Import] public PersonViewModel ViewModel { get { ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:17","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"Using Design-Time Sample Data\r如果使用可视化设计工具（如Blend或Visual Studio 2013），则设计时样本数据变得非常重要。视图可以填充数据和图像，使设计任务更容易，更快速地完成。这样可以提高生产力和创造力。 包含数据模板的空列表控件将不可见，除非它们填充了数据，使编辑空控件的任务更耗时，因为您需要运行应用程序以查看上次编辑在运行时的外观。 示例数据源\r您可以使用以下任何来源的示例数据： 混合Visual Studio 2013 XML示例数据 混合Visual Studio 2013和Visual Studio 2013 XAML示例数据 XAML资源 码 以下各小节介绍了每个来源的数据。 混合XML示例数据\rBlend使您能够快速创建XML模式并填充相应的XML文件。这是在不依赖任何项目类的情况下完成的。 此类示例数据的目的是让设计人员快速启动他们的项目，而无需等待开发人员或应用程序类可供使用之前。 虽然Blend和Visual Studio设计器都支持大多数示例数据，但XML示例数据是Blend功能，并且不在Visual Studio设计器中呈现。 注意： XML样本数据文件在构建时不会编译或添加到程序集中; 但是，XML模式将编译到构建的程序集中。 Visual Studio 2013和Visual Studio 2013 XAML示例数据的混合\r从Expression Blend 4和Visual Studio 2010开始，添加了d：DesignData标记扩展，以启用XAML样本数据的设计时加载。 示例数据XAML文件包含实例化一个或多个类型的XAML，并为属性分配值。 d：DesignData具有Source属性，该属性将统一资源标识符（URI）提取到位于项目中的示例数据XAML文件。的d：DesignData标记扩展加载XAML文件，解析它，然后返回一个对象图。对象图可以由d：DataContext属性，CollectionViewSource d：DesignSource属性或DomainDataSource d：DesignData属性使用。 d：DesignData标记扩展克服的挑战之一是它可以为不可创建的用户类型创建样本数据。例如，无法在代码中创建WCF富Internet应用程序（RIA）服务实体派生对象。此外，开发人员可能拥有自己的类型，这些类型不可创建，但仍希望拥有这些类型的示例数据。 您可以通过在解决方案资源管理器中设置示例数据文件上的Build Action属性来更改d：DesignData处理示例数据文件的方式，如下所示： Build Action = DesignData - 将创建虚拟类型 Build Action = DesignDataWithDesignTimeCreatableTypes - 将创建真实类型 当Blend用于为类创建示例数据时，它会创建一个XAML示例数据文件，并将Build Action设置为DesignData。如果需要实际类型，请在Visual Studio中打开解决方案，并将示例数据文件的Build Action更改为DesignDataWithDesignTimeCreatableTypes。 ***注意：**在下图中，“ **自定义工具”*属性为空。这是样本数据正常工作所必需的。默认情况下，Blend正确地将此属性设置为空。 *使用Visual Studio 2013添加示例数据文件时，通常会添加新的资源字典项并从那里进行编辑。在这种情况下，您必须设置“ **构建操作”**并清除“ **自定义工具”*属性。 Expression Blend提供了用于快速创建和绑定XAML样本数据的工具。可以在Visual Studio 2013设计器中使用和查看XAML示例数据，如下图所示。 生成样本数据后，数据将显示在“数据”窗格中，如下图所示。 然后，您可以将其拖到视图的根元素（例如UserControl）上，并将其设置为d：DataContext属性。您还可以将样本数据集合拖放到项目控件上，Blend会将示例数据连接到控件。 注意：XAML示例数据文件不会编译到构建的程序集中或包含在构建的程序集中。 XAML资源\r您可以在XAML中创建实例化所需类型的资源，然后将该资源绑定到DataContext或列表控件。 此技术可用于快速创建用于编辑数据模板的丢弃样本数据，该数据模板在没有样本数据的情况下编辑需要更长时间。 Code\r如果您更喜欢在代码中创建示例数据，则可以编写一个类，该类公开将样本数据返回给其使用者的属性或方法。例如，您可以编写一个Customers类，该类在其默认的空构造函数中填充了Customer类的多个实例。每个Customer实例也将设置适当的属性值。 可用于使用前面描述的示例数据类的一种技术是使用d：DataContext，d：DesignInstance组合，确保将d： DesignInstance IsDesignTimeCreatable属性设置为True。IsDesignTimeCreatable必须为True的原因是您希望执行customer构造函数，以便运行填充该类的代码。如果将客户视为虚假类型，则客户代码将永远不会运行，并且工具只能发现“形状”。 以下XAML示例实例化Customers类，然后将其设置为d：DataContext。此Grid的子控件可以使用Customers类公开的数据。 \u003cGrid d:DataContext=\"{d:DesignInstance local:Customers, IsDesignTimeCreatable=True}\"\u003e ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:18","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"UI布局关键决策\r当您开始复合应用程序项目时，您需要做出一些UI设计决策，这些决策以后很难更改。通常，这些决策是应用程序范围的，它们的一致性有助于开发人员和设 以下是重要的UI布局决策： 确定应用程序流程并相应地定义区域。 确定加载每个区域将使用的视图类型。 确定是否要使用区域导航API。 确定要使用的UI设计模式（MVVM，演示模型等）。 确定样本数据策略。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:19","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 上一个主题描述了如何通过将应用程序的用户界面（UI），表示逻辑和业务逻辑分成三个独立的类（View，ViewModel和Model）来实现ModelViewViewModel（MVVM）模式的基本元素，实现这些类之间的交互（通过数据绑定，命令和数据验证接口），并实施处理构造和连接的策略。本主题描述了一些复杂的场景，并描述了MVVM模式如何支持它们。下一节将介绍如何将命令链接在一起或与子视图关联，以及如何扩展命令以支持自定义要求。 “ 使用依赖注入容器”（例如Unity应用程序块（Unity））或使用托管可扩展性框架（MEF）时，“ 高级构造和连接 ”一节提供了有关处理构造和连接的指导。最后一节描述了如何通过提供单元测试应用程序的视图模型和模型类以及测试行为的指导来测试MVVM应用程序。 ","date":"2019-07-02","objectID":"/2019/07/prism10-advancemvvm/:0:0","tags":["Prism","高级MVVM"],"title":"Prism 高级MVVM","uri":"/2019/07/prism10-advancemvvm/"},{"categories":"Prism","content":"命令\r命令提供了一种将命令的实现逻辑与其UI表示分开的方法。数据绑定或行为提供了一种方法，用于声明性地将视图中的元素与视图模型提供的命令相关联。的部分中，命令和实施MVVM模式描述了如何命令可以作为命令对象或在视图模型命令的方法来实现，以及它们是如何可以从控制在视图中通过使用调用的内置命令由某些控件提供的属性。 WPF路由命令：应该注意的是，MVVM模式中作为命令对象或命令方法实现的命令与WPF的路由命令的内置实现略有不同。WPF路由命令通过在UI树中的元素（特别是逻辑树）路由来传递命令消息。因此，命令消息在UI树中从聚焦元素向上或向下路由到显式指定的目标元素; 默认情况下，它们不会路由到UI树之外的组件，例如与视图关联的视图模型。但是，WPF路由命令可以使用视图代码隐藏中定义的命令处理程序将命令调用转发到视图模型类。 复合命令\r在许多情况下，视图模型定义的命令将绑定到关联视图中的控件，以便用户可以直接从视图中调用该命令。但是，在某些情况下，您可能希望能够从应用程序UI的父视图中的控件调用一个或多个视图模型上的命令。 例如，如果您的应用程序允许用户同时编辑多个项目，您可能希望允许用户使用应用程序工具栏或功能区中的按钮所代表的单个命令来保存所有项目。在这种情况下，Save All命令将调用每个项目的视图模型实例实现的每个Save命令，如下图所示。 Prism通过CompositeCommand类支持这种情况。 所述CompositeCommand类表示从多个子指令构成的指令。调用复合命令时，将依次调用其每个子命令。在需要在UI中将一组命令表示为单个命令或者要调用多个命令来实现逻辑命令的情况下，它非常有用。 例如，CompositeCommand类用于股票交易者参考实现（Stock Trader RI），以实现买入/卖出视图中的“ 全部提交”按钮所代表的SubmitAllOrders命令。当用户单击“ 全部提交”按钮时，将执行由各个买/卖交易定义的每个SubmitCommand。 该CompositeCommand类维护子类的命令（列表DelegateCommand实例）。在执行该方法CompositeCommand类只是调用执行每个反过来子命令的方法。在CanExecute方法同样调用CanExecute每个子命令的方法，但是如果有子命令不能执行时，CanExecute方法将返回错误。换句话说，默认情况下，只有在可以执行所有子命令时才能执行CompositeCommand。 注册和取消子命令\r使用RegisterCommand和UnregisterCommand方法注册或取消注册子命令。例如，在Stock Trader RI中，每个买/卖订单的提交和取消命令都使用SubmitAllOrders和CancelAllOrders复合命令进行注册，如以下代码示例所示（请参阅OrdersController类）。 // OrdersController.cs commandProxy.SubmitAllOrdersCommand.RegisterCommand( orderCompositeViewModel.SubmitCommand ); commandProxy.CancelAllOrdersCommand.RegisterCommand( orderCompositeViewModel.CancelCommand ); 注意：前面的commandProxy对象提供对Submit和Cancel复合命令的实例访问，这些命令是静态定义的。有关更多信息，请参阅类文件StockTraderRICommands.cs。 在活动子视图上执行命令\rExecuting Commands on Active Child Views 通常，您的应用程序需要在应用程序的UI中显示子视图的集合，其中每个子视图将具有相应的视图模型，而该视图模型又可以实现一个或多个命令。复合命令可用于表示应用程序UI中子视图实现的命令，并有助于协调从父视图中调用它们的方式。为了支持这些场景，Prism CompositeCommand和DelegateCommand类被设计为与Prism区域一起使用。 Prism的Regin（区域，在Composing接口）提供了一种方法用于子视图与在应用程序的UI逻辑占位符相关联。它们通常用于将子视图的特定布局与其逻辑占位符及其在UI中的位置分离。区域基于附加到特定布局控件的命名占位符。下图显示了一个示例，其中每个子视图都已添加到名为EditRegion的区域，并且UI设计器已选择使用Tab控件来布局该区域内的视图。 父视图级别的复合命令通常用于协调如何调用子视图级别的命令。在某些情况下，您将需要执行所有显示视图的命令，如前面所述的Save All命令示例中所示。在其他情况下，您将希望仅在活动视图上执行该命令。在这种情况下，复合命令将仅对被视为活动的视图执行子命令; 它不会在非活动的视图上执行子命令。例如，您可能希望在应用程序的工具栏或功能区上实现缩放命令，该命令仅导致当前活动项目被缩放，如下图所示。 为了支持这种情况，Prism提供了IActiveAware接口。所述IActiveAware接口定义的IsActive属性，返回True时实施者是活动的，以及一个IsActiveChanged每当激活状态改变时引发事件。 您可以在子视图或视图模型上实现IActiveAware接口。它主要用于跟踪区域内子视图的活动状态。视图是否处于活动状态由区域适配器确定，该适配器协调特定区域控件内的视图。对于前面显示的Tab控件，有一个区域适配器，例如，它将当前所选选项卡中的视图设置为活动状态。 该DelegateCommand类还实现了IActiveAware接口。可以将CompositeCommand配置为通过为构造函数中的monitorCommandActivity参数指定True来评估子DelegateCommands的活动状态（除了CanExecute状态）。当此参数设置为true，CompositeCommand类将在确定CanExecute方法的返回值以及在Execute方法中执行子命令时考虑每个子DelegateCommand的活动状态。 当monitorCommandActivity参数为true时，CompositeCommand类会出现以下行为： CanExecute。仅在可以执行所有活动命令时返回true。根本不会考虑不活动的子命令。 执行。执行所有活动命令。根本不会考虑不活动的子命令。 您可以使用此功能来实现前面描述的示例。通过在子视图模型上实现IActiveAware接口，当您的子视图对该区域变为活动或非活动时，将通知您。当子视图的活动状态更改时，您可以更新子命令的活动状态。然后，当用户调用缩放复合命令时，将调用活动子视图上的缩放命令。 集合中的命令\r在视图中显示项目集合时经常遇到的另一种常见情况是，您需要将集合中每个项目的UI与父视图级别（而不是项目级别）的命令相关联。 例如，在下图所示的应用程序中，视图显示ListBox控件中的项集合，用于显示每个项的数据模板定义了一个Delete按钮，允许用户从集合中删除单个项。 因为该视图模型实现的删除命令，面临的挑战是要连接的删除按钮在每个项目的用户界面中，对删除由视图模型实现的命令。之所以出现这种困难是因为ListBox中每个项的数据上下文引用了集合中的项而不是实现Delete命令的父视图模型。 解决此问题的一种方法是使用ElementName绑定属性将数据模板中的按钮绑定到父视图中的命令，以确保绑定相对于父控件而不是相对于数据模板。以下XAML说明了这种技术。 \u003cGrid x:Name=\"root\"\u003e \u003cListBox ItemsSource=\"{Binding Path=Items}\"\u003e \u003cListBox.ItemTemplate\u003e \u003cDataTemplate\u003e \u003cButton Content=\"{Binding Path=Name}\" Command=\"{Binding ElementName=root, Path=DataContext.DeleteCommand}\" /\u003e \u003c/DataTemplate\u003e \u003c/ListBox.ItemTemplate\u003e \u003c/ListBox\u003e \u003c/Grid\u003e 数据模板中按钮控件的内容绑定到集合中项目的Name属性。但是，按钮的命令通过根元素的数据上下文绑定到Delete命令。这允许按钮在父视图级别而不是在项目级别绑定到命令。您可以使用CommandParameter属性指定要应用命令的项目，也可以实现命令以对当前所选项目进行操作（通过CollectionView）。 ","date":"2019-07-02","objectID":"/2019/07/prism10-advancemvvm/:0:1","tags":["Prism","高级MVVM"],"title":"Prism 高级MVVM","uri":"/2019/07/prism10-advancemvvm/"},{"categories":"Prism","content":"交互触发器和命令\rInteraction Triggers and Commands 另一种命令方法是使用Blend for Visual Studio 2013交互触发器和InvokeCommandAction操作。 \u003cButton Content=\"Submit\" IsEnabled=\"{Binding CanSubmit}\"\u003e \u003ci:Interaction.Triggers\u003e \u003ci:EventTrigger EventName=\"Click\"\u003e \u003ci:InvokeCommandAction Command=\"{Binding SubmitCommand}\"/\u003e \u003c/i:EventTrigger\u003e \u003c/i:Interaction.Triggers\u003e \u003c/Button\u003e 此方法可用于您可以附加交互触发器的任何控件。如果要将命令附加到未实现ICommandSource接口的控件，或者要在默认事件以外的事件上调用命令，则此功能特别有用。同样，如果需要为命令提供参数，可以使用CommandParameter属性。 下面显示了如何使用配置为侦听ListBox的SelectionChanged事件的Blend EventTrigger 。发生此事件时，InvokeCommandAction将调用SelectedCommand。 \u003cListBox ItemsSource=\"{Binding Items}\" SelectionMode=\"Single\"\u003e \u003ci:Interaction.Triggers\u003e \u003ci:EventTrigger EventName=\"SelectionChanged\"\u003e \u003ci:InvokeCommandAction Command=\"{Binding SelectedCommand}\" /\u003e \u003c/i:EventTrigger\u003e \u003c/i:Interaction.Triggers\u003e \u003c/ListBox\u003e 启用命令的控件与行为 支持命令的WPF控件允许您以声明方式将控件挂接到命令。当用户以特定方式与控件交互时，这些控件将调用指定的命令。例如，对于Button控件，将在用户单击按钮时调用该命令。与命令关联的此事件是固定的，无法更改。 行为还允许您以声明方式将控件连接到命令。但是，行为可以与控件引发的一系列事件相关联，并且它们可以用于在视图模型中有条件地调用关联的命令对象或命令方法。换句话说，行为可以解决许多与启用命令的控件相同的场景，并且它们可以提供更大程度的灵活性和控制。 您需要选择何时使用启用命令的控件以及何时使用行为以及要使用的行为类型。如果您希望使用单一机制将视图中的控件与视图模型中的功能相关联或者为了保持一致性，则可以考虑使用行为，即使对于本身支持命令的控件也是如此。 如果您只需要使用启用命令的控件来调用视图模型上的命令，并且如果您对调用命令的默认事件感到满意，则可能不需要行为。同样，如果您的开发人员或UI设计人员不使用Blend for Visual Studio 2013，您可能会支持启用命令的控件（或自定义附加行为），因为Blend行为需要额外的语法。 ","date":"2019-07-02","objectID":"/2019/07/prism10-advancemvvm/:0:2","tags":["Prism","高级MVVM"],"title":"Prism 高级MVVM","uri":"/2019/07/prism10-advancemvvm/"},{"categories":"Prism","content":"将EventArgs参数传递给命令\r当您需要调用命令以响应位于视图中的控件引发的事件时，您可以使用Prism的InvokeCommandAction。Prism的InvokeCommandAction与Blend SDK中的同名类有两种不同。首先，Prism InvokeCommandAction根据命令的CanExecute方法的返回值更新关联控件的启用状态。其次，Prism InvokeCommandAction使用从父触发器传递给它的EventArgs参数，如果未设置**CommandParameter，**则将其传递给关联的命令。 有时你需要一个参数传递给来自父触发，如EventArgs作为EventTrigger参数。在这种情况下，您不能使用Blend的InvokeCommandAction操作。 在下面的代码中，您可以看到Prism的InvokeCommandAction具有一个名为TriggerParameterPath的属性，该属性用于指定作为命令参数传递的参数的成员（可能是嵌套的）。在以下示例中，SelectionChanged EventArgs 的AddedItems属性将传递给SelectedCommand命令。 \u003cListBox Grid.Row=\"1\" Margin=\"5\" ItemsSource=\"{Binding Items}\" SelectionMode=\"Single\"\u003e \u003ci:Interaction.Triggers\u003e \u003ci:EventTrigger EventName=\"SelectionChanged\"\u003e \u003c!-- This action will invoke the selected command in the view model and pass the parameters of the event to it. --\u003e \u003cprism:InvokeCommandAction Command=\"{Binding SelectedCommand}\" TriggerParameterPath=\"AddedItems\" /\u003e \u003c/i:EventTrigger\u003e \u003c/i:Interaction.Triggers\u003e \u003c/ListBox\u003e ","date":"2019-07-02","objectID":"/2019/07/prism10-advancemvvm/:0:3","tags":["Prism","高级MVVM"],"title":"Prism 高级MVVM","uri":"/2019/07/prism10-advancemvvm/"},{"categories":"Prism","content":"处理异步交互\rHandling Asynchronous Interactions 您的视图模型通常需要与应用程序中的服务和组件进行交互，这些服务和组件是异步通信而不是同步通信。如果您通过网络与Web服务或其他资源交互，或者您的应用程序使用后台任务执行计算或I / O，则尤其如此。异步执行这些操作可确保您的应用程序保持响应，这对于提供良好的用户体验至关重要。 当用户启动异步请求或后台任务时，很难预测响应何时到达（或者即使它将到达），并且通常很难预测它将返回什么线程。因为UI只能在UI线程中更新，所以通常需要通过在UI线程上调度请求来更新UI。 ","date":"2019-07-02","objectID":"/2019/07/prism10-advancemvvm/:0:4","tags":["Prism","高级MVVM"],"title":"Prism 高级MVVM","uri":"/2019/07/prism10-advancemvvm/"},{"categories":"Prism","content":"检索数据并与Web服务交互\rRetrieving Data and Interacting with Web Services 在与Web服务或其他远程访问技术交互时，您将经常遇到IAsyncResult模式。在此模式中，您可以使用BeginGetQuestionnaire和EndGetQuestionnaire等方法，而不是调用GetQuestionnaire等方法。要启动异步调用，请调用BeginGetQuestionnaire。要在调用目标方法时获取结果或确定是否存在异常，请在调用完成时调用EndGetQuestionnaire。 要确定何时调用EndGetQuestionnaire，您可以轮询完成或（最好）在调用BeginGetQuestionnaire期间指定回调。使用回调方法，当目标方法的执行完成时，将调用您的回调方法，允许您从那里调用EndGetQuestionnaire，如此处所示。 IAsyncResult asyncResult = this.service.BeginGetQuestionnaire(GetQuestionnaireCompleted, null); // object state, not used in this example private void GetQuestionnaireCompleted(IAsyncResult result) { try { questionnaire = this.service.EndGetQuestionnaire(result); } catch (Exception ex) { // Do something to report the error. } } 需要注意的是，在调用End方法（在本例中为EndGetQuestionnaire）时，将引发在执行请求期间发生的任何异常。您的应用程序必须处理这些，并且可能需要通过UI以线程安全的方式报告它们。如果您不处理这些，线程将结束，您将无法处理结果。 由于响应通常不在UI线程上，如果您计划修改任何会影响UI状态的内容，则需要使用线程Dispatcher或SynchronizationContext对象将响应分派给UI线程。在WPF中，您通常会使用调度程序。 在下面的代码示例中，异步检索Questionnaire对象，然后将其设置为QuestionnaireView的数据上下文。您可以使用调度程序的CheckAccess方法来查看您是否在UI线程上。如果不是，则需要使用BeginInvoke方法在UI线程上执行请求。 var dispatcher = System.Windows.Deployment.Current.Dispatcher; if (dispatcher.CheckAccess()) { QuestionnaireView.DataContext = questionnaire; } else { dispatcher.BeginInvoke( () =\u003e { Questionnaire.DataContext = questionnaire; }); } Model-View-ViewModel参考实现（MVVM RI）显示了如何使用类似于前面示例的基于IAsyncResult的服务接口的示例。它还包装服务，为消费者提供更简单的回调机制，并处理调用者对调用者线程的调度。例如，以下代码示例显示了问卷的检索。 this.questionnaireRepository.GetQuestionnaireAsync( (result) =\u003e { this.Questionnaire = result.Result; }); 返回的结果对象将包装检索到的结果以及可能发生的错误。以下代码示例显示了如何评估错误。 this.questionnaireRepository.GetQuestionnaireAsync( (result) =\u003e { if (result.Error == null) { this.Questionnaire = result.Result; ... } else { // Handle error. } }); ","date":"2019-07-02","objectID":"/2019/07/prism10-advancemvvm/:0:5","tags":["Prism","高级MVVM"],"title":"Prism 高级MVVM","uri":"/2019/07/prism10-advancemvvm/"},{"categories":"Prism","content":"用户交互模式\r通常，应用程序需要在继续操作之前通知用户事件的发生或要求确认。这些交互通常是简短的交互，旨在简单地告知应用程序应用程序的更改或从中获取简单的响应。这些交互中的一些可以对用户呈现模态，例如当显示对话框或消息框时，或者它们对于用户可能看起来是非模态的，例如当显示Toast通知或弹出窗口时。 在这些情况下，有多种方法可以与用户进行交互，但是在基于MVVM的应用程序中以保持关注点清晰分离的方式实现它们可能具有挑战性。例如，在非MVVM应用程序中，您经常在UI的代码隐藏文件中使用MessageBox类来简单地提示用户进行响应。在MVVM应用程序中，这不合适，因为它会破坏视图和视图模型之间关注点的分离。 就MVVM模式而言，视图模型负责启动与用户的交互以及消费和处理任何响应，而视图负责使用适当的任何用户体验实际管理与用户的交互。保持视图模型中实现的表示逻辑与视图实现的用户体验之间的关注点分离有助于提高可测试性和灵活性。 在MVVM模式中实现这些类型的用户交互有两种常用方法。一种方法是实现视图模型可以使用的服务来启动与用户的交互，从而保持其在视图的实现上的独立性。另一种方法使用视图模型引发的事件来表达与用户交互的意图，以及视图中绑定到这些事件并管理交互的可视方面的组件。以下各节将介绍这些方法中的每一种。 使用交互服务\r在该方法中，视图模型依赖于交互服务组件以通过消息框发起与用户的交互。此方法通过将交互的可视实现封装在单独的服务组件中来支持关注点和可测试性的清晰分离。通常，视图模型依赖于交互服务接口。它经常通过依赖注入或服务定位器获取对交互服务实现的引用。 在视图模型引用交互服务之后，它可以在必要时以编程方式请求与用户的交互。交互服务实现交互的可视方面，如下图所示。根据用户界面的实现要求，在视图模型中使用接口引用允许使用不同的实现。例如，可以提供WPF的交互服务的实现，允许更多地重用应用程序的表示逻辑。 模态交互（例如，在执行可以继续之前向用户呈现MessageBox或模态弹出窗口以获取特定响应的位置）可以使用阻塞方法调用以同步方式实现，如以下代码示例所示。 var result = interactionService.ShowMessageBox( \"Are you sure you want to cancel this operation?\", \"Confirm\", MessageBoxButton.OK ); if (result == MessageBoxResult.Yes) { CancelRequest(); } 然而，这种方法的一个缺点是它迫使同步编程模型。另一种异步实现允许视图模型提供回调以在完成交互时执行。以下代码说明了这种方法。 非模态交互 interactionService.ShowMessageBox( \"Are you sure you want to cancel this operation?\", \"Confirm\", MessageBoxButton.OK, result =\u003e { if (result == MessageBoxResult.Yes) { CancelRequest(); } }); 通过允许实现模态和非模态交互，异步方法在实现交互服务时提供了更大的灵活性。例如，在WPF中，MessageBox类可用于实现与用户的真正模态交互。 使用交互请求对象\r在MVVM模式中实现简单用户交互的另一种方法是允许视图模型通过与视图中的行为耦合的交互请求对象直接向视图本身发出交互请求。交互请求对象封装交互请求的详细信息及其响应，并通过事件与视图进行通信。视图订阅这些事件以启动交互的用户体验部分。视图通常会将交互的用户体验封装在与视图模型提供的交互请求对象数据绑定的行为中，如下图所示。 这种方法提供了一种简单但灵活的机制，可以保持视图模型和视图之间的清晰分离 - 它允许视图模型封装应用程序的表示逻辑，包括任何所需的用户交互，同时允许视图完全封装视觉互动的各个方面。可以轻松测试视图模型的实现，包括通过视图与用户的预期交互，并且UI设计器在通过使用封装不同用户的不同行为选择如何在视图中实现交互时具有很大的灵活性互动的经验。 此方法与MVVM模式一致，使视图能够反映它在视图模型上观察到的状态更改，并使用双向数据绑定来实现两者之间的数据通信。在交互请求对象中封装交互的非可视元素，以及使用相应的行为来管理交互的可视元素，与命令对象和命令行为的使用方式非常相似。 这种方法是Prism采用的方法。Prism Library通过IInteractionRequest接口和InteractionRequest 类直接支持此模式。所述IInteractionRequest接口定义的事件来发起的相互作用。视图中的行为绑定到此接口并订阅它公开的事件。所述InteractionRequest 类实现IInteractionRequest接口和定义了两个Raise方法来允许视图模型发起交互，并指定为请求的上下文中，并且任选地，一个回调委托。 从ViewModel启动交互请求\r所述InteractionRequest 类坐标的交互请求期间视图模型的与该视图的相互作用。所述抬起方法允许视图模型来启动交互和指定一个上下文对象，交互完成后调用的回调方法。上下文对象允许视图模型将数据和状态传递给视图，以便在与用户交互期间使用它。如果指定了回调方法，则上下文对象将被传递回视图模型; 这允许用户在交互期间进行的任何更改都传递回视图模型。 public interface IInteractionRequest { event EventHandler\u003cInteractionRequestedEventArgs\u003e Raised; } public class InteractionRequest\u003cT\u003e : IInteractionRequest where T : INotification { public event EventHandler\u003cInteractionRequestedEventArgs\u003e Raised; public void Raise(T context) { this.Raise(context, c =\u003e { }); } public void Raise(T context, Action\u003cT\u003e callback) { var handler = this.Raised; if (handler != null) { handler( this, new InteractionRequestedEventArgs( context, () =\u003e { if (callback != null) callback(context); } )); } } } Prism提供预定义的上下文类，支持常见的交互请求场景。该INotification接口用于所有上下文对象。当交互请求用于通知用户应用程序中的重要事件时。它提供了两个属性 - Title和Content- 将显示给用户。通常，通知是单向的，因此预计用户不会在交互期间更改这些值。该通知类是这个接口的默认实现。 所述IConfirmation接口扩展了INotification接口，增加了第三属性Confirmed -其用于表示用户已确认或拒绝该操作。在确认类，所提供的IConfirmation实现，用于实现MessageBox用户想获得一个Yes/No风格的交互。您可以定义实现INotification接口的自定义上下文类，以封装支持交互所需的任何数据和状态。 要使用InteractionRequest 类，视图模型类将创建InteractionRequest 类的实例，并定义只读属性以允许视图对其进行数据绑定。当视图模型想要发起请求时，它将调用Raise方法，传入上下文对象和（可选）回调委托。 public InteractionRequestViewModel() { this.ConfirmationRequest = new InteractionRequest\u003cIConfirmation\u003e(); ... // Commands for each of the buttons. Each of these raise a different interaction request. this.RaiseConfirmationCommand = new DelegateCommand(this.RaiseConfirmation); ... } public InteractionRequest\u003cIConfirmation\u003e ConfirmationRequest { get; private set; } private void RaiseConfirmation() { this.ConfirmationRequest.Raise( new Confirmation { Content = \"Confirmation Message\", Title = \"Confirmation\" }, c =\u003e { InteractionResultMessage = c.Confirmed ? \"The user accepted.\" : \"The user cancelled.\"; }); } 交互性快速入门示出了如何IInteractionRequest接口和**InteractionRequest **类用于实现视图和视图模型（参见InteractionRequestVi","date":"2019-07-02","objectID":"/2019/07/prism10-advancemvvm/:0:6","tags":["Prism","高级MVVM"],"title":"Prism 高级MVVM","uri":"/2019/07/prism10-advancemvvm/"},{"categories":"Prism","content":"Advanced Construction and Wire-Up\r要成功实现MVVM模式，您需要完全理解视图，模型和视图模型类的职责，以便您可以在正确的类中实现应用程序的代码。实现正确的模式以允许这些类进行交互（通过数据绑定，命令，交互请求等）也是一个重要的要求。最后一步是考虑如何在运行时实例化视图，视图模型和模型类并将它们相互关联。 如果在应用程序中使用依赖项注入容器，则选择适当的策略来管理此步骤尤为重要。托管可扩展性框架（MEF）和Unity应用程序块（Unity）都提供了指定视图，视图模型和模型类之间的依赖关系以及在运行时由容器实现它们的能力。 通常，您将视图模型定义为视图的依赖项，以便在构造视图时（使用容器）它自动实例化所需的视图模型。反过来，视图模型所依赖的任何组件或服务也将由容器实例化。成功实例化视图模型后，视图会将其设置为其数据上下文。 使用MEF创建视图和视图模型\r使用MEF，您可以使用import属性指定视图对视图模型的依赖性，并且可以指定要通过export属性实例化的具体视图模型类型。您可以通过属性或构造函数参数将视图模型导入视图。 例如，StockTrader参考实现中的Shell视图声明了视图模型的只写属性以及import属性。实例化视图时，MEF会创建相应导出视图模型的实例并设置属性值。setter属性将视图模型指定为视图的数据上下文，如此处所示。 [Import] ShellViewModel ViewModel { set { this.DataContext = value; } } 定义并导出视图模型，如此处所示。 [Export] public class ShellViewModel : BindableBase { ... } 另一种方法是在视图上定义导入构造函数，如此处所示。 public Shell() { InitializeComponent(); } [ImportingConstructor] public Shell(ShellViewModel viewModel) : this() { this.DataContext = viewModel; } 然后，视图模型将由MEF实例化，并作为参数传递给视图的构造函数。 注意：您可以在MEF和Unity中使用属性注入或构造函数注入; 但是，您可能会发现属性注入更简单，因为您不必维护两个构造函数。设计时工具（如Visual Studio和Expression Blend）要求控件具有默认的无参数构造函数，以便在设计器中显示它们。您定义的任何其他构造函数应确保调用默认构造函数，以便可以通过InitializeComponent方法正确初始化视图。* 使用Unity创建视图和视图模型\r使用Unity作为依赖注入容器与使用MEF类似，并且支持基于属性和基于构造函数的注入。主要区别在于通常不会在运行时隐式发现类型; 相反，他们必须在容器中注册。 通常，您在视图模型上定义接口，以便视图模型的特定具体类型可以与视图分离。例如，视图可以通过构造函数参数定义其对视图模型的依赖性，如此处所示。 public Shell() { InitializeComponent(); } public Shell(ShellViewModel viewModel) : this() { this.DataContext = viewModel; } 注意：默认的无参数构造函数是允许视图在设计时工具中工作所必需的，例如Visual Studio和Blend for Visual Studio 2013。 或者，您可以在视图上定义只写视图模型属性，如此处所示。Unity将实例化所需的视图模型，并在实例化视图后调用setter属性。 public Shell() { InitializeComponent(); } [Dependency] public ShellViewModel ViewModel { set { this.DataContext = value; } } 视图模型类型已在Unity容器中注册，如此处所示。 IUnityContainer container; container.RegisterType\u003cShellViewModel\u003e(); 然后可以通过容器实例化视图，如此处所示。 IUnityContainer container; var view = container.Resolve\u003cShell\u003e(); Creating the View and View Model Using an External Class\r通常，您会发现定义控制器或服务类以协调视图的实例化和视图模型类很有用。此方法可以与依赖项注入容器（如MEF或Unity）一起使用，或者在视图显式创建其所需的视图模型时使用。 在您的应用程序中实现导航时，此方法特别有用。在这种情况下，控制器与UI中的占位符控件或区域相关联，并且它协调视图的构造和放置到该占位符或区域中。 例如，服务类可用于使用容器构建视图并在主页面中显示它们。在此示例中，视图由视图名称指定。通过在UI服务上调用ShowView方法启动导航，如此简单示例所示。 private void NavigateToQuestionnaireList() { // Ask the UI service to go to the \"questionnaire list\" view. this.uiService.ShowView(ViewNames.QuestionnaireTemplatesList); } UI服务与应用程序的UI中的占位符控件相关联; 它封装了所需视图的创建，并在UI中协调其外观。所述ShowView所述的UIService创建（使得其视图模型和其他依赖可以实现）通过所述容器中的视图的一个实例，并然后显示它在适当的位置，如下所示。 public void ShowView(string viewName) { var view = this.ViewFactory.GetView(viewName); this.MainWindow.CurrentView = view; } 注意：Prism为区域内的导航提供广泛的支持。区域导航使用与前一种方法非常相似的机制，区域管理器负责协调特定区域中视图的实例化和放置。欲了解更多信息，请参见基于视图导航，在导航。 ","date":"2019-07-02","objectID":"/2019/07/prism10-advancemvvm/:0:7","tags":["Prism","高级MVVM"],"title":"Prism 高级MVVM","uri":"/2019/07/prism10-advancemvvm/"},{"categories":"Prism","content":"测试MVVM应用程序\r从MVVM应用程序测试模型和视图模型与测试任何其他类相同，并且可以使用相同的工具和技术 - 例如单元测试和模拟框架。但是，有一些测试模式是典型的模型和视图模型类，可以从标准测试技术和测试助手类中受益。 测试INotifyPropertyChanged实现\r实现INotifyPropertyChanged接口允许视图对模型和视图模型中发生的更改做出反应。这些更改不仅限于控件中显示的域数据; 它们还用于控制视图，例如视图模型状态，可以启动动画或禁用控件。 简单案例\r可以通过将事件处理程序附加到PropertyChanged事件并检查在为属性设置新值之后是否引发事件来测试可以由测试代码直接更新的属性。辅助类（如PropertyChangeTracker类）可用于附加处理程序并收集结果; 这可以避免编写测试时的重复性任务。以下代码示例显示了使用此类助手类的测试。 var changeTracker = new PropertyChangeTracker(viewModel); viewModel.CurrentState = \"newState\"; CollectionAssert.Contains(changeTracker.ChangedProperties, \"CurrentState\"); 作为保证INotifyPropertyChanged接口实现的代码生成过程的结果的属性（例如模型设计者生成的代码中的属性）通常不需要进行测试。 Computed and Non-Settable Properties\r当测试代码无法设置属性时 - 例如具有非公共设置器的属性或只读，计算属性 - 测试代码需要激发测试对象导致属性及其相应通知的更改。但是，测试的结构与更简单的情况相同，如下面的代码示例所示，其中模型对象的更改会导致视图模型中的属性发生更改。 var changeTracker = new PropertyChangeTracker(viewModel); var question = viewModel.Questions.First() as OpenQuestionViewModel; question.Question.Response = \"some text\"; CollectionAssert.Contains(changeTracker.ChangedProperties, \"UnansweredQuestions\"); Whole Object Notifications\r实现INotifyPropertyChanged接口时，允许对象使用null或空字符串作为已更改的属性名称引发PropertyChanged事件，以指示对象中的所有属性可能已更改。这些案例可以像通知各个属性名称的案例一样进行测试。 ","date":"2019-07-02","objectID":"/2019/07/prism10-advancemvvm/:0:8","tags":["Prism","高级MVVM"],"title":"Prism 高级MVVM","uri":"/2019/07/prism10-advancemvvm/"},{"categories":"Prism","content":"测试INotifyDataErrorInfo实现\r有几种机制可用于使绑定能够执行输入验证，例如在设置属性时抛出异常，实现IDataErrorInfo接口以及实现INotifyDataErrorInfo接口。实现INotifyDataErrorInfo接口允许更复杂，因为它支持指示每个属性的多个错误并执行异步和跨属性验证; 因此，它也需要最多的测试。 测试INotifyDataErrorInfo实现有两个方面：测试验证规则是否正确实现，并测试接口实现的要求，例如当GetErrors方法的结果不同时引发ErrorsChanged事件。 测试验证规则\r验证逻辑通常很容易测试，因为它通常是一个自包含的过程，其输出取决于输入。对于与验证规则关联的每个属性，应该对使用有效值，无效值，边界值等的验证属性名称调用GetErrors方法的结果进行测试。如果共享验证逻辑，就像使用数据注释的验证属性以声明方式表示验证规则一样，更详尽的测试可以集中在共享验证逻辑上。另一方面，必须彻底测试自定义验证规则。 // Invalid case var notifyErrorInfo = (INotifyDataErrorInfo)question; question.Response = -15; Assert.IsTrue(notifyErrorInfo.GetErrors(\"Response\").Cast\u003cValidationResult\u003e().Any()); // Valid case var notifyErrorInfo = (INotifyDataErrorInfo)question; question.Response = 15; Assert.IsFalse(notifyErrorInfo.GetErrors(\"Response\").Cast\u003cValidationResult\u003e().Any()); 跨属性验证规则遵循相同的模式，通常需要更多测试来适应不同属性的值组合。 测试INotifyDataErrorInfo实现的要求\r除了为GetErrors方法生成正确的值之外，INotifyDataErrorInfo接口的实现必须确保正确引发ErrorsChanged事件，例如GetErrors的结果不同时。此外，HasErrors属性必须反映实现该接口的对象的整体错误状态。 实现INotifyDataErrorInfo接口没有强制方法。但是，依赖于累积验证错误并执行必要通知的对象的实现通常是首选，因为它们更易于测试。这是因为没有必要验证每个验证属性上的每个验证规则是否满足INotifyDataErrorInfo接口的所有成员的要求（当然，因为错误管理对象已经过适当测试）。 测试接口要求至少应包括以下验证： 该HasErrors属性反映对象的整体错误状态。如果其他属性仍具有无效值，则为此属性设置有效值不会导致此属性发生更改。 所述ErrorsChanged当通过在结果为一个变化反映了一个属性更改错误状态，事件被引发GetErrors方法。错误状态更改可能从有效状态（即无错误）变为无效状态，反之亦然，或者它可能从无效状态变为不同的无效状态。GetErrors的更新结果可用于ErrorsChanged事件的处理程序。 在测试INotifyPropertyChanged接口的实现时，辅助类（例如MVVM示例项目中的NotifyDataErrorInfoTestHelper类）通常通过处理重复的内务操作和标准检查来更轻松地为INotifyDataErrorInfo接口的实现编写测试。在实现接口时，它们特别有用，而不依赖于某种可重用的错误管理器。以下代码示例显示了此类型的帮助程序类。 var helper = new NotifyDataErrorInfoTestHelper\u003cNumericQuestion, int?\u003e( question, q =\u003e q.Response); helper.ValidatePropertyChange( 6, NotifyDataErrorInfoBehavior.Nothing); helper.ValidatePropertyChange( 20, NotifyDataErrorInfoBehavior.FiresErrorsChanged | NotifyDataErrorInfoBehavior.HasErrors | NotifyDataErrorInfoBehavior.HasErrorsForProperty); helper.ValidatePropertyChange( null, NotifyDataErrorInfoBehavior.FiresErrorsChanged | NotifyDataErrorInfoBehavior.HasErrors | NotifyDataErrorInfoBehavior.HasErrorsForProperty); helper.ValidatePropertyChange( 2, NotifyDataErrorInfoBehavior.FiresErrorsChanged); 测试异步服务调用\r在实现MVVM模式时，视图模型通常会异步调用服务上的操作。对调用这些操作的代码的测试通常使用模拟或存根作为实际服务的替代。 用于实现异步操作的标准模式提供了有关线程的不同保证，在该线程中发生有关操作状态的通知。虽然基于事件的异步设计模式保证在适合应用程序的线程上调用事件的处理程序，但IAsyncResult设计模式不提供任何此类保证，强制发起调用的视图模型代码以确保任何更改会影响视图发布到UI线程。 处理线程问题需要更复杂，因此通常更难以测试代码。它通常还要求测试本身是异步的。当保证在UI线程中发生通知时，或者因为使用了基于标准事件的异步模式，或者因为视图模型依赖于服务访问层来将通知编组到适当的线程，所以可以简化测试并且可以基本上发挥作用一个“UI线程的调度程序”。 服务被模拟的方式取决于用于实现其操作的异步事件模式。如果使用基于方法的模式，则使用标准模拟框架创建的服务接口的模拟通常就足够了，但如果使用基于事件的模式，则基于实现添加和删除处理程序的方法的自定义类进行模拟对于服务事件通常是首选。 以下代码示例显示了对使用mocks for services在UI线程中通知的异步操作成功完成时的相应行为的测试。在此示例中，测试代码在进行异步服务调用时捕获视图模型提供的回调。然后，测试通过调用回调来模拟测试后期调用的完成。此方法允许测试使用异步服务的组件，而不会使测试异步。 questionnaireRepositoryMock .Setup( r =\u003e r.SubmitQuestionnaireAsync( It.IsAny\u003cQuestionnaire\u003e(), It.IsAny\u003cAction\u003cIOperationResult\u003e\u003e())) .Callback\u003cQuestionnaire, Action\u003cIOperationResult\u003e\u003e( (q, a) =\u003e callback = a); uiServiceMock .Setup(svc =\u003e svc.ShowView(ViewNames.QuestionnaireTemplatesList)) .Callback\u003cstring\u003e(viewName =\u003e requestedViewName = viewName); submitResultMock .Setup(sr =\u003e sr.Error) .Returns\u003cException\u003e(null); CompleteQuestionnaire(viewModel); viewModel.Submit(); // Simulate callback posted to the UI thread. callback(submitResultMock.Object); // Check expected behavior – request to navigate to the list view. Assert.AreEqual(ViewNames.QuestionnaireTemplatesList, requestedViewName); ***注意：*使用此测试方法仅执行被测对象的功能; 它不测试代码是否是线程安全的。 ","date":"2019-07-02","objectID":"/2019/07/prism10-advancemvvm/:0:9","tags":["Prism","高级MVVM"],"title":"Prism 高级MVVM","uri":"/2019/07/prism10-advancemvvm/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 Model-View-ViewModel（MVVM）模式可帮助您将应用程序的业务和表示逻辑与其用户界面（UI）完全分离。在应用程序逻辑和UI之间保持清晰的分离有助于解决许多开发和设计问题，并使您的应用程序更容易测试，维护和发展。它还可以极大地改善代码重用机会，并允许开发人员和UI设计人员在开发应用程序的各个部分时更轻松地进行协作。 使用MVVM模式，应用程序的UI以及底层表示和业务逻辑被分成三个独立的类：视图(view)，它封装了UI和UI逻辑; 视图模型(viewmodel)，它封装了表示逻辑和状态; 模型（model）封装了应用程序的业务逻辑和数据。 Prism包含示例和参考实现，展示如何在Windows Presentation Foundation（WPF）应用程序中实现MVVM模式。Prism Library还提供了可以帮助您在自己的应用程序中实现模式的功能。这些功能体现了实现MVVM模式的最常见实践，旨在支持可测试性并与Expression Blend和Visual Studio配合使用。 ","date":"2019-07-01","objectID":"/2019/07/prism9-mvvm/:0:0","tags":["Prism","MVVM"],"title":"Prism MVVM","uri":"/2019/07/prism9-mvvm/"},{"categories":"Prism","content":"Class Responsibilities and Characteristics\r类的责任和特征 MVVM模式是Presentation Model模式的近似变体，经过优化以利用WPF的一些核心功能，例如数据绑定，数据模板，命令和行为。 在MVVM模式中，视图封装了UI和任何UI逻辑，视图模型封装了表示逻辑和状态，模型封装了业务逻辑和数据。视图通过数据绑定，命令和更改通知事件与视图模型交互。视图模型查询，观察和协调模型的更新，转换，验证和聚合数据，以便在视图中显示。 下图显示了三个MVVM类及其交互。 MVVM类及其交互\r与所有分离的表示模式一样，有效使用MVVM模式的关键在于理解将应用程序代码分解为正确类的适当方式，以及理解这些类在各种场景中交互的方式。以下部分描述了MVVM模式中每个类的职责和特征。 视图类\r视图的职责是定义用户在屏幕上看到的内容的结构和外观。理想情况下，视图的代码隐藏只包含一个调用InitializeComponent方法的构造函数。在某些情况下，代码隐藏可能包含UI逻辑代码，该代码实现了在可扩展应用程序标记语言（XAML）中表达难以或低效的视觉行为，例如复杂的动画，或者当代码需要直接操作视觉元素时部分观点。您不应该在视图中放置任何需要进行单元测试的逻辑代码。通常，视图的代码隐藏中的逻辑代码将通过UI自动化测试方法进行测试。 在WPF中，视图中的数据绑定表达式将根据其数据上下文进行评估。在MVVM中，视图的数据上下文设置为视图模型。视图模型实现视图可以绑定的属性和命令，并通过更改通知事件通知视图状态的任何更改。视图与其视图模型之间通常存在一对一的关系。 通常，视图是Control- derived或UserControl派生的类。但是，在某些情况下，视图可以由数据模板表示，该数据模板指定用于在显示对象时可视地表示对象的UI元素。使用数据模板，可视化设计人员可以轻松定义视图模型的呈现方式，也可以修改其默认的可视化表示，而无需更改底层对象本身或用于显示它的控件的行为。 可以将数据模板视为没有任何代码隐藏的视图。它们旨在绑定到特定的视图模型类型，只要需要在UI中显示一个。在运行时，将自动实例化由数据模板定义的视图，并将其数据上下文设置为相应的视图模型。 在WPF中，您可以在应用程序级别将数据模板与视图模型类型相关联。然后，无论何时在UI中显示，WPF都会自动将数据模板应用于指定类型的任何视图模型对象。这称为隐式数据模板。数据模板可以与使用它的控件一起定义，也可以在父视图外的资源字典中定义，并以声明方式合并到视图的资源字典中。 总而言之，该视图具有以下主要特征： 视图是可视元素，例如窗口，页面，用户控件或数据模板。视图定义视图中包含的控件及其可视布局和样式。 视图通过其DataContext属性引用视图模型。视图中的控件是绑定到视图模型公开的属性和命令的数据。 视图可以自定义视图和视图模型之间的数据绑定行为。例如，视图可以使用值转换器来格式化要在UI中显示的数据，或者它可以使用验证规则来向用户提供额外的输入数据验证。 视图定义并处理UI视觉行为，例如可以从视图模型中的状态更改或通过用户与UI的交互触发的动画或过渡。 视图的代码隐藏可以定义UI逻辑以实现在XAML中难以表达的视觉行为，或者需要直接引用视图中定义的特定UI控件。 视图模型类\rMVVM模式中的视图模型封装了视图的表示逻辑和数据。它没有直接引用视图或有关视图的特定实现或类型的任何知识。视图模型实现视图可以绑定数据的属性和命令，并通过更改通知事件通知视图任何状态更改。视图模型提供的属性和命令定义UI提供的功能，但视图确定如何呈现该功能。 视图模型负责协调视图与所需的任何模型类的交互。通常，视图模型和模型类之间存在一对多关系。视图模型可以选择直接将模型类公开给视图，以便视图中的控件可以直接将数据绑定到它们。在这种情况下，需要设计模型类以支持数据绑定和相关的更改通知事件。有关此方案的详细信息，请参阅本主题后面的“ 数据绑定 ”一节。 视图模型可以转换或操纵模型数据，以便视图可以轻松地使用它。视图模型可以定义其他属性以专门支持视图; 这些属性通常不属于模型的一部分（或不能添加到模型中）。例如，视图模型可以组合两个字段的值以使视图更容易呈现，或者它可以计算具有最大长度的字段的输入剩余字符数。视图模型还可以实现数据验证逻辑以确保数据一致性。 视图模型还可以定义视图可以用于在UI中提供视觉变化的逻辑状态。视图可以定义反映视图模型状态的布局或样式更改。例如，视图模型可以定义指示数据异步提交到Web服务的状态。视图可以在此状态期间显示动画，以向用户提供视觉反馈。 通常，视图模型将定义可在UI中表示并且用户可以调用的命令或操作。一个常见示例是视图模型提供允许用户将数据提交到Web服务或数据存储库的Submit命令。视图可以选择用按钮表示该命令，以便用户可以单击按钮来提交数据。通常，当命令变得不可用时，其关联的UI表示将被禁用。命令提供了一种封装用户操作并将其与UI中的可视表示清晰分离的方法。 总而言之，视图模型具有以下关键特征： 视图模型是非可视类，不是从任何WPF基类派生的。它封装了支持应用程序中的用例或用户任务所需的表示逻辑。视图模型可以独立于视图和模型进行测试。 视图模型通常不直接引用视图。它实现了视图可以绑定数据的属性和命令。它通过INotifyPropertyChanged和INotifyCollectionChanged接口通过更改通知事件通知视图任何状态更改。 视图模型协调视图与模型的交互。它可以转换或操作数据，以便视图可以轻松使用它，并可以实现模型上可能不存在的其他属性。它还可以通过IDataErrorInfo或INotifyDataErrorInfo接口实现数据验证。 视图模型可以定义视图可以在视觉上向用户表示的逻辑状态。 注意：查看或查看模型？ 很多时候，确定应该实现某些功能的地方并不明显。一般的经验法则是：任何与屏幕上UI的特定视觉外观有关并且可以在以后重新设置样式的内容（即使您当前没有计划重新设置样式）也应该进入视图; 对应用程序的逻辑行为很重要的任何内容都应该进入视图模型。此外，由于视图模型应该不具有视图中特定可视元素的明确知识，因此以编程方式操作视图中的可视元素的代码应驻留在视图的代码隐藏中或封装在行为中。同样，检索或操作要通过数据绑定在视图中显示的数据项的代码应驻留在视图模型中。 模型类\rMVVM模式中的模型封装了业务逻辑和数据。业务逻辑被定义为与应用程序数据的检索和管理有关的任何应用程序逻辑，并确保强制执行确保数据一致性和有效性的任何业务规则。为了最大化重用机会，模型不应包含任何特定于用例或特定于用户任务的行为或应用程序逻辑。 通常，模型表示应用程序的客户端域模型。它可以基于应用程序的数据模型和任何支持业务和验证逻辑来定义数据结构。该模型还可以包括支持数据访问和缓存的代码，尽管通常使用单独的数据存储库或服务。通常，模型和数据访问层是作为数据访问或服务策略的一部分生成的，例如ADO.NET实体框架，WCF数据服务或WCF RIA服务。 通常，模型实现了可以轻松绑定到视图的工具。这通常意味着它通过INotifyPropertyChanged和INotifyCollectionChanged接口支持属性和集合更改通知。表示对象集合的模型类通常派生自ObservableCollection 类，该类提供INotifyCollectionChanged接口的实现。 该模型还可以通过IDataErrorInfo（或INotifyDataErrorInfo）接口支持数据验证和错误报告。该IDataErrorInfo的和INotifyDataErrorInfo接口使WPF数据绑定时通知值发生改变，这样的UI可以更新。它们还支持UI层中的数据验证和错误报告。 注意：如果您的模型类没有实现所需的接口，该怎么办？ 有时您需要使用未实现INotifyPropertyChanged，INotifyCollectionChanged，IDataErrorInfo或INotifyDataErrorInfo接口的模型对象。在这些情况下，视图模型可能需要包装模型对象并将所需的属性公开给视图。这些属性的值将由模型对象直接提供。视图模型将为它公开的属性实现所需的接口，以便视图可以轻松地将数据绑定到它们。 该模型具有以下主要特征： 模型类是非可视类，它封装了应用程序的数据和业务逻辑。他们负责管理应用程序的数据，并通过封装所需的业务规则和数据验证逻辑来确保其一致性和有效性。 模型类不直接引用视图或视图模型类，也不依赖于它们的实现方式。 模型类通常通过INotifyPropertyChanged和INotifyCollectionChanged接口提供属性和集合更改通知事件。这允许它们在视图中容易地数据绑定。表示对象集合的模型类通常派生自**ObservableCollection **类。 模型类通常通过IDataErrorInfo或INotifyDataErrorInfo接口提供数据验证和错误报告。 模型类通常与封装数据访问和缓存的服务或存储库结合使用。 View,ViewModel,Model互动\rMVVM模式通过将每个应用程序的用户界面，其表示逻辑以及业务逻辑和数据分离为单独的类，提供了清晰的分离。因此，在实现MVVM时，重要的是将应用程序的代码分解为正确的类，如上一节所述。 精心设计的视图，视图模型和模型类不仅会封装正确类型的代码和行为; 它们的设计也使它们可以通过数据绑定，命令和数据验证接口","date":"2019-07-01","objectID":"/2019/07/prism9-mvvm/:0:1","tags":["Prism","MVVM"],"title":"Prism MVVM","uri":"/2019/07/prism9-mvvm/"},{"categories":"Prism","content":"数据绑定\r数据绑定在MVVM模式中起着非常重要的作用。WPF提供强大的数据绑定功能。您的视图模型和（理想情况下）您的模型类应设计为支持数据绑定，以便它们可以利用这些功能。通常，这意味着它们必须实现正确的接口。 WPF数据绑定支持多种数据绑定模式。通过单向数据绑定，可以将UI控件绑定到视图模型，以便在呈现显示时它们反映基础数据的值。当用户在UI中修改基础数据时，双向数据绑定也将自动更新基础数据。 为确保在视图模型中数据发生更改时UI保持最新，它应实现相应的更改通知界面。如果它定义了可以绑定数据的属性，它应该实现INotifyPropertyChanged接口。如果视图模型表示集合，则它应实现INotifyCollectionChanged接口，或者从提供此接口实现的**ObservableCollection **类派生。这两个接口都定义了每当基础数据发生更改时引发的事件。引发这些事件时，将自动更新任何数据绑定控件。 在许多情况下，视图模型将定义返回对象的属性（反过来，可以定义返回其他对象的属性）。WPF数据绑定支持通过Path属性绑定到嵌套属性。因此，视图的视图模型返回对其他视图模型或模型类的引用是很常见的。视图可访问的所有视图模型和模型类应根据需要实现INotifyPropertyChanged或INotifyCollectionChanged接口。 以下部分描述了如何实现所需的接口以支持MVVM模式中的数据绑定。 实现INotifyPropertyChanged\r在视图模型或模型类中实现INotifyPropertyChanged接口允许它们在基础属性值更改时向视图中的任何数据绑定控件提供更改通知。实现此接口非常简单，如以下代码示例所示。 public class Questionnaire : INotifyPropertyChanged { private string favoriteColor; public event PropertyChangedEventHandler PropertyChanged; ... public string FavoriteColor { get { return this.favoriteColor; } set { if (value != this.favoriteColor) { this.favoriteColor = value; var handler = this.PropertyChanged; if (handler != null) { handler(this, new PropertyChangedEventArgs(\"FavoriteColor\")); } } } } } 由于需要在event参数中指定属性名称，因此在许多视图模型类上实现INotifyPropertyChanged接口可能是重复且容易出错的。Prism库提供了BindableBase基类，您可以从中派生以类型安全的方式实现INotifyPropertyChanged接口的视图模型类，如此处所示。 public abstract class BindableBase : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged; ... protected virtual bool SetProperty\u003cT\u003e(ref T storage, T value, [CallerMemberName] string propertyName = null) {...} protected void OnPropertyChanged\u003cT\u003e( Expression\u003cFunc\u003cT\u003e\u003e propertyExpression) {...} protected void OnPropertyChanged(string propertyName) {...} } 派生视图模型类可以通过调用SetProperty方法在setter中引发属性更改事件。所述的SetProperty方法检查被设定的值支持字段是否是不同的。如果不同，则更新后备字段并引发PropertyChanged事件。 下面的代码示例演示如何设置属性，并通过在OnPropertyChanged方法中使用lambda表达式同时发出另一个属性的更改。此示例来自Stock Trader RI。该TransactionInfo和TickerSymbol属性相关。如果TransactionInfo属性更改，则TickerSymbol也可能会更新。通过调用OnPropertyChanged的TickerSymbol中的setter属性TransactionInfo财产，二的PropertyChanged事件将提高，一个用于TransactionInfo，一个用于TickerSymbol。 public TransactionInfo TransactionInfo { get { return this.transactionInfo; } set { SetProperty(ref this.transactionInfo, value); this.OnPropertyChanged(() =\u003e this.TickerSymbol); } } **注意：**以这种方式使用lambda表达式会产生很小的性能成本，因为必须为每次调用计算lambda表达式。好处是，如果重命名属性，此方法可提供编译时类型安全性和重构支持。虽然性能成本很低，并且通常不会影响您的应用程序，但如果您有许多更改通知，则会产生成本。在这种情况下，您应该考虑使用非lambda方法重载。 通常，模型或视图模型将包含其值从模型或视图模型中的其他属性计算的属性。处理属性更改时，请务必同时为任何计算属性引发通知事件。 实现INotifyCollectionChanged\r您的视图模型或模型类可以表示项的集合，也可以定义一个或多个返回项集合的属性。在任何一种情况下，您可能希望在ItemsControl中显示集合，例如ListBox，或者在视图中的DataGrid控件中。这些控件可以是绑定到视图模型的数据，该视图模型表示集合或通过ItemSource属性返回集合的属性。 \u003cDataGrid ItemsSource=\"{Binding Path=LineItems}\" /\u003e 为了正确支持更改通知请求，视图模型或模型类（如果它表示集合）应实现INotifyCollectionChanged接口（除了INotifyPropertyChanged接口）。如果视图模型或模型类定义了返回对集合的引用的属性，则返回的集合类应实现INotifyCollectionChanged接口。 但是，实现INotifyCollectionChanged接口可能具有挑战性，因为它必须在集合中添加，删除或更改项目时提供通知。它不是直接实现接口，而是通常更容易使用或派生自已实现它的集合类。所述**的ObservableCollection **类提供这个接口的实现和通常用作任一个基类或执行该代表项的集合的性质。 如果需要为视图提供数据绑定的集合，并且不需要跟踪用户的选择或支持对集合中项目的过滤，排序或分组，则只需在视图模型上定义属性即可返回对**ObservableCollection **实例的引用。 public class OrderViewModel : BindableBase { public OrderViewModel( IOrderService orderService ) { this.LineItems = new ObservableCollection\u003cOrderLineItem\u003e( orderService.GetLineItemList() ); } public ObservableCollection\u003cOrderLineItem\u003e LineItems { get; private set; } } 如果获得对集合类的引用（例如，来自未实现INotifyCollectionChanged的其他组件或服务），则通常可以使用其中一个构造函数将该集合包装在**ObservableCollection 实例中，该构造函数采用IEnumerable 或List **参数。 注意：BindableBase可以在Prism.Mvvm命名空间中找到，该命名空间位于Prism.Core NuGet包中。 实现ICollectionView\r上面的代码示例演示如何实现一个简单的视图模型属性，该属性返回可以通过视图中的数据绑定控件显示的项集合。由于ObservableCollection 类实现了INotifyCollectionChanged接口，因此在添加或删除项目时，视图中的控件将自动更新以反映集合中的当前项目列表。 但是，您通常需要更精细地控制项目集合在视图中的显示方式，或者在视图模型本身内跟踪用户与显示的项目集合的交互。例如，您可能需要根据视图模型中实现的表示逻辑来过滤或排序项目集合，或者您可能需要跟踪视图中当前选定的项目，以便在视图模型中实现命令可以对当前选定的项目采取行动。 WPF通过提供实现ICollectionView接口的各种类来支持这些场景。此接口提供允许对集合进行过滤，排序或分组的属性和方法，并允许跟踪或更改当前选定的项目。WPF使用ListCollectionView类提供此接口的实现。 集合视图类通过包装","date":"2019-07-01","objectID":"/2019/07/prism9-mvvm/:0:2","tags":["Prism","MVVM"],"title":"Prism MVVM","uri":"/2019/07/prism9-mvvm/"},{"categories":"Prism","content":"命令\r除了提供对要在视图中显示或编辑的数据的访问之外，视图模型还可能定义可由用户执行的一个或多个动作或操作。在WPF中，用户可以通过UI执行的操作或操作通常被定义为命令。命令提供了一种方便的方法来表示可以轻松绑定到UI中的控件的操作或操作。它们封装了实现操作或操作的实际代码，并有助于使其与视图中的实际可视化表示分离。 当用户与视图交互时，用户可以以多种不同的方式直观地表示和调用命令。在大多数情况下，它们是通过鼠标单击调用的，但也可以通过快捷键按下，触摸手势或任何其他输入事件来调用它们。视图中的控件是绑定到视图模型命令的数据，以便用户可以使用控件定义的任何输入事件或手势来调用它们。视图中的UI控件与命令之间的交互可以是双向的。在这种情况下，可以在用户与UI交互时调用该命令，并且可以在启用或禁用基础命令时自动启用或禁用UI。 视图模型可以将命令实现为命令方法或命令对象（实现ICommand接口的对象）。在任何一种情况下，视图与命令的交互都可以以声明方式定义，而不需要在视图的代码隐藏文件中使用复杂的事件处理代码。例如，WPF中的某些控件本身支持命令并提供Command属性，该属性可以是绑定到视图模型提供的ICommand对象的数据。在其他情况下，命令行为可用于将控件与视图模型提供的命令方法或命令对象相关联。 **注意：**行为是一种功能强大且灵活的可扩展性机制，可用于封装交互逻辑和行为，然后可以与视图中的控件进行声明性关联。命令行为可用于将命令对象或方法与未专门设计用于与命令交互的控件相关联。 以下部分描述了如何在视图中实现命令，命令方法或命令对象，以及如何将它们与视图中的控件相关联。 实现基于任务的委托命令\r在许多情况下，命令使用长时间运行的事务调用代码，这些事务无法阻止UI线程。对于这种情况，你应该使用FromAsyncHandler的方法DelegateCommand类，它创建的新实例DelegateCommand从一个异步处理方法。 // DelegateCommand.cs public static DelegateCommand FromAsyncHandler(Func\u003cTask\u003e executeMethod, Func\u003cbool\u003e canExecuteMethod) { return new DelegateCommand(executeMethod, canExecuteMethod); } 例如，以下代码显示如何通过指定SignInAsync和CanSignIn视图模型方法的委托来构造表示登录命令的DelegateCommand实例。然后，该命令通过只读属性公开给视图，该属性返回对ICommand的引用。 // SignInFlyoutViewModel.cs public DelegateCommand SignInCommand { get; private set; } ... SignInCommand = DelegateCommand.FromAsyncHandler(SignInAsync, CanSignIn); ","date":"2019-07-01","objectID":"/2019/07/prism9-mvvm/:0:3","tags":["Prism","MVVM"],"title":"Prism MVVM","uri":"/2019/07/prism9-mvvm/"},{"categories":"Prism","content":"实现命令对象\r命令对象是实现ICommand接口的对象。该接口定义了一个Execute方法，它封装了操作本身，以及一个CanExecute方法，它指示是否可以在特定时间调用该命令。这两种方法都只使用一个参数作为命令的参数。对命令对象中的操作的实现逻辑的封装意味着它可以更容易地进行单元测试和维护。 实现ICommand接口非常简单。但是，您可以在应用程序中轻松使用此接口的许多实现。例如，您可以使用Blend for Visual Studio SDK中的ActionCommand类或Prism提供的DelegateCommand类。 注意：DelegateCommand可以在Prism.Commands命名空间中找到，该命名空间位于Prism.Core NuGet包中。 Prism DelegateCommand类封装了两个委托，每个委托引用在视图模型类中实现的方法。它继承自DelegateCommandBase类，该类通过调用这些委托来实现ICommand接口的Execute和CanExecute方法。您可以在DelegateCommand类构造函数中为视图模型方法指定委托，其定义如下。 // DelegateCommand.cs public class DelegateCommand\u003cT\u003e : DelegateCommandBase { public DelegateCommand(Action\u003cT\u003e executeMethod,Func\u003cT,bool\u003e canExecuteMethod ): base((o) =\u003e executeMethod((T)o), (o) =\u003e canExecuteMethod((T)o)) { ... } } 例如，以下代码示例显示如何通过为OnSubmit和CanSubmit视图模型方法指定委托来构造表示Submit命令的DelegateCommand实例。然后，该命令通过只读属性公开给视图，该属性返回对ICommand的引用。 public class QuestionnaireViewModel { public QuestionnaireViewModel() { this.SubmitCommand = new DelegateCommand\u003cobject\u003e( this.OnSubmit, this.CanSubmit ); } public ICommand SubmitCommand { get; private set; } private void OnSubmit(object arg) {...} private bool CanSubmit(object arg) { return true; } } 当在DelegateCommand对象上调用Execute方法时，它只是通过您在构造函数中指定的委托将调用转发到视图模型类中的方法。同样，调用CanExecute方法时，将调用视图模型类中的相应方法。构造函数中CanExecute方法的委托是可选的。如果未指定委托，则DelegateCommand将始终为CanExecute返回true。 该DelegateCommand类是一个泛型类型。type参数指定传递给Execute和CanExecute方法的命令参数的类型。在前面的示例中，command参数的类型为object。Prism还提供了非泛型版本的DelegateCommand类，以便在不需要命令参数时使用。 视图模型可以通过调用DelegateCommand对象上的RaiseCanExecuteChanged方法来指示命令的CanExecute状态的更改。这会导致引发CanExecuteChanged事件。UI中绑定到该命令的任何控件都将更新其启用状态以反映绑定命令的可用性。 可以使用ICommand接口的其他实现。Expression Blend SDK提供的ActionCommand类与前面描述的Prism的DelegateCommand类类似，但它仅支持单个Execute方法委托。Prism还提供了CompositeCommand类，它允许将DelegateCommands组合在一起执行。有关使用CompositeCommand类的更多信息，请参阅“ 高级MVVM方案 ”中的“复合命令” 。 从视图调用命令对象\r有许多方法可以将视图中的控件与视图模型提供的命令对象相关联。某些WPF控件，特别是ButtonBase派生控件，如Button或RadioButton，以及Hyperlink或MenuItem派生控件，可以通过Command属性轻松地将数据绑定到命令对象。WPF还支持将视图模型ICommand绑定到KeyGesture。 \u003cButton Command=\"{Binding Path=SubmitCommand}\" CommandParameter=\"SubmitOrder\"/\u003e 也可以使用CommandParameter属性选择性地定义命令参数。预期参数的类型在Execute和CanExecute目标方法中指定。当用户与该控件交互时，控件将自动调用目标命令，并且命令参数（如果提供）将作为参数传递给命令的Execute方法。在前面的示例中，按钮将在单击时自动调用SubmitCommand。此外，如果指定了CanExecute处理程序，则在CanExecute返回false时将自动禁用该按钮，如果返回true，将启用它。 另一种方法是使用Blend for Visual Studio 2013交互触发器和InvokeCommandAction行为。有关InvokeCommandAction行为以及将命令与事件关联的更多信息，请参阅“ 高级MVVM方案”中的“交互触发器和命令” 。 数据验证和错误报告\r通常需要您的视图模型或模型来执行数据验证并向视图发出任何数据验证错误信号，以便用户可以采取行动纠正它们。 WPF支持管理更改绑定到视图中控件的各个属性时发生的数据验证错误。对于与控件数据绑定的单个属性，视图模型或模型可以通过拒绝传入的错误值并抛出异常来表示属性设置器中的数据验证错误。如果数据绑定上的ValidatesOnExceptions属性为true，则WPF中的数据绑定引擎将处理该异常并向用户显示存在数据验证错误的可视提示。 但是，应尽可能避免以这种方式抛出属性异常。另一种方法是在视图模型或模型类上实现IDataErrorInfo或INotifyDataErrorInfo接口。这些接口允许您的视图模型或模型对一个或多个属性值执行数据验证，并向视图返回错误消息，以便可以通知用户错误。 实现IDataErrorInfo\r该IDataErrorInfo的接口提供了性能数据验证和错误报告的基本支持。它定义了两个只读属性：一个索引器属性，其属性名称为索引器参数，以及一个Error属性。两个属性都返回一个字符串值。 indexer属性允许视图模型或模型类提供特定于命名属性的错误消息。空字符串或空返回值向视图指示已更改的属性值有效。的错误属性允许视图模型或模型类，以提供对整个对象的错误消息。但请注意，WPF数据绑定引擎当前不会调用此属性。 所述IDataErrorInfo的时首先显示数据绑定属性索引器属性被访问，并且每当它随后被更改。因为为所有更改的属性调用了indexer属性，所以应该小心确保数据验证尽可能快速有效。 将视图中的控件绑定到要通过IDataErrorInfo接口验证的属性时，请将数据绑定上的ValidatesOnDataErrors属性设置为true。这将确保数据绑定引擎将请求数据绑定属性的错误信息。 \u003cTextBox Text=\"{Binding Path=CurrentEmployee.Name, Mode=TwoWay, ValidatesOnDataErrors=True, NotifyOnValidationError=True }\" /\u003e 实现INotifyDataErrorInfo\r该INotifyDataErrorInfo界面比更灵活IDataErrorInfo的接口。它支持属性的多个错误，异步数据验证，以及在对象的错误状态更改时通知视图的能力。 所述INotifyDataErrorInfo接口定义了一个HasErrors属性，该属性允许视图模型，以指示用于任何性质的误差（或多个误差）是否存在，和一个GetErrors方法，其允许视图模型返回错误消息的列表的特定属性。 所述INotifyDataErrorInfo接口还限定ErrorsChanged事件。这通过允许视图或视图模型通过ErrorsChanged事件指示特定属性的错误状态更改来支持异步验证方案。可以通过多种方式更改属性值，而不仅仅是通过数据绑定 - 例如，作为Web服务调用或后台计算的结果。该ErrorsChanged事件使得一旦数据验证错误已被确定视图模型告知错误的观点。 要支持INotifyDataErrorInfo，您需要维护每个属性的错误列表。Model-View-ViewModel参考实现（MVVM RI）演示了一种使用ErrorsContainer集合类来实现此目的的方法，该集合类跟踪对象中的所有验证错误。如果错误列表发生更改，它还会引发通知事件。以下代码示例显示了DomainObject（根模型对象），并使用ErrorsContainer类显示了INotifyDataErrorInfo的示例实现。 public abstract class DomainObject : INotif","date":"2019-07-01","objectID":"/2019/07/prism9-mvvm/:0:4","tags":["Prism","MVVM"],"title":"Prism MVVM","uri":"/2019/07/prism9-mvvm/"},{"categories":"Prism","content":"Construction and Wire-Up\rMVVM模式可以帮助您将UI与表示和业务逻辑和数据完全分离，因此在正确的类中实现正确的代码是有效使用MVVM模式的重要第一步。通过数据绑定和命令管理视图和视图模型类之间的交互也是需要考虑的重要方面。下一步是考虑如何在运行时实例化视图，视图模型和模型类并将它们相互关联。 **注意：**如果在应用程序中使用依赖项注入容器，则选择适当的策略来管理此步骤尤为重要。托管可扩展性框架（MEF）和Unity应用程序块（Unity）都提供了指定视图，视图模型和模型类之间的依赖关系以及使容器满足它们的能力。有关更高级的方案，请参阅高级MVVM方案。 通常，视图与其视图模型之间存在一对一的关系。视图和视图模型通过视图的数据上下文属性松散耦合; 这允许视图中的可视元素和行为是绑定到视图模型上的属性，命令和方法的数据。您将需要决定如何在运行时通过DataContext属性来管理视图的实例化以及查看模型类及其关联。 在构建和连接视图和视图模型时也必须小心，以确保保持松耦合。如前一节所述，视图模型理想情况下不应依赖于视图的任何特定实现。同样，理想情况下，视图应该不依赖于视图模型的任何特定实现。 **注意：**但是，应该注意，视图将隐式依赖于视图模型上的特定属性，命令和方法，因为它定义了数据绑定。如果视图模型未实现所需的属性，命令或方法，则数据绑定引擎将生成运行时异常，该异常将在调试期间显示在Visual Studio输出窗口中。 可以通过多种方式在运行时构建视图和视图模型并将其关联。适合您的应用程序的方法在很大程度上取决于您是首先创建视图还是视图模型，以及是以编程方式还是以声明方式创建视图模型。以下部分描述了在运行时可以创建视图和视图模型类以及相互关联的常用方法。 使用XAML创建视图模型\r也许最简单的方法是视图以声明方式在XAML中实例化其对应的视图模型。构造视图时，还将构造相应的视图模型对象。您还可以在XAML中指定将视图模型设置为视图的数据上下文。 \u003cUserControl.DataContext\u003e \u003cmy:MyViewModel/\u003e \u003c/UserControl.DataContext\u003e 创建此视图时，将自动构建MyViewModel的实例并将其设置为视图的数据上下文。此方法要求您的视图模型具有默认（无参数）构造函数。 视图的声明性构造和视图模型的分配具有以下优点：它很简单并且在诸如Microsoft Expression Blend或Microsoft Visual Studio的设计时工具中运行良好。此方法的缺点是视图具有相应视图模型类型的知识，并且视图模型类型必须具有默认构造函数。 以编程方式创建视图模型\r另一种方法是视图在其构造函数中以编程方式实例化其对应的视图模型实例。然后，它可以将其设置为其数据上下文，如以下代码示例所示。 public MyView() { InitializeComponent(); this.DataContext = new MyViewModel(); } 使用视图模型定位器创建视图模型\r创建视图模型实例并将其与视图关联的另一种方法是使用视图模型定位器。 Prism视图模型定位器具有AutoWireViewModel附加属性，在设置时调用ViewModelLocationProvider类中的AutoWireViewModelChanged方法来解析视图的视图模型。默认情况下，它使用基于约定的方法。 在Basic MVVM QuickStart中，MainWindow.xaml使用视图模型定位器来解析视图模型。 \u003cWindow x:Class=\"QuickStart.Views.MainWindow\" ... xmlns:prism=\"http://prismlibrary.com/\" prism:ViewModelLocator.AutoWireViewModel=\"True\"\u003e Prism的ViewModelLocator类有一个附加属性AutoWireViewMode l，当设置为true时，将尝试定位视图的视图模型，然后将视图的数据上下文设置为视图模型的实例。若要查找相应的视图模型，ViewModelLocationProvider首先尝试从ViewModelLocationProvider类的Register方法注册的任何映射中解析视图模型。如果使用此方法无法解析视图模型，例如，如果未创建映射，则ViewModelLocationProvider回归到基于约定的方法来解决正确的视图模型类型。此约定假定视图模型与视图类型在同一个程序集中，视图模型位于a。ViewModels子命名空间，该视图位于。查看子命名空间，该视图模型名称与视图名称对应，以“ViewModel”结尾。有关如何更改Prism的视图模型定位器约定的说明，请参阅附录D：扩展棱镜。 注意：ViewModelLocationProvider可以在Prism.Core NuGet包中的Prism.Mvvm命名空间中找到。ViewModelLocator可以在Prism.WPF NuGet包中的Prism.Mvvm命名空间中找到。 创建定义为数据模板的视图\r视图可以定义为数据模板并与视图模型类型相关联。数据模板可以定义为资源，也可以在显示视图模型的控件中内联定义。控件的“内容”是视图模型实例，数据模板用于直观地表示它。WPF将自动实例化数据模板，并在运行时将其数据上下文设置为视图模型实例。此技术是首先实例化视图模型，然后创建视图的情况的示例。 数据模板灵活轻便。UI设计人员可以使用它们轻松定义视图模型的可视化表示，而无需任何复杂的代码。数据模板仅限于不需要任何UI逻辑（代码隐藏）的视图。Microsoft Blend for Visual Studio 2013可用于可视化设计和编辑数据模板。 以下示例显示绑定到客户列表的ItemsControl。底层集合中的每个客户对象都是一个视图模型实例。客户的视图由内联数据模板定义。在以下示例中，每个客户视图模型的视图由一个StackPanel组成，其中标签和文本框控件绑定到视图模型上的Name属性。 \u003cItemsControl ItemsSource=\"{Binding Customers}\"\u003e \u003cItemsControl.ItemTemplate\u003e \u003cDataTemplate\u003e \u003cStackPanel Orientation=\"Horizontal\"\u003e \u003cTextBlock VerticalAlignment=\"Center\" Text=\"Customer Name: \" /\u003e \u003cTextBox Text=\"{Binding Name}\" /\u003e \u003c/StackPanel\u003e \u003c/DataTemplate\u003e \u003c/ItemsControl.ItemTemplate\u003e \u003c/ItemsControl\u003e 您还可以将数据模板定义为资源。以下示例显示了数据模板定义的资源，并通过StaticResource标记扩展应用于内容控件。 \u003cUserControl ...\u003e \u003cUserControl.Resources\u003e \u003cDataTemplate x:Key=\"CustomerViewTemplate\"\u003e \u003clocal:CustomerContactView /\u003e \u003c/DataTemplate\u003e \u003c/UserControl.Resources\u003e \u003cGrid\u003e \u003cContentControl Content=\"{Binding Customer}\" ContentTemplate=\"{StaticResource CustomerViewTemplate}\" /\u003e \u003c/Grid\u003e \u003c/UserControl\u003e 这里，数据模板包装了一个具体的视图类型。这允许视图定义代码隐藏行为。通过这种方式，数据模板机制可用于从外部提供视图和视图模型之间的关联。虽然前面的示例显示了UserControl资源中的模板，但它通常会放在应用程序的资源中以供重用。 ","date":"2019-07-01","objectID":"/2019/07/prism9-mvvm/:0:5","tags":["Prism","MVVM"],"title":"Prism MVVM","uri":"/2019/07/prism9-mvvm/"},{"categories":"Prism","content":"关键决定\r当您选择使用MVVM模式构建应用程序时，您将不得不做出某些难以在以后更改的设计决策。通常，这些决策是应用程序范围的，并且它们在整个应用程序中的一致使用将提高开发人员和设 以下总结了实现MVVM模式时最重要的决策： 确定查看和查看您将使用的模型构造的方法。您需要确定您的应用程序是首先构造视图还是视图模型，以及是否使用依赖注入容器，例如Unity或MEF。您通常希望这在整个应用程序范围内保持一致。有关详细信息，请参阅部分，建设和线向上，这个主题和部分先进施工和线向上，在高级MVVM方案。 确定是否将视图模型中的命令作为命令方法或命令对象公开。命令方法很容易公开，可以通过视图中的行为来调用。命令对象可以巧妙地封装命令和启用/禁用逻辑，并且可以通过行为或通过ButtonBase派生控件上的Command属性调用。为了使开发人员和设计人员更容易，最好将其作为应用程序范围内的选择。有关更多信息，请参阅本主题中的“ 命令 ”一节。 确定视图模型和模型如何向视图报告错误。您的模型可以支持IDataErrorInfo或INotifyDataErrorInfo。并非所有模型都需要报告错误信息，但对于那些模型，最好为开发人员提供一致的方法。有关详细信息，请参阅本主题中的“ 数据验证和错误报告 ”部分。 确定Microsoft Blend for Visual Studio 2013设计时数据支持对您的团队是否重要。如果您将使用Blend来设计和维护UI并希望查看设计时数据，请确保您的视图和视图模型提供的构造函数没有参数，并且您的视图提供了设计时数据上下文。或者，考虑使用Microsoft Blend for Visual Studio 2013提供的设计时功能，使用设计时属性，例如d：DataContext和d：DesignSource。有关更多信息，请参阅在编写用户界面中创建设计器友好视图的准则。 ","date":"2019-07-01","objectID":"/2019/07/prism9-mvvm/:0:6","tags":["Prism","MVVM"],"title":"Prism MVVM","uri":"/2019/07/prism9-mvvm/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 Modular Application Development Using Prism Library for WPF 模块化应用程序是一个应用程序，它被分成一组松散耦合的功能单元（命名模块），可以集成到更大的应用程序中。客户端模块封装了应用程序的整体功能的一部分，并且通常表示一组相关的问题。它可以包括一组相关组件，例如应用程序功能，包括用户界面和业务逻辑，或应用程序基础结构，例如用于记录或验证用户的应用程序级服务。模块彼此独立，但可以以松散耦合的方式彼此通信。使用模块化应用程序设计，您可以更轻松地开发，测试，部署和维护应用程序。 例如，考虑个人银行应用程序。用户可以访问各种功能，例如在账户之间转账，支付账单以及从单个用户界面（UI）更新个人信息。但是，在幕后，这些功能中的每一个都封装在一个离散模块中。这些模块相互通信，并与后端系统（如数据库服务器和Web服务）进行通信。应用服务集成了每个不同模块中的各种组件，并处理与用户的通信。用户看到的视图类似于单个应用程序的集成视图。 下图显示了具有多个模块的模块化应用程序的设计。 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:0","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"构建模块化应用程序的好处\r您可能已经使用程序集，接口和类构建了一个架构良好的应用程序，并采用了良好的面向对象设计原则。即便如此，除非非常小心，否则您的应用程序设计可能仍然是“单一的”（所有功能都在应用程序内以紧密耦合的方式实现），这可能使应用程序难以开发，测试，扩展和维护。 另一方面，模块化应用程序方法可以帮助您识别应用程序的大规模功能区域，并允许您独立开发和测试该功能。这可以使开发和测试更容易，但它也可以使您的应用程序更灵活，更容易在未来扩展。模块化方法的好处是它可以使您的整体应用程序架构更加灵活和可维护，因为它允许您将应用程序分解为可管理的部分。每个部分都封装了特定的功能，每个部分都通过清晰但松散耦合的通信渠道进行集成。 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:1","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"Prism对模块化应用程序开发的支持\rPrism为您的应用程序中的模块化应用程序开发和运行时模块管理提供支持。使用Prism的模块化开发功能可以节省您的时间，因为您不必实现和测试自己的模块化框架。Prism支持以下模块化应用程序开发功能： 用于注册命名模块和每个模块位置的模块目录; 您可以通过以下方式创建模块目录： 通过代码或可扩展应用程序标记语言（XAML）定义模块 通过发现目录中的模块，您可以加载所有模块，而无需在集中目录中明确定义 通过在配置文件中定义模块 模块的声明性元数据属性，以支持初始化模式和依赖性 与依赖注入容器集成以支持模块之间的松散耦合 对于模块加载： 依赖管理，包括重复和循环检测，以确保模块以正确的顺序加载，并且只加载和初始化一次 模块的按需和后台下载，以最大限度地减少应用程序启动时间; 其余模块可以在后台加载和初始化，也可以在需要时加载和初始化 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:2","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"核心概念\r本节介绍与Prism模块化相关的核心概念，包括IModule接口，模块加载过程，模块目录，模块之间的通信以及依赖注入容器。 IModule：模块化应用程序的构建块\r模块是功能和资源的逻辑集合，以可以单独开发，测试，部署和集成到应用程序中的方式打包。包可以是一个或多个程序集。每个模块都有一个中心类，负责初始化模块并将其功能集成到应用程序中。该类实现了IModule接口。 *注意：实现IModule接口的类的存在足以将包标识为模块。 该IModule的接口只有一个方法，名为初始化，您可以在其中实现的任何逻辑需要初始化和模块的功能集成到应用程序。根据模块的用途，它可以将视图注册到组合用户界面，为应用程序提供其他服务，或扩展应用程序的功能。以下代码显示了模块的最低实现。 public class MyModule : IModule { public void Initialize() { // Do something here. } } 模块寿命\rPrism中的模块加载过程包括以下内容： 注册/发现模块。在运行时为特定应用程序加载的模块在模块目录中定义。该目录包含有关要加载的模块，其位置以及加载顺序的信息。 加载模块。包含模块的程序集将加载到内存中。此阶段可能需要从某个远程位置或本地目录检索模块。 初始化模块。然后初始化模块。这意味着创建模块类的实例并通过IModule接口调用它们的Initialize方法。 下图显示了模块加载过程。 模块目录\r所述ModuleCatalog保存关于能够由应用程序使用的模块的信息。目录本质上是ModuleInfo类的集合。ModuleInfo类中描述了每个模块，该类记录了模块的其他属性中的名称，类型和位置。使用ModuleInfo实例填充ModuleCatalog有几种典型方法： 在代码中注册模块 在XAML中注册模块 在配置文件中注册模块 在磁盘上的本地目录中发现模块 您应该使用的注册和发现机制取决于您的应用程序需要什么。使用配置文件或XAML文件允许您的应用程序不需要引用模块。使用目录可以允许应用程序发现模块，而无需在文件中指定它们。 控制何时加载模块\rPrism应用程序可以尽快初始化模块，称为“可用时”，或者当应用程序需要它们时，称为“按需”。请考虑以下加载模块的准则： 运行应用程序所需的模块必须与应用程序一起加载，并在应用程序运行时进行初始化。 包含几乎总是在应用程序的典型使用中使用的功能的模块可以在后台加载并在可用时进行初始化。 可以按需加载和初始化包含很少使用的功能（或其他模块可选择依赖的支持模块）的模块。 考虑如何对应用程序进行分区，常见使用方案，应用程序启动时间以及下载的数量和大小，以确定如何配置模块以进行下载和初始化。 将模块与应用程序集成\rPrism提供以下类来引导您的应用程序：UnityBootstrapper或MefBootstrapper。这些类可用于创建和配置模块管理器以发现和加载模块。您可以覆盖配置方法，以在几行代码中注册XAML文件，配置文件或目录位置中指定的模块。 使用模块Initialize方法将模块与应用程序的其余部分集成。执行此操作的方式因应用程序的结构和模块的内容而异。以下是将模块集成到应用程序中的常见操作： 将模块的视图添加到应用程序的导航结构中。在使用视图发现或视图注入构建复合UI应用程序时，这很常见。 订阅应用程序级别的事件或服务。 使用应用程序的依赖注入容器注册共享服务。 在模块之间进行通信\r即使模块之间的耦合度较低，模块也可以相互通信。有几种松散耦合的通信模式，每种都有自己的优势。通常，这些模式的组合用于创建所得到的解决方案。以下是其中一些模式： 松散耦合的事件。模块可以广播已发生的特定事件。其他模块可以订阅这些事件，以便在事件发生时通知他们。松耦合事件是在两个模块之间建立通信的轻量级方式; 因此，它们很容易实现。但是，过于依赖事件的设计可能变得难以维护，尤其是如果必须协调许多事件以完成单个任务。在这种情况下，考虑共享服务可能更好。 共享服务。共享服务是可以通过公共接口访问的类。通常，共享服务位于共享程序集中，并提供系统范围的服务，例如身份验证，日志记录或配置。 共享资源。如果您不希望模块直接相互通信，您还可以通过共享资源（如数据库或一组Web服务）间接进行通信。 依赖注入和模块化应用程序\rUnity应用程序块（Unity）和托管可扩展性框架（MEF）等容器允许您轻松使用控制反转（IoC）和依赖注入，它们是强大的设计模式，有助于以松散耦合的方式组合组件。它允许组件获得对它们所依赖的其他组件的引用，而无需对这些引用进行硬编码，从而促进更好的代码重用和更高的灵活性。在构建松散耦合的模块化应用程序时，依赖注入非常有用。Prism旨在与用于组成应用程序中的组件的依赖注入容器无关。容器的选择取决于您，并且在很大程度上取决于您的应用要求和偏好。然而， 模式和实践Unity Application Block提供了一个功能齐全的依赖注入容器。它支持基于属性和基于构造函数的注入和策略注入，允许您透明地在组件之间注入行为和策略; 它还支持许多其他典型的依赖注入容器功能。 MEF（它是.NET Framework 4.5的一部分）通过支持基于依赖注入的组件组合提供对构建可扩展.NET应用程序的支持，并提供支持模块化应用程序开发的其他功能。它允许应用程序在运行时发现组件，然后以松散耦合的方式将这些组件集成到应用程序中。MEF是一个很好的可扩展性和组合框架。它包括程序集和类型发现，类型依赖性解析，依赖注入以及一些不错的程序集下载功能。Prism支持利用MEF功能，以及以下内容： 通过XAML和代码属性进行模块注册 通过配置文件和目录扫描进行模块注册 加载模块时的状态跟踪 使用MEF时模块的自定义声明性元数据 Unity和MEF依赖注入容器都可以与Prism无缝协作。 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:3","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"关键决定\r您要做的第一个决定是您是否要开发模块化解决方案。如上一节所述，构建模块化应用程序有许多好处，但是您需要花费时间和精力来获得这些好处。如果您决定开发模块化解决方案，还有几个需要考虑的事项： 确定您将使用的框架。您可以创建自己的模块化框架，使用Prism，MEF或其他框架。 确定如何组织解决方案。通过定义每个模块的边界来处理模块化体系结构，包括哪些组件是每个模块的一部分。您可以决定使用模块化来简化开发，以及控制应用程序的部署方式或是否支持插件或可扩展体系结构。 确定如何对模块进行分区。可以根据需求对模块进行不同的分区，例如，按功能区域，提供程序模块，开发团队和部署要求进行分区。 确定应用程序将为所有模块提供的核心服务。例如，核心服务可以是错误报告服务或身份验证和授权服务。 如果您使用的是Prism，请确定在模块目录中注册模块时使用的方法。对于WPF，您可以在代码，XAML，配置文件中注册模块，或在磁盘上的本地目录中发现模块。 确定您的模块通信和依赖策略。模块需要相互通信，您需要处理模块之间的依赖关系。 确定您的依赖注入容器。通常，模块化系统需要依赖注入，控制反转或服务定位器，以允许松散耦合和动态加载和创建模块。Prism允许在使用Unity，MEF或其他容器之间进行选择，并为Unity或基于MEF的应用程序提供库。 最小化应用程序启动时间。考虑模块的按需和后台下载，以最大限度地减少应用程序启动时间。 确定部署要求。您需要考虑如何部署应用程序。 下一节提供了有关这些决策的详细信息。 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:4","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"将您的应用程序划分为模块\r当您以模块化方式开发应用程序时，可以将应用程序组织到单独的客户端模块中，这些模块可以单独开发，测试和部署。每个模块都将封装应用程序的一部分整体功能。您必须做出的首要设计决策之一是决定如何将应用程序的功能划分为离散模块。 模块应该封装一组相关的问题，并具有一组独特的职责。模块可以表示应用程序的垂直切片或水平服务层。大型应用程序可能有两种类型的模块。 围绕垂直切片组织模块的应用程序 围绕水平层组织模块的应用程序 较大的应用程序可能具有使用垂直切片和水平层组织的模块。模块的一些示例包括以下内容： 包含特定应用程序功能的模块，例如Stock Trader参考实现中的新闻模块（Stock Trader RI） 包含特定子系统或功能的模块，用于一组相关用例，例如采购，发票或总帐 包含基础结构服务的模块，例如日志记录，缓存和授权服务，或Web服务 除了其他内部系统之外，包含调用业务线（LOB）系统（如Siebel CRM和SAP）的服务的模块 模块应该对其他模块具有最小的依赖关系。当模块依赖于另一个模块时，它应该通过使用共享库中定义的接口而不是具体类型来松散耦合，或者通过使用EventAggregator通过EventAggregator事件类型与其他模块进行通信。 模块化的目标是以一种即使在添加和删除功能和技术时仍保持灵活性，可维护性和稳定性的方式对应用程序进行分区。实现此目的的最佳方法是设计应用程序，使模块尽可能独立，具有良好定义的接口，并尽可能隔离。 确定项目与模块的比率\r有几种方法可以创建和打包模块。建议的和最常见的方法是为每个模块创建一个组件。这有助于保持逻辑模块分离并促进适当的封装。它还使得更容易将组件作为模块边界以及如何部署模块的包装进行讨论。但是，没有什么可以阻止单个程序集包含多个模块，在某些情况下，这可能是首选，以最大限度地减少解决方案中的项目数量。对于大型应用程序，拥有10-50个模块并不罕见。将每个模块分离到自己的项目中会增加解决方案的复杂性，并会降低Visual Studio的性能。 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:5","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"使用依赖注入来实现松散耦合\r模块可以依赖于主机应用程序或其他模块提供的组件和服务。Prism支持在模块之间注册依赖关系的能力，以便以正确的顺序加载和初始化它们。Prism还支持在将模块加载到应用程序时初始化模块。在模块初始化期间，模块可以检索对其所需的附加组件和服务的引用，和/或注册它包含的任何组件和服务，以使其可供其他模块使用。 模块应使用独立机制来获取外部接口的实例，而不是直接实例化具体类型，例如通过使用依赖注入容器或工厂服务。诸如Unity或MEF之类的依赖注入容器允许类型通过依赖注入自动获取所需的接口和类型的实例。Prism与Unity和MEF集成，允许模块轻松使用依赖注入。 下图显示了加载模块时需要获取或注册组件和服务引用的典型操作顺序。 在此示例中，OrdersModule程序集定义了OrdersRepository类（以及实现顺序功能的其他视图和类）。所述CustomerModule组件限定CustomersViewModel类依赖于OrdersRepository，通常基于由服务暴露的接口上。应用程序启动和引导过程包含以下步骤： 引导程序启动模块初始化过程，模块加载程序加载并初始化OrdersModule。 在OrdersModule的初始化中，它将OrdersRepository注册到容器中。 然后，模块加载器加载CustomersModule。模块加载的顺序可以由模块元数据中的依赖项指定。 该CustomersModule构建的一个实例CustomerViewModel通过容器以解决该问题。该CustomerViewModel对一个依赖OrdersRepository（通常基于它的接口上），并指示它通过构造或财产注射。容器根据OrdersModule注册的类型在视图模型的构造中注入该依赖项。最终结果是从CustomerViewModel到OrderRepository的接口引用，而没有这些类之间的紧密耦合。 注意：用于公开OrderRespository（IOrderRepository）的接口可以驻留在单独的“共享服务”程序集或“订单服务”程序集中*，该程序集仅包含公开这些服务所需的服务接口和类型。这样，CustomersModule和OrdersModule之间就没有硬依赖关系。* 请注意，两个模块都依赖于依赖注入容器。在模块构建器中的模块构造期间注入该依赖性。 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:6","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"核心情景\r本节介绍在应用程序中使用模块时将遇到的常见方案。这些方案包括定义模块，注册和发现模块，加载模块，初始化模块，指定模块依赖关系，按需加载模块，在后台下载远程模块以及检测模块何时已加载。您可以在代码，XAML或应用程序配置文件中注册和发现模块，也可以通过扫描本地目录来注册和发现模块。 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:7","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"定义模块\r模块是功能和资源的逻辑集合，以可以单独开发，测试，部署和集成到应用程序中的方式打包。每个模块都有一个中心类，负责初始化模块并将其功能集成到应用程序中。该类实现了IModule接口，如下所示。 public class MyModule : IModule { public void Initialize() { // Initialize module } } 实现Initialize方法的方式取决于应用程序的要求。模块目录中定义了模块类类型，初始化模式和任何模块依赖性。对于目录中的每个模块，模块加载器创建模块类的实例，然后调用Initialize方法。模块按模块目录中指定的顺序处理。运行时初始化顺序基于模块下载，可用和满足依赖性的时间。 根据应用程序使用的模块目录的类型，可以通过模块类本身的声明性属性或模块目录文件中的模块依赖性来设置模块依赖性。以下部分提供了更多详细信息。 创建模块目录\rprotected override IModuleCatalog CreateModuleCatalog() { return new AggregateModuleCatalog() } 注册和发现模块\r应用程序可以加载的模块在模块目录中定义。Prism Module Loader使用模块目录来确定哪些模块可以加载到应用程序中，何时加载它们以及它们的加载顺序。 模块目录由实现IModuleCatalog接口的类表示。模块目录类由应用程序引导程序类在应用程序初始化期间创建。Prism提供了不同的模块目录实现供您选择。您还可以通过调用AddModule方法或从ModuleCatalog派生来创建具有自定义行为的模块目录，从另一个数据源填充模块目录。 **注意：**通常，Prism中的模块使用依赖注入容器和公共服务定位器来检索模块初始化所需的类型实例。Unity和MEF容器都由Prism支持。虽然注册，发现，下载和初始化模块的整个过程是相同的，但细节可以根据是使用Unity还是MEF而有所不同。本主题将解释方法之间特定于容器的差异。 在代码中注册模块\r最基本的模块目录由ModuleCatalog类提供。您可以使用此模块目录通过指定模块类类型以编程方式注册模块。您还可以以编程方式指定模块名称和初始化模式。要直接使用ModuleCatalog类注册模块，请在应用程序的Bootstrapper类中调用AddModule方法。以下代码中显示了一个示例。 protected override void ConfigureModuleCatalog() { Type moduleCType = typeof(ModuleC); ModuleCatalog.AddModule( new ModuleInfo() { ModuleName = moduleCType.Name, ModuleType = moduleCType.AssemblyQualifiedName, }); } **注意：**如果您的应用程序直接引用模块类型，您可以按类型添加它，如上所示; 否则，您需要提供完全限定的类型名称和程序集的位置。 要查看在代码中定义模块目录的另一个示例，请参阅Stock Trader参考实现（Stock Trader RI）中的StockTraderRIBootstrapper.cs。 注：该引导程序基类提供了CreateModuleCatalog方法来帮助创建的ModuleCatalog。默认情况下，此方法创建ModuleCatalog实例，但可以在派生类中重写此方法，以便创建不同类型的模块目录。 使用XAML文件注册模块\r您可以通过在XAML文件中指定模块目录来以声明方式定义模块目录。XAML文件指定要创建的模块目录类类型以及要添加到哪个模块。通常，.xaml文件作为资源添加到shell项目中。模块目录由引导程序创建，并调用CreateFromXaml方法。从技术角度来看，这种方法非常类似于在代码中定义ModuleCatalog，因为XAML文件只是定义了要实例化的对象的层次结构。 以下代码示例显示了指定模块目录的XAML文件。 \u003c--! ModulesCatalog.xaml --\u003e \u003cModularity:ModuleCatalog xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:sys=\"clr-namespace:System;assembly=mscorlib\" xmlns:Modularity=\"clr-namespace:Microsoft.Practices.Prism.Modularity;assembly=Microsoft.Practices.Prism\"\u003e \u003cModularity:ModuleInfoGroup Ref=\"file://DirectoryModules/ModularityWithMef.Desktop.ModuleB.dll\" InitializationMode=\"WhenAvailable\"\u003e \u003cModularity:ModuleInfo ModuleName=\"ModuleB\" ModuleType=\"ModularityWithMef.Desktop.ModuleB, ModularityWithMef.Desktop.ModuleB, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\" /\u003e \u003c/Modularity:ModuleInfoGroup\u003e \u003cModularity:ModuleInfoGroup InitializationMode=\"OnDemand\"\u003e \u003cModularity:ModuleInfo Ref=\"file://ModularityWithMef.Desktop.ModuleE.dll\" ModuleName=\"ModuleE\" ModuleType=\"ModularityWithMef.Desktop.ModuleE, ModularityWithMef.Desktop.ModuleE, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\" /\u003e \u003cModularity:ModuleInfo Ref=\"file://ModularityWithMef.Desktop.ModuleF.dll\" ModuleName=\"ModuleF\" ModuleType=\"ModularityWithMef.Desktop.ModuleF, ModularityWithMef.Desktop.ModuleF, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\"\u003e \u003cModularity:ModuleInfo.DependsOn\u003e \u003csys:String\u003eModuleE\u003c/sys:String\u003e \u003c/Modularity:ModuleInfo.DependsOn\u003e \u003c/Modularity:ModuleInfo\u003e \u003c/Modularity:ModuleInfoGroup\u003e \u003c!-- Module info without a group --\u003e \u003cModularity:ModuleInfo Ref=\"file://DirectoryModules/ModularityWithMef.Desktop.ModuleD.dll\" ModuleName=\"ModuleD\" ModuleType=\"ModularityWithMef.Desktop.ModuleD, ModularityWithMef.Desktop.ModuleD, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\" /\u003e \u003c/Modularity:ModuleCatalog\u003e 注意： ModuleInfoGroups提供了一种方便的方法来对同一程序集中的模块进行分组，以相同的方式进行初始化，或者只对同一组中的模块具有依赖性。模块之间的依赖关系可以在同一ModuleInfoGroup中的模块中定义; 但是，您无法在不同的ModuleInfoGroups中定义模块之间的依赖关系。将模块放在模块组中是可选的。为组设置的属性将应用于其包含的所有模块。请注意，模块也可以在不在组内的情况下进行注册。 在应用程序的Bootstrapper类中，您需要指定XAML文件是ModuleCatalog的源，如以下代码所示。 protected override IModuleCatalog CreateModuleCatalog() { return ModuleCatalog.CreateFromXaml(new Uri(\"/MyProject;component/ModulesCatalog.xaml\", UriKind.Relative)); } 使用配置文件注册模块\r在WPF中，可以在App.config文件中指定模块信息。此方法的优点是此文件未编译到应用程序中。这使得在运行时添加或删除模块非常容易，无需重新编译应用程序。 以下代码示例显示了指定模块目录的配置文件。如果要自动加载模块，请设置startupLoaded =“true”","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:8","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"加载模块\r填充ModuleCatalog后，可以加载和初始化模块。模块加载意味着模块组件从磁盘传输到内存。该ModuleManager会负责协调加载和初始化过程。 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:9","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"初始化模块\r模块加载后，它们被初始化。这意味着创建了模块类的实例并调用了其Initialize方法。初始化是将模块与应用程序集成的地方。考虑以下模块初始化的可能性： 使用应用程序注册模块的视图。如果您的模块使用视图发现或视图注入参与用户界面（UI）组合，则您的模块将需要将其视图或视图模型与相应的区域名称相关联。这允许视图在应用程序中的菜单，工具栏或其他可视区域上动态显示。 订阅应用程序级别的事件或服务。通常，应用程序会公开您的模块感兴趣的特定于应用程序的服务和/或事件。使用Initialize方法将模块的功能添加到那些应用程序级别的事件和服务。 例如，应用程序可能会在关闭时引发事件，并且您的模块想要对该事件做出反应。您的模块也可能必须向应用程序级服务提供一些数据。例如，如果您已创建MenuService（它负责添加和删除菜单项），则可以在模块的Initialize方法中添加正确的菜单项。 注意：默认情况下，模块实例生存期是短暂的。在加载过程中调用Initialize方法后，将释放对模块实例的引用。如果您没有为模块实例建立强引用链，则会进行垃圾回收。如果您订阅包含对模块的弱引用的事件，则此行为可能会导致调试有问题，因为您的模块在垃圾收集器运行时“消失”。 使用依赖项注入容器注册类型。如果使用依赖注入模式（如Unity或MEF），则模块可以为应用程序或其他模块注册要使用的类型。它还可能要求容器解析所需类型的实例。 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:10","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"指定模块依赖项\r模块可能依赖于其他模块。如果模块A依赖于模块B，则必须在模块A之前初始化模块B. ModuleManager会跟踪这些依赖关系并相应地初始化模块。根据您定义模块目录的方式，您可以在代码，配置或XAML中定义模块依赖性。 在代码中指定依赖项\r对于在代码中注册模块或按目录发现模块的WPF应用程序，Prism提供了在创建模块时使用的声明性属性，如以下代码示例所示。 // (when using Unity) [Module(ModuleName = \"ModuleA\")\\] [ModuleDependency(\"ModuleD\")\\] public class ModuleA: IModule { ... } 在XAML中指定依赖项\r以下XAML显示了模块F依赖于模块E的位置。 \u003c-- ModulesCatalog.xaml --\u003e \u003cModularity:ModuleInfo Ref=\"file://ModularityWithMef.Desktop.ModuleE.dll\" moduleName=\"ModuleE\" moduleType=\"ModularityWithMef.Desktop.ModuleE, ModularityWithMef.Desktop.ModuleE, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\"\u003e \u003cModularity:ModuleInfo Ref=\"file://ModularityWithMef.Desktop.ModuleF.dll\" moduleName=\"ModuleF\" moduleType=\"ModularityWithMef.Desktop.ModuleF, ModularityWithMef.Desktop.ModuleF, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\"\u003e \u003cModularity:ModuleInfo.DependsOn\u003e \u003csys:String\u003eModuleE\u003c/sys:String\u003e \u003c/Modularity:ModuleInfo.DependsOn\u003e \u003c/Modularity:ModuleInfo\u003e . . . 在配置中指定依赖项\r以下示例App.config文件显示了模块F依赖于模块E的位置。 \u003c!-- App.config --\u003e \u003cmodules\u003e \u003cmodule assemblyFile=\"ModularityWithUnity.Desktop.ModuleE.dll\" moduleType=\"ModularityWithUnity.Desktop.ModuleE, ModularityWithUnity.Desktop.ModuleE, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\" moduleName=\"ModuleE\" startupLoaded=\"false\" /\u003e \u003cmodule assemblyFile=\"ModularityWithUnity.Desktop.ModuleF.dll\" moduleType=\"ModularityWithUnity.Desktop.ModuleF, ModularityWithUnity.Desktop.ModuleF, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\" moduleName=\"ModuleF\" startupLoaded=\"false\"\u003e \u003cdependencies\u003e \u003cdependency moduleName=\"ModuleE\" /\u003e \u003c/dependencies\u003e \u003c/module\u003e \u003c/modules\u003e 按需加载模块\r要按需加载模块，您需要指定将它们加载到模块目录中，并将InitializationMode设置为OnDemand。执行此操作后，您需要在应用程序中编写请求加载模块的代码。 在代码中指定按需加载\r使用属性将模块指定为按需，如以下代码示例所示。 // Boostrapper.cs protected override void ConfigureModuleCatalog() { . . . Type moduleCType = typeof(ModuleC); this.ModuleCatalog.AddModule(new ModuleInfo() { ModuleName = moduleCType.Name, ModuleType = moduleCType.AssemblyQualifiedName, InitializationMode = InitializationMode.OnDemand }); . . . } 在XAML中指定按需加载\r在XAML中定义模块目录时，可以指定InitializationMode.OnDemand，如以下代码示例所示。 \u003c!-- ModulesCatalog.xaml --\u003e ... \u003cmodule assemblyFile=\"ModularityWithUnity.Desktop.ModuleE.dll\" moduleType=\"ModularityWithUnity.Desktop.ModuleE, ModularityWithUnity.Desktop.ModuleE, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\" moduleName=\"ModuleE\" startupLoaded=\"false\" /\u003e ... 在配置中指定按需加载\r在App.config文件中定义模块目录时，可以指定InitializationMode.OnDemand，如以下代码示例所示。 \u003c!-- App.config --\u003e \u003cmodule assemblyFile=\"ModularityWithUnity.Desktop.ModuleC.dll\" moduleType=\"ModularityWithUnity.Desktop.ModuleC, ModularityWithUnity.Desktop.ModuleC, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\" moduleName=\"ModuleC\" startupLoaded=\"false\" /\u003e 请求按需加载模块\r在按需指定模块后，应用程序可以请求加载模块。想要启动加载的代码需要获取对引导程序向容器注册的IModuleManager服务的引用。 private void OnLoadModuleCClick(object sender, RoutedEventArgs e) { moduleManager.LoadModule(\"ModuleC\"); } ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:11","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"检测模块何时加载\r所述ModuleManager会服务提供了一个用于事件的应用程序的模块负载时来跟踪或无法加载。您可以通过依赖注入IModuleManager接口来获取对此服务的引用。 this.moduleManager.LoadModuleCompleted += this.ModuleManager_LoadModuleCompleted; void ModuleManager_LoadModuleCompleted(object sender, LoadModuleCompletedEventArgs e) { ... } 为了使应用程序和模块保持松散耦合，应用程序应避免使用此事件将模块与应用程序集成。相反，模块的Initialize方法应该处理与应用程序的集成。 该LoadModuleCompletedEventArgs包含IsErrorHandled财产。如果模块无法加载并且应用程序想要阻止ModuleManager记录错误并抛出异常，则可以将此属性设置为true。 ***注意：*加载并初始化模块后，无法卸载模块组件。Prism库不会保存模块实例引用，因此初始化完成后可能会对模块类实例进行垃圾回收。 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:12","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"MEF中的模块\r如果您选择使用MEF作为依赖注入容器，本节仅突出显示差异。 注意：使用MEF时，MefBootstrapper使用MefModuleManager。它扩展了ModuleManager并实现了IPartImportsSatisfiedNotification接口，以确保在MEF导入新类型时更新ModuleCatalog*。* 使用MEF在代码中注册模块\r使用MEF时，可以将ModuleExport属性应用于模块类，以使MEF自动发现类型。以下是一个例子。 [ModuleExport(typeof(ModuleB), InitializationMode = InitializationMode.OnDemand)] public class ModuleB : IModule { ... } 您还可以使用MEF来发现和加载模块，使用AssemblyCatalog类（可用于发现程序集中的所有导出的模块类）和AggregateCatalog类（允许将多个目录组合到一个逻辑目录中）。默认情况下，Prism MefBootstrapper类创建一个AggregateCatalog实例。然后，您可以覆盖ConfigureAggregateCatalog方法以注册程序集，如以下代码示例所示。 protected override void ConfigureAggregateCatalog() { base.ConfigureAggregateCatalog(); //Module A is referenced in in the project and directly in code. this.AggregateCatalog.Catalogs.Add(new AssemblyCatalog(typeof(ModuleA).Assembly)); this.AggregateCatalog.Catalogs.Add(new AssemblyCatalog(typeof(ModuleC).Assembly)); . . . } Prism MefModuleManager实现使MEF AggregateCatalog和Prism ModuleCatalog保持同步，从而允许Prism发现通过ModuleCatalog或AggregateCatalog添加的模块。 注意： MEF 广泛使用Lazy 来防止导出和导入类型的实例化，直到使用Value*属性。* 使用MEF在目录中发现模块\rMEF提供了一个DirectoryCatalog，可用于检查包含模块（以及其他MEF导出类型）的程序集的目录。在这种情况下，您将覆盖ConfigureAggregateCatalog方法以注册该目录。此方法仅适用于WPF。 要使用此方法，首先需要使用ModuleExport属性将模块名称和依赖项应用于模块，如以下代码示例所示。这允许MEF导入模块并允许Prism 更新ModuleCatalog。 protected override void ConfigureAggregateCatalog() { base.ConfigureAggregateCatalog(); . . . DirectoryCatalog catalog = new DirectoryCatalog(\"DirectoryModules\"); this.AggregateCatalog.Catalogs.Add(catalog); } 使用MEF在代码中指定依赖关系\r对于使用MEF的WPF应用程序，请使用ModuleExport属性，如下所示。 // (when using MEF) [ModuleExport(typeof(ModuleA), DependsOnModuleNames = new string[] { \"ModuleD\" })] public class ModuleA : IModule { ... } 因为MEF允许您在运行时发现模块，所以您还可以在运行时发现模块之间的新依赖关系。虽然您可以在ModuleCatalog旁边使用MEF ，但重要的是要记住ModuleCatalog在从XAML或配置加载时（在加载任何模块之前）验证依赖关系链。如果ModuleCatalog中列出了一个模块，然后使用MEF加载，则将使用ModuleCatalog依赖项，并忽略DependsOnModuleNames属性。 使用MEF指定按需加载\r如果使用MEF和ModuleExport属性来指定模块和模块依赖关系，则可以使用InitializationMode属性指定应按需加载模块，如此处所示。 [ModuleExport(typeof(ModuleC), InitializationMode = InitializationMode.OnDemand)] public class ModuleC : IModule { } ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:13","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 Managing Dependencies Between Components Using the Prism Library for WPF 基于Prism库的应用程序是复合应用程序，可能包含许多松散耦合的类型和服务。他们需要进行交互以提供内容并根据用户操作接收通知。因为它们是松散耦合的，所以它们需要一种相互交互和通信的方式来提供所需的业务功能。为了将这些不同的部分组合在一起，基于Prism库的应用依赖于依赖注入容器。 依赖注入容器通过提供实例化类实例的工具并根据容器的配置管理其生命周期来减少对象之间的依赖关系。在对象创建期间，容器会将对象所需的所有依赖项注入其中。如果尚未创建这些依赖项，则容器首先创建并解析它们的依赖项。在某些情况下，容器本身被解析为依赖项。例如，当使用Unity应用程序块（Unity）作为容器时，模块会注入容器，因此可以使用该容器注册其视图和服务。 使用容器有几个好处： 容器不需要组件来定位其依赖项或管理它们的生命周期。 容器允许交换已实现的依赖项而不影响组件。 容器通过允许模拟依赖项来促进可测试性。 容器通过允许将新组件轻松添加到系统中来提高可维护性。 在基于Prism库的应用程序的上下文中，容器具有特定的优点： 容器在加载时将模块依赖项注入模块。 容器用于注册和解析视图模型和视图。 容器可以创建视图模型并注入视图。 容器注入组合服务，例如区域管理器和事件聚合器。 容器用于注册特定于模块的服务，这些服务是具有模块特定功能的服务。 注意： Prism指南中的某些示例依赖Unity应用程序块（Unity）作为容器。其他代码示例（例如Modularity QuickStarts）使用Managed Extensibility Framework（MEF）。Prism库本身不是特定于容器的，您可以将其服务和模式与其他容器一起使用，例如Castle Windsor，StructureMap和Spring.NET。 ","date":"2019-06-28","objectID":"/2019/06/prism7-unitycontainer/:0:0","tags":["Prism","UnityContainer"],"title":"Prism UnityContainer","uri":"/2019/06/prism7-unitycontainer/"},{"categories":"Prism","content":"关键决策：选择依赖注入容器\rPrism Library为依赖注入容器提供了两个选项：Unity或MEF。棱镜是可扩展的，从而允许使用其他容器而不需要一点工作。Unity和MEF都为依赖注入提供了相同的基本功能，即使它们的工作方式非常不同。两个容器提供的一些功能包括： 它们都使用容器注册类型。 他们都用容器注册实例。 它们都强制创建已注册类型的实例。 它们都将注册类型的实例注入到构造函数中。 它们都将已注册类型的实例注入属性。 它们都具有用于标记需要管理的类型和依赖项的声明性属性。 它们都解决了对象图中的依赖关系。 Unity提供了MEF不具备的几种功能： 它解决了没有注册的具体类型。 它解决了开放的泛型。 它使用拦截来捕获对象的调用并向目标对象添加其他功能。 MEF提供了Unity不具备的几种功能： 它发现目录中的程序集。 它使用XAP文件下载和程序集发现。 它会在发现新类型时重新组合属性和集合。 它会自动导出派生类型。 它与.NET Framework一起部署。 容器具有不同的功能和不同的工作方式，但Prism库将与容器一起使用并提供类似的功能。在考虑使用哪个容器时，请记住前面的功能并确定哪种容量更适合您的方案。 ","date":"2019-06-28","objectID":"/2019/06/prism7-unitycontainer/:0:1","tags":["Prism","UnityContainer"],"title":"Prism UnityContainer","uri":"/2019/06/prism7-unitycontainer/"},{"categories":"Prism","content":"使用容器的注意事项\r在使用容器之前，您应该考虑以下事项： 考虑使用容器注册和解析组件是否合适： 考虑在您的方案中是否可以接受向容器注册和从中解析实例的性能影响。例如，如果需要创建10,000个多边形以在渲染方法的局部范围内绘制曲面，则通过容器解析所有这些多边形实例的成本可能会产生显着的性能成本，因为容器使用反射来创建每个实体。 如果存在许多或深度依赖性，则创建成本会显着增加。 如果组件没有任何依赖关系或者不是其他类型的依赖关系，那么将它放在容器中可能没有意义。 如果组件具有一组与该类型不可分割的依赖关系并且永远不会更改，则将其放入容器中可能没有意义。 考虑组件的生命周期是否应该注册为单例或实例： 如果组件是充当单个资源（例如日志记录服务）的资源管理器的全局服务，则可能需要将其注册为单例。 如果组件为多个使用者提供共享状态，您可能希望将其注册为单例。 如果正在注入的对象需要在每次依赖对象需要时注入一个新实例，请将其注册为非单例。例如，每个视图可能需要一个视图模型的新实例。 考虑是否要通过代码或配置配置容器： 如果要集中管理所有不同的服务，请通过配置配置容器。 如果要有条件地注册特定服务，请通过代码配置容器。 如果您有模块级服务，请考虑通过代码配置容器，以便仅在加载模块时注册这些服务。 **注意：**某些容器（如MEF）无法通过配置文件进行配置，必须通过代码进行配置。 ","date":"2019-06-28","objectID":"/2019/06/prism7-unitycontainer/:0:2","tags":["Prism","UnityContainer"],"title":"Prism UnityContainer","uri":"/2019/06/prism7-unitycontainer/"},{"categories":"Prism","content":"核心情景\r容器用于两个主要目的，即注册和解析。 注册\r在将依赖项注入对象之前，需要向容器注册依赖项的类型。注册类型通常涉及向容器传递接口和实现该接口的具体类型。注册类型和对象主要有两种方法：通过代码或通过配置。具体方式因容器而异。 通常，有两种方法可以通过代码在容器中注册类型和对象： 您可以使用容器注册类型或映射。在适当的时候，容器将构建您指定的类型的实例。 您可以将容器中的现有对象实例注册为单例。容器将返回对现有对象的引用。 使用Unity容器注册类型\r在初始化期间，类型可以注册其他类型，例如视图和服务。注册允许通过容器提供其依赖项，并允许从其他类型访问它们。要做到这一点，类型将需要将容器注入模块构造函数。以下代码显示了命令QuickStart中的OrderModule类型如何注册类型。 // OrderModule.cs public class OrderModule : IModule { public void Initialize() { this.container.RegisterType\u003cIOrdersRepository, OrdersRepository\u003e(new ContainerControlledLifetimeManager()); ... } ... } 根据您使用的容器，也可以通过配置在代码外部执行注册。有关此示例，请参阅。 **注意：**与配置相比，在代码中注册的优点是只有在模块加载时才会进行注册。 使用MEF注册类型\rMEF使用基于属性的系统来向容器注册类型。因此，向容器添加类型注册很简单：它需要在类型中添加**[Export]**属性，如下面的代码示例所示。 [Export(typeof(ILoggerFacade))] public class CallbackLogger: ILoggerFacade { } 使用MEF时的另一个选择是创建类的实例并使用容器注册该特定实例。带有MEF QuickStart的Modularity中的QuickStartBootstrapper在ConfigureContainer方法中显示了一个示例，如下所示。 protected override void ConfigureContainer() { base.ConfigureContainer(); // Because we created the CallbackLogger and it needs to // be used immediately, we compose it to satisfy any imports it has. this.Container.ComposeExportedValue\u003cCallbackLogger\u003e(this.callbackLogger); } **注意：**使用MEF作为容器时，建议您使用属性来注册类型。 ","date":"2019-06-28","objectID":"/2019/06/prism7-unitycontainer/:0:3","tags":["Prism","UnityContainer"],"title":"Prism UnityContainer","uri":"/2019/06/prism7-unitycontainer/"},{"categories":"Prism","content":"Resolving\r注册类型后，可以将其解析或注入为依赖项。在解析类型并且容器需要创建新实例时，它会将依赖项注入这些实例。 通常，在解析类型时，会发生以下三种情况之一： 如果尚未注册该类型，则容器会引发异常。 **注意：**某些容器（包括Unity）允许您解析尚未注册的具体类型。 如果类型已注册为单例，则容器将返回单例实例。如果这是第一次调用该类型，则容器会创建它并保留它以供将来调用。 如果类型尚未注册为单例，则容器将返回新实例。 **注意：**默认情况下，使用MEF注册的类型是单例，容器包含对象的引用。在Unity中，默认情况下会返回新的对象实例，并且容器不会维护对该对象的引用。 ","date":"2019-06-28","objectID":"/2019/06/prism7-unitycontainer/:0:4","tags":["Prism","UnityContainer"],"title":"Prism UnityContainer","uri":"/2019/06/prism7-unitycontainer/"},{"categories":"Prism","content":"使用Unity解析实例\r命令快速入门中的以下代码示例显示了从容器中解析OrdersEditorView和OrdersToolBar视图的位置，以将它们与相应的区域相关联。 // OrderModule.cs public class OrderModule : IModule { public void Initialize() { this.container.RegisterType\u003cIOrdersRepository, OrdersRepository\u003e(new ContainerControlledLifetimeManager()); // Show the Orders Editor view in the shell's main region. this.regionManager.RegisterViewWithRegion(\"MainRegion\", () =\u003e this.container.Resolve\u003cOrdersEditorView\u003e()); // Show the Orders Toolbar view in the shell's toolbar region. this.regionManager.RegisterViewWithRegion(\"GlobalCommandsRegion\", () =\u003e this.container.Resolve\u003cOrdersToolBar\u003e()); } ... } 该OrdersEditorViewModel构造包含以下依赖（订单仓库和订单命令代理），当其解决注入。 // OrdersEditorViewModel.cs public OrdersEditorViewModel(IOrdersRepository ordersRepository, OrdersCommandProxy commandProxy) { this.ordersRepository = ordersRepository; this.commandProxy = commandProxy; // Create dummy order data. this.PopulateOrders(); // Initialize a CollectionView for the underlying Orders collection. this.Orders = new ListCollectionView( _orders ); // Track the current selection. this.Orders.CurrentChanged += SelectedOrderChanged; this.Orders.MoveCurrentTo(null); } 除了前面代码中显示的构造函数注入之外，Unity还允许注入属性。应用**[Dependency]**属性的任何属性将在解析对象时自动解析并注入。 ","date":"2019-06-28","objectID":"/2019/06/prism7-unitycontainer/:0:5","tags":["Prism","UnityContainer"],"title":"Prism UnityContainer","uri":"/2019/06/prism7-unitycontainer/"},{"categories":"Prism","content":"使用MEF解析实例\r以下代码示例显示了使用MEF QuickStart的Modularity中的Bootstrapper如何获取shell的实例。代码可以请求接口的实例，而不是请求具体类型。 protected override DependencyObject CreateShell() { return this.Container.GetExportedValue\u003cShell\u003e(); } 在MEF解析的任何类中，您也可以使用构造函数注入，如下面的模块化与MEF QuickStart中的ModuleA中的代码示例所示，其中注入了ILoggerFacade和IModuleTracker。 [ImportingConstructor] public ModuleA(ILoggerFacade logger, IModuleTracker moduleTracker) { if (logger == null) { throw new ArgumentNullException(\"logger\"); } if (moduleTracker == null) { throw new ArgumentNullException(\"moduleTracker\"); } this.logger = logger; this.moduleTracker = moduleTracker; this.moduleTracker.RecordModuleConstructed(WellKnownModuleNames.ModuleA); } 另一种选择是使用属性注入，如Modularity with MEF QuickStart 中的ModuleTracker类所示，其中注入了ILoggerFacade的实例。 [Export(typeof(IModuleTracker))] public class ModuleTracker : IModuleTracker { [Import] private ILoggerFacade Logger; } ","date":"2019-06-28","objectID":"/2019/06/prism7-unitycontainer/:0:6","tags":["Prism","UnityContainer"],"title":"Prism UnityContainer","uri":"/2019/06/prism7-unitycontainer/"},{"categories":"Prism","content":"在Prism中使用依赖注入容器和服务\r依赖注入容器（通常称为“容器”）用于满足组件之间的依赖关系; 满足这些依赖性通常涉及注册和解决。Prism Library提供对Unity容器和MEF的支持，但它不是特定于容器的。因为库通过IServiceLocator接口访问容器，所以可以替换容器。为此，您的容器必须实现IServiceLocator接口。通常，如果要更换容器，则还需要提供自己的容器特定引导程序。该IServiceLocator接口在Common Service Locator Library中定义。这是一项开源工作，旨在提供IoC（控制反转）容器的抽象，例如依赖注入容器和服务定位器。使用此库的目的是利用IoC和服务位置，而不必与特定实现相关联。 Prism库提供UnityServiceLocatorAdapter和MefServiceLocatorAdapter。两个适配器都通过扩展ServiceLocatorImplBase类型来实现ISeviceLocator接口。下图显示了类层次结构。 虽然Prism Library不引用或依赖于特定容器，但应用程序通常依赖于特定容器。这意味着特定应用程序引用容器是合理的，但Prism Library不直接引用容器。例如，Stock Trader RI和Prism附带的几个QuickStart依赖Unity作为容器。其他样品和快速入门依赖于MEF。 ","date":"2019-06-28","objectID":"/2019/06/prism7-unitycontainer/:0:7","tags":["Prism","UnityContainer"],"title":"Prism UnityContainer","uri":"/2019/06/prism7-unitycontainer/"},{"categories":"Prism","content":"IServiceLocator\r以下代码显示了IServiceLocator接口。 public interface IServiceLocator : IServiceProvider { object GetInstance(Type serviceType); object GetInstance(Type serviceType, string key); IEnumerable\u003cobject\u003e GetAllInstances(Type serviceType); TService GetInstance\u003cTService\u003e(); TService GetInstance\u003cTService\u003e(string key); IEnumerable\u003cTService\u003e GetAllInstances\u003cTService\u003e(); } 服务定位器在Prism库中扩展，扩展方法如下面的代码所示。您可以看到IServiceLocator仅用于解析，这意味着它用于获取实例; 它不用于注册。 // ServiceLocatorExtensions public static class ServiceLocatorExtensions { public static object TryResolve(this IServiceLocator locator, Type type) { try { return locator.GetInstance(type); } catch (ActivationException) { return null; } } public static T TryResolve\u003cT\u003e(this IServiceLocator locator) where T: class { return locator.TryResolve(typeof(T)) as T; } } Unity容器不支持的TryResolve扩展方法 - 如果已注册，则返回要解析的类型的实例; 否则，它返回null。 所述ModuleInitializer使用IServiceLocator为加载模块期间解析模块，作为显示在下面的代码示例。 // ModuleInitializer.cs - Initialize() IModule moduleInstance = null; try { moduleInstance = this.CreateModule(moduleInfo); moduleInstance.Initialize(); } ... // ModuleInitializer.cs - CreateModule() protected virtual IModule CreateModule(string typeName) { Type moduleType = Type.GetType(typeName); if (moduleType == null) { throw new ModuleInitializeException(string.Format(CultureInfo.CurrentCulture, Properties.Resources.FailedToGetType, typeName)); } return (IModule)this.serviceLocator.GetInstance(moduleType); } ","date":"2019-06-28","objectID":"/2019/06/prism7-unitycontainer/:0:8","tags":["Prism","UnityContainer"],"title":"Prism UnityContainer","uri":"/2019/06/prism7-unitycontainer/"},{"categories":"Prism","content":"使用IServiceLocator的注意事项\rIServiceLocator并不是通用容器。容器具有不同的使用语义，这通常决定了为什么选择容器。考虑到这一点，Stock Trader RI直接使用依赖注入容器而不是使用IServiceLocator。这是您的应用程序开发的推荐方法。 在以下情况下，您可能适合使用IServiceLocator： 您是一家独立软件供应商（ISV），负责设计需要支持多个容器的第三方服务。 您正在设计一个服务，以便在使用多个容器的组织中使用。 ","date":"2019-06-28","objectID":"/2019/06/prism7-unitycontainer/:0:9","tags":["Prism","UnityContainer"],"title":"Prism UnityContainer","uri":"/2019/06/prism7-unitycontainer/"},{"categories":"Prism","content":"使用Prism\r注意：该版本为Prism6,最新版已有较大改动。 使用Prism Library开发复合应用程序时所需的常见活动。 此示例，描述了创建由定义单个视图的单个模块组成的基本Prism应用程序所需的步骤。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:1:0","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"定义Shell\r应用程序shell提供应用程序的基本布局。此布局使用模块可用于放置视图的区域定义。Views和shells可以使用区域来定义可添加内容的可发现区域，如下图所示。Shells通常设置整个应用程序的外观，并包含整个应用程序中使用的样式。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:1:1","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"创建Bootstrapper\r引导程序是连接应用程序与Prism Library服务和Unity或MEF容器的粘合剂。每个应用程序都会创建一个特定于应用程序的引导程序，它通常从UnityBootstrapper或MefBootstrapper继承，如下图所示。您需要确定要用于填充模块目录的方法。最低限度，每个应用程序将提供模块目录和shell。 默认情况下，引导程序使用.NET Framework Trace类记录事件。大多数应用程序都希望提供自己的日志记录服务，例如Enterprise Library日志记录。应用程序可以在其引导程序中提供其日志记录服务。 默认情况下，UnityBootstrapper和MefBootstrapper启用Prism Library服务。可以在特定于应用程序的引导程序中禁用或替换它们。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:1:2","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"创建Module\r该模块包含特定于应用程序功能的视图和服务。通常，这些包含在单独的程序集中，由不同的团队开发。模块由实现IModule接口的类表示。这些模块在初始化期间注册其视图和服务，并可能向shell添加一个或多个视图。根据您的模块发现方法，您可能需要将属性应用于模块类或定义模块之间的依赖关系。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:1:3","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"将Module View添加到Shell\r模块利用shell的区域来放置内容。在初始化期间，模块使用RegionManager定位shell中的区域，并向这些区域添加一个或多个视图，或者注册要在这些区域内创建的一个或多个视图类型。该RegionManager是负责跟踪区域的整个应用程序，是从引导程序初始化的核心服务。 文档中的其余主题提供了有关Prism关键概念的详细信息。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:1:4","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"使用Prism库为WPF初始化应用程序\r本主题介绍了为WPF应用程序启动和运行Prism所需要做的事情。Prism应用程序需要在应用程序启动过程中进行注册和配置 - 这称为Bootstrapper应用程序。Prism Bootstrapper过程包括创建和配置模块目录，创建依赖注入容器（如Unity），为UI组合配置默认区域适配器，创建和初始化shell视图以及初始化模块。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:2:0","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"Bootstrapper\r引导程序是一个类，负责初始化使用Prism库构建的应用程序。通过使用引导程序，您可以更好地控制Prism库组件如何连接到您的应用程序。 Prism库包含一个默认的抽象Bootstrapper基类，可以专门用于任何容器。Bootstrapper类中的许多方法都是虚方法。您可以在自己的自定义引导程序实现中适当地覆盖这些方法。 Prism库提供了一些派生自Bootstrapper的附加基类，这些基类具有适用于大多数应用程序的默认实现。应用程序引导程序实现的唯一阶段是创建和初始化shell。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:2:1","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"Dependency Injection\r使用Prism Library构建的应用程序依赖于容器提供的依赖注入。该库提供了与Unity应用程序块（Unity）或托管扩展性框架（MEF）一起使用的程序集，它允许您使用其他依赖项注入容器。引导过程的一部分是配置此容器并使用容器注册类型。 Prism库包括UnityBootstrapper和MefBootstrapper类，它们实现了在应用程序中使用Unity或MEF作为依赖注入容器所需的大部分功能。除了上图中显示的阶段之外，每个引导程序还添加了一些特定于其容器的步骤。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:2:2","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"Creating the Shell\r在传统的Windows Presentation Foundation（WPF）应用程序中，启动主窗口的App.xaml文件中指定了启动统一资源标识符（URI）。 在使用Prism Library创建的应用程序中，引导程序负责创建shell或主窗口。这是因为shell依赖于需要在显示shell之前注册的服务（例如Region Manager）。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:2:3","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"关键决定\r在您决定在应用程序中使用Prism库之后，还需要做出一些额外的决定： 您需要决定是否使用MEF，Unity或其他容器作为依赖注入容器。这将确定您应该使用哪个提供的引导程序类，以及是否需要为另一个容器创建引导程序。 您应该考虑应用程序中所需的特定于应用程序的服务。这些将需要在容器中注册。 确定内置日志记录服务是否足以满足您的需求，或者是否需要创建其他日志记录服务。 确定应用程序如何发现模块：通过显式代码声明，通过目录扫描，配置或XAML发现的模块上的代码属性。 本主题的其余部分提供了更多详细信息。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:2:4","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"Core Scenarios\r创建启动序列是构建Prism应用程序的重要部分。本节介绍如何创建引导程序并对其进行自定义以创建shell，配置依赖项注入容器，注册应用程序级服务以及如何加载和初始化模块。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:2:5","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"创建Bootstrapper\r如果您选择使用Unity或MEF作为依赖注入容器，则可以轻松地为您的应用程序创建一个简单的引导程序。您需要创建一个派生自MefBootstrapper或UnityBootstrapper的新类。然后，实现CreateShell方法。（可选）您可以覆盖InitializeShell方法以进行特定于shell的初始化。 实现CreateShell方法\r该CreateShell方法允许开发者指定一个棱镜应用顶层窗口。shell通常是MainWindow或MainPage。通过返回应用程序的shell类的实例来实现此方法。在Prism应用程序中，您可以创建shell对象，或者根据应用程序的要求从容器中解析它。 以下代码示例中显示了使用ServiceLocator解析shell对象的示例。 protected override DependencyObject CreateShell() { return ServiceLocator.Current.GetInstance\u003cShell\u003e(); } 注意：您经常会看到ServiceLocator用于解析类型的实例而不是特定的依赖注入容器。该服务定位是通过调用容器实现的，所以它使容器无关代码一个不错的选择。您也可以直接引用和使用容器而不是ServiceLocator。 实现InitializeShell方法\r创建shell后，可能需要运行初始化步骤以确保准备好显示shell。对于WPF应用程序，您将创建shell应用程序对象并将其设置为应用程序的主窗口，如此处所示（来自WPF的Modularity QuickStarts）。 protected override void InitializeShell() { Application.Current.MainWindow = Shell; Application.Current.MainWindow.Show(); } InitializeShell的基本实现什么都不做。不调用基类实现是安全的。 创建和配置模块目录\rCreating and Configuring the Module Catalog 如果要构建模块应用程序，则需要创建和配置模块目录。Prism使用具体的IModuleCatalog实例来跟踪应用程序可用的模块，可能需要下载的模块以及模块所在的位置。 该引导程序提供了一个受保护的ModuleCatalog属性来引用目录以及一个基实现虚拟的CreateModuleCatalog方法。基础实现返回一个新的ModuleCatalog ; 但是，可以重写此方法以提供不同的IModuleCatalog实例，如下面的代码来自模块化中的QuickStartBootstrapper和MEF for WPF QuickStart。 protected override IModuleCatalog CreateModuleCatalog() { // When using MEF, the existing Prism ModuleCatalog is still // the place to configure modules via configuration files. return new ConfigurationModuleCatalog() } 在UnityBootstrapper和MefBootstrapper类中，Run方法调用CreateModuleCatalog方法，然后使用返回的值设置类的ModuleCatalog属性。如果重写此方法，则无需调用基类的实现，因为您将替换提供的功能。有关模块化的更多信息，请参阅“模块化应用程序开发”。 创建和配置容器\rCreating and Configuring the Container 容器在使用Prism Library创建的应用程序中起着关键作用。Prism Library和构建在它上面的应用程序都依赖于一个容器来注入所需的依赖项和服务。在容器配置阶段，注册了几个核心服务。除了这些核心服务之外，您还可以使用特定于应用程序的服务，这些服务提供与组合相关的其他功能。 核心服务\r下表列出了Prism库中的核心非应用程序特定服务。 服务界面 描述 IModuleManager 定义将检索和初始化应用程序模块的服务的接口。 IModuleCatalog 包含有关应用程序中模块的元数据。Prism Library提供了几种不同的目录。 IModuleInitializer 初始化模块。 IRegionManager 注册和检索区域，这些区域是布局的可视容器。 IEventAggregator 在发布者和订阅者之间松散耦合的事件集合。 ILoggerFacade 日志记录机制的包装器，因此您可以选择自己的日志记录机制。Stock Trader参考实施（Stock Trader RI）通过EnterpriseLibraryLoggerAdapter类使用Enterprise Library Logging Application Block 作为如何使用您自己的记录器的示例。使用CreateLogger方法返回的值，通过引导程序的Run方法向容器注册日志记录服务。向容器注册另一个记录器将不起作用; 而是覆盖引导程序上的CreateLogger方法。 IServiceLocator 允许Prism库访问容器。如果要自定义或扩展库，这可能很有用。 Prism，UnityBootstrapper和MefBootstrapper中有两个Bootstrapper派生类。创建和配置不同的容器涉及以不同方式实现的类似概念。 在UnityBootstrapper中创建和配置容器\rCreating and Configuring the Container in the UnityBootstrapper 该UnityBootstrapper类的CreateContainer方法简单地创建并返回的新实例UnityContainer。在大多数情况下，您无需更改此功能; 但是，该方法是虚拟的，从而允许这种灵活性。 创建容器后，可能需要为您的应用程序配置容器。UnityBootstrapper中的ConfigureContainer实现默认注册了许多核心Prism服务，如下所示。 注意：此示例是模块在其Initialize方法中注册模块级服务的情况。 // UnityBootstrapper.cs protected virtual void ConfigureContainer() { ... if (useDefaultConfiguration) { RegisterTypeIfMissing(typeof(IServiceLocator), typeof(UnityServiceLocatorAdapter), true); RegisterTypeIfMissing(typeof(IModuleInitializer), typeof(ModuleInitializer), true); RegisterTypeIfMissing(typeof(IModuleManager), typeof(ModuleManager), true); RegisterTypeIfMissing(typeof(RegionAdapterMappings), typeof(RegionAdapterMappings), true) RegisterTypeIfMissing(typeof(IRegionManager), typeof(RegionManager), true); RegisterTypeIfMissing(typeof(IEventAggregator), typeof(EventAggregator), true); RegisterTypeIfMissing(typeof(IRegionViewRegistry), typeof(RegionViewRegistry), true); RegisterTypeIfMissing(typeof(IRegionBehaviorFactory), typeof(RegionBehaviorFactory), true); RegisterTypeIfMissing(typeof(IRegionNavigationJournalEntry), typeof(RegionNavigationJournalEntry), false); RegisterTypeIfMissing(typeof(IRegionNavigationJournal), typeof(RegionNavigationJournal), false); RegisterTypeIfMissing(typeof(IRegionNavigationService), typeof(RegionNavigationService), false); RegisterTypeIfMissing(typeof(IRegionNavigationContentLoader), typeof(UnityRegionNavigationContentLoader), true); } } 引导程序的RegisterTypeIfMissing方法确定服务是否已经注册 - 它不会注册两次。这允许您通过配置覆盖默认注册。您也可以默认关闭注册任何服务; 为此，请使用重载的Bootstrapper.R","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:2:6","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 ViewModelLocator用于绑定视图的DataContext，以使用标准命名约定的一个ViewModel的实例。 Prism ViewModelLocator有一个AutoWireViewModel附加属性，当设置为true调用类中的AutoWireViewModelChanged方法ViewModelLocationProvider来解析视图的ViewModel时，然后将视图的数据上下文设置为该ViewModel的实例。 将AutoWireViewModel附加属性添加到每个视图： \u003cWindow x:Class=\"Demo.Views.MainWindow\" ... xmlns:prism=\"http://prismlibrary.com/\" prism:ViewModelLocator.AutoWireViewModel=\"True\"\u003e 要查找ViewModel，ViewModelLocationProvider首先尝试从ViewModelLocationProvider.Register方法注册的任何映射中解析ViewModel （请参阅自定义ViewModel注册）。如果使用此方法无法解析ViewModel，则会ViewModelLocationProvider回退到基于约定的方法来解析正确的ViewModel类型。 该惯例假定： ViewModel与视图类型位于同一个程序集中 ViewModel位于.ViewModels子命名空间中 视图位于.Views子命名空间中 ViewModel名称与视图名称对应，以“ViewModel”结尾。 注意 本ViewModelLocationProvider可以在发现Prism.Mvvm命名空间中的Prism.Core NuGet包。本ViewModelLocator可以在发现Prism.Mvvm命名空间中的Prism.WPF NuGet包。 注意 ViewModelLocator是必需的，并且在使用Xamarin.Forms进行开发时会自动应用于每个View，因为它负责向INavigationServiceViewModel 提供正确的实例。在开发Xamarin.Forms应用程序时，ViewModelLocator只能选择退出。 ","date":"2019-06-26","objectID":"/2019/06/prism5-viewmodellocator/:0:0","tags":["Prism","ViewModelLocator"],"title":"Prism ViewModel Locator","uri":"/2019/06/prism5-viewmodellocator/"},{"categories":"Prism","content":"更改命名约定\r如果您的应用程序不遵循ViewModelLocator默认命名约定，则可以更改约定以满足应用程序的要求。本ViewModelLocationProvider类提供了一个称为静态方法SetDefaultViewTypeToViewModelTypeResolver，可以用来提供自己的约定关联视图查看模型。 要更改ViewModelLocator命名约定，请覆盖类中的ConfigureViewModelLocator方法App.xaml.cs。然后在ViewModelLocationProvider.SetDefaultViewTypeToViewModelTypeResolver方法中提供自定义命名约定逻辑。 protected override void ConfigureViewModelLocator() { base.ConfigureViewModelLocator(); ViewModelLocationProvider.SetDefaultViewTypeToViewModelTypeResolver((viewType) =\u003e { var viewName = viewType.FullName.Replace(\".ViewModels.\", \".CustomNamespace.\");//看视频就明白了 var viewAssemblyName = viewType.GetTypeInfo().Assembly.FullName; var viewModelName = $\"{viewName}ViewModel, {viewAssemblyName}\"; return Type.GetType(viewModelName); }); } ","date":"2019-06-26","objectID":"/2019/06/prism5-viewmodellocator/:0:1","tags":["Prism","ViewModelLocator"],"title":"Prism ViewModel Locator","uri":"/2019/06/prism5-viewmodellocator/"},{"categories":"Prism","content":"自定义ViewModel注册\r可能存在您的应用程序遵循ViewModelLocator默认命名约定的情况，但您有许多不符合约定的ViewModel。您可以ViewModelLocator使用该ViewModelLocationProvider.Register方法直接将ViewModel的映射注册到特定视图，而不是尝试自定义命名约定逻辑以有条件地满足所有命名要求。 以下示例显示了在名为MainWindow的ViewModel和ViewModel 之间创建映射的各种方法CustomViewModel。 类型/类型 ViewModelLocationProvider.Register(typeof(MainWindow).ToString(), typeof(CustomViewModel)); 类型/工厂 ViewModelLocationProvider.Register(typeof(MainWindow).ToString(), () =\u003e Container.Resolve\u003cCustomViewModel\u003e()); 通用工厂 ViewModelLocationProvider.Register\u003cMainWindow\u003e(() =\u003e Container.Resolve\u003cCustomViewModel\u003e()); 通用类型 ViewModelLocationProvider.Register\u003cMainWindow, CustomViewModel\u003e(); 注意\r直接注册ViewModel ViewModelLocator比依赖默认命名约定更快。这是因为命名约定需要使用反射，而自定义映射直接提供类型ViewModelLocator。 重要\r该viewTypeName参数必须是视图的Type（Type.ToString()）的完全限定名称。否则映射将失败。 ","date":"2019-06-26","objectID":"/2019/06/prism5-viewmodellocator/:0:2","tags":["Prism","ViewModelLocator"],"title":"Prism ViewModel Locator","uri":"/2019/06/prism5-viewmodellocator/"},{"categories":"Prism","content":"控制ViewModel的解析方式\r默认情况下，ViewModelLocator将使用您选择的DI容器来创建Prism应用程序以解析ViewModels。但是，如果您需要自定义ViewModel的解析方式或完全更改解析器，则可以使用该ViewModelLocationProvider.SetDefaultViewModelFactory方法实现此目的。 此示例显示如何更改用于解析ViewModel实例的容器。 protected override void ConfigureViewModelLocator() { base.ConfigureViewModelLocator(); ViewModelLocationProvider.SetDefaultViewModelFactory(viewModelType) =\u003e { return MyAwesomeNewContainer.Resolve(viewModelType); }); } 这是一个示例，说明如何检查为其创建ViewModel的视图类型，以及执行逻辑来控制ViewModel的创建方式。 protected override void ConfigureViewModelLocator() { base.ConfigureViewModelLocator(); ViewModelLocationProvider.SetDefaultViewModelFactory((view, viewModelType) =\u003e { switch (view) { case Window window: //your logic break; case UserControl userControl: //your logic break; } return MyAwesomeNewContainer.Resolve(someNewType); }); } ","date":"2019-06-26","objectID":"/2019/06/prism5-viewmodellocator/:0:3","tags":["Prism","ViewModelLocator"],"title":"Prism ViewModel Locator","uri":"/2019/06/prism5-viewmodellocator/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 Prism库提供了一种事件机制，可以在应用程序中松散耦合的组件之间进行通信。该机制基于事件聚合器服务，允许发布者和订阅者通过事件进行通信，但仍然没有彼此直接引用。 在EventAggregator提供多种发布/订阅功能。这意味着可以有多个发布者引发相同的事件，并且可以有多个订阅者收听同一事件。考虑使用EventAggregator跨模块发布事件以及在业务逻辑代码（如控制器和演示者）之间发送消息时。 使用Prism Library创建的事件是键入的事件。这意味着您可以在运行应用程序之前利用编译时类型检查来检测错误。在Prism Library中，EventAggregator允许订阅者或发布者定位特定的EventBase。事件聚合器还允许多个发布者和多个订阅者，如下图所示。 ","date":"2019-06-25","objectID":"/2019/06/prism4-eventaggregator/:0:0","tags":["Prism","EventAggregator"],"title":"Prism Event Aggregator","uri":"/2019/06/prism4-eventaggregator/"},{"categories":"Prism","content":"IEventAggregator\rEventAggregator类被提供作为在容器中的服务，并且可以通过检索IEventAggregator界面。事件聚合器负责定位或构建事件以及保留系统中事件的集合。 public interface IEventAggregator { TEventType GetEvent\u003cTEventType\u003e() where TEventType : EventBase; } 如果EventAggregator事件尚未构造，则在第一次访问时构造事件。这使发布者或订阅者无需确定事件是否可用。 ","date":"2019-06-25","objectID":"/2019/06/prism4-eventaggregator/:0:1","tags":["Prism","EventAggregator"],"title":"Prism Event Aggregator","uri":"/2019/06/prism4-eventaggregator/"},{"categories":"Prism","content":"PubSubEvent\r连接发布者和订阅者的真正工作是由PubSubEvent班级完成的。EventBase是Prism Library中包含的类的唯一实现。此类维护订户列表并处理订阅者的事件调度。 PubSubEvent类是一个通用类，需要将其定义为一般类型的有效载荷类型。这有助于在编译时强制发布者和订阅者提供成功事件连接的正确方法。以下代码显示了PubSubEvent类的部分定义。 ","date":"2019-06-25","objectID":"/2019/06/prism4-eventaggregator/:0:2","tags":["Prism","EventAggregator"],"title":"Prism Event Aggregator","uri":"/2019/06/prism4-eventaggregator/"},{"categories":"Prism","content":"创建一个事件\rPubSubEvent\u003cTPayload\u003e意图是为应用程序或模块的特定事件的基类。TPayLoad是事件的有效负载的类型。有效负载是在事件发布时将传递给订阅者的参数。 例如，以下代码显示了TickerSymbolSelectedEvent。有效负载是包含公司符号的字符串。请注意此类的实现是如何为空。 public class TickerSymbolSelectedEvent : PubSubEvent\u003cstring\u003e{} 注意\r在复合应用程序中，事件经常在多个模块之间共享，因此它们在公共位置定义。通常的做法是在共享程序集中定义这些事件，例如“核心”或“基础结构”项目。 ","date":"2019-06-25","objectID":"/2019/06/prism4-eventaggregator/:0:3","tags":["Prism","EventAggregator"],"title":"Prism Event Aggregator","uri":"/2019/06/prism4-eventaggregator/"},{"categories":"Prism","content":"发布事件\r发布者通过从EventAggregator调用Publish方法中检索事件来引发事件。要访问EventAggregator，可以通过向IEventAggregator类构造函数添加类型参数来使用依赖项注入。 public class MainPageViewModel { IEventAggregator _eventAggregator; public MainPageViewModel(IEventAggregator ea) { _eventAggregator = ea; } } 以下代码演示了如何发布TickerSymbolSelectedEvent。 _eventAggregator.GetEvent\u003cTickerSymbolSelectedEvent\u003e().Publish(\"STOCK0\"); ","date":"2019-06-25","objectID":"/2019/06/prism4-eventaggregator/:0:4","tags":["Prism","EventAggregator"],"title":"Prism Event Aggregator","uri":"/2019/06/prism4-eventaggregator/"},{"categories":"Prism","content":"订阅事件\r订阅者可以使用类中Subscribe可用的方法重载之一来参与事件PubSubEvent。 public class MainPageViewModel { public MainPageViewModel(IEventAggregator ea) { ea.GetEvent\u003cTickerSymbolSelectedEvent\u003e().Subscribe(ShowNews); } void ShowNews(string companySymbol) { //implement logic } } 有几种订阅方式PubSubEvents。使用以下标准来帮助确定最适合您需求的选项： 如果您需要能够在收到事件时更新UI元素，请订阅以在UI线程上接收事件。 如果您需要过滤事件，请在订阅时提供过滤器委托。 如果您对事件有性能问题，请考虑在订阅时使用强引用的委托，然后手动取消订阅PubSubEvent。 如果以上都不适用，请使用默认订阅。 以下部分描述了这些选项。 在UI线程订阅\r订阅者通常需要更新UI元素以响应事件。在WPF中，只有UI线程可以更新UI元素。 默认情况下，订阅者在发布者的线程上接收事件。如果发布者从UI线程发送事件，则订阅者可以更新UI。但是，如果发布者的线程是后台线程，则订阅者可能无法直接更新UI元素。在这种情况下，订户需要使用Dispatcher类在UI线程上安排更新。 该PubSubEvent具有棱镜图书馆可以通过允许用户自动接收UI线程上的事件协助。订阅者在订阅期间指示此信息，如以下代码示例所示。 public class MainPageViewModel { public MainPageViewModel(IEventAggregator ea) { ea.GetEvent\u003cTickerSymbolSelectedEvent\u003e().Subscribe(ShowNews, ThreadOption.UIThread); } void ShowNews(string companySymbol) { //implement logic } } 以下选项适用于ThreadOption： PublisherThread：使用此设置在发布商的主题上接收活动。这是默认设置。 BackgroundThread：使用此设置在.NET Framework线程池线程上异步接收事件。 UIThread：使用此设置在UI线程上接收事件。 注意 为了PubSubEvent在UI线程上发布给订阅者，EventAggregator最初必须在UI线程上构建。 订阅过滤\r订阅者可能不需要处理已发布事件的每个实例。在这些情况下，订户可以使用过滤器参数。filter参数是类型的，System.Predicate\u003cTPayLoad\u003e并且是在发布事件时执行的委托，以确定已发布事件的有效负载是否与调用订阅者回调所需的一组条件匹配。如果有效负载不满足指定的条件，则不执行订户回调。 通常，此过滤器作为lambda表达式提供，如以下代码示例所示。 public class MainPageViewModel { public MainPageViewModel(IEventAggregator ea) { TickerSymbolSelectedEvent tickerEvent = ea.GetEvent\u003cTickerSymbolSelectedEvent\u003e(); tickerEvent.Subscribe(ShowNews, ThreadOption.UIThread, false, companySymbol =\u003e companySymbol == \"STOCK0\"); } void ShowNews(string companySymbol) { //implement logic } } 注意\r该Subscribe方法返回一个类型的订阅令牌Prism.Events.SubscriptionToken，可用于稍后删除对该事件的订阅。当您使用匿名委托或lambda表达式作为回调委托时，或者使用不同的过滤器订阅相同的事件处理程序时，此标记特别有用。 注意\r建议不要在回调委托中修改有效负载对象，因为多个线程可能同时访问有效负载对象。您可以使有效负载不可变，以避免并发错误。 使用强引用订阅\r如果您在短时间内提出多个事件并注意到它们的性能问题，则可能需要使用强委托引用进行订阅。如果您这样做，则需要在处置订户时手动取消订阅该事件。 默认情况下，PubSubEvent维护对订阅者处理程序的弱委托引用并对订阅进行过滤。这意味着PubSubEvent保留的引用不会阻止订户的垃圾收集。使用弱委托引用可以使订户免于取消订阅并允许正确的垃圾收集。 但是，维护此弱委托引用比相应的强引用要慢。对于大多数应用程序，此性能不会很明显，但如果您的应用程序在短时间内发布大量事件，则可能需要对PubSubEvent使用强引用。如果您确实使用了强委托引用，则订阅者应该取消订阅，以便在不再使用订阅对象时启用正确的垃圾回收。 要使用强引用进行订阅，请使用方法keepSubscriberReferenceAlive上的参数Subscribe，如以下代码示例所示。 public class MainPageViewModel { public MainPageViewModel(IEventAggregator ea) { bool keepSubscriberReferenceAlive = true; TickerSymbolSelectedEvent tickerEvent = ea.GetEvent\u003cTickerSymbolSelectedEvent\u003e(); tickerEvent.Subscribe(ShowNews, ThreadOption.UIThread, keepSubscriberReferenceAlive, companySymbol =\u003e companySymbol == \"STOCK0\"); } void ShowNews(string companySymbol) { //implement logic } } keepSubscriberReferenceAlive参数的类型的bool： 设置为时true，事件实例保留对订户实例的强引用，从而不允许它收集垃圾。有关如何取消订阅的信息，请参阅本主题后面的“取消订阅事件”一节。 当设置为false（省略此参数时的默认值）时，事件维护对订户实例的弱引用，从而允许垃圾收集器在没有其他引用时配置订阅者实例。收集订户实例后，将自动取消订阅该事件。 ","date":"2019-06-25","objectID":"/2019/06/prism4-eventaggregator/:0:5","tags":["Prism","EventAggregator"],"title":"Prism Event Aggregator","uri":"/2019/06/prism4-eventaggregator/"},{"categories":"Prism","content":"取消事件订阅\r如果您的订户不再想要接收活动，您可以使用订阅者的处理程序取消订阅，也可以使用订阅令牌取消订阅。 以下代码示例演示如何直接取消订阅处理程序。 public class MainPageViewModel { TickerSymbolSelectedEvent _event; public MainPageViewModel(IEventAggregator ea) { _event = ea.GetEvent\u003cTickerSymbolSelectedEvent\u003e(); _event.Subscribe(ShowNews); } void Unsubscribe() { _event.Unsubscribe(ShowNews); } void ShowNews(string companySymbol) { //implement logic } } 以下代码示例演示如何取消订阅订阅令牌。令牌作为方法的返回值提供Subscribe。 public class MainPageViewModel { TickerSymbolSelectedEvent _event; SubscriptionToken _token; public MainPageViewModel(IEventAggregator ea) { _event = ea.GetEvent\u003cTickerSymbolSelectedEvent\u003e(); _token = _event.Subscribe(ShowNews); } void Unsubscribe() { _event.Unsubscribe(_token); } void ShowNews(string companySymbol) { //implement logic } } ","date":"2019-06-25","objectID":"/2019/06/prism4-eventaggregator/:0:6","tags":["Prism","EventAggregator"],"title":"Prism Event Aggregator","uri":"/2019/06/prism4-eventaggregator/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 在许多情况下，视图模型定义的命令将绑定到关联视图中的控件，以便用户可以直接从视图中调用该命令。但是，在某些情况下，您可能希望能够从应用程序UI的父视图中的控件调用一个或多个视图模型上的命令。 例如，如果您的应用程序允许用户同时编辑多个项目，您可能希望允许用户使用应用程序工具栏或功能区中的按钮所代表的单个命令来保存所有项目。在这种情况下，Save All命令将调用每个项目的视图模型实例实现的每个Save命令，如下图所示。 Prism通过CompositeCommand课程支持这种情况。 CompositeCommand类表示从多个子指令构成的指令。调用复合命令时，将依次调用其每个子命令。在需要在UI中将一组命令表示为单个命令或者要调用多个命令来实现逻辑命令的情况下，它非常有用。 本CompositeCommand类维护子类命令列表 （DelegateCommand实例）。CompositeCommand类的Execute方法依次调用每个子类的Execute命令方法。CanExecute方法类似地调用每个子命令的CanExecute方法，但是如果无法执行任何子命令，则该CanExecute方法将返回false。换句话说，默认情况下，CompositeCommand只有在可以执行所有子命令时才能执行。 ","date":"2019-06-24","objectID":"/2019/06/prism3-compositecommands/:0:0","tags":["Prism","compositecommands"],"title":"Prism Composite Commands","uri":"/2019/06/prism3-compositecommands/"},{"categories":"Prism","content":"创建Composite Commands\r要创建复合命令，请实例化一个CompositeCommand实例，然后将其公开为ICommand或ComponsiteCommand属性。 public class ApplicationCommands { private CompositeCommand _saveCommand = new CompositeCommand(); public CompositeCommand SaveCommand { get { return _saveCommand; } } } ","date":"2019-06-24","objectID":"/2019/06/prism3-compositecommands/:0:1","tags":["Prism","compositecommands"],"title":"Prism Composite Commands","uri":"/2019/06/prism3-compositecommands/"},{"categories":"Prism","content":"使得Composite Commands全局可用\r通常，CompositeCommands在整个应用程序中共享，需要全局可用。当您CompositeCommand在整个应用程序中使用同一个CompositeCommand实例注册子命令时，这一点很重要。这需要在应用程序中将CompositeCommand作为单例取消。这可以通过使用依赖注入（DI）或将CompositeCommand定义为静态类来完成。 使用依赖注入\r定义CompositeCommands的第一步是创建一个接口。 public interface IApplicationCommands { CompositeCommand SaveCommand { get; } } 接下来，创建一个实现该接口的类。 public class ApplicationCommands : IApplicationCommands { private CompositeCommand _saveCommand = new CompositeCommand(); public CompositeCommand SaveCommand { get { return _saveCommand; } } } 定义ApplicationCommands类后，必须将其注册为容器的单例。 public partial class App : PrismApplication { protected override void RegisterTypes(IContainerRegistry containerRegistry) { containerRegistry.RegisterSingleton\u003cIApplicationCommands, ApplicationCommands\u003e(); } } 接下来，请求IApplicationCommandsViewModel构造函数中的接口。一旦有了ApplicationCommands该类的实例，现在可以使用适当的CompositeCommand注册DelegateCommands。 public DelegateCommand UpdateCommand { get; private set; } public TabViewModel(IApplicationCommands applicationCommands) { UpdateCommand = new DelegateCommand(Update); applicationCommands.SaveCommand.RegisterCommand(UpdateCommand); } 使用静态类\r创建一个代表CompositeCommands的静态类 public static class ApplicationCommands { public static CompositeCommand SaveCommand = new CompositeCommand(); } 在ViewModel中，将子命令与静态ApplicationCommands类关联。 public DelegateCommand UpdateCommand { get; private set; } public TabViewModel() { UpdateCommand = new DelegateCommand(Update); ApplicationCommands.SaveCommand.RegisterCommand(UpdateCommand); } 注意 为了提高代码的可维护性和可测试性，建议您使用可靠性注入方法。 ","date":"2019-06-24","objectID":"/2019/06/prism3-compositecommands/:0:2","tags":["Prism","compositecommands"],"title":"Prism Composite Commands","uri":"/2019/06/prism3-compositecommands/"},{"categories":"Prism","content":"绑定全局可用命令\r一旦创建了CompositeCommands，就必须将它们绑定到UI元素以调用命令。 使用依赖注入 (Dependency Injection)\r使用DI时，必须将IApplicationCommands暴露给View。在视图的ViewModel中，请IApplicationCommands在构造函数中请求并IApplicationCommands为该实例设置type属性。 public class MainWindowViewModel : BindableBase { private IApplicationCommands _applicationCommands; public IApplicationCommands ApplicationCommands { get { return _applicationCommands; } set { SetProperty(ref _applicationCommands, value); } } public MainWindowViewModel(IApplicationCommands applicationCommands) { ApplicationCommands = applicationCommands; } } 在视图中，将按钮绑定到ApplicationCommands.SaveCommand属性。这SaveCommand是在ApplicationCommands类上定义的属性。 \u003cButton Content=\"Save\" Command=\"{Binding ApplicationCommands.SaveCommand}\"/\u003e 使用静态类\r如果您使用的是静态类方法，则以下代码示例演示如何将按钮绑定到WPF中的静态ApplicationCommands类。 \u003cButton Content=\"Save\" Command=\"{x:Static local:ApplicationCommands.SaveCommand}\" /\u003e ","date":"2019-06-24","objectID":"/2019/06/prism3-compositecommands/:0:3","tags":["Prism","compositecommands"],"title":"Prism Composite Commands","uri":"/2019/06/prism3-compositecommands/"},{"categories":"Prism","content":"取消注册命令\r如前面的示例所示，使用该CompositeCommand.RegisterCommand方法注册子命令。但是，当您不再希望响应CompositeCommand或者您要销毁View / ViewModel以进行垃圾回收时，您应该使用该CompositeCommand.UnregisterCommand方法取消注册子命令。 public void Destroy() { _applicationCommands.UnregisterCommand(UpdateCommand); } 重要\r您必须从CompositeCommand不再需要View / ViewModel（为GC准备好）时取消注册您的命令。否则你会引入内存泄漏。 ","date":"2019-06-24","objectID":"/2019/06/prism3-compositecommands/:0:4","tags":["Prism","compositecommands"],"title":"Prism Composite Commands","uri":"/2019/06/prism3-compositecommands/"},{"categories":"Prism","content":"在活动视图上执行命令\r父视图级别的复合命令通常用于协调如何调用子视图级别的命令。在某些情况下，您将需要执行所有显示视图的命令，如前面所述的Save All命令示例中所示。在其他情况下，您将希望仅在活动视图上执行该命令。在这种情况下，复合命令将仅对被视为活动的视图执行子命令; 它不会在非活动的视图上执行子命令。例如，您可能希望在应用程序的工具栏上实现缩放命令，该命令仅导致当前活动项目被缩放，如下图所示。 为了支持这种情况，Prism提供了IActiveAware界面。该IActiveAware接口定义了一个IsActive返回属性true时实施者是活动的，并且IsActiveChanged当活动状态改变时引发事件。 您可以IActiveAware在视图或ViewModel上实现该接口。它主要用于跟踪视图的活动状态。视图是否处于活动状态由特定控件内的视图决定。例如，对于Tab控件，有一个适配器将当前选定选项卡中的视图设置为活动状态。 本DelegateCommand类还实现了IActiveAware接口。CompositeCommand可被配置成评估子类DelegateCommands的活动状态（除了CanExecute通过指定状态）true为monitorCommandActivity在构造参数。当此参数设置为时true，CompositeCommand类在确定方法的返回值以及在CanExecute方法中执行子命令时将考虑每个子DelegateCommand的活动状态Execute。 public class ApplicationCommands : IApplicationCommands { private CompositeCommand _saveCommand = new CompositeCommand(true); public CompositeCommand SaveCommand { get { return _saveCommand; } } } 当monitorCommandActivity参数为时true，CompositeCommand该类表现出以下行为： CanExecute：true仅在可以执行所有活动命令时返回。根本不会考虑不活动的子命令。 Execute：执行所有活动命令。根本不会考虑不活动的子命令。 通过IActiveAware在ViewModel上实现界面，当您的视图变为活动或非活动时，您将收到通知。当视图的活动状态更改时，您可以更新子命令的活动状态。然后，当用户调用复合命令时，将调用活动子视图上的命令。 public class TabViewModel : BindableBase, IActiveAware { private bool _isActive; public bool IsActive { get { return _isActive; } set { _isActive = value; OnIsActiveChanged(); } } public event EventHandler IsActiveChanged; public DelegateCommand UpdateCommand { get; private set; } public TabViewModel(IApplicationCommands applicationCommands) { UpdateCommand = new DelegateCommand(Update); applicationCommands.SaveCommand.RegisterCommand(UpdateCommand); } private void Update() { //implement logic } private void OnIsActiveChanged() { UpdateCommand.IsActive = IsActive; //set the command as active IsActiveChanged?.Invoke(this, new EventArgs()); //invoke the event for al listeners } } ","date":"2019-06-24","objectID":"/2019/06/prism3-compositecommands/:0:5","tags":["Prism","compositecommands"],"title":"Prism Composite Commands","uri":"/2019/06/prism3-compositecommands/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 除了提供对要在视图中显示或编辑的数据的访问之外，ViewModel还可能定义可由用户执行的一个或多个动作或操作。用户可以通过UI执行的动作或操作通常被定义为命令。命令提供了一种方便的方法来表示可以轻松绑定到UI中的控件的操作或操作。它们封装了实现操作或操作的实际代码，并有助于使其与视图中的实际可视化表示分离。 当用户与视图交互时，用户可以以多种不同的方式直观地表示和调用命令。在大多数情况下，它们是通过鼠标单击调用的，但也可以通过快捷键按下，触摸手势或任何其他输入事件来调用它们。视图中的控件是绑定到ViewModel命令的数据，以便用户可以使用控件定义的任何输入事件或手势来调用它们。视图中的UI控件与命令之间的交互可以是双向的。在这种情况下，可以在用户与UI交互时调用该命令，并且可以在启用或禁用基础命令时自动启用或禁用UI。 ViewModel可以将命令实现为命令对象（实现ICommand接口的对象）。可以以声明方式定义视图与命令的交互，而无需在视图的代码隐藏文件中使用复杂的事件处理代码。例如，某些控件固有地支持命令并提供Command可以是绑定到ICommandViewModel提供的对象的数据的属性。在其他情况下，命令行为可用于将控件与ViewModel提供的命令方法或命令对象相关联。 实现ICommand界面很简单。Prism提供了DelegateCommand这个界面的实现，您可以在应用程序中轻松使用它。 ","date":"2019-06-23","objectID":"/2019/06/prism2-commanding/:0:0","tags":["Prism","Commanding"],"title":"Prism Commanding","uri":"/2019/06/prism2-commanding/"},{"categories":"Prism","content":"DelegateCommand\rPrism DelegateCommand类封装了两个委托，每个委托引用在ViewModel类中实现的方法。它通过调用这些委托来实现ICommand接口Execute和CanExecute方法。您可以在DelegateCommand类构造函数中指定ViewModel方法的委托。例如，以下代码示例显示如何DelegateCommand通过指定OnSubmit和CanSubmit ViewModel方法的委托来构造表示Submit命令的实例。然后，该命令通过只读属性公开给视图，该属性返回对该参数的引用DelegateCommand。 public class ArticleViewModel { public DelegateCommand SubmitCommand { get; private set; } public ArticleViewModel() { SubmitCommand = new DelegateCommand\u003cobject\u003e(Submit, CanSubmit); } void Submit(object parameter) { //implement logic } bool CanSubmit(object parameter) { return true; } } 在DelegateCommand对象上调用Execute方法时，它只是通过您在构造函数中指定的委托将调用转发到ViewModel类中的方法。同样，CanExecute调用该方法时，将调用ViewModel类中的相应方法。CanExecute构造函数中方法的委托是可选的。如果没有指定一个委托，DelegateCommand将始终返回true了CanExecute。 该DelegateCommand班是一个泛型类型。type参数指定传递给Execute和CanExecute方法的命令参数的类型。在前面的示例中，command参数是type object。非通用的版本DelegateCommand类也通过棱镜用于提供当没有所需的命令参数，并且被定义为如下： public class ArticleViewModel { public DelegateCommand SubmitCommand { get; private set; } public ArticleViewModel() { SubmitCommand = new DelegateCommand(Submit, CanSubmit); } void Submit() { //implement logic } bool CanSubmit() { return true; } } 所述DelegateCommand故意阻止使用值类型（int，双，布尔等）。因为ICommand需要一个object具有值类型T将导致当意外行为CanExecute(null)XAML初始化命令绑定期间被调用。使用default(T)被认为是被拒绝作为解决方案，因为实现者无法区分有效值和默认值。如果要将值类型用作参数，则必须使用DelegateCommand\u003cNullable\u003cint\u003e\u003e或使用简写?语法（DelegateCommand\u003cint?\u003e）使其可为空。 ","date":"2019-06-23","objectID":"/2019/06/prism2-commanding/:0:1","tags":["Prism","Commanding"],"title":"Prism Commanding","uri":"/2019/06/prism2-commanding/"},{"categories":"Prism","content":"从View调用DelegateCommands\r有许多方法可以将视图中的控件与ViewModel提供的命令对象相关联。某些WPF，Xamarin.Forms和UWP控件可以通过Command属性轻松地绑定到命令对象。 \u003cButton Command=\"{Binding SubmitCommand}\" CommandParameter=\"OrderId\"/\u003e 也可以使用CommandParameter属性选择性地定义命令参数。期望参数的类型在DelegateCommand\u003cT\u003e泛型声明中指定。当用户与该控件交互时，控件将自动调用目标命令，并且命令参数（如果提供）将作为参数传递给命令的Execute方法。在前面的示例中，按钮将SubmitCommand在单击时自动调用。此外，如果CanExecute指定了委托，则CanExecute返回时将自动禁用该按钮，如果返回false则将启用该按钮true。 ","date":"2019-06-23","objectID":"/2019/06/prism2-commanding/:0:2","tags":["Prism","Commanding"],"title":"Prism Commanding","uri":"/2019/06/prism2-commanding/"},{"categories":"Prism","content":"Raising Change Notifications\rViewModel通常需要指示命令CanExecute状态的更改，以便UI中绑定到该命令的任何控件都将更新其启用状态以反映绑定命令的可用性。在DelegateCommand提供了几种这些通知发送到用户界面。 RaiseCanExecuteChanged\rRaiseCanExecuteChanged每当需要手动更新绑定的UI元素的状态时，请使用该方法。例如，当IsEnabled属性值更改时，我们调用RaiseCanExecuteChanged属性的setter来通知UI状态更改。 private bool _isEnabled; public bool IsEnabled { get { return _isEnabled; } set { SetProperty(ref _isEnabled, value); SubmitCommand.RaiseCanExecuteChanged(); } } ObservesProperty\r如果命令应在属性值更改时发送通知，则可以使用该ObservesProperty方法。使用该ObservesProperty方法时，只要提供的属性的值发生更改，DelegateCommand将自动调用RaiseCanExecuteChanged以通知UI状态更改。 public class ArticleViewModel : BindableBase { private bool _isEnabled; public bool IsEnabled { get { return _isEnabled; } set { SetProperty(ref _isEnabled, value); } } public DelegateCommand SubmitCommand { get; private set; } public ArticleViewModel() { SubmitCommand = new DelegateCommand(Submit, CanSubmit).ObservesProperty(() =\u003e IsEnabled); } void Submit() { //implement logic } bool CanSubmit() { return IsEnabled; } } 注意 使用该ObservesProperty方法时，您可以链接注册多个属性以供观察。示例：ObservesProperty(() =\u003e IsEnabled).ObservesProperty(() =\u003e CanSave)。 ObservesCanExecute\r如果您CanExecute是简单Boolean属性的结果，则可以省去声明CanExecute委托，并使用该ObservesCanExecute方法。ObservesCanExecute当注册的属性值发生变化时，它不仅会向UI发送通知，而且还会使用与实际CanExecute委托相同的属性。 public class ArticleViewModel : BindableBase { private bool _isEnabled; public bool IsEnabled { get { return _isEnabled; } set { SetProperty(ref _isEnabled, value); } } public DelegateCommand SubmitCommand { get; private set; } public ArticleViewModel() { SubmitCommand = new DelegateCommand(Submit, CanSubmit).ObservesCanExecute(() =\u003e IsEnabled); } void Submit() { //implement logic } } 警告\r不要尝试链式注册ObservesCanExecute方法。CanExcute代表只能观察到一个属性。 ","date":"2019-06-23","objectID":"/2019/06/prism2-commanding/:0:3","tags":["Prism","Commanding"],"title":"Prism Commanding","uri":"/2019/06/prism2-commanding/"},{"categories":"Prism","content":"基于Task-Based的DelegateCommand\rasync/await调用Execute委托内部的异步方法是一个非常常见的要求。每个人的第一直觉是他们需要一个AsyncCommand，但这种假设是错误的。ICommand本质上是同步的，并且代表Execute和CanExecute代表应被视为事件。这意味着这async void是一个非常有效的语法用于命令。使用异步方法有两种方法DelegateCommand。 方法一 public class ArticleViewModel { public DelegateCommand SubmitCommand { get; private set; } public ArticleViewModel() { SubmitCommand = new DelegateCommand(Submit); } async void Submit() { await SomeAsyncMethod(); } } 方法二 public class ArticleViewModel { public DelegateCommand SubmitCommand { get; private set; } public ArticleViewModel() { SubmitCommand = new DelegateCommand(async ()=\u003e await Submit()); } Task Submit() { return SomeAsyncMethod(); } } ","date":"2019-06-23","objectID":"/2019/06/prism2-commanding/:0:4","tags":["Prism","Commanding"],"title":"Prism Commanding","uri":"/2019/06/prism2-commanding/"},{"categories":"Prism","content":"简介\r注意：该版本为Prism6,最新版已有较大改动。 Prism需要.Framework4.5，包含MVVM（Model-View-ViewModel）模式，Navigation，和MEF（Managed Extensibility Framework） ","date":"2019-06-22","objectID":"/2019/06/prism1-introduce/:1:0","tags":["Prism"],"title":"Prism 简介","uri":"/2019/06/prism1-introduce/"},{"categories":"Prism","content":"前期准备\r学习Prism需要一些WPF的概念，需要了解和熟悉 XAML(Extensible Application Markup Language)。在WPF应用程序中以声明方式定义和初始化用户界面的语言。 数据绑定(Binding)。这就是UI元素如何连接到WPF中的组件和数据。 资源(Resources)。这些是在WPF中创建和管理样式，数据模板和控件模板的方式。 命令(Commands)。这些是用户手势和输入连接到控件的方式。 用户控件(User Controls)。这些是提供自定义行为或自定义外观的组件。 依赖属性(Dependency properties)。这些是公共语言运行时（CLR）属性系统的扩展，用于启用属性设置和监视，以支持数据绑定，路由命令和事件。 行为(Behaviors)。行为是封装交互功能的对象，可以轻松应用于用户界面中的控件。 ","date":"2019-06-22","objectID":"/2019/06/prism1-introduce/:2:0","tags":["Prism"],"title":"Prism 简介","uri":"/2019/06/prism1-introduce/"},{"categories":"Prism","content":"关键概念\rPrism提供了您可能不熟悉的功能和设计模式，特别是如果您是设计模式和复合应用程序开发的新手。本节简要概述了Prism背后的主要概念，并定义了您将在整个文档和代码中使用的一些术语。 模块（Modules）。模块是可以独立开发，测试和（可选）部署的功能包。在许多情况下，模块由不同的团队开发和维护。典型的Prism应用程序由多个模块构建。模块可用于表示特定的业务相关功能（例如，配置文件管理），并封装实现该功能所需的所有视图，服务和数据模型。模块还可用于封装可在多个应用程序中重用的常见应用程序基础结构或服务（例如，日志记录和异常管理服务）。 模块目录（Module Catalog）。在复合应用程序中，必须由主机应用程序在运行时发现和加载模块。在Prism中，模块目录用于指定要加载哪些模块，何时加载以及按什么顺序加载。模块目录由ModuleManager和ModuleLoader组件使用，如果模块是远程的，则负责下载模块，将模块的程序集加载到应用程序域中，以及初始化模块。Prism允许以不同方式指定模块目录，包括以编程方式使用代码，以声明方式使用XAML或使用配置文件。如果需要，您还可以实现自定义模块目录。 壳（Shell）。shell是加载模块的宿主应用程序。shell定义了应用程序的整体布局和结构，但它通常不知道它将托管的确切模块。它通常实现常见的应用程序服务和基础结构，但大多数应用程序的功能和内容都是在模块中实现的。shell还提供顶级窗口或可视元素，然后将托管由加载的模块提供的不同UI组件。 视图（Views）。视图是UI控件，用于封装应用程序的特定功能或功能区域的UI。视图与MVVM模式结合使用，MVVM模式用于在UI与应用程序的表示逻辑和数据之间提供关注点的清晰分离。视图用于封装UI并定义用户交互行为，从而允许独立于底层应用程序功能更新或替换视图。视图使用数据绑定与视图模型类交互。 视图模型（View models）。视图模型是封装应用程序的表示逻辑和状态的类。它们是MVVM模式的一部分。View模型封装了应用程序的大部分功能。视图模型定义属性，命令和事件，视图中的控件可以对其进行数据绑定。 模型（Models）。模型类封装了应用程序数据和业务逻辑。它们用作MVVM模式的一部分。模型封装了数据以及任何相关的验证和业务规则，以确保数据的一致性和完整性。 命令（Commands）。命令用于封装应用程序功能，允许独立于应用程序的UI定义和测试它们。它们可以在视图模型中定义为命令对象或命令方法。Prism提供DelegateCommand类和CompositeCommand类。后者用于表示一起调用的命令集合。 地区（Regions）。区域是在应用程序的UI（在shell或视图中）中定义的逻辑占位符，其中显示视图。区域允许更新应用程序UI的布局，而无需更改应用程序逻辑。许多常用控件可用作区域，允许视图自动显示在控件中，例如ContentControl，ItemsControl，ListBox或TabControl。可以以编程方式或自动方式在区域内显示视图。Prism还为实施区域导航提供支持。区域可以通过RegionManager组件由其他组件定位，该组件使用RegionAdapter和RegionBehavior组件，以协调特定区域内的视图显示。 导航（Navigation）。导航定义为应用程序通过其与应用程序或内部应用程序状态更改进行交互而更改其UI的过程。Prism支持两种导航样式：基于状态的导航，其中现有视图的状态被更新以实现简单的导航场景;以及视图切换导航，其中创建新视图并在应用程序的UI内替换旧视图。视图切换导航使用基于统一资源标识符（URI）的导航机制与Prism区域相结合，以允许实现灵活的导航方案。 事件聚合（EventAggregator）。复合应用程序中的组件通常需要以松散耦合的方式与应用程序中的其他组件和服务进行通信。为了支持这一点，Prism提供了EventAggregator组件，它实现了pub-sub事件机制，从而允许组件发布事件和其他组件来订阅这些事件，而不需要引用另一个事件。所述EventAggregator经常被用来允许在不同的模块中定义的部件彼此通信。 依赖注入容器（Dependency injection container）。整个Prism使用依赖注入（DI）模式来允许管理组件之间的依赖关系。依赖注入允许在运行时实现组件依赖性，并且它支持可扩展性和可测试性。Prism旨在与Unity或MEF一起使用，或通过ServiceLocator与任何其他依赖注入容器一起使用。 服务（Services）。服务是封装非UI相关功能的组件，例如日志记录，异常管理和数据访问。服务可以由应用程序定义，也可以在模块内定义。服务通常在依赖注入容器中注册，以便它们可以根据需要定位或构造，并由依赖于它们的其他组件使用。 控制器（Controllers）。控制器是用于协调要在应用程序UI中的区域中显示的视图的构造和初始化的类。控制器封装了表示要显示哪些视图的表示逻辑。控制器将使用Prism的视图切换导航机制，该机制提供可扩展的基于URI的导航机制，以协调区域内视图的构造和放置。Application Controller模式定义了映射到此职责的抽象。 引导程序（Bootstrapper）。该引导程序组件应用程序使用来初始化各个棱镜组件和服务。它用于初始化依赖注入容器，以便向其注册任何应用程序级组件和服务。它还用于配置和初始化模块目录以及shell的视图和视图模型或演示者。 Prism的设计使您可以单独使用任何前述功能和设计模式，也可以根据您的要求和应用场景一起使用。您可以以任意组合使用MVVM模式，模块化，区域，命令或事件，而无需采用所有这些模式。当然，如果您想充分利用分离关注点和松散耦合提供的好处，您通常会将Prism的许多功能和设计模式相互结合使用。下图显示了典型的Prism应用程序体系结构，并展示了Prism的所有各种功能如何在多模块复合应用程序中协同工作。 使用Prism库的典型复合应用程序架构 大多数Prism应用程序由一个shell应用程序组成，该应用程序定义用于显示顶级视图的区域和可由加载的模块访问的共享服务。shell定义了一个合适的Module catalog，以指定在启动时加载哪些模块（如果适用）。还定义了依赖注入容器，其允许在运行时实现组件依赖性。应用程序启动时，Bootstrapper在容器中注册共享服务和组件。 各个模块封装了整个应用程序功能的一部分，并使用分离的表示模式（如MVVM）定义视图，视图模型，模型和服务组件。加载模块时，模块中定义的视图将显示在shell定义的区域内。初始化完成后，用户然后使用基于状态或视图切换的导航在应用程序内导航，以协调应用程序区域内的新视图的可视更新或显示。 ","date":"2019-06-22","objectID":"/2019/06/prism1-introduce/:3:0","tags":["Prism"],"title":"Prism 简介","uri":"/2019/06/prism1-introduce/"},{"categories":"随笔","content":"学习最终还是听说读写的能力，不管知识点的多少，最好的学习方法还是将知识点梳理出脉络和结构进行定向输出的过程。这其中有很多的细节 学习的目的\r","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:0:0","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"人的学习\r","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:1:0","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"为何学习\r找出规律 压缩信息 ","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:1:1","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"如何学习\r明确任务 通过例子 ","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:1:2","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"学习误区\r错误的输入输出 错误的知识类型 把知识当信息 ","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:1:3","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"如何应用\r分而治之 二阶知识 ","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:1:4","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"机器的学习\r","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:2:0","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"为何建模\r识别模式 压缩数据 ","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:2:1","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"如何建模\r明确任务 样本训练 ","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:2:2","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"建模误区\r错误的输入输出 错误的学习算法 浅层学习 深度学习 错误迁移模式 ","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:2:3","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"如何应用\r分而治之 先验知识 思维导图的目的\r","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:2:4","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"思维导图\r常见学习的误区 阅读知识描述 理解文字意思 不断重复描述 思维导图的使用 先写出一个关键词 不断问自己它是什么 想出很多的例子，强迫自己用一个关键词来描述很多的例子 分析所有例子的共同输入和输出，找出规律 需要学习的是规律，而不是具体情况 通过共同的规律来预测未见过的情况 ","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:3:0","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"思维导图设计\r明确输入输出任务 将信息压缩成知识 例子重塑大脑连接 二阶知识拆分只是 如何画思维导图\r","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:4:0","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"使用步骤\r搜集例子 头脑风暴 上网调查 自我提问 一阶知识 分类 它是什么 为什么是 回归 它的目的 如何达成 二阶知识 组合关系 它有什么 执行步骤 先后顺序 ","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:5:0","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"使用技巧\r工具使用 外框 视角、注意力 联系 跨层知识关系 笔记 知识描述 概要 显示描述 知识命名 定语名词 动词宾语 使用误区 记录所有信息 知识间不独立 记忆他人导图 从不验证更新 画无规律信息 怎样喜欢学习\r保持好奇心 Stay Hungry,Stay Foolish! ","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:6:0","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"计划\r","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:0:0","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"长期计划\r要把计划列成一个详细的清单，而且要注明时间和完成期限 只是一个计划告诉你方向 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:1:0","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"短期计划\r细计划 把一个三年的学习计划，按照某种规律（逻辑、类型、阶段等等）分成三份，安排到每一年， 每年的学习内容细化，安排到每一个月。因为一个月有三十天，所以可以把一个月分为三个周期：第一个十天，第二个十天，第三个十天，十天就是一个周期。确定这个周期学习什么，下个周期学习什么，以此类推。 画一张每日工作表，自己每天晚上计划一下第二天的学习内容。 将整个计划分成若干阶段，每个阶段20小时阶段（2+2+2+2+2+5+5，每周20小时，工作日2小时，周末5小时），每周20小时，每天学习完进行练习，每周学习完进行测试。 计划调整 有时计划会低估或则高估自己的学习能力，根据每天的学习内容即时调整 执行\r快速浏览： 看目录：知道每一章重点在哪一节，用来解决什么问题 看课后习题，圈出术语和知识点 详细阅读： 根据重点和术语有重点的看书中概念，案例，图表 做题： 做课后习题 回顾： 看着目录知道这一章讲哪些内容，有哪些专业术语和知识点 测试： 学完课程后去网上找试卷进行测试 总结： 读一本书要写读书笔记，学知识要写总结 目的是把书中的知识和自己的理解结合起来形成自己的想法和思路，将自己的笔记标注时间，以后可以复习 定向输出： 找一个平台定向输出自己的所学。在写作的过程中，需要不断回忆自己学到的知识，并且利用自己的语言将它表达出来。还要思考文章的结构，怎么才能循序渐进地把一个复杂的道理讲得明白，讲得令人心服口服，讲得让人无懈可击。如果有某些细节自己不知道、不清楚，为了避免文中出现疏漏，你就会去查阅资料或者翻阅书籍，这就完成了一个巩固与复习的过程。 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:2:0","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"学习障碍\r","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:0","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"仪式感\r人藉由这种仪式带来的仪式感，来给自己一种强烈的自我暗示———这种自我暗示能够使自我变革，把自己的专注力、反应能力、运动能力迅速提升； 睡觉前，想一想今天学了哪些内容，第二天要学习哪些内容； 醒来，想一下今天又哪些任务； ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:1","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"预热\r提前半小时到达学习地点，准备好学习所需的物品； 翻看今天要学习的内容，浏览重要的概念和例题； 最后一分钟什么也不做，静心； ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:2","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"放松\r身体能量:每隔50分钟吃点东西喝点水 情绪能量:听音乐，做运动 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:3","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"厌倦感\r在高效学习的晚上，还有一部分愉悦的学习热情的时候中断学习，这样第二天可以更快进入学习状态 在讨厌某件事情的时候立马做，在开心的余热中立刻结束。 运动趋向运动，静止趋向静止 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:4","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"能量爆发期\r规划自己一天当中哪几个阶段学习热情比较高，效率高，为这几个阶段做提前准备，为了下午的学习，中午先休息一会，在工作之余听听音乐 在疲劳来临之前休息放松是最好的缓解疲劳的方法 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:5","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"计划被中断\r当天的某个计划被中断，没什么大不了，继续计划就可以 60分的完成也好过不完成。不要放弃 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:6","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"奖惩机制\r每天锻炼，没做好每天多做 看视频，没做好每天不看视频来锻炼 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:7","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"自我经营\r人与人最大的差别，不是他们的社会地位和收入水平，而是他们在业余时间学什么、做什么。 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:8","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"当机立断\r无论学什么，一定要当机立断，今天写计划，今天就执行，别等别拖别准备。 总结\r自学的本质就是管理自己，经营自己，掌控自己，驾驭自己，最后得到时间上的盈利——时间价值最大化。 人，终究是要学会使用自己，而不是放纵自己。 参考文献\rhttps://www.zhihu.com/question/21107510 https://www.zhihu.com/question/36766890/answer/70795756 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:9","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"Web","content":"DOM(document object medol)文档对象模型。 DOM就是HTML页面的模型，将每个标签都做为一个对象，JavaScript通过调用DOM中的属性、方法就可以对网页中的文本框、层等元素进行编程控制。比如通过操作文本框的DOM对象，就可以读取文本框中的值、设置文本框中的值。 JavaScript→Dom就是C#→.Net Framwork。没有.net，C#只能for、while，连WriteLine、MessageBox都不行。Dom就是一些让JavaScript能操作HTML页面控件的类、函数。 DOM也像WinForm一样，通过事件、属性、方法进行编程。 CSS+JavaScript+DOM=DHTML 学习阶段只考虑IE。用IE Collection安装IE所有版本，学习使用IE6（要调试必须使用本机安装的版本）。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:0:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"事件\r事件：\u003cbody onmousedown=\"alert('哈哈')\"\u003e当点击鼠标的时候执行onmousedown中的代码。有时间事件响应的代码太多，就放到单独的函数中： \u003cscript type=\"text/javascript\"\u003e function bodymousedown() { alert(\"网页被点坏了，赔吧！\"); alert(\"逗你玩的！\"); } \u003c/script\u003e \u003cbody onmousedown=\"bodymousedown()\"\u003e bodymousedown后的括号不能丢（ onmousedown=“bodymousedown” ），因为表示onmousedown事件发生时调用bodymousedown函数，而不是onmousedown事件的响应函数是bodymousedown。 \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function setTxt() { t1.value = \"1234\"; } \u003c/script\u003e \u003c/head\u003e \u003cbody onload=\"setTxt();\" onunload=\"alert('欢迎下次光临！')\" onbeforeunload=\"window.event.returnValue='确定关闭？'\"\u003e \u003cinput id=\"t1\" type=\"text\" value=\"\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:1:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"动态设置事件\r可以在代码中动态设置事件响应函数，就像.Net中btn.Click+=一样 function f1() { alert(\"1\"); } function f2(){ alert(\"2\"); } \u003cinput type=\"button\" onclick=\"document.ondblclick=f1\" value=\"关联事件1\" /\u003e//注意f1不要加括号。如果加上括号就变成了执行f1函数，并且将函数的返回值复制给document.ondblclick \u003cinput type=\"button\" onclick=\"document.ondblclick=f2\" value=\"关联事件2\" /\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function load() { alert('地球日'); alert('2012不远了'); } function f1() { alert(\"f1\"); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"按钮\" onclick=\"document.onclick=f1\" /\u003e \u003cinput type=\"button\" value=\"关闭\" onclick=\"window.close()\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:2:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"window对象\rwindow对象代表当前浏览器窗口，使用window对象的属性、方法的时候可以省略window，比如window.alert(‘a’)可以省略成alert(‘aa’)。 alert方法，弹出消息对话框 confirm方法，显示“确定”、“取消”对话框，如果按了【确定】按钮，就返回true，否则就false if (confirm(\"是否继续？\")) { alert(\"确定\"); } else { alert(\"取消\"); } + 重新导航到指定的地址：navigate(\"http://www.rupeng.com\");\r+ setInterval每隔一段时间执行指定的代码，第一个参数为代码的字符串，第二个参数为间隔时间（单位毫秒），返回值为定时器的标识\r`setInterval(\"alert('hello')\", 5000);`\r+ clearInterval取消setInterval的定时执行，相当于Timer中的Enabled=False。因为setInterval可以设定多个定时，所以clearInterval要指定清除那个定时器的标识，即setInterval的返回值。\rvar intervalId = setInterval(\"alert('hello')\", 5000);\rclearInterval(intervalId); + setTimeout也是定时执行，但是不像setInterval那样是重复的定时执行，只执行一次，clearTimeout也是清除定时。很好区分：Interval：间隔；timeout：超时。 var timeoutId = setTimeout(\"alert('hello')\", 2000); + showModalDialog弹出模态对话框，注意showModalDialog必须在onClick等用户手动触发的事件中才会执行，否则可能会被最新版本的浏览器当成广告弹窗而拦截。\r+ 第一个参数为弹出模态窗口的页面地址。\r+ 在弹出的页面中调用window.close()（不能省略window.close()中的window.）关闭窗口，只有在对话框中调用window.close()才会自动关闭窗口，否则浏览器会提示用户进行确认。\r+ 除了有特有的属性之外，当然还有通用的HTML元素的事件：onclick（单击）、ondblclick（双击）、onkeydown（按键按下）、onkeypress（点击按键）、onkeyup（按键释放）、onmousedown（鼠标按下）、onmousemove（鼠标移动）、onmouseout（鼠标离开元素范围）、onmouseover（鼠标移动到元素范围）、onmouseup（鼠标按键释放）等。\r\u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e1234567890\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e var tid; function setTimeoutDemo() { tid = setTimeout(\"alert('下课了')\", 3000); } function clearTimeoutDemo() { //判断tid是否初始化 if (tid) { clearTimeout(tid); } } var dir = \"left\"; function scroll() { var title = window.document.title; if (dir == \"left\") { var first = title.charAt(0); var last = title.substring(1, title.length); //start 从0数 end从1数 } else if (dir == \"right\") { var last = title.charAt(title.length - 1); var first = title.substring(0, title.length - 1); } window.document.title = last + first; } setInterval(\"scroll()\", 500); function setDir(str) { dir = str; } function scrollRight() { var title = window.document.title; var last = title.charAt(title.length - 1); var first = title.substring(0, title.length - 1); title = last + first; window.document.title = title; } window.showModalDialog(\"1-.htm\"); function showDialog() { window.showModalDialog(\"1-.htm\"); } function show() { window.showModelessDialog(\"1-.htm\"); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"启动\" onclick=\"setTimeoutDemo();\" /\u003e \u003cinput type=\"button\" value=\"取消\" onclick=\"clearTimeoutDemo();\" /\u003e \u003cinput type=\"button\" value=\"向左\" onclick=\"setDir('left')\" /\u003e \u003cinput type=\"button\" value=\"向右\" onclick=\"setDir('right')\" /\u003e \u003cbr /\u003e \u003cinput type=\"button\" value=\"模式窗口\" onclick=\"showDialog()\" /\u003e \u003cinput type=\"button\" value=\"非模式窗口\" onclick=\"show()\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e var times = 10; function count() { var btn = document.getElementById(\"btn\"); if (times \u003e 0) { btn.value = \"同意(倒计时\" + times + \")\"; times--; } else { btn.value = \"同意\"; btn.disabled = false; clearInterval(tid); } } var tid = setInterval(\"count()\", 1000); \u003c/script\u003e \u003c/head\u003e \u003cbody onload=\"count()\"\u003e 注册协议 \u003cbr /\u003e \u003cinput id=\"btn\" type=\"button\" value=\"同意\" disabled=\"disabled\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:3:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"window对象属性\rwindow.location.href='http://www.itcast.cn'，重新导向新的地址，和navigate方法效果一样。window.location.reload() 刷新页面 window.event是非常重要的属性，用来获得发生事件时的信息，事件不局限于window对象的事件，所有元素的事件都可以通过event属性取到相关信息。类似于winForm中的e(EventArg). altKey属性，bool类型，表示发生事件时alt键是否被按下，类似的还有ctrlKey、shiftKey属性，例子 \u003cinput type=\"button\" value=\"点击\" onclick=\"if(event.altKey){alert('Alt点击')}else{alert('普通点击')}\" /\u003e ； clientX、clientY 发生事件时鼠标在客户区的坐标；screenX、screenY 发生事件时鼠标在屏幕上的坐标；offsetX、offsetY 发生事件时鼠标相对于事件源（比如点击按钮时触发onclick）的坐标。 returnValue属性，如果将returnValue设置为false，就会取消默认事件的处理。在超链接的onclick里面禁止访问href的页面。在表单校验的时候禁止提交表单到服务器，防止错误数据提交给服务器、防止页面刷新。 srcElement，获得事件源对象。几个事件共享一个事件响应函数用。 keyCode，发生事件时的按键值。 button，发生事件时鼠标按键，1为左键，2为右键，3为左右键同时按。\u003cbody onmousedown=\"if(event.button==2){alert('禁止复制');}\"\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:4:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"（*）screen对象，屏幕的信息\ralert(\"分辨率：\" + screen.width + \"*\" + screen.height); if (screen.width \u003c 1024 || screen.height \u003c 768){ alert(\"分辨率太低！\"); } ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:5:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"clipboardData对象\r对粘贴板的操作。clearData(“Text”)清空粘贴板；getData(“Text”)读取粘贴板的值，返回值为粘贴板中的内容；setData(“Text”,val)，设置粘贴板中的值。 案例：复制地址给友好。见备注。 当复制的时候body的oncopy方法被触发，直接return false就是禁止复制。\u003cbody oncopy=“alert(‘禁止复制！’);return false;” 很多元素也有oncopy、onpaste事件： 案例：禁止粘贴帐号。见备注。 在网站中复制文章的时候，为了防止那些拷贝党不添加文章来源，自动在复制的内容后添加版权声明。 function modifyClipboard() { clipboardData.setData('Text', clipboardData.getData('Text') + '本文来自传智播客技术专区，转载请注明来源。' + location.href); } + `oncopy=\"setTimeout('modifyClipboard()',100)\"`。用户复制动作发生0.1秒以后再去改粘贴板中的内容。100ms只是一个经常取值，写1000、10、50、200……都行。不能直接在oncopy里修改粘贴板。\r+ 不能直接在oncopy中执行对粘贴板的操作，因此设定定时器，0.1秒以后执行，这样就不再oncopy的执行调用栈上了。\rhistory操作历史记录 window.history.back()后退；window.history.forward()前进。也可以用window.history.go(-1)、window.history.go(1)前进 \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function getXY() { document.title = window.event.clientX + \" \" + window.event.clientY; } function turnInto(right) { if (right) { alert(\"欢迎进入\"); } else { alert(\"非法入侵\"); window.event.returnValue = false; alert(\"123123\"); } } function btnClick() { return false; alert(\"abc\"); } function txtKeyDown() { var txt = window.event.srcElement; if (txt.id == \"txtNums\") { if (window.event.keyCode \u003e= 48 \u0026\u0026 window.event.keyCode \u003c= 57) { } else { return false; } } else if (txt.id = \"txt\") { } } \u003c/script\u003e \u003c/head\u003e \u003cbody onmousemove=\"getXY()\" onmousedown=\"if(window.event.button==2){alert('禁止复制')}\"\u003e \u003cinput type=\"button\" value=\"url\" onclick=\"alert(window.location.href);\" /\u003e \u003cinput type=\"button\" value=\"转向\" onclick=\"window.location.href='2-window对象.htm'\" /\u003e \u003cinput type=\"button\" value=\"reload\" onclick=\"window.location.reload()\" /\u003e \u003cinput type=\"button\" value=\"ctrlKey\" onclick=\"if(window.event.ctrlKey){alert('按下ctrl')}else{alert('没有按下')}\" /\u003e \u003cbr /\u003e \u003ca href=\"1-.htm\" onclick=\"turnInto(0)\"\u003e超链接\u003c/a\u003e \u003cinput type=\"button\" value=\"returnValue\" onclick=\"btnClick();\" /\u003e \u003cform action=\"http://www.baidu.com\"\u003e \u003cinput type=\"submit\" onclick=\"alert('请输入用户名密码');window.event.returnValue=false\"/\u003e \u003c/form\u003e \u003cinput id=\"txtNums\" type=\"text\" value=\"\" onkeydown=\"return txtKeyDown()\" /\u003e \u003cinput id=\"txt\" type=\"text\" value=\"\" onkeydown=\"txtKeyDown()\" /\u003e \u003cinput type=\"button\" value=\"screen\" onclick=\"alert(window.screen.width + ' ' + window.screen.height)\" /\u003e \u003chr /\u003e 手机号：\u003cinput type=\"text\" value=\"\" oncopy=\"alert('禁止复制');return false\" /\u003e\u003cbr /\u003e 重复手机号：\u003cinput type=\"text\" value=\"\" onpaste=\"alert('请输入');return false\" /\u003e \u003chr /\u003e \u003cinput id=\"tabc\" type=\"text\" value=\"213123123\" /\u003e\u003cinput type=\"button\" value=\"copy\" onclick=\"window.clipboardData.setData('text',tabc.value);alert('复制成功');\" /\u003e\u003cbr /\u003e \u003cinput id=\"t123\" type=\"text\" value=\"\" /\u003e\u003cinput type=\"button\" value=\"paste\" onclick=\"t123.value=clipboardData.getData('text')\" /\u003e\u003cbr /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function setClip() { var text = window.clipboardData.getData(\"text\"); text = text + \"转载请注明：\" + window.location.href; window.clipboardData.setData(\"text\",text); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003ctextarea id=\"t1\" oncopy=\"setTimeout('setClip()',50)\"\u003e asdfasdfasdf asdfasdfasdf \u003c/textarea\u003e \u003ca href=\"6-history.htm\"\u003e链接\u003c/a\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"后退\" onclick=\"window.history.back()\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:6:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"document属性。\r是最复杂的属性之一。后面讲解详细使用。 document是window对象的一个属性，因为使用window对象成员的时候可以省略window.，所以一般直接写document document的方法： write：向文档中写入内容。writeln，和write差不多，只不过最后添加一个回车 \u003cinput type=\"button\" value=\"点击\" onclick=\"document.write('\u003cfont color=red\u003e你好\u003c/font\u003e')\" /\u003e + 在onclick等事件中写的代码会冲掉页面中的内容，只有在页面加载过程中write才会与原有内容融合在一起\r\u003cscript type=\"text/javascript\"\u003e document.write('\u003cfont color=red\u003e你好\u003c/font\u003e'); \u003c/script\u003e + write经常在广告代码、整合资源代码中被使用。见备注\r内容联盟、广告代码、cnzz，不需要被主页面的站长去维护内容，只要被嵌入的js内容提供商修改内容，显示的内容就变了。 getElementById方法（非常常用），根据元素的Id获得对象，网页中id不能重复。也可以直接通过元素的id来引用元素，但是有有效范围、form1.textbox1之类的问题，因此不建议直接通过id操作元素，而是通过getElementById （*）getElementsByName，根据元素的name获得对象，由于页面中元素的name可以重复，比如多个RadioButton的name一样，因此getElementsByName返回值是对象数组。 （*）getElementsByTagName，获得指定标签名称的元素数组，比如getElementsByTagName(“p”)可以获得所有的标签。 案例：实现checkbox的全选，反选 案例：点击一个按钮，被点击的按钮显示“呜呜”，其他按钮显示“哈哈”。 案例：十秒钟后协议文本框下的注册按钮才能点击，时钟倒数。(btn.disabled = true ) \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function writeDemo() { document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); } document.writeln(\"123\u003cbr/\u003e\"); document.writeln(\"123\u003cbr/\u003e\"); document.writeln(\"\u003ca href='123.htm'\u003e123\u003c/a\u003e\"); document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); document.write(\"\u003cul\u003e\u003cli\u003e开始\u003c/li\u003e\u003cli\u003e运行\u003c/li\u003e\u003cli\u003e结束\u003c/li\u003e\u003c/ul\u003e\"); //document.write(\"\u003cscript type='text/javascript'\u003ealert('hello world');\u003c\\/script\u003e\"); \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv\u003eabc \u003cscript type=\"text/javascript\"\u003e document.writeln(\"123\u003cbr/\u003e\"); document.writeln(\"123\u003cbr/\u003e\"); \u003c/script\u003eabc \u003c/div\u003e \u003cdiv\u003e sdfsd \u003c/div\u003e \u003cinput type=\"button\" value=\"按钮\" onclick=\"writeDemo()\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function setText() { var txt = document.getElementById(\"t1\"); txt.value = \"123\"; //t1.value = \"123\"; } function setText2() { var txt = document.getElementById(\"t2\"); txt.value = \"abc\"; //form1.t2.value = \"abc\"; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput id=\"t1\" type=\"text\" value=\"\" /\u003e \u003cform id=\"form1\"\u003e \u003cinput id=\"t2\" type=\"text\" value=\"\" /\u003e \u003c/form\u003e \u003cinput type=\"button\" value=\"按钮\" onclick=\"setText()\" /\u003e \u003cinput type=\"button\" value=\"按钮2\" onclick=\"setText2()\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function btnClick() { var chks = document.getElementsByName(\"hobby\"); //错误 // for (var c in chks) { // alert(c); // } for (var i = 0; i \u003c chks.length; i++) { //alert(chks[i].value); chks[i].checked = \"checked\"; } } function checkAll() { var chkAll = document.getElementById(\"chkAll\"); var chks = document.getElementsByName(\"hobby\"); for (var i = 0; i \u003c chks.length; i++) { chks[i].checked = chkAll.checked; } } function reverseCheck() { var chks = document.getElementsByName(\"hobby\"); for (var i = 0; i \u003c chks.length; i++) { chks[i].checked = !chks[i].checked; } } function checkSingle() { var b = true; //假设全被选中 var chkAll = document.getElementById(\"chkAll\"); var chks = document.getElementsByName(\"hobby\"); for (var i = 0; i \u003c chks.length; i++) { //查找所有子的checkbox，判断是否被选中 //如果有一个checkbox没有被选中，则退出循环，最终全选的checkbox为false if (!chks[i].checked) { b = false; break; } } chkAll.checked = b; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"checkbox\" value=\"cf\" onclick=\"checkSingle()\" name=\"hobby\"/\u003e吃饭\u003cbr /\u003e \u003cinput type=\"checkbox\" value=\"sj\" onclick=\"checkSingle()\" name=\"hobby\"/\u003e睡觉\u003cbr /\u003e \u003cinput type=\"checkbox\" value=\"ddd\" onclick=\"checkSingle()\" name=\"hobby\"/\u003e打豆豆\u003cbr /\u003e \u003cbr /\u003e\u003cbr /\u003e \u003cinput id=\"chkAll\" type=\"checkbox\" onclick=\"checkAll()\"/\u003e全选 \u003cinput type=\"button\" value=\"反选\" onclick=\"reverseCheck()\" /\u003e \u003cinput type=\"button\" value=\"全选\" onclick=\"btnClick()\" /\u003e \u003cbr /\u003e \u003cinput type=\"checkbox\" value=\"ctl\" /\u003e春天里\u003cbr /\u003e \u003cinput type=\"checkbox\" value=\"xtl\" /\u003e夏天里\u003cbr /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"htt","date":"2019-04-04","objectID":"/2019/04/web4-dom/:6:1","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"dom动态创建\rdocument.write只能在页面加载过程中才能动态创建。 可以调用document的createElement方法来创建具有指定标签的DOM对象，然后通过调用某个元素的appendChild方法将新创建元素添加到相应的元素下 function showit() { var divMain = document.getElementById(\"divMain\"); var btn = document.createElement(\"input\"); btn.type = \"button\"; btn.value = \"我是动态的！\"; divMain.appendChild(btn); } \u003cdiv id=\"divMain\"\u003e\u003c/div\u003e \u003cinput type=\"button\" value=\"ok\" onclick=\"showit()\" /\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function createBtn() { var btn = document.createElement(\"input\"); btn.type = \"button\"; btn.value = \"新按钮\"; btn.onclick = function() { alert(\"我是新来的\"); } var d = document.getElementById(\"d1\"); d.appendChild(btn); } function createLink() { var link = document.createElement(\"a\"); link.href = \"http://www.baidu.com\"; link.innerText = \"百度\"; link.target = \"_blank\"; var d = document.getElementById(\"d1\"); d.appendChild(link); } function btnClick(){ alert(\"我是新来的\"); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"创建按钮\" onclick=\"createBtn()\" /\u003e \u003cinput type=\"button\" value=\"创建超链接\" onclick=\"createLink()\" /\u003e \u003cdiv id=\"d1\"\u003eabc\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e Value 获取表单元素 几乎所有DOM元素都有innerText、innerHTML属性（注意大小写），分别是元素标签内内容的文本表示形式和HTML源代码，这两个属性是可读可写的。 \u003ca href=\"http://www.itcast.cn\" id=\"link1\"\u003e传\u003cfont color=\"Red\"\u003e智\u003c/font\u003e播客\u003c/a\u003e \u003cinput type=\"button\" value=\"inner*\" onclick=\"alert(document.getElementById('link1').innerText);alert(document.getElementById('link1').innerHTML);\" /\u003e 用innerHTML也可以替代createElement，属于简单、粗放型、后果自负的创建 function createlink() { var divMain = document.getElementById(\"divMain\"); divMain.innerHTML = \"\u003ca href='http://www.rupeng.com'\u003e如鹏网\u003c/a\u003e\"; } \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function getLinkText() { var link = document.getElementById(\"link1\"); alert(link.innerText); alert(link.innerHTML); } function setDiv() { var div = document.getElementById(\"d1\"); //div.innerText = \"\u003cfont color='red'\u003e123123\u003c/font\u003e\"; //div.innerHTML = \"\u003cfont color='red'\u003e123123\u003c/font\u003e\"; //div.innerHTML = \"\u003cul\u003e\u003cli\u003e春天里\u003c/li\u003e\u003cli\u003e怒放\u003c/li\u003e\u003c/ul\u003e\"; //div.innerHTML = \"\u003cinput type='text' value='1234' /\u003e\"; //div.innerText = div.innerText + \"123123\"; //Node节点 Element元素的区别 //html文档里所有的内容都是节点 标签 属性 文本 //元素 一个完整的标签 //var txtNode = document.createTextNode(\"123123\"); // div.appendChild(txtNode); div.innerHTML = \"\u003cscript type='text/javascript'\u003efunction test(){alert('hello');}\u003c\\/script\u003e\"; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003ca id=\"link1\" href=\"http://www.itcast.cn\"\u003e传智\u003cfont color=\"red\"\u003e播客\u003c/font\u003e\u003c/a\u003e \u003cinput type=\"button\" value=\"按钮\" onclick=\"getLinkText()\" /\u003e \u003cdiv id=\"d1\"\u003eabcd\u003c/div\u003e \u003cinput type=\"button\" value=\"set div\" onclick=\"setDiv() \" /\u003e \u003cinput type=\"button\" value=\"test\" onclick=\"test()\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function createTable() { var div = document.getElementById(\"d1\"); var dic = { \"baidu\": \"http://www.baidu.com\", \"传智播客\": \"http://www.itcast.cn\", \"cnbeta\": \"http://www.cnbeta.com\" }; var table = document.createElement(\"table\"); table.border = 1; for (var key in dic) { var tr = document.createElement(\"tr\"); var td0 = document.createElement(\"td\"); td0.innerText = key; //把td0加到tr中 tr.appendChild(td0); var td1 = document.createElement(\"td\"); td1.innerHTML = \"\u003ca href='\" + dic[key] + \"'\u003e\" + dic[key] + \"\u003c/a\u003e\"; tr.appendChild(td1); //把tr添加到table中 table.appendChild(tr); } //把table添加到div中 div.appendChild(table); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"d1\"\u003e\u003c/div\u003e \u003cinput type=\"button\" value=\"load。。。\" onclick=\"createTable()\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:7:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"浏览器兼容性的例子\rie6，ie7对table.appendChild(“tr”)的支持和IE8不一样，用insertRow、insertCell来代替或者为表格添加tbody，然后向tbody中添加tr。FF不支持InnerText。 所以动态加载网站列表的程序修改为： var tr = tableLinks.insertRow(-1);//FF必须加-1这个参数 var td1 = tr.insertCell(-1); td1.innerText = key; var td2 = tr.insertCell(-1); td2.innerHTML = \"\u003ca href='\" + value + \"'\u003e\" + value + \"\u003c/a\u003e\"; 或者： \u003ctable id=\"tableLinks\"\u003e \u003ctbody\u003e\u003c/tbody\u003e \u003c/table\u003e，然后tableLinks. tBodies[0].appendChild(tr); \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function add() { var name = document.getElementById(\"txtName\").value; var content = document.getElementById(\"txtContent\").value; var tr = document.createElement(\"tr\"); var td0 = document.createElement(\"td\"); td0.innerText = name; tr.appendChild(td0); var td1 = document.createElement(\"td\"); td1.innerText = content; tr.appendChild(td1); var table = document.getElementById(\"re\"); table.appendChild(tr); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003e 最新新闻 \u003c/p\u003e \u003ctable id=\"re\"\u003e\u003c/table\u003e \u003chr /\u003e 评论： \u003cinput id=\"txtName\" type=\"text\" value=\"\" /\u003e\u003cbr /\u003e \u003ctextarea id=\"txtContent\" cols=\"50\" rows=\"10\"\u003e\u003c/textarea\u003e \u003cbr /\u003e \u003cinput type=\"button\" value=\"评论\" onclick=\"add()\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function add() { var name = document.getElementById(\"txtName\").value; var content = document.getElementById(\"txtContent\").value; var table = document.getElementById(\"re\"); var tr = table.insertRow(-1); var td = tr.insertCell(-1); td.innerHTML = name; var td1 = tr.insertCell(-1); td1.innerHTML = content; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003e 最新新闻 \u003c/p\u003e \u003ctable id=\"re\"\u003e\u003c/table\u003e \u003chr /\u003e 评论： \u003cinput id=\"txtName\" type=\"text\" value=\"\" /\u003e\u003cbr /\u003e \u003ctextarea id=\"txtContent\" cols=\"50\" rows=\"10\"\u003e\u003c/textarea\u003e \u003cbr /\u003e \u003cinput type=\"button\" value=\"评论\" onclick=\"add()\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:8:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"事件冒泡\r事件冒泡：如果元素A嵌套在元素B中，那么A被点击不仅A的onclick事件会被触发，B的onclick也会被触发。触发的顺序是“由内而外” 。验证：在页面上添加一个table、table里有tr、tr里有td，td里放一个p，在p、td、tr、table中添加onclick事件响应，见备注。 \u003ctable onclick=\"alert('table onclick');\"\u003e \u003ctr onclick=\"alert('tr onclick');\"\u003e \u003ctd onclick=\"alert('td onclick');\"\u003e\u003cp onclick=\"alert('p onclick');\"\u003eaaaa\u003c/p\u003e\u003c/td\u003e \u003ctd\u003ebbb\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function btn3() { alert(event.srcElement.value); } //事件响应函数的调用函数 function btn4() { alert(this.value); } function initBtn5() { var btn = document.getElementById(\"btn5\"); //事件响应函数 btn.onclick = btn4; } \u003c/script\u003e \u003c/head\u003e \u003cbody onload=\"initBtn5()\"\u003e \u003ctable onclick=\"alert('table')\"\u003e \u003ctr onclick=\"alert('tr')\"\u003e \u003ctd onclick=\"alert('td')\"\u003e \u003cdiv onclick=\"alert('div')\"\u003easd\u003c/div\u003e\u003c/td\u003e \u003ctd\u003e2\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003cinput type=\"button\" value=\"click1\" onclick=\"alert(event.srcElement.value)\" /\u003e\u003cbr /\u003e \u003c!-- 事件响应函数--\u003e \u003cinput type=\"button\" value=\"click2\" onclick=\"alert(this.value)\" /\u003e \u003cinput type=\"button\" value=\"click3\" onclick=\"btn3()\" /\u003e \u003cinput type=\"button\" value=\"click4\" onclick=\"btn4()\" /\u003e \u003cinput id=\"btn5\" type=\"button\" value=\"click5\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:8:1","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"this\r事件中的this。 除了可以使用event.srcElement在事件响应函数中 this表示发生事件的控件。 只有在事件响应函数才能使用this获得发生事件的控件，在事件响应函数调用的函数中不能使用，如果要使用则要将this传递给函数或者使用event.srcElement。 (*)this和event.srcElement的语义是不一样的，this就是表示当前监听事件的这个对象，event.srcElement是引发事件的对象：事件冒泡。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:9:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"修改样式\r易错：修改元素的样式不是设置class属性，而是className属性。案例：网页开关灯的效果。 修改元素的样式不能this.style=\"background-color:Red\"。 易错：单独修改样式的属性使用“style.属性名”。注意在css中属性名在JavaScript中操作的时候属性名可能不一样，主要集中在那些属性名中含有-的属性，因为JavaScript中-是不能做属性、类名的。所以CSS中背景颜色是background-color，而JavaScript则是style.backgroundColor；元素样式名是class，在JavaScript中是className属性；font-size→style.fontSize；margin-top→style.marginTop 单独修改控件的样式\u003cinput type=\"button\" value=\"AAA\" onclick=\"this.style.color='red'\" /\u003e。技巧，没有文档的情况下的值属性名，随便给一个元素设定id，然后在js中就能id.style.出来能用的属性。 \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e .light{ background-color:White; } .dark { background-color:Black; } \u003c/style\u003e \u003cscript type=\"text/javascript\"\u003e function open1() { document.body.className = \"light\"; } function close1() { document.body.className = \"dark\"; } function change() { var txt = document.getElementById(\"txt1\"); //错误 不能这样用。可以把style看成一个只读属性 //txt.style = \"background-color:Green\"; txt.style.backgroundColor = \"Green\"; txt.style.color = \"red\"; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"开灯\" onclick=\"open1()\" /\u003e \u003cinput type=\"button\" value=\"关灯\" onclick=\"close1()\" /\u003e \u003cinput id=\"txt1\" type=\"text\" value=\"123\" /\u003e \u003cinput type=\"button\" value=\"click\" onclick=\" change() \" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function initTxt() { var txts = document.getElementsByTagName(\"input\"); for (var i = 0; i \u003c txts.length; i++) { if (txts[i].type == \"text\") { //事件响应函数 txts[i].onblur = iBlur; } } } function iBlur() { if (this.value.length \u003c= 0) { this.style.backgroundColor = \"red\"; } else { this.style.backgroundColor = \"white\"; } } function iFocus(txt) { txt.value = \"\"; } \u003c/script\u003e \u003c/head\u003e \u003cbody onload=\"initTxt()\"\u003e \u003cinput type=\"text\" value=\"\"/\u003e \u003cinput type=\"text\" value=\"\" /\u003e \u003cinput type=\"text\" value=\"\" /\u003e \u003cinput type=\"button\" value=\"click\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function iBlur(txt) { var t2 = document.getElementById(\"t2\"); t2.style.backgroundColor = txt.style.backgroundColor; t2.style.color = txt.style.color; t2.style.width = txt.style.width; t2.value = txt.value; } function iFocus(txt) { var t1 = document.getElementById(\"t1\"); txt.style.backgroundColor = t1.style.backgroundColor; txt.style.color = t1.style.color; txt.style.width = t1.style.width; txt.value = t1.value; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput id=\"t1\" type=\"text\" value=\"\" style=\"background-color:Green; color:Red; width:300px\" /\u003e \u003cinput type=\"text\" onfocus=\"iFocus(this)\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function init() { var table = document.getElementById(\"rating\"); var tds = table.getElementsByTagName(\"td\"); for (var i = 0; i \u003c tds.length; i++) { //事件响应函数 tds[i].onmouseover = change; tds[i].onclick = stop; tds[i].style.cursor = \"pointer\"; } } //记录是否点鼠标，默认没点 var isClick = false; function stop() { isClick = true; } function indexOf(arr,element){ var j = -1; for(var i=0;i\u003carr.length;i++){ if(arr[i] == element) { j = i; break; } } return j; } function change() { //当没点鼠标的时候去执行 if (!isClick) { var table = document.getElementById(\"rating\"); var tds = table.getElementsByTagName(\"td\"); var n = indexOf(tds, this); for (var i = 0; i \u003c= n; i++) { //tds[i].style.backgroundColor = \"red\"; tds[i].innerText = \"★\"; } for (var i = n + 1; i \u003c tds.length; i++) { //tds[i].style.backgroundColor = \"white\"; tds[i].innerText = \"☆\"; } } } \u003c/script\u003e \u003c/head\u003e \u003cbody onload=\"init()\"\u003e \u003ctable id=\"rating\"\u003e \u003ctr\u003e \u003ctd\u003e☆\u003c/td\u003e\u003ctd\u003e☆\u003c/td\u003e\u003ctd\u003e☆\u003c/td\u003e\u003ctd\u003e☆\u003c/td\u003e\u003ctd\u003e☆\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function init() { var d1 = document.getElementById(\"d1\"); var links = d1.getElementsByTagName(\"a\"); for (var i = 0; i \u003c links.length; i++) { links[i].onclick = linkClick; } } function linkClick() { var d1 = document.getElementById(\"d1\"); var links = d1.getElementsByTagName(\"a\")","date":"2019-04-04","objectID":"/2019/04/web4-dom/:10:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"控制层显示\r修改style.display，例子：切换层的显示 function togglediv() { var div1 = document.getElementById('div1'); if (div1.style.display == '') { div1.style.display = 'none';//不显示 } else { div1.style.display = '';//显示 } } 案例：注册页面，点击“高级”CheckBox，则显示高级选项，否则隐藏 案例：鼠标放到一个超链接的时候，在鼠标的位置显示一个黄色背景，带图片的悬浮提示，鼠标离开就消失。提示：鼠标进入控件的事件是onmouseover，离开的事件是onmouseout。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:11:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"Body事件的范围\rIE中如果在body上添加onclick、onmousemove等事件响应，那么如果页面没有满，则 “body 中最后一个元素以下（横向不限制）” 的部分是无法响应事件的，必须使用代码在document上监听那些事件，比如document.onmousemove = MovePic FF中也差不多。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:12:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"元素的位置、大小单位\r通过dom读取元素的top、left、width、height等取到的值不是数字，而是“10px”这样的字符串；为这些属性设值的时候IE可以是80、90这样的数字，FF必须是“80px”、“90%”等这样的字符串形式，为了兼容统一用字符串形式。 易错：不要写成div1.style.width=80px，而是div1.style.width=‘80px’ 如果要修改元素的大小（宽度加10），则首先要取出元素的宽度，然后用parseInt将宽度转换为数字（parseInt可以将\"20px\"这样数字开头的包含其他内容的字符串解析为20，）；然后加上一个值，再加上px赋值回去。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:13:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"层的操作\r元素的position 样式值：static（无定位，显示在默认位置）、absolute（绝对定位）、fixed（相对于窗口的固定定位，位置不会随着浏览器的滚动而变化，IE6不支持）、relative（相对元素默认位置的定位）。如果要通过代码修改元素的坐标则一般使用absolute，然后修改元素的top（上边缘距离）、left（左边缘距离）两个样式值。left、top都是指的层的左上角的坐标 案例：跟着鼠标飞的图片。提示：鼠标移动的事件是onmousemove（一边移动事件一边触发，而不是移动开始或者移动完成才触发），通过window.event的clientX、clientY属性获得鼠标的位置。 案例：放三个超链接，鼠标放上时候动态生成一个层，层显示在鼠标的位置，鼠标离开的时候移除该层removeChild 案例：点击按钮层动态变大。提示：英文字母连续单词不会在中间自动换行的陷阱 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:14:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"易错\r易错：不要写成div1.style.width=80px，而是div1.style.width=‘80px’ 修改元素的样式不能this.style=“background-color:Red”，哪怕可以的话也是把以前所有样式都冲掉了。单独修改控件的样式this.style. background=‘red’，只修改要修改的样式。技巧，没有文档的情况下的值属性名，随便给一个元素设定id，然后在js中就能id.style.出来能用的属性。 createElement的两种用法，注意innerText的问题 var input = document.createElement(\"\")快速创建元素，并且赋值，但是注意设置的inner部分不会被设置var link = document.createElement(\"百度\") label.setAttribute(“for”, “username”); //设定一些Dom元素属性名特殊的属性,label.for = “username\"会有问题。label.setAttribute(“xuehao”,“33333”) ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:15:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"form对象\rdocument.getElementById(‘btn1’).click() form对象是表单的Dom对象。 方法：submit()提交表单，但是不会触发onsubmit事件。 实现autopost，也就是焦点离开控件以后页面立即提交，而不是只有提交submit按钮以后才提交，当光标离开的时候触发onblur事件，在onblur中调用form的submit方法。代码见备注。 在点击submit后form的onsubmit事件被触发，在onsubmit中可以进行数据校验，数据数据有问题，返回false即可取消提交 \u003cform name=\"form1\" action=\"a.aspx\" method=\"get\" onsubmit=\"if(document.getElementById('txtname').value.length\u003c=0){alert('姓名必填');return false;}\"\u003e 自动提交 \u003cform name=\"form1\" action=\"a.aspx\" method=\"get\"\u003e \u003cinput type=\"text\" onblur=\"form1.submit()\" /\u003e \u003cinput type=\"text\" /\u003e \u003c/form\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:16:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"不同浏览器差异\r面试题：说说开发项目的时候不同浏览器的不同点，你是怎么解决的？Button,appendChild,insertCell,px 不同浏览器中对DOM支持的方法不一样 获取网页中那个元素触发了事件：在IE里使用srcElement ；在FireFox里使用target 使用Dom获取和更改网页标签元素内文本：在IE里使用innerText ；在FireFox里使用textContent 动态为网页或元素绑定事件：在IE中绑定事件的方法是attachEvent ；在FireFox中绑定事件的方法是addEventListener 更多http://www.360doc.com/content/09/0319/12/16915_2855107.shtml。 不同浏览器中对CSS的支持不一样，所以出现在IE中显示正常的网页，在FF下全部乱掉了。哀悼网页使用的CSS只有IE支持，FF都不支持。 JQuery之类的框架进行了封装，将不同浏览器的差异帮开发人员处理了，开发人员只要调用JQuery的方法，JQuery会帮助在不同浏览器中进行翻译。用JQuery就可以解决不同浏览器上Dom的不同。对于CSS的不同是美工的事，IETester、FF、Chrome。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:17:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"弹出对话框处理\r复习，使用window.showModalDialog(‘dialog.htm’)弹出模态对话框 给对话框传递参数，使用showModalDialog的第二个参数传递参数，在对话框中用window.dialogArguments获得传递的参数值；对话框中给window.parent.returnValue设定返回值，这样在父窗口中就可以通过showModalDialog返回值读取设置的返回值了。例子：弹出对话框询问用户姓名，向用户问好；弹出含有“是”、“否”、“取消”三个按钮的模态窗口，点击按钮的时候窗口关闭，然后主窗口显示用户点击的按钮。 传递多个参数，将参数包装到数组中，然后仍然是通过第二个参数传递，返回多个返回值也可以返回数组：var arr = new Array();arr[0]=30;arr[1]=“tom”; 练习（面试题），弹出一个含有确定、取消、重试三个按钮的对话框，并且得知用户的选择。 给对话框传递参数，使用showModalDialog的第二个参数传递参数，在对话框中用window.dialogArguments获得传递的参数值；对话框中给window.parent.returnValue设定返回值，这样在父窗口中就可以通过showModalDialog返回值读取设置的返回值了： dialog.htm： function getData() { return document.getElementById('mytext1').value; } \u003cbody onLoad=\"javascript:document.getElementById('mytext1').value=window.dialogArguments;\"\u003e \u003cinput type=\"text\" id=\"mytext1\"/\u003e \u003cinput type=\"button\" value=\"确定\" onclick=\"javascript:window.parent.returnValue=getData();window.close();\"\u003e \u003c/body\u003e 主页面： var result=window.showModalDialog('dialog2.htm',777); alert(result); 传递多个参数，将参数包装到数组中即可：var arr = new Array();arr[0]=30;arr[1]=“tom”; ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:18:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"JS正则表达式\rJavaScript中创建正则表达式类的方法： var regex = new RegExp(”\\d{5}\") 或者 var regex = /\\d{5}/ /表达式/是JavaScript中专门为简化正则表达式编写而提供的语法，写在//中的正则表达式就不用管转义符了。 RegExp对象的方法： （1）test(str)判断字符串str是否匹配正则表达式，相当于IsMatch var regex = /.+@.+/; alert(regex.test(\"a@b.com\")); alert(regex.test(\"ab.com\")); （2）exec(str)进行搜索匹配，返回值为匹配结果，没找到返回null() （3）compile编译表达式，提高运行速度。 () ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:19:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"string 的正则表达\rReplace match String对象中提供了一些与正则表达式相关的方法，相当于对于RegExp类的包装，简化调用： match(regexp)，相当于调用exec var s = \"aaa@163.com\"; var regex = /(.+)@(.+)/; var match = s.match(regex); alert(RegExp.$1 + \"，服务器：\" + RegExp.$2); 练习：光标离开Email地址框的时候用正则表达式校验是否是合法的Email地址，如果不是的话Email地址框变红，并且注册按钮禁用，否则Email地址框颜色为白色，启用注册按钮。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:20:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"HTML JS压缩\rHTML、JavaScript的压缩和混淆。去掉空格、缩短变量名，让js、html尺寸更小，提高下载速度。 HTML、JS压缩、混淆有动态和静态两种方案。HTML压缩器，比如HTML Compress，JavaScript压缩工具：Google Closure Compiler、YUI Compressor 等。 很多js库都提供了.min.js、compress.js的压缩版本。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:21:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"什么是JAVASCRIPT\rHTML只是描述网页长相的标记语言，没有计算、判断能力，如果所有计算、判断（比如判断文本框是否为空、判断两次密码是否输入一致）都放到服务器端执行的话网页的话页面会非常慢、用起来也很难用，对服务器的压力也很大，因此要求能在浏览器中执行一些简单的运算、判断。JavaScript就是一种在浏览器端执行的语言。HTML内容，css衣服，修饰，js控制 JavaScript的Java没直接的关系，唯一的关系就是JavaScript原名LiveScript，后来吸收了Java的一些特性，升级为JavaScript。JavaScript有时被简称为JS。 JavaScript是解释型语言，无需编译就可以随时运行，这样哪怕语法有错误，没有语法错误的部分还是能正确运行。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:1:0","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"JAVASCRIPT开发环境\rVS中JavaScript、JQuery的自动完成功能：在VS2010中直接有，VS2008需要安装VisualStudio 2008SP1（http://www.microsoft.com/downloads/details.aspx?displaylang=zh-cn\u0026familyid=27673c47-b3b5-4c67-bd99-84e525b5ce61）和VS90SP1-KB958502-x86（http://code.msdn.microsoft.com/KB958502/Release/ProjectReleases.aspx?ReleaseId=1736）补丁会更强更好用。如果实在“.” 不出来也没关系，不影响运行。注意：先安装2008SP1，再安装VS90SP1-KB958502-x86。 JS是非常灵活的动态语言，不像C#等静态语言那样严谨，开发工具中的JS完成功能只是一个辅助、建议，“.”出来的成员调用可能不能用，“.”不出来的成员也许也能调用，因此不要因为“点儿不出来”而担心代码有问题。 VS2008的HTML编辑器中触发JavaScript自动完成：Ctrl+J。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:2:0","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"入门\r\u003cscript type=\"text/javascript\"\u003e alert(new Date().toLocaleDateString()); \u003c/script\u003e \u003cscript language=\"....\u003e已经不推荐使用。 JavaScript代码放到\u003cscript\u003e标签中，script可以放到\u003chead\u003e、\u003cbody\u003e等任意位置，而且可以有不止一个\u003cscript\u003e标签。alert函数是弹出消息窗口，new Date()是创建一个Date类的对象，默认值就是当前时间。 JS是大小写敏感的。 放到\u003chead\u003e中的\u003cscript\u003e在body加载之前就已经运行了。写在body中的\u003cscript\u003e是随着页面的加载而一个个执行的。 除了可以在页面中声明JavaScript以外，还可以将JavaScript写到单独的js文件中，然后在页面中引入：\u003cscript src=\"test.js\" type=\"text/javascript\"\u003e\u003c/script\u003e。声明到单独的js文件的好处是多页面也可以共享、减小网络流量。js文件的CDN(*)内容分发布网络(CDN),将别的服务器上的库 注意：不要写成\u003cscript src=\"test.js\" type=\"text/javascript\"/\u003e否则会有问题，这是一个比较特殊的地方。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:0","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"事件\r在超链接的点击里执行JavaScript：\u003ca href=\"javascript:alert(88)\"\u003e发发\u003c/a\u003e JavaScript中也有事件的概念，当按钮被点击的时候也可以执行JavaScript： \u003cinput type=\"button\" onclick=\"alert(99)\" value=\"久久\"/\u003e 只有超链接的href中的JavaScript中才需要加““javascript:”，因为它不是事件，而是把““javascript:”看成像“http:”、“ftp:”、“thunder://”、“ed2k://”、“mailto:”一样的网络协议，交由js解析引擎处理。只有href中这是这是一个特例。 \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e var sum = 0; for(int i = 0;i\u003c=100;i++){ sum += i; } alert(sum); function test() { var sum = 0; for(int i = 0;i\u003c=100;i++){ sum += i; } alert(sum); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003ca href=\"javascript:test()\"\u003eClick me\u003c/a\u003e \u003ca href=\"win.htm\" onclick=\"alert('123')\"\u003eClick me\u003c/a\u003e \u003cinput type=\"button\" value=\"按钮\" ondblclick=\"test()\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:1","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"变量\rJavaScript中即可以使用双引号声明字符串，也可以使用单引号声明字符串。主要是为了方便和html集成，避免转义符的麻烦。只有一种类型var JavaScript中有null、undefined两种，null表示变量的值为空，undefined则表示变量还没有指向任何的对象，未初始化。两者的区别参考资料。 JavaScript是弱类型，声明变量的时候无法：int i=0；只能通过var i=0;声明变量，和C#中的var不一样，不是C#中那样的类型推断。 JavaScript中也可以不用var声明变量，直接用，这样的变量是“全局变量”，因此除非确实想用全局变量，否则使用的时候最好加上var。 JS是动态类型的，因此var i=0;i=“abc”;是合法的。并且可以把方法放到var中， \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e var x = \"abc\"; if (!null) { alert(\"null\"); } if (!undefined) { alert(\"undefined\"); } if (x == null) { alert(\"null\"); } if (typeof(x) == \"undefined\") { alert(\"undefined\"); } if (!x) { alert(\"未初始化 0\"); } if (x) { alert(x); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:2","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"除错和调试\r如果JavaScript中的代码有语法错误，浏览器会弹出报错信息，查看报错信息就能帮助排查错误。 JavaScript的调试，使用VS可以很方便的进行JavaScript的调试，调试时需要注意几点： IE6的调试选项要打开，Internet选项→高级，去掉“禁用脚本调试”前的勾选。 以调试方式运行网页。 设置断点、监视变量等操作和C#一样。 案例：用循环语句的方法计算1到100之间整数的和 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:3","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"判断变量初始化\rJavaScript中判断变量、参数是否初始化 的三种方法： var x; if (x == null) { alert(\"null\"); } if (typeof (x) == \"undefined\") { alert('undefined'); } if (!x) {alert('不x');} if(x){}//变量被初始化了或者变量不为空或者变量不为0. 推荐用最后一种方法。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:4","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"函数声明\rJavaScript中声明函数的方式： function add(i1, i2) { return i1 + i2; } int add(int i1,int i2)//C#写法 不需要声明返回值类型、参数类型。函数定义以function开头。 var r = add(1, 2); alert(r); r = add(\"你好\", \"tom\"); alert(r); JavaScript中不像C#中那样要求所有路径都有返回值，没有返回值就是undefined。 易错：自定义函数名不要和js内置、dom内置方法重名，比如selectall、focus等函数名不要用。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:5","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"匿名函数\rvar f1 = function(i1, i2) { return i1 + i2; } alert(f1(1,2)); 类似于C#中的匿名函数。 这种匿名函数的用法在JQuery中的非常多 alert(function(i1, i2) { return i1 + i2; }(10,10));//直接声明一个匿名函数，立即使用。用匿名函数省得定义一个用一次就不用的函数，而且免了命名冲突的问题，js中没有命名空间的概念，因此很容易函数名字冲突。通过例子发现一旦命名冲突以最后声明的为准 必须\u003cscript src=\"my1.js\" type=\"text/javascript\"\u003e\u003c/script\u003e不能：\u003cscript src=\"my1.js\" type=\"text/javascript\"/\u003e ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:6","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"面向对象基础\rJavaScript中没有类的语法，是用函数闭包（closure）模拟出来的，下面讲解的时候还是用C#中的类、构造函数的概念，JavaScript中String、Date等“类”都被叫做“对象”，挺怪，方便初学者理解，不严谨。JavaScript中声明类（类不是类，是对象）： function Person(name,age) { this.name = name; this.age =age; this.sayHello=function(){ alert(\"你好，我是\"+this.name+\"，我\"+this.age+\"岁了\"); } } var p1 = new Person(\"tom\",20); p1.sayHello(); 必须要声明类名，function Person(name,age)可以看做是声明构造函数，Name、Age这些属性也是使用者动态添加了。var p1 = new Person(“tom”, 30);//不要丢了new，否则就变成调用函数了，p1为undefined。new 相当于创建了函数的一个实例 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:7","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"string 对象\rlength属性； charAt方法；取第几个字符 indexOf lastIndexOf Substr(start,length)、substring(start,end) split match、replace(只会替换一个，替换多个要用正则表达式)、search方法，正则表达式相关 var str = \"我爱北京天安门,北京天安门爱我\"; var reg = /我/g; alert(str.replace(\"我\", \"你\")); //replace()当第一个参数是字符串，只替换源字符串中的第一个匹配到的字符 如果是reg，就可以全部替换成功alert(str.replace(reg, \"你\")); 是正则表达式，是一个object ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:8","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"ARRAY对象\rJavaScript中的Array对象就是数组，首先是一个动态数组，而且是一个像C#中数组、ArrayList、Hashtable等的超强综合体。 var names = new Array(); names[0] = \"tom\"; names[1] = \"jerry\"; names[2] = \"lily\"; for (var i = 0; i \u003c names.length; i++) { alert(names[i]); } 无需预先制定大小，动态。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:9","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"dictionary\rJS中的Array是一个宝贝，不仅是一个数组，还是一个Dictionary，还是一个Stack。 var pinyins = new Array(); pinyins[\"人\"] = \"ren\"; pinyins[\"口\"] = \"kou\"; pinyins[\"手\"] = \"shou\"; alert(pinyins[\"人\"]); alert(pinyins.人); 像Hashtable、Dictionary那样用，而且像它们一样效率高。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:10","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"array简化\rArray还可以有简化的创建方式 var arr = [3, 5, 6, 8, 9]; 普通数组初始化 这种数组可以看做是pinyins[“人”] = “ren”;的特例，也就是key为0、1、2…… 字典风格的简化创建方式： var arr = {\"tom\":30,\"jim\":20}; ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:11","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"数组，for其他\r对于数组风格的Array来说，可以使用join方法拼接为字符串 var arr = [\"tom\",\"jim\",\"lily\"];\ralert(arr.join(\",\"));//JS中join是array的方法，不像.Net中是string的方法 for循环可以像C#中的foreach一样用 for循环还可以获得一个对象所有的成员，类似于.Net中的反射 for (var e in document) { alert(e); } 有了它没有文档也可以进行开发。 var p1 = new Object();//创建一个Object对象，动态增加属性、方法s p1.Name = \"tom\"; p1.Age = 30; p1.SayHello = function() { alert(\"hello\"); }; p1.SayHello(); for(var e in p1) {//对象的成员都是对象的key alert(e); } ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:12","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"扩展方法\r通过类对象的prototype设置扩展方法，下面为String对象增加quote（两边加字符）方法 String.prototype.quote = function(quotestr) { if (!quotestr) { quotestr = \"\\\"\"; } return quotestr + this + quotestr; }; alert(\"abc\".quote());alert(\"abc\".quote(\"|\")); 扩展方法的声明要在使用扩展方法之前执行。JS的函数没有专门的函数默认值的语法，但是可以不给参数传值，不传值的参数值就是undefined，自己做判断来给默认值。 一门新的语言学：数据类型，程序接口，类库 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:13","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"DotNet基础","content":"在windows form开发过程中还是有很多坑需要注意，包括一些重要代码记不得，在这个文件中进行汇总更新。 ","date":"2018-12-05","objectID":"/2018/12/dotnetbase5-winform/:0:0","tags":["DotNet基础","winform"],"title":"DotNet基础 winform","uri":"/2018/12/dotnetbase5-winform/"},{"categories":"DotNet基础","content":"命名规则\rM结尾表示model A结尾表示消息 Object表示 ,底层接口 Presenter表示，逻辑类 Transaction表示，具体逻辑 View表示界面接口 Helper：表示静态函数 Statements：表示字符串 E表示enum ~BTN按钮 私有变量m_ 获得Get 建立Build 生成Generate listbox 为 LB ","date":"2018-12-05","objectID":"/2018/12/dotnetbase5-winform/:1:0","tags":["DotNet基础","winform"],"title":"DotNet基础 winform","uri":"/2018/12/dotnetbase5-winform/"},{"categories":"DotNet基础","content":"一个项目体验\rusing System; using System.Windows.Forms; namespace AerationSystem { static class Program { /// \u003csummary\u003e /// 应用程序的主入口点。 /// \u003c/summary\u003e [STAThread] static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); GetAllFrom getform = new GetAllFrom(); getform.MakeLoginForm(); getform.login.ShowDialog(); if(getform.login.DialogResult==DialogResult.OK) { getform.MakeAllForm(); Application.Run(getform.currentMain); //Application.Run(new Form1()); } } } } 读取xml标签类 public class XMLHelper { /// \u003csummary\u003e /// 读取多行同一标签属性 /// \u003c/summary\u003e /// \u003cparam name=\"filename\"\u003e地址\u003c/param\u003e /// \u003cparam name=\"nodeflag\"\u003e标签\u003c/param\u003e /// \u003cparam name=\"strflag\"\u003e属性\u003c/param\u003e /// \u003creturns\u003e多行同一标签属性\u003c/returns\u003e public static string[] ReadMultipleTagOneAttribute(string filename,string nodeflag, string strflag) { try { XmlDocument xl = new XmlDocument(); xl.Load(filename); XmlNodeList xnl = xl.GetElementsByTagName(\"appSettings\")[0].ChildNodes; List\u003cstring\u003e vs = new List\u003cstring\u003e(); foreach (XmlNode cn in xnl) { if (cn.Name.Equals(nodeflag)) { vs.Add(cn.Attributes.GetNamedItem(strflag).Value); } } return vs.ToArray(); } catch (Exception ex) { Console.WriteLine(ex.StackTrace + ex.Message); } return null; } /// \u003csummary\u003e /// 读取同一标签多个属性,如果有多个同标签则返回null /// \u003c/summary\u003e /// \u003cparam name=\"filename\"\u003e地址\u003c/param\u003e /// \u003cparam name=\"nodeflag\"\u003e标签\u003c/param\u003e /// \u003cparam name=\"strflag\"\u003e多个属性\u003c/param\u003e /// \u003creturns\u003e多个属性值\u003c/returns\u003e public static string[] ReadMultipleAttributeOneTag(string filename, string nodeflag, string[] strflag) { try { XmlDocument xl = new XmlDocument(); xl.Load(filename); XmlNodeList xnl = xl.GetElementsByTagName(\"appSettings\")[0].ChildNodes; List\u003cstring\u003e vs = new List\u003cstring\u003e(); int tagcount = 0; foreach (XmlNode cn in xnl) { if (cn.Name.Equals(nodeflag)) { foreach (string s in strflag) { vs.Add(cn.Attributes.GetNamedItem(s).Value); } tagcount++; } } if (tagcount \u003e 1) { throw new Exception(\"出现多个相同标签\"); } return vs.ToArray(); } catch (Exception ex) { Console.WriteLine(ex.StackTrace + ex.Message); } return null; } } SQLHelper类 public class SQLDatabaseHelper { /// \u003csummary\u003e /// 返回多个表 /// \u003c/summary\u003e /// \u003cparam name=\"dbname\"\u003e数据库URL\u003c/param\u003e /// \u003cparam name=\"sqlstr\"\u003e执行语句\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static DataSet QueryDs(String dbname, String sqlstr) { OleDbConnection Connection = new OleDbConnection(dbname); try { Connection.Open(); OleDbDataAdapter oleDbAdapter = new OleDbDataAdapter(sqlstr, Connection); DataSet ds = new DataSet(); oleDbAdapter.Fill(ds); return ds; } catch (Exception ex) { Console.WriteLine(\"打开数据库连接异常:\" + ex.Message + \"\\r\\n\"); } finally { Connection.Close(); } return null; } /// \u003csummary\u003e /// 执行语句返会受影响函数 /// \u003c/summary\u003e /// \u003cparam name=\"dbname\"\u003e数据库URL\u003c/param\u003e /// \u003cparam name=\"sqlstr\"\u003e执行语句\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static int Execute(String dbname, String sqlstr) { OleDbConnection Connection = new OleDbConnection(dbname); try { Connection.Open(); OleDbCommand oleDbCommand = new OleDbCommand(sqlstr, Connection); return oleDbCommand.ExecuteNonQuery(); } catch (Exception ex) { Console.WriteLine(ex.Message); } finally { Connection.Close(); } return 0; } /// \u003csummary\u003e /// 执行多条语句 /// \u003c/summary\u003e /// \u003cparam name=\"dbname\"\u003e数据库url\u003c/param\u003e /// \u003cparam name=\"sqlstrs\"\u003e受影响的行数\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static int ExecuteAll(string dbname, string[] sqlstrs) { int count = 0; foreach (string s in sqlstrs) { count = count + Execute(dbname, s); } return count; } /// \u003csummary\u003e /// 返回表 /// \u003c/summary\u003e /// \u003cparam name=\"dbname\"\u003e数据库URL\u003c/param\u003e /// \u003cparam name=\"sqlstr\"\u003e执行语句\u003c/param\u003e /// \u003creturns\u003e受影响行数\u003c/returns\u003e public static DataTable QueryDt(String dbname, String sqlstr) { OleDbConnection Connection = new OleDbConnection(dbname); try { Connection.Open(); OleDbDataAdapter oleDbAdapter = new OleDbDataAdapter(sqlstr, Connection); OleDbCommandBuilder oleDbBuilder = new OleDbCommandBuilder(oleDbAdapter); DataSet ds = new DataSet(); oleDbAdapter.Fill(ds); return ds.Tables[0]; } catch (Exception ex) { Console.Writ","date":"2018-12-05","objectID":"/2018/12/dotnetbase5-winform/:2:0","tags":["DotNet基础","winform"],"title":"DotNet基础 winform","uri":"/2018/12/dotnetbase5-winform/"},{"categories":"DotNet基础","content":"自定义控件\rScreen.PrimaryScreen.WorkingArea.Width;获取桌面宽度，hight高度 this.size程序宽度 base.Invalidate(this.MenuRect)重绘矩形区域 this.FormBorderStyle = FormBorderStyle.None;无边框 this.SetStyle( ControlStyles.AllPaintingInWmPaint | ControlStyles.OptimizedDoubleBuffer | ControlStyles.ResizeRedraw | ControlStyles.Selectable | ControlStyles.ContainerControl | ControlStyles.UserPaint, true); this.SetStyle(ControlStyles.Opaque, false); this.UpdateStyles(); 绘制控件样式 Graphics g = e.Graphics;获取画布，如果是创建的使用完后要注销 FormWindowState.Maximized窗口状态 FormStartPosition.CenterParent窗体开启位置 继承form的重载类中WndProc有窗体循环，在该循环中提前捕获消息进行拦截。 设置背景图片 totalpic.ImageLocation = System.Windows.Forms.Application.StartupPath + “\\img\\” + comboBox2.Text.ToString() + “.jpg”; 使得panel1不可见的时候panel2填满panel1的区域，让panel1的dock设置为top，panel2的dock设置为fill。 ","date":"2018-12-05","objectID":"/2018/12/dotnetbase5-winform/:3:0","tags":["DotNet基础","winform"],"title":"DotNet基础 winform","uri":"/2018/12/dotnetbase5-winform/"},{"categories":"DotNet基础","content":"多线程和异步函数\r当异步线程在工作完成时如何通知调用线程 当异步线程出现异常的时候该如何处理 异步线程工作的进度如何实时的通知调用线程 如何在调用线程中取消正在工作的异步线程，并进行回滚操作 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:1:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"异步函数模型\r异步函数编程模式，只要是使用委托对象封装的函数都可以实现该函数的异步调用。因为委托类型有BeginInvoke和EndInvoke这两个方法来支持异步调用。 BeginInvoke无参数 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate void DoWork(); static void Main(string[] args) { DoWork d = new DoWork(WorkPro); d.BeginInvoke(null, null); for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread: {i}\"); } Console.WriteLine(\"Main Thread Done\"); Console.ReadKey(); } private static void WorkPro() { for (int i = 0; i \u003c 10; i++) { Thread.Sleep(10); Console.WriteLine($\"Asyn Thread: {i}\"); } Console.WriteLine(\"Asyn Thread Done\"); } } } 结果 Main Thread: 0 Asyn Thread: 0 Main Thread: 1 Asyn Thread: 1 Main Thread: 2 Asyn Thread: 2 Main Thread: 3 Asyn Thread: 3 Main Thread: 4 Main Thread Done Asyn Thread: 4 Asyn Thread: 5 Asyn Thread: 6 Asyn Thread: 7 Asyn Thread: 8 Asyn Thread: 9 Asyn Thread Done BeginInvoke有参数， BeginInvoke，IAsyncResult ，EndInvoke，使用这三个函数会等，异步调用EndInvoke返回再开启主线程，异步调用时间比主线程长，主线程会处于阻塞状态，阻塞位置在EndInvoke函数 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { DoWork d = new DoWork(WorkPro); IAsyncResult r = d.BeginInvoke(1000, null, null); int result = d.EndInvoke(r); Console.WriteLine($\"Asyn result:{result}\"); for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread: {i}\"); } Console.WriteLine(\"Main Thread Done\"); Console.ReadKey(); } private static int WorkPro(int count) { int sum = 0; for (int i = 0; i \u003c 10; i++) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread: {i}\"); } Console.WriteLine(\"Asyn Thread Done\"); return sum; } } } 结果： Asyn Thread: 0 Asyn Thread: 1 Asyn Thread: 2 Asyn Thread: 3 Asyn Thread: 4 Asyn Thread: 5 Asyn Thread: 6 Asyn Thread: 7 Asyn Thread: 8 Asyn Thread: 9 Asyn Thread Done Asyn result:45 Main Thread: 0 Main Thread: 1 Main Thread: 2 Main Thread: 3 Main Thread: 4 Main Thread Done 当调整EndInvoke的位置时， using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { DoWork d = new DoWork(WorkPro); IAsyncResult r = d.BeginInvoke(1000, null, null); for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread: {i}\"); } int result = d.EndInvoke(r); Console.WriteLine($\"Asyn result:{result}\"); Console.WriteLine(\"Main Thread Done\"); Console.ReadKey(); } private static int WorkPro(int count) { int sum = 0; for (int i = 0; i \u003c 10; i++) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread: {i}\"); } Console.WriteLine(\"Asyn Thread Done\"); return sum; } } } 结果： Main Thread: 0 Asyn Thread: 0 Main Thread: 1 Asyn Thread: 1 Main Thread: 2 Asyn Thread: 2 Main Thread: 3 Asyn Thread: 3 Main Thread: 4 Asyn Thread: 4 Asyn Thread: 5 Asyn Thread: 6 Asyn Thread: 7 Asyn Thread: 8 Asyn Thread: 9 Asyn Thread Done Asyn result:45 Main Thread Done 主线程执行时间比异步调用的长，并未看见阻塞 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { DoWork d = new DoWork(WorkPro); IAsyncResult r = d.BeginInvoke(1000, null, null); for (int i = 0; i \u003c 10; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread: {i}\"); } int result = d.EndInvoke(r); Console.WriteLine($\"Asyn result:{result}\"); Console.WriteLine(\"Main Thread Done\"); Console.ReadKey(); } private static int WorkPro(int count) { int sum = 0; for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread: {i}\"); } Console.WriteLine(\"Asyn Thread Done\"); return sum; } } } Main","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:1:1","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"自动通知主线程完成\r上面两个例子这并不是理想的状态，理想状态是，异步调用完成后自动通知主线程完成，主线程调用。 BeginInvoke 方法启动异步调用。该方法具有与你要异步执行的方法相同的参数，另加两个可选参数。 第一个参数是一个 AsyncCallback 委托，此委托引用在异步调用完成时要调用的方法。 第二个参数是一个用户定义的对象object，该对象将信息传递到回调方法。 BeginInvoke 将立即返回，而不会等待异步调用完成。 BeginInvoke 返回可用于监视异步调用的进度的 IAsyncResult。 EndInvoke 方法用于检索异步调用的结果。 它可以在调用 BeginInvoke之后的任意时间调用。 如果异步调用尚未完成，那么 EndInvoke 将阻止调用线程，直到完成异步调用。 EndInvoke 的参数包括要异步执行的方法的 out 和 ref 参数，以及 BeginInvoke 返回的 IAsyncResult。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { DoWork d = new DoWork(WorkPro); IAsyncResult r = d.BeginInvoke(1000, CallBack, d); for (int i = 0; i \u003c 10; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread: {i}\"); } Console.WriteLine(\"Main Thread Done\"); Console.ReadKey(); } private static int WorkPro(int count) { int sum = 0; for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread: {i}\"); } Console.WriteLine(\"Asyn Thread Done\"); return sum; } public static void CallBack(IAsyncResult r) { DoWork d = (DoWork)r.AsyncState; Console.WriteLine($\"Asyn result:{d.EndInvoke(r)}\"); } } } Main Thread: 0 Asyn Thread: 0 Main Thread: 1 Asyn Thread: 1 Main Thread: 2 Asyn Thread: 2 Main Thread: 3 Asyn Thread: 3 Main Thread: 4 Asyn Thread: 4 Asyn Thread Done Asyn result:10 Main Thread: 5 Main Thread: 6 Main Thread: 7 Main Thread: 8 Main Thread: 9 Main Thread Done 改进查看CallBack的执行情况 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { DoWork d = new DoWork(WorkPro); IAsyncResult r = d.BeginInvoke(1000, CallBack, d); for (int i = 0; i \u003c 10; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread: {i}\"); } Console.WriteLine(\"Main Thread Done\"); Console.ReadKey(); } private static int WorkPro(int count) { int sum = 0; for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread: {i}\"); } Console.WriteLine(\"Asyn Thread Done\"); return sum; } public static void CallBack(IAsyncResult r) { for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"CallBack: {i}\"); } DoWork d = (DoWork)r.AsyncState; Console.WriteLine($\"Asyn result:{d.EndInvoke(r)}\"); } } } Main Thread: 0 Asyn Thread: 0 Main Thread: 1 Main Thread: 2 Asyn Thread: 1 Asyn Thread: 2 Main Thread: 3 Asyn Thread: 3 Main Thread: 4 Asyn Thread: 4 Asyn Thread Done Main Thread: 5 Main Thread: 6 CallBack: 0 Main Thread: 7 CallBack: 1 Main Thread: 8 CallBack: 2 Main Thread: 9 Main Thread Done CallBack: 3 CallBack: 4 Asyn result:10 回调函数也处于另一个线程中，与主线程并行执行，并且执行时间不等 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:1:2","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"正常的线程调用\r.net在System.Threading和System.Threading.Tasks这两个命名空间中提供了Thread，ThreadPool，和Task三个类来处理多线程的问题，其中Thread是建立一个专用线程，ThreadPool是使用线程池中工作线程，而Task类是采用任务的方式，其内部也是使用线程池中的工作线程。 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:2:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"Thread类\r使用方法很简单，它开辟的是一个专用线程，不是线程池中的工作线程，不由线程池去管理。该类提供4个重载版本，常见的使用前面两个就好了。 public Thread( ThreadStart start )：其中ThreadStart是一个无参无返回值的委托类型。 public Thread( ParameterizedThreadStart start )：其中ParameterizedThreadStart 是一个带有一个Object类型的参数，无返回值的委托类型。 从Thread类提供了两个构造函数可以看出，Thread类能够异步调用无参无返回值的函数，也能够异步调用带一个Object类型的无返回值的函数。下面就给出一个例子简单的演示一下如何使用Thread异步执行一个带参数的函数。 using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { class Program { int interval = 200; static void Main(string[] args) { Program p = new Program(); Thread nonParameterThread = new Thread(new ThreadStart(p.NonParameterRun)); nonParameterThread.Start(); } /// \u003csummary\u003e /// 不带参数的启动方法 /// \u003c/summary\u003e public void NonParameterRun() { for (int i = 0; i \u003c 10; i++) { Console.WriteLine(\"系统当前时间毫秒值：\"+DateTime.Now.Millisecond.ToString()); Thread.Sleep(interval);//让线程暂停 } } } } 结果： 系统当前时间毫秒值：384 系统当前时间毫秒值：591 系统当前时间毫秒值：792 系统当前时间毫秒值：993 系统当前时间毫秒值：194 系统当前时间毫秒值：394 系统当前时间毫秒值：595 系统当前时间毫秒值：796 系统当前时间毫秒值：997 系统当前时间毫秒值：198 请按任意键继续. . . ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:2:1","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"带参数的线程\r线程输出10个值后就终止执行了，用ThreadStart委托作为构造函数来实例化thread是不带参数的，带参数的委托ParameterizedThreadStart，其带有一个Object参数的方法 using System; using System.Threading; namespace StartThread { class Program { int interval = 200; static void Main(string[] args) { Program p = new Program(); Thread parameterThread = new Thread(new ParameterizedThreadStart(p.ParameterRun)); parameterThread.Name = \"Thread A:\"; parameterThread.Start(5); } /// \u003csummary\u003e /// 带参数的启动方法 /// \u003c/summary\u003e /// \u003cparam name=\"ms\"\u003e让线程在运行过程中的休眠间隔\u003c/param\u003e public void ParameterRun(object ms) { int j = 10; int.TryParse(ms.ToString(), out j);//这里采用了TryParse方法，避免不能转换时出现异常 for (int i = 0; i \u003c j; i++) { Console.WriteLine(Thread.CurrentThread.Name + \"系统当前时间毫秒值：\" + DateTime.Now.Millisecond.ToString()); Thread.Sleep(j);//让线程暂停 } } } } 结果： Thread A:系统当前时间毫秒值：127 Thread A:系统当前时间毫秒值：136 Thread A:系统当前时间毫秒值：142 Thread A:系统当前时间毫秒值：148 Thread A:系统当前时间毫秒值：154 请按任意键继续. . . ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:3:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"两个线程参数不一样\r第一个线程启动后，线程实例就不需要存在了 两个线程间隔时间不一样 using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { class Program { int interval = 200; static void Main(string[] args) { Program p = new Program(); Thread parameterThread = new Thread(new ParameterizedThreadStart(p.ParameterRun)); parameterThread.Name = \"Thread A:\"; parameterThread.Start(30); //启动第二个线程 parameterThread = new Thread(new ParameterizedThreadStart(p.ParameterRun)); parameterThread.Name = \"Thread B:\"; parameterThread.Start(60); } /// \u003csummary\u003e /// 带参数的启动方法 /// \u003c/summary\u003e /// \u003cparam name=\"ms\"\u003e让线程在运行过程中的休眠间隔\u003c/param\u003e public void ParameterRun(object ms) { int j = 10; int.TryParse(ms.ToString(), out j);//这里采用了TryParse方法，避免不能转换时出现异常 for (int i = 0; i \u003c 10; i++) { Console.WriteLine(Thread.CurrentThread.Name+\"系统当前时间毫秒值：\" + DateTime.Now.Millisecond.ToString()); Thread.Sleep(j);//让线程暂停 } } } } 结果： Thread A:系统当前时间毫秒值：294 Thread B:系统当前时间毫秒值：294 Thread A:系统当前时间毫秒值：326 Thread B:系统当前时间毫秒值：357 Thread A:系统当前时间毫秒值：357 Thread A:系统当前时间毫秒值：388 Thread B:系统当前时间毫秒值：418 Thread A:系统当前时间毫秒值：419 Thread A:系统当前时间毫秒值：450 Thread B:系统当前时间毫秒值：479 Thread A:系统当前时间毫秒值：481 Thread A:系统当前时间毫秒值：511 Thread B:系统当前时间毫秒值：540 Thread A:系统当前时间毫秒值：543 Thread A:系统当前时间毫秒值：574 Thread B:系统当前时间毫秒值：600 Thread B:系统当前时间毫秒值：661 Thread B:系统当前时间毫秒值：723 Thread B:系统当前时间毫秒值：784 Thread B:系统当前时间毫秒值：845 请按任意键继续. . . ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:4:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"传递多参数\r如果需要传递两个参数怎么办呢，有两种方法 调用ParameterizedThreadStart，将参数封装成类，或者结构进行调用 构造线程类，将自己的线程和参数封装在一起 using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { class MyThreadParameter { private int interval; private int loopCount; /// \u003csummary\u003e /// 循环次数 /// \u003c/summary\u003e public int LoopCount { get { return loopCount; } } /// \u003csummary\u003e /// 线程的暂停间隔 /// \u003c/summary\u003e public int Interval { get { return interval; } } /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e /// \u003cparam name=\"interval\"\u003e线程的暂停间隔\u003c/param\u003e /// \u003cparam name=\"loopCount\"\u003e循环次数\u003c/param\u003e public MyThreadParameter(int interval,int loopCount) { this.interval = interval; this.loopCount = loopCount; } } class Program { int interval = 200; static void Main(string[] args) { Program p = new Program(); Thread parameterThread = new Thread(new ParameterizedThreadStart(p.MyParameterRun)); parameterThread.Name = \"Thread A:\"; MyThreadParameter paramter = new MyThreadParameter(50, 5); parameterThread.Start(paramter); } /// \u003csummary\u003e /// 带多个参数的启动方法 /// \u003c/summary\u003e /// \u003cparam name=\"ms\"\u003e方法参数\u003c/param\u003e public void MyParameterRun(object ms) { MyThreadParameter parameter = ms as MyThreadParameter;//类型转换 if (parameter != null) { for (int i = 0; i \u003c parameter.LoopCount; i++) { Console.WriteLine(Thread.CurrentThread.Name + \"系统当前时间毫秒值：\" + DateTime.Now.Millisecond.ToString()); Thread.Sleep(parameter.Interval);//让线程暂停 } } } } } 结果： Thread A:系统当前时间毫秒值：215 Thread A:系统当前时间毫秒值：270 Thread A:系统当前时间毫秒值：321 Thread A:系统当前时间毫秒值：372 Thread A:系统当前时间毫秒值：423 请按任意键继续. . . using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { class MyThreadParameter { private int interval; private int loopCount; private Thread thread; /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e /// \u003cparam name=\"interval\"\u003e线程的暂停间隔\u003c/param\u003e /// \u003cparam name=\"loopCount\"\u003e循环次数\u003c/param\u003e public MyThreadParameter(int interval,int loopCount) { this.interval = interval; this.loopCount = loopCount; thread = new Thread(new ThreadStart(Run)); } public void Start() { if (thread != null) { thread.Start(); } } private void Run() { for (int i = 0; i \u003c loopCount; i++) { Console.WriteLine(\"系统当前时间毫秒值：\" + DateTime.Now.Millisecond.ToString()); Thread.Sleep(interval);//让线程暂停 } } } class Program { static void Main(string[] args) { MyThreadParameter parameterThread = new MyThreadParameter(30, 5); parameterThread.Start(); } } } 结果 系统当前时间毫秒值：438 系统当前时间毫秒值：471 系统当前时间毫秒值：502 系统当前时间毫秒值：533 系统当前时间毫秒值：563 请按任意键继续. . . ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:5:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"多线程同干一件事\r多线程同干一件事的时候对发生一些问题 using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { public class ThreadLock { private Thread threadOne; private Thread threadTwo; private List\u003cstring\u003e ticketList; private object objLock = new object(); public ThreadLock() { threadOne = new Thread(new ThreadStart(Run)); threadOne.Name = \"Thread_1\"; threadTwo = new Thread(new ThreadStart(Run)); threadTwo.Name = \"Thread_2\"; } static void Main(string[] args) { ThreadLock th = new ThreadLock(); th.Start(); } public void Start() { ticketList = new List\u003cstring\u003e(10); for (int i = 1; i \u003c= 10; i++) { ticketList.Add(i.ToString().PadLeft(3, '0'));//实现3位的票号，如果不足3位数，则以0补足3位 } threadOne.Start(); threadTwo.Start(); } private void Run() { while (ticketList.Count \u003e 0)//① { string ticketNo = ticketList[0];//② Console.WriteLine(\"{0}:售出一张票，票号：{1}\", Thread.CurrentThread.Name, ticketNo); ticketList.RemoveAt(0);//③ Thread.Sleep(1); } } } } 结果： Thread_1:售出一张票，票号：001 Thread_2:售出一张票，票号：001 Thread_1:售出一张票，票号：003 Thread_2:售出一张票，票号：004 Thread_1:售出一张票，票号：005 Thread_2:售出一张票，票号：006 Thread_1:售出一张票，票号：007 Thread_2:售出一张票，票号：008 Thread_1:售出一张票，票号：008 Thread_2:售出一张票，票号：010 Thread_1:售出一张票，票号：010 未经处理的异常: System.ArgumentOutOfRangeException: 索引超出范围。必须为非负值并小于集合大小。 参数名: index 在 System.ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource) 在 System.Collections.Generic.List`1.RemoveAt(Int32 index) 在 StartThread.ThreadLock.Run() 位置 C:\\Users\\DuJinfeng\\Desktop\\C#源码\\test\\test\\练习\\test\\Program.cs:行号 79 在 System.Threading.ThreadHelper.ThreadStart_Context(Object state) 在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) 在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) 在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state) 在 System.Threading.ThreadHelper.ThreadStart() 请按任意键继续. . . 该程序在③处会出现问题，如果第一个线程在③处的时间片段正好用完第二个线程调用就会出现一张票被卖两次的问题 同步问题的解决方法： lock、 Mutex、 Monitor、 Semaphore、 Interlocked ReaderWriterLock等 同步策略可以有同步上下文、同步代码区、手动同步 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"上下文同步策略\r上下文同步： 同步上下文的策略主要是依靠SynchronizationAttribute类来实现 using System; using System.Collections.Generic; using System.Text; //需要添加对System.EnterpriseServices.dll这个类库的引用采用使用这个dll using System.EnterpriseServices; namespace StartThread { [Synchronization(SynchronizationOption.Required)]//确保创建的对象已经同步 public class SynchronizationAttributeClass { public void Run() { } } } 所有在同一个上下文域的对象共享同一个锁。这样创建的对象实例属性、方法和字段就具有线程安全性，需要注意的是类的静态字段、属性和方法是不具有线程安全性的。 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:1","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"同步代码区\r同步代码区是另外一种策略，它是针对特定部分代码进行同步的一种方法 lock同步 private void Run() { while (ticketList.Count \u003e 0)//① { lock (objLock) { if (ticketList.Count \u003e 0)//必须要再一次判断在1之后可能进入其他线程 { string ticketNo = ticketList[0];//② Console.WriteLine(\"{0}:售出一张票，票号：{1}\", Thread.CurrentThread.Name, ticketNo); ticketList.RemoveAt(0);//③ Thread.Sleep(1); } } } } Monitor类同步 private void Run() { while (ticketList.Count \u003e 0)//① { Monitor.Enter(objLock); if (ticketList.Count \u003e 0) { string ticketNo = ticketList[0];//② Console.WriteLine(\"{0}:售出一张票，票号：{1}\", Thread.CurrentThread.Name, ticketNo); ticketList.RemoveAt(0);//③ Thread.Sleep(1); } Monitor.Exit(objLock); } } 使用lock关键字的代码实际上是用Monitor来实现的。 lock (objLock){ //同步代码 } //等价于 try{ Monitor.Enter(objLock); //同步代码 } finally { Monitor.Exit(objLock); } Monitor类除了Enter()和Exit()方法之外，还有Wait()和Pulse()方法。 Wait()方法是临时释放当前活得的锁，并使当前对象处于阻塞状态 Pulse()方法是通知处于等待状态的对象可以准备就绪了，它一会就会释放锁 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Collections; using System.Threading; public class ThreadDemo { private Thread threadOne; private Thread threadTwo; private ArrayList stringList; private event EventHandler OnNumberClear;//数据删除完成引发的事件 public static void Main() { ThreadDemo demo = new ThreadDemo(10); demo.Action(); Console.ReadKey(); } public ThreadDemo(int number) { Random random = new Random(100); stringList = new ArrayList(number); for (int i = 0; i \u003c number; i++) { stringList.Add(random.Next().ToString()); } threadOne = new Thread(new ThreadStart(Run));//两个线程共同做一件事情 threadTwo = new Thread(new ThreadStart(Run));//两个线程共同做一件事情 threadOne.Name = \"线程1\"; threadTwo.Name = \"线程2\"; for (int i = 0; i \u003c number; i++) { Console.WriteLine($\"主线程1：{i.ToString()}\"); } OnNumberClear += new EventHandler(ThreadDemo_OnNumberClear); } /// \u003csummary\u003e /// 开始工作 /// \u003c/summary\u003e public void Action() { threadOne.Start(); threadTwo.Start(); } /// \u003csummary\u003e /// 共同做的工作 /// \u003c/summary\u003e private void Run() { string stringValue = null; while (true) { Monitor.Enter(this);//锁定，保持同步 stringValue = (string)stringList[0]; Console.WriteLine(Thread.CurrentThread.Name + \"删除了\" + stringValue); stringList.RemoveAt(0);//删除ArrayList中的元素 if (stringList.Count == 0) { OnNumberClear(this, new EventArgs());//引发完成事件 } Monitor.Exit(this);//取消锁定 Thread.Sleep(5); } } //执行完成之后，停止所有线程 void ThreadDemo_OnNumberClear(object sender, EventArgs e) { Console.WriteLine(\"执行完了，停止了所有线程的执行。\"); threadTwo.Abort(); threadOne.Abort();//终止线程调用 } } 结果： 主线程1：0 主线程1：1 主线程1：2 主线程1：3 主线程1：4 主线程1：5 主线程1：6 主线程1：7 主线程1：8 主线程1：9 线程1删除了2080427802 线程2删除了341851734 线程1删除了1431988776 线程2删除了1938005744 线程1删除了761513014 线程2删除了2037243568 线程1删除了1528357293 线程2删除了1311292502 线程1删除了749943798 线程2删除了319576108 执行完了，停止了所有线程的执行。 using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { public class ThreadWaitAndPluse { private object lockObject; private int number; private Random random; public ThreadWaitAndPluse() { lockObject = new object(); random = new Random(); } //显示生成数据的线程要执行的方法 public void ThreadMethodOne() { Monitor.Enter(lockObject);//获取对象锁 Console.WriteLine(\"当前进入的线程：\" + Thread.CurrentThread.GetHashCode()); for (int i = 0; i \u003c 5; i++) { Monitor.Wait(lockObject);//释放对象锁，并阻止当前线程 Console.WriteLine(\"WaitAndPluse1:工作\"); Console.WriteLine(\"WaitAndPluse1:得到了数据，number=\" + number + \",Thread ID=\" + Thread.CurrentThread.GetHashCode()); //通知其它等待锁的对象状态已经发生改变,当这个对象释放锁之后等待锁的对象将会活得锁 Monitor.Pulse(lockObject); } Console.WriteLine(\"退出当前线程：\" + Thread.CurrentThread.GetHashCode()); Monitor.Exit(lockObject);//释放对象锁 } //生成随机数据线程要执行的方法 public void ThreadMethodTwo() { Monitor.Enter(lockObject);//获取对象锁 Console.WriteLine(\"当前进入的线程：\" + Thread.CurrentThread.GetHashCode()); for (int i = 0; i \u003c 5; i++) { //通知其它等待锁的对象状态已经发生改变,当这个对象释放锁之后等待锁的对象将会活得锁 Monitor.Pulse(lockObject); Console.WriteLine(\"WaitAndPluse2:工作\"); number =random.Next(DateTime.Now.Millisecond);//生成随机数 Console.WriteLine(\"WaitAndPluse2:生成了数据，number=\" + number + \",Thread ID=\"","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:2","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"手动同步\rReaderWriterLock：ReaderWriterLock支持单个写线程和多个读线程的锁，使用ReaderWriterLock来进行读写同步比使用监视的方式（如Monitor）效率要高 .NET Framework 具有两个读取器 / 编写器锁， ReaderWriterLockSlim 和 ReaderWriterLock。 ReaderWriterLockSlim 建议将所有新的开发的。 ReaderWriterLockSlim 类似于 ReaderWriterLock, ，只是简化了递归、 升级和降级锁定状态的规则。 ReaderWriterLockSlim 可避免潜在的死锁的很多情况。 此外，性能的 ReaderWriterLockSlim 明显优于 ReaderWriterLock。 ReaderWriterLock 用于同步对资源的访问。 在任何给定时间，它允许多个线程的并发读访问权限，或者一个单独的线程的写访问权限。 在某个资源，很少更改的情况下 ReaderWriterLock 提供了更好的吞吐量比简单的一次锁，如 Monitor。 ReaderWriterLock 其中大多数的访问权限是读取，而写入是很少和持续时间较短的效果最佳。 多个读取器交替使用单个编写器，以便读取器和编写器都不被阻止较长时间 下面的示例演示如何使用 ReaderWriterLock 若要保护的共享的资源，一个整数值，名为 resource, ，即并发读取和写入以独占方式由多个线程。 请注意， ReaderWriterLock 以便对所有线程可见的类级别声明。 using System; using System.Threading; public class Example { static ReaderWriterLock rwl = new ReaderWriterLock(); // 定义受ReaderWriterLock保护的共享资源。 static int resource = 0; /// \u003csummary\u003e /// 线程数量 /// \u003c/summary\u003e const int numThreads = 10; /// \u003csummary\u003e /// 线程启动开关 /// \u003c/summary\u003e static bool running = true; /// \u003csummary\u003e /// 随机 /// \u003c/summary\u003e static Random rnd = new Random(); // 读取超时时间 static int readerTimeouts = 0; //写入超时时间 static int writerTimeouts = 0; //读取次数 static int reads = 0; //写入次数 static int writes = 0; public static void Main() { // 启动一系列线程以随机读取和写入共享资源。 Thread[] t = new Thread[numThreads]; for (int i = 0; i \u003c numThreads; i++) { t[i] = new Thread(new ThreadStart(ThreadProc)); t[i].Name = new String(Convert.ToChar(i + 65), 1); t[i].Start(); Console.WriteLine($\"线程：{t[i].Name }启动\"); if (i \u003e 10) Thread.Sleep(300); } // 告诉线程关闭并等待它们全部完成。 running = false; for (int i = 0; i \u003c numThreads; i++) { t[i].Join();//阻止调用线程，直到某个线程终止时为止。 Console.WriteLine($\"线程：{t[i].Name }阻止\"); } // 显示统计信息 Console.WriteLine($\"\\n{reads} 次读, {writes} 次写, 读取请求超时时间{readerTimeouts} , 写请求超时时间{writerTimeouts} .\"); Console.Write(\"退出 \"); Console.ReadLine(); } static void ThreadProc() { // 随机选择线程从共享资源中读取和写入的方式 while (running) { double action = rnd.NextDouble();//返回一个0-1之间的随机数 if (action \u003c .7) ReadFromResource(10);//80%读 else if (action \u003c .81) ReleaseRestore(50); else if (action \u003c .90) UpgradeDowngrade(100); else WriteToResource(100); } } // 请求并释放读卡器锁，并处理超时。 static void ReadFromResource(int timeOut) { try { rwl.AcquireReaderLock(timeOut);//获取读线程锁。//使用一个int超时值获取读线程 try { // 此线程可以安全地从共享资源中读取。 Display(\"读取资源值:\" + resource); Interlocked.Increment(ref reads);//对资源操作 } finally { // 确保已释放锁定。 rwl.ReleaseReaderLock();//减少锁计数。 } } catch (ApplicationException) { //读卡器锁定请求超时。 Interlocked.Increment(ref readerTimeouts);//时间增加 } } // 请求并释放写入程序锁定，并处理超时。 static void WriteToResource(int timeOut) { try { rwl.AcquireWriterLock(timeOut);//获取写线程锁。//使用一个int超时值获取写线程 try { // 此线程可以安全地从共享资源进行访问。 resource = rnd.Next(100); Display(\"写资源值: \" + resource); Interlocked.Increment(ref writes);//写入次数 } finally { // 确保已释放锁定。 rwl.ReleaseWriterLock();//减少写线程上锁的计数 } } catch (ApplicationException) { // The writer lock request timed out. Interlocked.Increment(ref writerTimeouts); } } // 请求读取器锁定，将读取器锁定升级到写入器锁定，并再次将其降级为读取器锁定。 static void UpgradeDowngrade(int timeOut) { try { rwl.AcquireReaderLock(timeOut);//通过设置的读时间int值获取读线程锁 try { // 这个线程从共享资源中读取是安全的。 Display(\"读资源值: \" + resource); Interlocked.Increment(ref reads); // 要写入资源，要么释放读取器锁定并请求写入程序锁定，要么升级读取器锁定。 //升级读取器锁将线程置于写入队列中，位于可能正在等待写入器锁定的任何其他线程之后。 try { LockCookie lc = rwl.UpgradeToWriterLock(timeOut);//将一个设置超时int值的读线程锁升级为写线程锁 try { // 此线程可以安全地从共享资源读取或写入。 resource = rnd.Next(100); Display(\"从读锁变成写锁写资源值: \" + resource); Interlocked.Increment(ref writes);//写值 } finally { // 确保已释放锁定。 rwl.DowngradeFromWriterLock(ref lc);//将线程的锁状态还原为调用 UpgradeToWriterLock 前的状态。 } } catch (ApplicationException) { // 更新写线程时间 Interlocked.Increment(ref writerTimeouts); } // 如果锁被降级，从资源中读取仍然是安全的。 Display(\"从读锁变成写锁再变读锁读资源值: \" + resource); Interlocked.Increment(ref reads); } finally { // 确保已释放锁定。 rwl.ReleaseReaderLock(); } } catch (ApplicationException) { // 读卡器锁定请求超时。 Interlocked.Increment(ref readerTimeouts); } } //释放所有锁，然后恢复锁定状态。 //使用序列号来确定另一个线程是否已获得写入器锁定，因为此线程上次访问该资源。 static void ReleaseRestore(int timeOut) { ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:3","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"AutoResetEvent 类\r通知正在等待的线程已发生事件。MSCN介绍中，终止状态就是有信号 AutoResetEvent（bool isover）：构造函数指示是否指示是否将初始状态设置为终止的 Reset:将事件状态设置为非终止状态，导致线程阻止。 Set:将事件状态设置为终止状态，允许一个或多个等待线程继续。将事件状态设置为有信号 WaitOne():阻止当前线程，直到当前 WaitHandle 收到信号。会自动改变信号，讲有信号自动变成无信号，需要自己调用set WaitOne(Int32):阻止当前线程，直到当前 WaitHandle 收到信号，同时使用 32 位带符号整数指定时间间隔 using System; using System.Threading; class Example { //mscn中终止状态就是有信号 //全局 private static AutoResetEvent event_1 = new AutoResetEvent(true);//初始化为终止状态，有信号 private static AutoResetEvent event_2 = new AutoResetEvent(false);//初始状态为非终止状态，没有信号 static void Main() { Console.WriteLine(\"按Enter键创建三个线程并启动它们。\\r\\n\" + \"线程在创建的AutoResetEvent1上等待\\r\\n\" + \"在信号状态，所以第一个线程被释放。\\r\\n\" + \"这使AutoResetEvent1进入无信号状态.\"); Console.ReadLine(); for (int i = 1; i \u003c 4; i++) { Thread t = new Thread(ThreadProc); t.Name = i+ \"号线程\"; Console.WriteLine(\"{0}号线程开始\",t.Name); t.Start(); } Thread.Sleep(250); for (int i = 0; i \u003c 2; i++) { Console.WriteLine(\"按Enter键以释放另一个线程。\"); Console.ReadLine(); event_1.Set(); Thread.Sleep(250); } Console.WriteLine(\"\\r\\n所有线程现在都在等待AutoResetEvent＃2。\"); for (int i = 0; i \u003c 3; i++) { Console.WriteLine(\"按Enter键以释放线程。\"); Console.ReadLine(); event_2.Set(); Thread.Sleep(250); } } static void ThreadProc() { string name = Thread.CurrentThread.Name; Console.WriteLine(\"{0} 等待AutoResetEvent # 1。\", name); event_1.WaitOne(); Console.WriteLine(\"{0} 从AutoResetEvent # 1中释放。\", name); Console.WriteLine(\"{0} 等待AutoResetEvent # 2。\", name); event_2.WaitOne(); Console.WriteLine(\"{0} 从AutoResetEvent # 2中释放。\", name); Console.WriteLine(\"{0} 结束。\", name); } } 结果 按Enter键创建三个线程并启动它们。 线程在创建的AutoResetEvent1上等待 在信号状态，所以第一个线程被释放。 这使AutoResetEvent1进入无信号状态. 1号线程号线程开始 2号线程号线程开始 1号线程 等待AutoResetEvent # 1。 1号线程 从AutoResetEvent # 1中释放。 1号线程 等待AutoResetEvent # 2。 2号线程 等待AutoResetEvent # 1。 3号线程号线程开始 3号线程 等待AutoResetEvent # 1。 按Enter键以释放另一个线程。 2号线程 从AutoResetEvent # 1中释放。 2号线程 等待AutoResetEvent # 2。 按Enter键以释放另一个线程。 3号线程 从AutoResetEvent # 1中释放。 3号线程 等待AutoResetEvent # 2。 所有线程现在都在等待AutoResetEvent＃2。 按Enter键以释放线程。 1号线程 从AutoResetEvent # 2中释放。 1号线程 结束。 按Enter键以释放线程。 2号线程 从AutoResetEvent # 2中释放。 2号线程 结束。 按Enter键以释放线程。 3号线程 从AutoResetEvent # 2中释放。 3号线程 结束。 请按任意键继续. . . ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:4","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"ManualResetEvent 类\r通知一个或多个正在等待的线程已发生事件。 ManualResetEvent：用一个指示是否将初始状态设置为终止的布尔值初始化，初始状态是否有信号 set:将事件状态设置为终止状态，允许一个或多个等待线程继续。,设置有信号,设为有信号后就一直有信号，即使waitone后也信号，直到reset将其设为无信号 WaitOne()：阻止当前线程，直到当前 WaitHandle 收到信号。 WaitOne(Int32)：阻止当前线程，直到当前 WaitHandle 收到信号，同时使用 32 位带符号整数指定时间间隔（以毫秒为单位）。 Reset：将事件状态设置为非终止状态，导致线程阻止。 using System; using System.Threading; public class Example { private static ManualResetEvent mre = new ManualResetEvent(false);//初始状态没有信号 static void Main() { Console.WriteLine(\"\\n启动3个在ManualResetEvent上阻塞的命名线程：\\n\"); for (int i = 0; i \u003c= 2; i++) { Thread t = new Thread(ThreadProc); t.Name = i+\"号线程\"; Console.WriteLine(\"{0}开始\", t.Name); t.Start(); } Thread.Sleep(500); Console.WriteLine(\"\\n当所有三个线程都已启动时，按Enter键调用Set（）\" + \"\\n释放所有线程。\\n\"); Console.ReadLine(); mre.Set(); Thread.Sleep(500); Console.WriteLine(\"\\n发出ManualResetEvent信号时，调用WaitOne（）的线程\" + \"\\n不要阻止。 按Enter键显示此信息。\\n\"); Console.ReadLine(); for (int i = 3; i \u003c= 4; i++) { Thread t = new Thread(ThreadProc); t.Name = i + \"号线程\"; t.Start(); } Thread.Sleep(500); Console.WriteLine(\"\\n按Enter键调用Reset（），以便线程再次阻止\" + \"\\n当他们调用WaitOne（）时.\\n\"); Console.ReadLine(); mre.Reset(); // Start a thread that waits on the ManualResetEvent. Thread t5 = new Thread(ThreadProc); t5.Name = \"Thread_5\"; t5.Start(); Thread.Sleep(500); Console.WriteLine(\"\\nPress Enter to call Set() and conclude the demo.\"); Console.ReadLine(); mre.Set(); } private static void ThreadProc() { string name = Thread.CurrentThread.Name; Console.WriteLine(name + \" 启动并调用mre.WaitOne（）\"); mre.WaitOne(); Console.WriteLine(name + \" ends.\"); } } 结果： 启动3个在ManualResetEvent上阻塞的命名线程： 0号线程开始 1号线程开始 0号线程 启动并调用mre.WaitOne（） 2号线程开始 1号线程 启动并调用mre.WaitOne（） 2号线程 启动并调用mre.WaitOne（） 当所有三个线程都已启动时，按Enter键调用Set（） 释放所有线程。 2号线程 ends. 0号线程 ends. 1号线程 ends. 发出ManualResetEvent信号时，调用WaitOne（）的线程 不要阻止。 按Enter键显示此信息。 3号线程 启动并调用mre.WaitOne（） 3号线程 ends. 4号线程 启动并调用mre.WaitOne（） 4号线程 ends. 按Enter键调用Reset（），以便线程再次阻止 当他们调用WaitOne（）时. Thread_5 启动并调用mre.WaitOne（） Press Enter to call Set() and conclude the demo. Thread_5 ends. 请按任意键继续. . . ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:5","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"Interlocked 类\r为多个线程共享的变量提供原子操作。 Increment(Int32)：以原子操作的形式递增指定变量的值并存储结果。 Add(Int32, Int32)：对两个 32 位整数进行求和并用和替换第一个整数，上述操作作为一个原子操作完成。 CompareExchange(Double, Double, Double)：比较两个双精度浮点数是否相等，如果相等，则替换第一个值。 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:6","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"waithandle\rWaitHandle类是一个抽象类，有多个类直接或者间接继承自WaitHandle类 在WaitHandle类中SignalAndWait、WaitAll、WaitAny及WaitOne这几个方法都有重载形式，其中除WaitOne之外都是静态的。 WaitHandle方法常用作同步对象的基类。WaitHandle对象通知其他的线程它需要对资源排他性的访问，其他的线程必须等待，直到WaitHandle不再使用资源和等待句柄没有被使用。 WaitHandle方法有多个Wait的方法，这些方法的区别如下： WaitAll：等待指定数组中的所有元素收到信号。 WaitAny：等待指定数组中的任一元素收到信号。 WaitOne：当在派生类中重写时，阻塞当前线程，直到当前的 WaitHandle 收到信号。 MSCN上面的代码 using System; using System.Threading; namespace AutoResetEvent_Examples { class MyMainClass { //Initially not signaled. const int numIterations = 5; static AutoResetEvent myResetEvent = new AutoResetEvent(false); static int number; static void Main() { //Create and start the reader thread. Thread myReaderThread = new Thread(new ThreadStart(MyReadThreadProc)); myReaderThread.Name = \"ReaderThread\"; myReaderThread.Start(); for (int i = 1; i \u003c= numIterations; i++) { Console.WriteLine(\"Writer thread writing value: {0}\", i); number = i; //Signal that a value has been written. myResetEvent.Set(); //Give the Reader thread an opportunity to act. Thread.Sleep(1); } //Terminate the reader thread. myReaderThread.Abort(); } static void MyReadThreadProc() { while (true) { //The value will not be read until the writer has written // at least once since the last read. myResetEvent.WaitOne();//等待set Console.WriteLine(\"{0} reading value: {1}\", Thread.CurrentThread.Name, number); } } } } 结果 Writer thread writing value: 1 ReaderThread reading value: 1 Writer thread writing value: 2 ReaderThread reading value: 2 Writer thread writing value: 3 ReaderThread reading value: 3 Writer thread writing value: 4 ReaderThread reading value: 4 Writer thread writing value: 5 ReaderThread reading value: 5 请按任意键继续. . . using System; using System.Threading; public class Example { // mre is used to block and release threads manually. It is // created in the unsignaled state. private static ManualResetEvent mre = new ManualResetEvent(false);//设为非终止状态，线程会被阻塞 static void Main() { Console.WriteLine(\"\\n启动在MalualReSeTebug上阻止的3个命名线程:\\n\"); for (int i = 0; i \u003c= 2; i++) { Thread t = new Thread(ThreadProc); t.Name = i+\"线程\"; t.Start(); } Thread.Sleep(500); Console.WriteLine(\"\\n当所有三个线程都已启动时，按Enter调用SET（）\" + \"\\n释放所有线程。\\n\"); Console.ReadLine(); mre.Set();//事件状态被设置为有信号，允许线程执行，3个线程执行，同时ManualResetEvent 被设置为终止状态，线程不会阻塞 Thread.Sleep(500); Console.WriteLine(\"\\n当一个MavaReSeTeEvices被发出信号时，调用WAOTIONE（）的线程\" + \"\\n不要阻塞。按Enter显示这一点。\\n\"); Console.ReadLine(); for (int i = 3; i \u003c= 4; i++) { Thread t = new Thread(ThreadProc); t.Name = i + \"线程\"; t.Start(); } Thread.Sleep(500); Console.WriteLine(\"\\n按Enter调用REST（），使线程再次阻塞\" + \"\\n当他们调用WAOTIFEL（）时。\\n\"); Console.ReadLine(); mre.Reset();//将ManualResetEvent 重新设为非终止状态 // Start a thread that waits on the ManualResetEvent. Thread t5 = new Thread(ThreadProc); t5.Name = \"5线程\"; t5.Start(); Thread.Sleep(500); Console.WriteLine(\"\\n按Enter调用SET（）并结束演示。\"); Console.ReadLine(); mre.Set(); // If you run this example in Visual Studio, uncomment the following line: //Console.ReadLine(); } private static void ThreadProc() { string name = Thread.CurrentThread.Name; Console.WriteLine(name + \" starts and calls mre.WaitOne()\"); mre.WaitOne();//当ManualResetEvent 设为非终止状态时，线程会被阻塞 Console.WriteLine(name + \" ends.\"); } } 启动在MalualReSeTebug上阻止的3个命名线程: 0线程 starts and calls mre.WaitOne() 2线程 starts and calls mre.WaitOne() 1线程 starts and calls mre.WaitOne() 当所有三个线程都已启动时，按Enter调用SET（） 释放所有线程。 1线程 ends. 0线程 ends. 2线程 ends. 当一个MavaReSeTeEvices被发出信号时，调用WAOTIONE（）的线程 不要阻塞。按Enter显示这一点。 3线程 starts and calls mre.WaitOne() 3线程 ends. 4线程 starts and calls mre.WaitOne() 4线程 ends. 按Enter调用REST（），使线程再次阻塞 当他们调用WAOTIFEL（）时。 5线程 starts and calls mre.WaitOne() 按Enter调用SET（）并结束演示。 这个讲的是一个计算过程，最终的计算结果为第一项＋第二项＋第三项，在计算第一、二、三项时需要使用基数来进行计算。在代码中使用了线程池也就是ThreadPool来操作 using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { //下面的代码摘自MSDN，笔者做了中文代码注释 //周公 public class EventWaitHandleDemo { double baseNumber, firstTerm, secondTerm, thirdTerm; AutoResetEvent[] autoEvents; ManualResetEvent ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:7","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"线程池\r为了处理短时间内大量创建对象，简单处理下，又要销毁损耗性能的行为，线程过多后会增加操作系统资源的占用，多线程资源竞争变得复杂 线程池的优点： 缩短程序的响应时间 不必维护管理生存周期短暂的问题 线程池会根据当前系统特点对池内的线程进行优化处理 在.NET中有一个线程的类ThreadPool，它提供了线程池的管理 ThreadPool是一个静态类，它没有构造函数，对外提供的函数也全部是静态的。其中有一个QueueUserWorkItem方法，它有两种重载形式，如下： public static bool QueueUserWorkItem(WaitCallback callBack):将方法排入队列以便执行。此方法在有线程池线程变得可用时执行。 public static bool QueueUserWorkItem(WaitCallback callBack,Object state):将方法排入队列以便执行，并指定包含该方法所用数据的对象。此方法在有线程池线程变得可用时执行。 QueueUserWorkItem方法中使用的的WaitCallback参数表示一个delegate，它的声明如下： public delegate void WaitCallback(Object state) 如果需要传递任务信息可以利用WaitCallback中的state参数，类似于ParameterizedThreadStart委托 using System.Threading; using System.Collections; using System.Diagnostics; using System; using System.ComponentModel; namespace ThreadPoolDemo { class ThreadPoolDemo1 { public ThreadPoolDemo1() { } public void Work() { ThreadPool.QueueUserWorkItem(new WaitCallback(CountProcess)); ThreadPool.QueueUserWorkItem(new WaitCallback(GetEnvironmentVariables)); } /// \u003csummary\u003e /// 统计当前正在运行的系统进程信息 /// \u003c/summary\u003e /// \u003cparam name=\"state\"\u003e\u003c/param\u003e private void CountProcess(object state) { Process[] processes = Process.GetProcesses(); foreach (Process p in processes) { try { Console.WriteLine(\"Id:{0},ProcessName:{1},StartTime:{2}\", p.Id, p.ProcessName, p.StartTime); } catch (Win32Exception e) { Console.WriteLine(\"ProcessName:{0}\", p.ProcessName); } finally { } } Console.WriteLine(\"获取进程信息完毕。\"); } /// \u003csummary\u003e /// 获取当前机器系统变量设置 /// \u003c/summary\u003e /// \u003cparam name=\"state\"\u003e\u003c/param\u003e public void GetEnvironmentVariables(object state) { IDictionary list=System.Environment.GetEnvironmentVariables(); foreach (DictionaryEntry item in list) { Console.WriteLine(\"key={0},value={1}\", item.Key, item.Value); } Console.WriteLine(\"获取系统变量信息完毕。\"); } static void Main(string[] args) { ThreadPoolDemo1 tpd1 = new ThreadPoolDemo1(); tpd1.Work(); Thread.Sleep(5000); Console.WriteLine(\"OK\"); Console.ReadLine(); } } } 在上面的代码中我们使用了线程池，并让它执行了两个任务，一个是列出系统当前所有环境变量的值，一个是列出系统当前运行的进程名和它们的启动时间。 当然，优点和缺点总是同时存在的，使用ThreadPool也有一些缺点，使用线程池有如下缺点： 1、一旦加入到线程池中就没有办法让它停止，除非任务执行完毕自动停止； 2、一个进程共享一个线程池； 3、要执行的任务不能有返回值（当然，线程中要执行的方法也是不能有返回值，如果确实需要返回值必须采用其它技巧来解决）； 4、在线程池中所有任务的优先级都是一样的，无法设置任务的优先级； 5、不太适合需要长期执行的任务（比如在Windows服务中执行），也不适合大的任务； 6、不能为线程设置稳定的关联标识，比如为线程池中执行某个特定任务的线程指定名称或者其它属性。 如果我们要面临的情况正好是线程池的缺点，那么我们只好继续使用线程而不是线程池。不过在某些情况下使用线程池确实可以带来很多方便的，比如在WEB服务器中，可以使用线程池来处理来自客户端的请求，可以以比较高的性能运行。 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:8","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"UI界面卡顿的问题\r在开发Windows应用程序时经常会使用到线程。对于耗时的操作如果不使用线程将会是UI界面长时间处于停滞状态，这种情况是用户非常不愿意看到的，在这种情况下我们希望使用线程来解决这个问题。 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Text; using System.Windows.Forms; using System.Threading; namespace ThreadPoolDemo { public partial class ThreadForm : Form { public ThreadForm() { InitializeComponent(); } private void btnThread_Click(object sender, EventArgs e) { Thread thread = new Thread(new ThreadStart(Run)); thread.Start(); } private void Run() { while (progressBar.Value \u003c progressBar.Maximum) { progressBar.PerformStep(); } } } } 本意是点击“启动”按钮来启动模拟一个操作，在进度条中显示操作的总体进度。不过如果我们真的点击“启动”按钮会很失望，因为它会抛出一个System.InvalidOperationException异常，异常描述就是“线程间操作无效: 从不是创建控件‘progressBar’的线程访问它。” 解决方案 CheckForIllegalCrossThreadCalls属性 因为在.NET中做了限制，不允许在调试环境下使用线程访问并非它自己创建的UI控件，这么做可能是怕在多线程环境下对界面控件进行操作会出现不可预知的情况， using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using System.Threading; namespace ThreadPoolDemo { public partial class ThreadForm : Form { public ThreadForm() { InitializeComponent(); } private void btnThread_Click(object sender, EventArgs e) { //指示是否对错误线程的调用，即是否允许在创建UI的线程之外访问线程 CheckForIllegalCrossThreadCalls = false; Thread thread = new Thread(new ThreadStart(Run)); thread.Start(); } private void Run() { while (progressBar.Value \u003c progressBar.Maximum) { progressBar.PerformStep(); } } } } 不过使用上面的代码我们可能还有些犯嘀咕，毕竟是不允许直接在线程中直接操作界面的，那么我们还可以用Invoke方法。 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using System.Threading; namespace ThreadPoolDemo { public partial class ThreadForm : Form { //定义delegate以便Invoke时使用 private delegate void SetProgressBarValue(int value); public ThreadForm() { InitializeComponent(); } private void btnThread_Click(object sender, EventArgs e) { progressBar.Value = 0; //指示是否对错误线程的调用，即是否允许在创建UI的线程之外访问线程 //CheckForIllegalCrossThreadCalls = false; Thread thread = new Thread(new ThreadStart(Run)); thread.Start(); } //使用线程来直接设置进度条 private void Run() { while (progressBar.Value \u003c progressBar.Maximum) { progressBar.PerformStep(); } } private void btnInvoke_Click(object sender, EventArgs e) { progressBar.Value = 0; Thread thread = new Thread(new ThreadStart(RunWithInvoke)); thread.Start(); } //使用Invoke方法来设置进度条 private void RunWithInvoke() { int value = progressBar.Value; while (value\u003c progressBar.Maximum) { //如果是跨线程调用 if (InvokeRequired) { this.Invoke(new SetProgressBarValue(SetProgressValue), value++); } else { progressBar.Value = ++value; } } } //跟SetProgressBarValue委托相匹配的方法 private void SetProgressValue(int value) { progressBar.Value = value; } } } 还可以使用BackgroundWorker类来完成同样的功能。 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using System.Threading; namespace ThreadPoolDemo { public partial class ThreadForm : Form { //定义delegate以便Invoke时使用 private delegate void SetProgressBarValue(int value); private BackgroundWorker worker; public ThreadForm() { InitializeComponent(); } private void btnThread_Click(object sender, EventArgs e) { progressBar.Value = 0; //指示是否对错误线程的调用，即是否允许在创建UI的线程之外访问线程 //CheckForIllegalCrossThreadCalls = false; Thread thread = new Thread(new ThreadStart(Run)); thread.Start(); } //使用线程来直接设置进度条 private void Run() { while (progressBar.Value \u003c progressBar.Maximum) { progressBar.PerformStep(); } } private void btnInvoke_Click(object sender, EventArgs e) { progressBar.Value = 0; Thread thread = new Thread(new ThreadStart(RunWithInvoke)); thread.Start(); } //使用Invoke方法来设置进度条 private void RunWithInvoke() { int value = progressBar.Value; while (value\u003c progressBar.Maximum) { //如果是跨线程调用 if (InvokeRequired) { this.Invoke(ne","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:7:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"Task类\rTask类是封装的一个任务类，内部使用的是ThreadPool类，提供了内建机制，让你知道什么时候异步完成以及如何获取异步执行的结果，并且还能取消异步执行的任务。下面看一个例子是如何使用Task类来执行异步操作的。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { Task t = new Task((c) =\u003e { int count = (int)c; for (int i = 0; i \u003c count; i++) { Thread.Sleep(10); Console.WriteLine($\"Asyn Thread:{i}\"); } Console.WriteLine(\"Asyn Thread Done\"); }, 10);//10为传递的参数C N0.1 t.Start(); for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread:{i}\"); } Console.WriteLine(\"Main Thread done\"); Console.ReadKey(); } } } Main Thread:0 Asyn Thread:0 Asyn Thread:1 Main Thread:1 Asyn Thread:2 Main Thread:2 Asyn Thread:3 Main Thread:3 Asyn Thread:4 Main Thread:4 Main Thread done Asyn Thread:5 Asyn Thread:6 Asyn Thread:7 Asyn Thread:8 Asyn Thread:9 Asyn Thread Done no.1处使用Task的构造函数为： public Task( Action\u003cObject\u003e action, Object state )一个Action\u003cObject\u003e类型的委托（即异步调用函数具有一个Object类型的参数），和一个Object类型的参数，也就是传递给异步函数的参数， Task类还有几种方式的重载，我们还可以传递一些TaskCreationOptions标志来控制Task的执行方式。在这里我使用的是lambda表达去写委托的，这样使得程序的结构更加的清晰，使用Start()来启动异步函数的调用。 有返回值，主线程阻塞 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { Task\u003cint\u003e t = new Task\u003cint\u003e((c) =\u003e { int count = (int)c; int sum = 0; for (int i = 0; i \u003c count; i++) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread:{i}\"); } Console.WriteLine(\"Asyn Thread Done\"); return sum; }, 10);//no.1 t.Start(); t.Wait(); Console.WriteLine($\"Asyn Result:{t.Result}\"); for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread:{i}\"); } Console.WriteLine(\"Main Thread done\"); Console.ReadKey(); } } } Asyn Thread:0 Asyn Thread:1 Asyn Thread:2 Asyn Thread:3 Asyn Thread:4 Asyn Thread:5 Asyn Thread:6 Asyn Thread:7 Asyn Thread:8 Asyn Thread:9 Asyn Thread Done Asyn Result:45 Main Thread:0 Main Thread:1 Main Thread:2 Main Thread:3 Main Thread:4 Main Thread done 如果任务中出现了异常，那么异常会被吞噬掉，并存储到一个集合中去，而线程可以返回到线程池中去。但是如果在代码中调用了Wait方法或者是Result属性，任务有异常发生就会被引发，不会被吞噬掉。其中Result属性内部本身也调用了Wati方法。Wait方法和上一节中的委托的EndInvoke方法类似，会使得调用线程阻塞直到异步任务完成。 取消正在运行的任务 取消任务要引用一个CancellationTokenSource 对象。在需要异步执行的方法中增加一个CancellationToken类型的形参。然后在异步函数的for循环代码中用一个if语句判断CancellationToken的CanBeCanceled属性，这个属性可以用来判断在调用线程是否取消任务的执行， 除CanBeCanceled属性之外，还可以使用ThrowIfCancellationRequested方法，该方法的作用是如果在调用线程调用CancellationTokenSource对象的Cancel方法，那么就会引发一个异常，然后在调用线程进行捕捉就好了，这是在异步函数中的处理方式。 no.1在构建任务之前需要建立一个CancellationTokenSource ， no2.并且把CancellationTokenSource传递给异步调用函数，传递的是CancellationTokenSource对象的Toke属性，该属性是一个CancellationToken类型的对象。这样就完成任务的取消模式，如果想在调用线程中取消任务的执行，只需要调用CancellationTokenSource 的Cancel方法就行啦。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { CancellationTokenSource cts = new CancellationTokenSource();//NO.1 Task\u003cint\u003e t = new Task\u003cint\u003e((c) =\u003e Sum(cts.Token, (int)c), 10);//NO.2 t.Start(); //cts.Cancel();//NO.3如果任务没有完成，但是Task有可能完成了 for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread:{i}\"); } cts.Cancel(); Console.WriteLine(\"Main Thread done\"); Console.ReadKey(); } static int Sum(CancellationToken ct, int count) { int sum = 0; for (int i = 0; i \u003c count; i++) { //if (!ct.CanBeCanceled) if (!ct.IsCancellationRequested) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread:{i}\"); } else { Console.WriteLine(\"任务取消\"); //return -1; } } Console.WriteLine(\"Asyn Thread Done\"); return sum; } } } 结果 Main Thread:0 Asyn Thread:0 Main Thread:1 Asyn Thread:1 Main Thread:2 Asyn Thread:2 Main Thread:3 Asyn Thread:3 Main Thread:4 Main Thread done","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:8:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"多线程UI的例子\rusing System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; using System.Threading; namespace testthreadui { public partial class Form1 : Form { private readonly TaskScheduler contextTaskScheduler;//声明一个任务调度器 public Form1() { InitializeComponent(); contextTaskScheduler = TaskScheduler.FromCurrentSynchronizationContext();//no.1获得一个上下文任务调度器 } private void button1_Click(object sender, EventArgs e) { Task\u003cint\u003e t = new Task\u003cint\u003e((n) =\u003e Sum((int)n), 100); t.Start(); t.ContinueWith(task =\u003e this.textBox1.Text = task.Result.ToString(), contextTaskScheduler);//当任务执行完之后执行 t.ContinueWith(task =\u003e MessageBox.Show(\"任务出现异常\"), CancellationToken.None, TaskContinuationOptions.OnlyOnFaulted, contextTaskScheduler);//当任务出现异常时才执行 for (int i = 0; i \u003c 10; i++) { textBox1.Text = i.ToString(); textBox2.Text = i.ToString(); Thread.Sleep(100); } } int Sum(int count) { try { int sum = 0; for (int i = 0; i \u003c count; i++) { Thread.Sleep(10); sum += i; //throw new Exception(\"错误\"); } Console.WriteLine(\"任务处理完成\"); return sum; } catch (Exception e) { MessageBox.Show(\"任务出现异常\"); } return -1; } private void button2_Click(object sender, EventArgs e) { textBox1.Text = 100.ToString(); } } } //未发现异常 实现实时更新UI 首先建立一个winform项目，在主窗体上拖入一个button，一个progressbar，一个lable。如下图所示。 编写一个处理数据的类（WriteDate），源代码如下 public class DataWrite { public delegate void UpdateUI(int step);//声明一个更新主线程的委托 public UpdateUI UpdateUIDelegate; public delegate void AccomplishTask();//声明一个在完成任务时通知主线程的委托 public AccomplishTask TaskCallBack; public void Write(object lineCount) { StreamWriter writeIO = new StreamWriter(\"text.txt\", false, Encoding.GetEncoding(\"gb2312\")); string head = \"编号,省,市\"; writeIO.Write(head); for (int i = 0; i \u003c (int)lineCount; i++) { writeIO.WriteLine(i.ToString() + \",湖南,衡阳\"); //写入一条数据，调用更新主线程ui状态的委托 UpdateUIDelegate(1); } //任务完成时通知主线程作出相应的处理 TaskCallBack(); writeIO.Close(); } } 主界面中的代码如下： 首先要建立一个委托来实现非创建控件的线程更新控件。 delegate void AsynUpdateUI(int step); 然后编写多线程去启动写入数据的方法以及回调的函数。 private void btnWrite_Click(object sender, EventArgs e) { int taskCount = 10000; //任务量为10000 this.pgbWrite.Maximum = taskCount; this.pgbWrite.Value = 0; DataWrite dataWrite = new DataWrite();//实例化一个写入数据的类 dataWrite.UpdateUIDelegate += UpdataUIStatus;//绑定更新任务状态的委托 dataWrite.TaskCallBack += Accomplish;//绑定完成任务要调用的委托 Thread thread = new Thread(new ParameterizedThreadStart(dataWrite.Write)); thread.IsBackground = true; thread.Start(taskCount); } //更新UI private void UpdataUIStatus(int step) { if (InvokeRequired) { this.Invoke(new AsynUpdateUI(delegate(int s) { this.pgbWrite.Value += s; this.lblWriteStatus.Text = this.pgbWrite.Value.ToString() + \"/\" + this.pgbWrite.Maximum.ToString(); }), step); } else { this.pgbWrite.Value += step; this.lblWriteStatus.Text = this.pgbWrite.Value.ToString() + \"/\" + this.pgbWrite.Maximum.ToString(); } } //完成任务时需要调用 private void Accomplish() { //还可以进行其他的一些完任务完成之后的逻辑处理 MessageBox.Show(\"任务完成\"); } 完整代码 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; using System.Threading; using System.IO; namespace testthreadui { public partial class Form1 : Form { delegate void AsynUpdateUI(int step); public Form1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { int taskCount = 10000; //任务量为10000 this.pgbWrite.Maximum = taskCount; this.pgbWrite.Value = 0; DataWrite dataWrite = new DataWrite();//实例化一个写入数据的类 dataWrite.UpdateUIDelegate += UpdataUIStatus;//绑定更新任务状态的委托 dataWrite.TaskCallBack += Accomplish;//绑定完成任务要调用的委托 Thread thread = new Thread(new ParameterizedThreadStart(dataWrite.Write)); thread.IsBackground = true; thread.Start(taskCount); } private void UpdataUIStatus(int step) { if (InvokeRequired) { this.Invoke(new AsynUpdateUI(delegate (int s) { ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:8:1","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"基本信息\r","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:1:0","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"CIL和JIT\rCIL通用中间语言 JIT just-in-time使得CIT代码仅在需要时才编译 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:1:1","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"程序集\r包含可执行文件.exe和库函数.dll和资源文件，不必把程序集集中到一个地方，全局程序缓存 程序集完全自描述的，逻辑单元而不是物理单元 可执行代码和库代码使用相同程序集结构，可执行文件多了一个主程序入口点。 程序集的一个重要特征是它们包含元数据描述了对应代码中定义的类型和方法。 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:1:2","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"CLR\r公共语言运行库CLR：包含实时编译器JIT,在程序运行时，JIT编译器会从IL代码生成本地代码，其他部分是垃圾回收器GC,调试器扩展和线程实用工具。垃圾回收器负责回收内存，调试扩展器允许在不同编程语言之间启动调试会话，线程实用工具负责在底层平台创建线程。 管理着正在执行的代码包括管理内存，处理安全以及跨语言调试 代码托管最重要的是内存回收机制 winform基于像素 wpf基于pirectX CLR执行应用程序之前，编写好源代码都需要编译，编译分为两个阶段 将源代码编译成microsoft中间语言IL CLR将I编译成平台专用的的本地代码 clr还有一个类型加载器的类型系统，类型加载器负责从程序集中加载类型。 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:1:3","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"编译过程\r.net兼容语言编写程序，托管语言 将代码编译为中间代码CIL，这未必是单文件，可以有多个源代码文件，再把链接带一个程序集中，称之为链接 使用JIT编译为本机代码 在托管的CLR环境下运行本机代码 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:1:4","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"基本语法\r","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:0","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"注释\r/* */和一行// ///可以通过配置，将这些注释提取出来组成文档文件 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:1","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"命名空间\r","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:2","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"代码大纲功能\r#region Using directives #endregion，大纲的名字为Using directives ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:3","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"变量\r先声明后使用 变量初始化：变量是类或结构中的字段，如果没有显式初始化，则创建这些变量时，其默认值就是0.方法的局部变量必须在代码中显示初始化。 整数 sbyte System.SByte -128~127 byte System.Byte 0~255 short System.Int16 -32768~32767 ushort System.UInt16 0~65535 int System.Int32 -21亿~21亿 uint System.UInt32 42亿 long System.Int64 19位数字 ulong System.UInt64 20位数字 浮点类型 位是最小数据单位，只能表示0-1 字节，8个二进制位构成1个字节，是存储空间的基本计量单位， 字：由若干字节构成，不同计算机有不同的字长，8位计算机一个字等于一个字节，16位一个字等于两个字节，字是计算机数据处理和运算的单位 1kb等于1024个字节 1M等于1024KB 1G等于1024M 1T等于1024G float System.Single 4字节 double System.Double 8个字节 decimal System.Decimal 16个字节 布尔和文本 char System.Char Unicode 0~65535 2个字节 bool System.Boolean 1个字节 string System.String 转义字符 ' 单引号 0x0027 '’ 双引号 0x0022 \\ 反斜杠 0x005c \\0 空 0x0000 \\a 警告 0x0007 \\b 退格 0x0008 \\f 换页 0x000C \\n 换行 0x0000A \\r 回车 0x000D \\t 水平制表符 0x0009 \\v 垂直制表符 0x000B @转义字符，避免大量使用\\ 全局变量：Program.全局变量，在声明变量前要进行初始化 常量： 常量必须初始化，指定值后不能更改。 常量总是隐式静态的， 值类型和引用类型：值类型存储在栈中，应用类型存储在堆中。值类型和引用类型互换要经过装箱拆箱，在传递函数参数时，值类型会进行复制，而引用相当于传递指针，返回值相同。引用类型由垃圾回收器进行回收，值类型不需要，超出其作用域就会在内存中删除。 ref:如果是结构类型使用ref传递参数，则变成传递引用，**但如果是引用类型，即使参数在函数中变化了引用，新的应用还是会传递回去。**ref传递的值要先初始化。 out：用法基本和ref一样，但传入的值只需要定义 可空类型：int? 和int,唯一的多开销是一个可以确定它是否为空 的布尔成员，值可以直接转换可空，int?=int;可空转换成值需要强制int=(int)int?;但如果为空会生成一个异常，最好的方法是int=int?.hasvalue?int?.value:-1；可以转换成较短短语int=int??-1 枚举也是值类型：默认情况下，枚举是int,也可以改变成其他整数类型，强制转换将int转换成枚举，当分配给常量是不同位时，flags属性需要枚举设置，获得所有枚举，var day in Enum.GetName(typeof(Color)); 结构：值类型，不能继承，每个结构都自动由ValueType派生。 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:4","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"基本运算符\r一目运算符 二目运算符 = += -= *= /= %= 运算符优先级 ++,–(前缀);(),+,-,!,~ *,/,% +,- \u003e\u003e ,« \u003c,\u003e,\u003c=，\u003e= ==,！= \u0026 ^ | \u0026\u0026 || =,+=,-=,*=,/=,%= ++,–后缀 布尔运算符 ！ \u0026 | ^一真一否才为真 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:5","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"基本语句\rgoto语句 goto \u003clabelName\u003e \u003clabelName\u003e: if语句 if(\u003ctest\u003e) { \u003ccode executed if \u003ctestis true\u003e; } else { \u003ccode executed if \u003ctestis false\u003e; } switch switch(\u003ctestvar\u003e) { case\u003ccomparsionVall\u003e: \u003ccode to execute if \u003ctestVar\u003e\u003e==\u003ccomparisonvall\u003e\u003e break; ........ default: \u003ccode to execute if \u003ctestVar\u003e\u003e!=\u003ccomparisonvall\u003e\u003e break; } do do { \u003ccode to be looped\u003e } while(\u003cTest\u003e) while while(\u003ctest\u003e) { \u003ccode to looped\u003e } for for(\u003cinitialization\u003e;\u003ccondition\u003e;\u003coperation\u003e) { \u003ccode to loop\u003e } foreach foreach(\u003cbaseType\u003e\u003cname\u003ein\u003carray\u003e) { //can use \u003cnamefor each element }//该函数只能只读 循环中的中断 循环的中断： break立刻终止循环 continue立刻终止当前循环 goto可以跳出循环 return跳出循环,即包含循环的函数 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:6","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"基本数据结构\r转换 隐式转换：编译器执行转换 显示转换：需要额外转换 (\u003cdestinationType\u003e)\u003csourceVar\u003e 显示转换的检查：checked和unchecked checked( \u003cexpression\u003e)检查是否会溢出，溢出则出现错误 unchecked(\u003cexpression\u003e)溢出不出现错误 可以通过设置属性，使得显示转换都默认检查checked 枚举 enum\u003ctypename\u003e:\u003cunderlyingType\u003e { \u003cvalue1\u003e, \u003cvalue2\u003e=\u003cactualValue2\u003e, ... } 结构体：值类型 struct\u003ctypename\u003e:\u003cunderlyingType\u003e { \u003cmemberDeclarations\u003e, ... } 数组 数组声明：\u003cbaseType\u003e[]\u003cname\u003e; 二维数组声明：\u003cbaseType\u003e[,]\u003cname\u003e; 数组调用：frendName[index] 锯齿数组 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:7","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"基本函数\rConsole Console.WriteLine(“字符串”); Console.WriteLine(\"{0}{1}{2}\",n_a,n_b,n_c); str=Console.ReadLine(); Convert n_double=Convert.ToDouble();强制转换成double n_int=Convert.ToInt32();强制转换成int ToBase64CharArray 将 8 位无符号整数数组的子集转换为用 Base 64 数字编码的 Unicode 字符数组的等价子集。 ToBase64String 将 8 位无符号整数数组的值转换为它的等效 String 表示形式（使用 base 64 数字编码）。 ToBoolean 将指定的值转换为等效的布尔值。 ToByte 将指定的值转换为 8 位无符号整数。 ToChar 将指定的值转换为 Unicode 字符。 ToDateTime 将指定的值转换为 DateTime。 ToDecimal 将指定值转换为 Decimal 数字。 ToDouble 将指定的值转换为双精度浮点数字。 ToInt16 将指定的值转换为 16 位有符号整数。 ToInt32 将指定的值转换为 32 位有符号整数。 ToInt64 将指定的值转换为 64 位有符号整数。 ToSByte 将指定的值转换为 8 位有符号整数。 ToSingle 将指定的值转换为单精度浮点数字。 ToString 将指定值转换为其等效的 String 表示形式。 ToUInt16 将指定的值转换为 16 位无符号整数。 ToUInt32 将指定的值转换为 32 位无符号整数。 ToUInt64 将指定的值转换为 64 位无符号整数。 Convert.ReadKey( ); enum (enumerationType)Enum.Parse(typeof (enumerationType),enumerationValueString);字符串转换成枚举 string .ToCharArray()这个函数可以将String编程char[]数组 .Length字符串长度 .ToLower字符串全部小写 .ToUpper字符串全部大写 .Trim字符串删除空格 .PadLeft()和.PadRight()字符串左边或者右边添加空格 .IndexOf(’,’);定位到，的下标 .Split(’ ‘);切片 object 类的函数基本是object函数 .ToString()输出类名； 函数格式 static \u003creturnType\u003cFunctionName\u003e(\u003cparamType\u003e\u003cparaName\u003e,...) { ... renturn \u003creturnValue\u003e; }//普通函数定义 可以直接定义表达式函数public bool IsSquare(Reactangle rect)=\u003erect.height==rect.width; 参数函数 参数数组，C#允许函数指定一个特殊参数，该参数必须是函数的最后一个，称为参数素组， static \u003creturnType\u003cFunctionName\u003e(\u003cp1Type\u003e\u003cp1Name\u003e,...Params\u003ctype\u003e[]\u003cname\u003e) { ... renturn \u003creturnValue\u003e; } class Prigram { static int SunVals(params int [] vals) { int sum=0; foreach(int val in vals) { sum+=val; } return sum; } static void Main(string [] args) { int sum=SumVals(1,5,2,9,8); console.writeline(\"summed values={0}\",sum); } } 可选参数 public void TestMethod(int i,int j=12) { } 引用参数 引用参数，需要用关键字ref 调用引用函数\u003cFunctionName\u003e(ref \u003cparaName\u003e) static \u003creturnType\u003cFunctionName\u003e(ref \u003cparamType\u003e\u003cparaName\u003e,...) { ... renturn \u003creturnValue\u003e; } 扩展方法 public static int GetWordCount(this string s)=\u003es.split().length; 调用int wordcount=fox.GetWordCount(); 函数重载 特征标不一样就行 引用和非引用也属于重载 委托 委托，和重载差不多，只不过重载特征表不同，而委托特征标相同而函数名不同，可以根据需求NEW出不同的函数，委托的利用在于可以将其当成参数传递给函数，让函数因需求执行不同的操作，类似于多态 委托是一种存储函数引用的类型 委托声明类似于函数，但是不带函数体，且要使用关键字delegate，委托指定了一个返回类型和一个参数列表 定义了委托后，就可以声明该委托类型的变量，接着把这个变量初始化为与委托具有相同返回类型和参数列表的函数引用，之后就可以使用委托变量调用这个函数 例子，可以把委托变量作为参数传递给一个函数，这样，该函数就可以使用委托调用它引用的任何函数 class Program { delegate double ProcessDelegate(double param1, double param2); static double Multiply(double param1, double param2) { return param1 * param2; } static double Divide(double param1, double param2) { return param1 / param2; } static void Main(string[] args) { ProcessDelegate process; Console.WriteLine(\"imput two intege：\"); string input = Console.ReadLine(); string [] commaPos = input.Split(','); double param1 = Convert.ToDouble(commaPos[0]); double param2 = Convert.ToDouble(commaPos[1]); Console.WriteLine(\"Enter M to Multiply or D to divide:\"); input = Console.ReadLine(); if (input == \"M\") process = new ProcessDelegate(Multiply);//process=Multiply; else process = new ProcessDelegate(Divide);//process=Divide; Console.WriteLine(\"result :{0}\", process(param1, param2)); Console.ReadKey(); } } ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:3:0","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"调试\r","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:4:0","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"断点\r可以查看输出窗口，输出/调试， 语句Debug.WriteLine()将调试信息显示到调试窗口 Trace.WriteLine()，用法相同，可以用于发布 Debug.WriteLine(“Add 1 to i”,“MyFunc”);结果为： MyFunc:Add 1 to i; using System.Diagnostics; Debug.WriteLineIf()增加一个必选项，当是真的时候进行输出 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:4:1","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"跟踪点\r有点类似于Debug.WriteLine() ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:4:2","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"Trace\rTrace.Assert(myVar\u003c0,\"variable out of bounds\",\"please contact vendor with the error code KCW001.\") ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:4:3","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"异常\rtry抛出异常，catch抛出异常时执行的代码，finally包含最终执行的代码 即使try中有return， finally还是会执行，在finally中还是会改变return中的值 try {...} catch(\u003cexceptionType\u003ee) {...} finally {...} 抛出异常包括内容 throw(new ArgumentOutOfRangeException(\"MyIntProp\",value,\"MyIntProp must be assigned a value between 0 and 10\")); catch中捕获异常显示 catch (Exception e) { Console.WriteLine(\"Exception {0} thrown.\", e.GetType().FullName); Console.WriteLine(\"Message:\\n\\\"{0}\\\"\", e.Message); } ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:4:4","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"面向对象编程\r类包括：字段/属性/方法/常量/构造函数/索引器/运算符/事件/类型/析构函数 字段：不应该被设置为public 属性：自动实现的属性也就是没有声明私有字段，就可以使用初始化器来初始化；public int Age{set;get;}=42; set和get可以被访问修饰符修饰，但get和set中必须有一个具有属性的访问级别，属性其实并不怎么消耗资源，因为在JIT中，被变成内联函数， readonly:readonly只能在构造函数中赋值，然后就不好修改。 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:0","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"构造函数\r静态构造函数 创建包含静态构造函数的类实例 访问包含静态构造函数的类的静态成员时，（无论创建多少个实例，静态构造函数只调用一次。） 构造函数和析构函数，和C++一样 静态类不能实例化对象，只能包含静态成员， 如果没有构造函数，编译器会自动添加一个默认构造函数 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:1","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"派生类构造函数的调用\r构造函数总是按照层次结构顺序调用的：先调用object的构造函数，然后从上到下一次调用，直到达到编译器要实例化的类为止 如果要调用基类的非默认构造函数就需要使用构造函数初始化器。 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:2","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"访问修饰符\rpublic/ 所有类型成员/任何代码均可以访问该项 protected/类型和内嵌类型的所有成员/只有派生类型能够访问该类 internal/所有类型和成员/只能包含他的程序集中能够访问该类 private/类型和内嵌类型的所有成员/只能在它所属的类型中访问该项 protected internal/类型和内嵌类型的所有成员/只能在包含他的程序集和派生类型的任何代码中访问该项 new/static /virtual/abstract/override/sealed/extern ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:3","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"字段和属性\r统一建模语言Unified Modeling Language(UML) ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:4","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"接口\r接口可以看成是类的引用，可以引用任何实现该接口的类 一般情况下接口只能包含：方法，属性，索引器，事件的声明 把公共实例(非静态)方法和属性组合起来，以封装特定功能的一个集合,接口不能实例化 IDisposable接口的对象必须实现其Dispose()方法，当不再需要某个对象时就调用这个方法，释放重要资源， C#简化了这种方法，using关键字可以在代码块中初始化使用重要资源的对象，这个代码块的结尾会自动调用Dispose()方法 \u003cClassName\u003e\u003cVariableName\u003e=new \u003cClassName\u003e(); ... using(\u003cVariableName\u003e) { ... } 或 using(\u003cClassName\u003e\u003cVariableName\u003e=new \u003cClassName\u003e()) {...} 接口可以彼此集成，和类的集成差不多 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:5","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"继承\rC#类可以派生自另一个类和多个接口，只有虚方法和抽象方法才能使用override重写，不然是不能重写的，如果不重写虚方法或抽象方法，需要使用关键字new，那么调用的时候调用子类方法就可以使用base.方法 纯虚基类，重写方法，也可以不重写，虚方法可以实现，也可以实现（同属性） 基类成员的访问性 protected\\privated\\public 抽象基类不能实例化，抽象基类必须被继承，成员没有实现代码，在派生类中实现他们 抽象基类在UML中为斜体 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:6","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"is and as\rIBankAccount account= o as IBankAccount; if(o is IBankAccount){IBankAccount account = (IBankAccount)o;} ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:7","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"多态\r通过实例化不同的派生类调用派生类的重写方法 将派生类赋给基类调用基类重写方法，实际上调用了基类的重写方法 接口的多态性，尽管不能实例化接口，可以建立接口类型的变量，然后就可以在支持该接口的对象上，使用这个变量来访问接口提供的方法和属性 例如不适用基类提供的方法，而是把该方法放在接口上，实例化也支持该接口，唯一的区别是方法的实现代码不一样（接口不包含方法的实现），通过接口可以实现访问多个对象的方法而不依赖于一个公共的基类 Cow myCow=new Cow(); Chicken myChicken=new Chicken(); IConsume consumeInterface; consumeInterface = myCow; consumeInterface.EatFood(); consumeInterface = myChicken; consumeInterface.EatFood(); 对象之间的关系 包含关系，这个成员字段可以是公共字段，此时是继承关系一样，容器对象的用户就可以访问它的方法和属性，与继承不同的是，不能访问类的内部代码，类变成其私有变量 集合关系，增加了功能的数组 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:8","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"密封类和密封方法\r如果不允许创建派生自某个自定义类的类，该自定义类就应该是密封的，sealed 使用密封类可以提高性能，编译器知道该类没有派生，因此就没有虚函数表 string是密封的 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:9","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"托管和非托管\r托管和非托管资源，存储在托管或本机堆中的对象，垃圾回收器释放存储在托管堆中的对象，却不会释放本机堆中的对象。 值数据类型：window使用虚拟寻址系统，可以将程序所使用的内存地址映射内存中的实际地址（编译器来做）。每个进程都会有4G的内存，该内存被称为虚拟内存，从0开始往下排。在虚拟内存中有一个地方叫做栈，栈存储的是不是对象成员的值数据类型，调用方法时，栈存储传递给方法的所有参数副本。 栈实际上是向下填充的，先0x800000,然后0x799999 int a=10; double b=7999; 在运行到a=10时，int是四个字节，0x799999-0x799996被10占用，下一个空闲单元是0x799995,double 8个字节，就是0x799987 超出b的定义域后就会加8个字节，超出a的定义域后就会加4个字节。 ab进入栈的顺序是由编译器来决定的，编译器会查看作用域的顺序来决定哪个先进栈哪个后进栈。 引用类型的堆：堆上的内存是向上分配的 void Work() { Customer arabel;//1 arabel= new Customer();//2 Customer othercustomer2=new Customer();//3 } 首先1声明一个customer的引用arabel，在栈上给这个引用分配存储空间，该引用为4个字节， 2分配堆上的内存，以存储一个真正的Customer对象，然后把变量arabel的值设置为新分配的customer对象的内存地址，该customer可能包含32个字节，类的字节数和类的字段等成员有关 3是声明一个customer的引用，放在栈上，实例化一个customer对象放在堆上，将堆上的地址放到栈的引用上。 非托管堆： 当一个引用变量超出作用域时，它的引用会从栈中删除，但引用的对象任然在堆中，一直到程序终止，或垃圾回收器回收他们。 垃圾回收，删除堆中不再有被引用的所有对象，垃圾回收器（C++垃圾回收）在引用跟表中找到所有引用对象，在引用对象树中查找，在完成删除后，堆会立即把对象分散开来，与已经释放的内存混在一起。 托管堆： 如果托管堆也是这样，其给新对象分配内存时就是一个很难处理的问题，运行库必须遍历整个堆，才能找到足够大内存来存储新的对象。但垃圾回收器不会让堆处在这种状态，它在释放完可以释放的资源后，会将其他对象回推到堆的底部，再次形成连续数据块，在移动时所用引用都要更新，这需要垃圾回收器来完成。 垃圾回收期的压缩操作就是托管堆和非托管堆的区别，托管堆虽然要压缩，但分配内存时，只需要地址就好，不需要遍历地址列表。 创建对象时，会把对象放到托管堆上称为0代，创建新对象会被移动到这一部分，第一次回收后，保留下来的内容会被压缩移动到堆的下一部分上或世代部分，第1代对应部分，此时第0代对应的部分为空，新的对象依然被放到这个部分，遗留下来的内容让在第1代部分，第二次回收，第1代被压缩到第2代部分，第0代被压缩到第1代，第0代为空，放新的内容。如果新的对象超出第0代部分就会进行垃圾回收 垃圾回收可以提供应用程序性能，可以在架构堆上处理较大对象的方式， .NET较大对象有自己的堆，称为大对象堆，对象大于85000个字节就会被放在这个堆上，而不是主堆上，因为较大对象的压缩代价比较大，所以不放在主堆上压缩 第二代和大对象堆的回收即压缩过程是在后台线程中进行的 强引用和弱引用 仍在引用的对象的内存为强引用，可以回收不在根表中直接或间接引用的托管内存 A引用B,B引用C,C引用A，则GC会销毁所有对象。 实例化一个类，只要有代码引用它就是强引用 var myclassVariable = new MyClass(); var myCache=new MyCache(); myCache.Add(myclassVariable); myclassVariable=null//3 当第3步运行时就不能释放myclassVariable所引用的内存，因为缓存中还存在引用。在弱引用中就可以避免这种现象。 弱引用可以创建和使用对象，但是如果垃圾回收器在运行就可以回收 弱引用是由WeakReference创建的。需要使用IsAlive属性来确认是否被回收，Target属性可以返回一个强引用，不为null就可以访问 var myWeakReference = new WeakRefernece(new DataObject()); if(myWeakReference.IsActive) { DataObject strongReference=myWeakReference.Target as DataTarget; if(strongReference!=null) {} } else {} 垃圾回收器不释放非托管资源 比如：文件句柄，网络连接，数据库连接，等 定义类时，可以有两种机制来自动释放非托管资源 声明一个析构函数（或则终结器），作为类成员 class MyClass { ~MyClass() { } } 编译器在编译析构函数时，会隐式把析构函数的代码编译为等价于重写Finalize()方法的代码，从而确保父类的Finalize（）会被执行 等价 protected override void Finalize() { try {} finally { base.Finally(); } } C#析构函数具有不确定性，无法确定析构函数会被何时执行，同时析构函数会延迟对象从内存中删除的时间，有析构函数两次才能删除对象，第一次调用析构函数，第二次调用才真正删除，同时会被另起一个线程来调用Finally() 实现System.IDisposable 接口 该接口替代析构函数 class MyClass:IDisposable { public void Dispose() { } } Dispose()方法的实现显示释放由对象直接使用的所有非托管资源。Dispose为何时释放非托管资源提供了精确的控制。 using语句会自动调用Dispose()方法 上面的两种方法都实现了释放非托管资源 下面是一个双重实现的代码： using System; public class ResourceHolder:IDisposable { private bool _isDisposed=false; public void Dispose() { DisPose(true); GC.SuppressFinalize(this); } protected virtual void Dispose(bool disposing) { if(!_isDisposed) { if(disposing) { //cleanup managed objects by calling their dispose() methods } //clean up unmanaged objects } _isDisposed = true; } ~ResourceHolder() { Dispose(false); } public void SomeMethod() { //enture object not already disposed before execution of any method if(_isDisposed) { throw new ObjectDisposedException(\"ResourceHolder\"); } //method implementation } } ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:10","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"指针\rC#也是可以使用指针的，unsafe{}，在C#高级编程5.5不安全代码。留坑 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:11","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"运算符重载\r","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:12","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"事件\r对象可以激活和使用事件，作为他们处理的一部分，事件非常重要，可以在代码的其他部分起作用，类似于异常，但是功能更强大 可以在Animal对象添加到Animal集合中，执行特性的代码，而这部分代码不是Animal类的一部分，也不是调用Add()方法的代码的一部分，为此，需要给代码添加事件处理程序，这是一种特殊类型的函数，在事件发生时调用，还需要配置这个处理程序，以监听自己感兴趣的事情 private void Button1_Click_1(object sender, RoutedEventArgs e) { ((Button)sender).Content = \"clicked\"; Button newButton = new Button(); newButton.Content = \"NEW Button\"; newButton.Margin = new Thickness(10, 10, 200, 200); newButton.Click += newButton_click; ((Grid)((Button)sender).Parent).Children.Add(newButton); } private void newButton_click(object sender, RoutedEventArgs e) { ((Button)sender).Content = \"clicked\"; } ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:13","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"引用类型还是值类型\r在C#中，数据根据变量的类型以两种方法中的一种存储在一个变量中： 值类型的内存的同一个地方存储它们和它们的内容，栈 引用类型存储指向内存中其他某个位置的引用，实际内容存储在这个位置，堆 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:14","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"定义类\r类声明为内部，只有当前项目的代码能够访问 internal(默认) 其他项目代码也能访问public 类是抽象的，不能实例化，只能继承abstract，密封的sealed不能继承,如果基类是抽象的，在派生类必须全部实现 无或internal 只能在当前项目中访问 public可以在任何地方访问类 abstract或internal abstract类只能在当前项目访问，不能实例化，只能被继承 public abstracrt类可以在任何地方访问，不能实例化，只能继承 sealed或internal sealed类只能在当前项目访问，不能被继承，只能实例化 public sealed类可以在任何地方访问，不能被继承只能实例化 public sealed class MyClass { //Class members } 派生类的可访问性不能高于基类 类还可以指定接口，同时必须实现该接口的所有成员，如果不想使用给定的接口成员，就可以提供一个空的实现方法，继承类（只能有一个）再继承接口，接口可以有多个 接口的定义,不能在接口中使用abstract或sealed，可以使用继承的方式继承接口 interface IMyInterface { .... } 所有类都隐式继承System.Object类 多态性便可以使用，比较重要的基类方法GetType()ToStrign() if(myObject.GetType()==typeof(MyComplexClass)) { } 初始化列表 ：base(i) :this(5,6)调用自己的两个参数的构造函数，可以伪装成默认构造函数 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:15","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"定义类成员\rpublic,private,internal,protected readonly表示字段只能在执行构造函数的过程中赋值，static 静态变量，const也是静态的 方法 virtual方法可以重写 abstract方法必须在非抽象的派生类中重写（只用于抽象类中） override方法重写了一个基类方法（如果方法被重写，就必须要使用关键字）,如果使用了override,也可以使用sealed来指定在派生类中不能对这个方法做进一步修改即这个方法不能由派生类重写 extern方法定义在其他地方 多态测试，使用virtual和override多态测试成功 属性 定义与字段类似，get和set关键字来定义，可以控制属性的访问级别 右击refactor(重构)-Encapsulate Field可以快熟添加属性 自动属性： public int MyIntProp { get;set; } + 按通常的方式定义属性的名称、类型和可访问性，但是没有提供get和set的实现代码，实现代码由编译器提供（私有字段的名字也由编译器提供，将set变成private set即变成只读）\rprivate int myInt; public int myIntProp { get { return myInt; } public set { if(value\u003e0\u0026\u0026value\u003c10) myInt=value; else throw(new ArgumentOutOfRangeException(\"MyIntProp\",value,\"MyIntProp must be assigned a value between 0 and 10\")); } } 隐藏 隐藏基类方法，会产生2个警告（如果要确定隐藏需要加上new）,无论基类怎样限制，只要派生类没有调用override都是影藏 要对派生类的用户隐藏继承的公共成员，但仍能访问其功能，要给继承的虚拟成员添加实现代码，而不是简单地用重写的新实现代码替换它，可以使用base关键字：base.DoSomething() this最常用的功能是将当前对象实例的引用传递给一个方法，该方法有一个参数是指向基类的，this关键字的另一个常用方法是限定局部类型成员 class Animal { public void EatFood() { Console.WriteLine(\"Animal is adjusted\"); } } class Chicken : Animal { public void EatFood()//new public void EatFood() { Console.WriteLine(\"Chicken is adjusted\"); } } class Cow : Animal { public void EatFood()//new public void EatFood() { Console.WriteLine(\"Cow is adjusted\"); } } 套嵌类型成员 public class MyClass { public class MyNestedClass { public int NestedClassField; } }//实例化时： MyClass.MyNestedClass myObj=new MyClass.MyNestedClass(); public class ClassA { private int state = -1; public int State { get { return state; } } public class ClassB { public void SetPrivateState(ClassA target, int newState) { target.state = newState; } } } class Program { static void Main(string[] args) { ClassA myObject = new ClassA(); Console.WriteLine(\"myObject.State = {0}\", myObject.State); ClassA.ClassB myOtherObject = new ClassA.ClassB(); myOtherObject.SetPrivateState(myObject, 999); Console.WriteLine(\"myObject.State = {0}\", myObject.State); Console.ReadKey(); } }//嵌套类修改只读变量 接口 接口不会有访问修饰符 接口成员没有实现 接口没有字段成员(但是接口可以定义自动属性) 不能有关键字static/virtual/abstract/sealed来定义接口 但接口是可以继承的，如果要隐藏基类成员，需要加关键字new public interface IMyInterface { void DoSomething(); void DoSomethingElse(); } public class MyClass:IMyInterface { public void DoSomething() { } public void DoSomethingElse() { } }//接口类必须包含接口的所有成员包括匹配的指定签名包括get和set public interface IMyInterface { void DoSomething(); void DoSomethingElse(); } public class MyBaseClass { public void DoSomething() { } } public class MyDerivedClass:MyBaseClass,IMyInterface { public void DoSomethingElse() { } } public interface IMyInterface { void DoSomething(); void DoSomethingElse(); } public class MyBaseClass:IMyInterface { public virtual void DoSomething() { } public virtual void DoSomethingElse() { } } public class MyDerivedClass:MyBaseClass { public override void DoSomethingElse() { } public override void DoSomethingElse() { } } + 实现接口\rMyClass myObj=new MyClass(); IMyInterface myInt=myObj; myInt.DoSomething(); public class MyClass :IMyInterface { void IMyInterface.DoSomething()//显示调用 { } public void DoSomething()//隐式调用 { } } public interface IMyInterface { int MyIntProperty { get; } } public class MyBaseClass:IMyInterface { public int MyIntProperty{get;protected set;} } + 把接口放在不同的文件中partial\r//定义类时使用 public partial class MyClass { } //部分方法定义 public partial class MyClass { partial void DoSomethingElse(); public void DoSomething() { console.writeline(\"do something started\"); DoSomethingElse(); console.writeline(\"do something ended\"); } } public partial class MyClass { partial void DoSomethingElse() { console.writeline(\"DoSomethingElse called\"); } } //如果删除部分方法的实现部分，编译时编译器会以为调用了一个空的部分方法会直接删除部分方法的调用 集合 可以使用集合来维护对象组 集合大多是通过System.Collections名称空间中的接口而获得的，集合的语法已经标准化了 System.Collections包括几个接口： IEnumerable可以迭代集合中的项foreach ICollection继承上一个接口，可以获取集合中项的个数，并能把项复制到一个简单的数组类型中count()copyto(),add(),remove(),clear() IList继承上两个接口，提供了集合的项列表，允许访问这些项，并提供一些基本功能insert(),removeat(),派生于Icollection\u003cT\u003e接口 ISet获取两个集合的交集 IDictionary继承与前两个接口，可以通过键值访问项列表 ILookup接口，键和值 Icomparer实现compar","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:16","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"泛型\r泛型是以实例化的过程中提供的类型或类为基础建立的，可以毫不费力的对对象进行强类型化,使用泛型强化为各种类型。与C++不同，C++是在编译期间来强类型化，而C#是在运行期间强类型化 CollectionClass\u003cItemClass\u003e items= new CollectionClass\u003cItemClass\u003e(); items.Add(new ItemClass); .net 提供的泛型，包括System.Collections.Generic名称空间 可空类型，引用类型可以为空，值类型必须有一个值，扩展值类型让其可为空，泛型使用了System.Nullable类型提供了值类型为空的一种方法 System.Nullable\u003cint\u003e nullableInt;变量nullableInt可以包含int类型的任意值，还可以拥有null nullableInt=null;等价于nullableInt=new System.Nullable\u003cint\u003e(); nullableInt.HasValue,该方法不适用于引用类型，引用类型本身可能为NULL int？ nullableInt；int？是System.Nullable\u003cint\u003e 的缩写 可控类型null+任何数都为null,null在布尔运算中的大小介于FALSE和TRUE之间 ？？运算符为空结合运算符，是一个二元运算符，允许给可能等于NULL的表达式提供另一个值，op1??op2等价于op1==null?op2:op1; List\u003cT\u003e myCollection=new List\u003cT\u003e(); Item 获取或设置指定索引处的元素。 Count 获取 List 中实际包含的元素数。 Add 将对象添加到 List 的结尾处。 AddRange 将指定集合的元素添加到 List 的末尾。 Clear 从 List 中移除所有元素。 Contains 确定某元素是否在 List 中。 ConvertAll 将当前 List 中的元素转换为另一种类型，并返回包含转换后的元素的列表。 Equals(Object) 确定指定的 Object 是否等于当前的 Object。 （继承自 Object。） Remove 从 List 中移除特定对象的第一个匹配项。 Sort() 使用默认比较器对整个 List 中的元素进行排序。 ToArray 将 List 的元素复制到新数组中。 ToString 返回表示当前对象的字符串。 （继承自 Object。） using System.Collections.Generic; List\u003cAnimal\u003e animalCollection = new List\u003cAnimal\u003e(); animalCollection.Add(new Cow(\"Jack\")); animalCollection.Add(new Chicken(\"Vera\")); foreach (Animal myAnimal in animalCollection) { myAnimal.Feed(); } 或者 public class Animals:List\u003cAnimal\u003e {} 对泛型进行排序 System.Collections.Generic名称空间包含List\u003cT\u003eT类型对象集合,Dictionary\u003cK,V\u003e与K类型的键值相关的V类型的项的集合 List\u003cT\u003e 使用泛型接口IComparer\u003cT\u003e和IComparable\u003cT\u003e int IComparable\u003cT\u003e.CompareTo(T otherObj) bool IComparable\u003cT\u003e.Equals(T otherObj) int IComparer\u003cT\u003e.Compare(T objectA,T objectB) bool ICompare\u003cT\u003e.Equals(T objectA,T objectB) int IComparer\u003cT\u003e.GetHashCode(T objectA) 给列表排序，需要有一个方法来比较两个T类型的对象，要在列表中搜索，需要用一个方法来检查T类型的对象 两个泛型委托： Comparison\u003cT\u003e int method(T objectA,TobjectB) Predicate\u003cT\u003e bool method(T targetObject) public class Vectors : List\u003cVector\u003e { public Vectors() { } public Vectors(IEnumerable\u003cVector\u003e initialItems) { foreach (Vector vector in initialItems) { Add(vector); } } public string Sum() { StringBuilder sb = new StringBuilder();//表示可变字符字符串 Vector currentPoint = new Vector(0.0, 0.0); sb.Append(\"origin\"); foreach (Vector vector in this) { sb.AppendFormat(\" + {0}\", vector); currentPoint += vector; } sb.AppendFormat(\" = {0}\", currentPoint); return sb.ToString(); } } public static class VectorDelegates { public static int Compare(Vector x, Vector y) { if (x.R \u003e y.R) { return 1; } else if (x.R \u003c y.R) { return -1; } return 0; } public static bool TopRightQuadrant(Vector target) { if (target.Theta \u003e= 0.0 \u0026\u0026 target.Theta \u003c= 90.0) { return true; } else { return false; } } } class Program { static void Main(string[] args) { Vectors route = new Vectors(); route.Add(new Vector(2.0, 90.0)); route.Add(new Vector(1.0, 180.0)); route.Add(new Vector(0.5, 45.0)); route.Add(new Vector(2.5, 315.0)); Console.WriteLine(route.Sum()); Comparison\u003cVector\u003e sorter = new Comparison\u003cVector\u003e(VectorDelegates.Compare);//委托 route.Sort(sorter);//这个个语句可以简化route.Sort(VectorDelegates.Compare); Console.WriteLine(route.Sum()); Predicate\u003cVector\u003e searcher = new Predicate\u003cVector\u003e(VectorDelegates.TopRightQuadrant);//委托 Vectors topRightQuadrantRoute = new Vectors(route.FindAll(searcher)); Console.WriteLine(topRightQuadrantRoute.Sum()); Console.ReadKey(); } } + `Dictionary\u003cK,V\u003e`该类型建立键/值对应这个类需要实例化两个类型，分别用于键和值\rDictionary\u003cstring ,int\u003ethings=new Directionary\u003cstring ,int \u003e() things.Add(\"Green Things\",29); foreach(strign key in things.Values) { using key; } foreach(int value in things.Values) { usign value } foreach(KeyValuePair\u003cstring,int \u003e thing in things) { using things.key and things.value } + 每个键都独立的，如果相同抛出异常`Dictionary\u003cstring ,int\u003ethings=new Directionary\u003cstring ,int \u003e(stringComparer.CurrentCultureIgnoreCase)`自己的类用作键，不区分发小写比较，这样同一个类就会出现异常\r定义泛型 要创建泛型类 class MyGenericClass\u003cT1,T2,T3\u003e { } + 定义泛型后就可以像使用其他数据类型一样使用它们\r+ default关键字,default(T1),如果T1是值类型使之默认为0，如果为引用就默认为null\r+ 约束\rclass MyGenericClass\u003cT1,T2,T3\u003e where T:constraint1,constraint2 { } //约束必须在继承后面 + struct类型必须为值类型\r+ class类型必须为引用类型\r+ ba","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:17","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"事件\r事件必须订阅，可以由多个订阅 using System.Timers; class Program { static int counter = 0; static string displayString = \"This string will appear one letter at a time. \"; static void Main(string[] args) { Timer myTimer = new Timer(100);//创建定时器，毫秒 myTimer.Elapsed += new ElapsedEventHandler(WriteChar);//Elapsed事件该事件必须匹配System.Timers.ElapsedEventHandler委托类型的返回值 //处理程序和事件订阅起来，事件处理方法初始化为一个新的委托实例 //可以直接写成myTimer.Elapsed +=WriteChar； myTimer.Start();//启动定时器 System.Threading.Thread.Sleep(200);//将当前线程阻塞指定的毫秒数 Console.ReadKey(); } static void WriteChar(object source, ElapsedEventArgs e) { Console.Write(displayString[counter++ % displayString.Length]); } } System.Timers.ElapsedEventHandler委托类型是标准委托之一， void \u003cMethodName\u003e(object source,ElapsedEventArgs e) 定义事件 public delegate void MessageHandler(string messageText);//定义委托，该委托用于定义的事件必须指明返回值的参数值 public class Connection { public event MessageHandler MessageArrived;//给时间命名并指定委托的类型 private Timer pollTimer;//定时器 public Connection() { pollTimer = new Timer(100);//定时器时间 pollTimer.Elapsed += new ElapsedEventHandler(CheckForMessage);//定时器的事件委托 } public void Connect() { pollTimer.Start();//定时器开始 } public void Disconnect() { pollTimer.Stop();//定时器结束 } private static Random random = new Random(); private void CheckForMessage(object source, ElapsedEventArgs e)//定时器的委托函数； { Console.WriteLine(\"Checking for new messages.\"); if ((random.Next(9) == 0) \u0026\u0026 (MessageArrived != null))///生成一个0-9的数，如果是0，并且事件有订阅者，则事件实现委托就使用委托来 { MessageArrived(\"Hello Mum!\"); } } } public class Display { public void DisplayMessage(string message) { Console.WriteLine(\"Message arrived: {0}\", message); } } class Program { static void Main(string[] args) { Connection myConnection = new Connection(); Display myDisplay = new Display(); myConnection.MessageArrived +=new MessageHandler(myDisplay.DisplayMessage);//将委托和函数绑定 myConnection.Connect(); System.Threading.Thread.Sleep(200); Console.ReadKey(); } } 多用途事件处理程序 Timer.Elapsed事件的委托包含了事件处理程序中常见的两类参数 object source:引发事件对象的引用 ElapsdEventArgs:由事件传送的参数 由不同对象引发的几个相同事件使用相同事件处理程序 public class MessageArrivedEventArgs : EventArgs//定义消息类 { private string message; public string Message { get { return message; } } public MessageArrivedEventArgs() { message = \"No message sent.\"; } public MessageArrivedEventArgs(string newMessage) { message = newMessage; } } public class Connection { public event EventHandler\u003cMessageArrivedEventArgs\u003e MessageArrived;//事件，EventHandler\u003cT\u003e为委托模板，将消息类传入 private Timer pollTimer; public string Name { get; set; } public Connection() { pollTimer = new Timer(100); pollTimer.Elapsed += new ElapsedEventHandler(CheckForMessage); } public void Connect() { pollTimer.Start(); } public void Disconnect() { pollTimer.Stop(); } private static Random random = new Random(); private void CheckForMessage(object source, ElapsedEventArgs e) { Console.WriteLine(\"Checking for new messages.\"); if ((random.Next(9) == 0) \u0026\u0026 (MessageArrived != null)) { MessageArrived(this, new MessageArrivedEventArgs(\"Hello Mum!\"));//发送消息 } } } public class Display//事件响应函数 { public void DisplayMessage(object source, MessageArrivedEventArgs e) { Console.WriteLine(\"Message arrived from: {0}\", ((Connection)source).Name); Console.WriteLine(\"Message Text: {0}\", e.Message); } } class Program { static void Main(string[] args) { Connection myConnection1 = new Connection(); myConnection1.Name = \"First connection.\"; Connection myConnection2 = new Connection(); myConnection2.Name = \"Second connection.\"; Display myDisplay = new Display(); myConnection1.MessageArrived += myDisplay.DisplayMessage; myConnection2.MessageArrived += myDisplay.DisplayMessage; myConnection1.Connect(); myConnection2.Connect(); System.Threading.Thread.Sleep(200); Console.ReadKey(); } } + .net提供了两个委托类型：EventHandler和`EventHandler\u003cT\u003e`\r+ 匿名方法，纯粹是为了用作委托目的而创建的\rdelegate(parameters) { } parameters参数化列表 myConnection1.MessageArrived += delegate(Connection source,MessageArriveEventArgs e) {Console.writeline(\"message arrived from{0}\",source.Name);} ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:18","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"特性，元数据\r可以为代码段标记一些信息，这些信息可以从外部读取 [DebuggerStepThrough] public void DullMethod() {}该特性说明，在调试的时候不进入该方法进行逐句调试，而是跳过该方法,该特性通过DebuggerStepThroughAttribute这个类来实现的，这个类位于System.Diagnostics名称空间中 特性的参数可以自己设置[DoesInterestingThings(1000, WhatDoesItDo = “voodoo”)] 读取特性需要用到反射,Type.GetCustomAttributes来实现 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:19","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"补充\r对象初始化器 省略构造函数的括号，自动调用无参数构造函数，之后调用初始化器 同时对象初始化器还可以进行嵌套 //初始化器,使用默认构造函数实现赋值 \u003cclassname\u003e \u003cvariableName\u003e=new \u003cclaseename\u003e { \u003cpropertyOrField1\u003e=\u003cvalue1\u003e, \u003cpropertyOrField2\u003e=\u003cvalue2\u003e, \u003cpropertyOrField3\u003e=\u003cvalue3\u003e, ... } Curry tastyCurry=new Curry { MainInte=\"ddddd\"; Origin=new restaurant { Name=\"ddd\"; } }; 集合初始化器 类型推理：var ,编译器来确定类型，var关键字还可以通过数组初始化器来推断数组的类型：var myarray=new [] {4,5,6,7};4,5,6,7必须遵循：相同的类型，相同的引用类型或空，所有元素的类型都可以隐式转换为同一类型 匿名对象：为了减少创建对象所消耗的时间，其理念就是让编辑器根据要存储的数据自动创建类型，而不是定义简单的数据存储类型 匿名类型 var curry=new { MainIngredient=\"lamb\", Style=\"Dhansnk\", Spiciness=5 }; + 使用var关键字，因为匿名类型没有可以使用的标识符，\r+ new后面没有指定类型的名称\r+ 匿名对象的属性被定义为只读，如果在存储对象中修改属性的值，就不能使用匿名对象。\r+ 使用动态查找功能可以处理未知的C#类型\rclass Program { static void Main(string[] args) { var curries = new[] { new { MainIngredient = \"Lamb\", Style = \"Dhansak\", Spiciness = 5 }, new { MainIngredient = \"Lamb\", Style = \"Dhansak\", Spiciness = 5 }, new { MainIngredient = \"Chicken\", Style = \"Dhansak\", Spiciness = 5 } }; Console.WriteLine(curries[0].ToString()); Console.WriteLine(curries[0].GetHashCode()); Console.WriteLine(curries[1].GetHashCode()); Console.WriteLine(curries[2].GetHashCode()); Console.WriteLine(curries[0].Equals(curries[1]));//比较状态，即每个属性的值 Console.WriteLine(curries[0].Equals(curries[2])); Console.WriteLine(curries[0] == curries[1]); Console.WriteLine(curries[0] == curries[2]); Console.ReadKey(); } } { MainIngredient = Lamb, Style = Dhansak, Spiciness = 5 } 294897435 294897435 621671265 True False False False 动态类型：dynamic myDynamicVar;在编译期间会被object替代， 默认参数类型 可变参数 命名参数：首先选定必选参数，再指定命名的可选参数 public static List\u003cstring\u003e GetWords( string sentence, bool capitalizeWords = false, bool reverseOrder = false, bool reverseWords = false) { List\u003cstring\u003e words = new List\u003cstring\u003e(sentence.Split(' ')); if (capitalizeWords) words = CapitalizeWords(words); if (reverseOrder) words = ReverseOrder(words); if (reverseWords) words = ReverseWords(words); return words; } words = WordProcessor.GetWords( sentence, reverseWords: true, capitalizeWords: true); 扩展方法 要创建和使用扩展方法必须： 创建一个非泛型静态类 使用扩展方法的语法，为所创建的类添加扩展方法，做为静态方法 确保使用扩展方法的代码用using语法导入包含扩展方法类的名称空间 通过扩展类型的一个实例调用扩展方法，与调用扩展类型的其他方法一样。 扩展方法的要求： 方法必须是静态的 方法必须包含一个参数，表示调用扩展方法的类型实例 实例参数必须是方法定义的第一个参数， 除了this关键字外，实例参数不能有其他修饰符 public static class ExtensionClass { public static \u003cReturnType\u003e \u003cExtensionMethodName\u003e(this \u003cTyprToExtend\u003e instance ,\u003cotherParamters\u003e) { ... } } public static class ExtensionClass { public static \u003cReturnType\u003e \u003cExtensionMethodName\u003e(this \u003cTyprToExtend\u003e instance ,\u003cotherParamters\u003e) { ... } } \u003cTypeToExtend\u003e myVar; //myVar is initialized by code not shown here myVar.\u003cExtensionMethodName\u003e(); \u003cTypeToExtend\u003e myVar; ExtensionClass.\u003cExtensionMethodName\u003e(myVar); //导入后可以通过IntelliSense查看扩展方法 //定义了一个扩展方法后还可以将其运用到派生于这个类型的子类型中 namespace ExtensionLib { public static class WordProcessor { public static List\u003cstring\u003e GetWords( this string sentence, bool capitalizeWords = false, bool reverseOrder = false, bool reverseWords = false) { List\u003cstring\u003e words = new List\u003cstring\u003e(sentence.Split(' ')); if (capitalizeWords) words = CapitalizeWords(words); if (reverseOrder) words = ReverseOrder(words); if (reverseWords) words = ReverseWords(words); return words; } public static string ToStringReversed(this object inputObject) { return ReverseWord(inputObject.ToString()); } } } using ExtensionLib; static void Main(string[] args) { Console.WriteLine(\"Enter a string to convert:\"); string sourceString = Console.ReadLine(); Console.WriteLine(\"String with title casing: {0}\", sourceString.GetWords(capitalizeWords: true) .AsSentence()); Console.WriteLine(\"String backwards: {0}\", sourceString.GetWords(reverseOrder: true, reverseWords: true).AsSentence()); Console.WriteLine(\"String length backwards: {0}\", sourceString.Length.ToStringReversed()); Console.ReadKey(); } lambda表达式 定义一个事件处理方法，其返回类型和参数匹配要订阅的事件需要委托返回类型和参数 声明一个委托类型的变量 把委托变量初始化为委托类型的实例，实例指向事件处理方法 把委托变量添加到时间的订阅者列表中 正常的事件 Timer myTimer =new Timer(1000); myTimer.Elapsed+=new ElapsedEvendHandler(WriteChar); //可以直接写成 myTimer.Elapsed+=WriteChar； //使","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:6:0","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数据库\r","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:0:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数据库概述\rDBMS(DataBase Management System,数据库管理系统)和数据库。平时谈到“数据库”可能有两种含义：MSSQLServer、Oracle等某种DBMS；存放一堆数据表的一个分类(Catalog) 数据库的构成-管理软件/服务/数据文件(表,视图…) 不同品牌的DBMS有自己的不同的特点：MYSQL、MSSQLServer、DB2、Oracle、Access、Sybase等。对于开发人员来讲，大同小异 除了Access、SQLServerCE等文件型数据库之外，大部分数据库都需要数据库服务器才能运行。学习\\开发时是连接本机的数据库，上线运行时是数据库运行在单独的服务器 为什么要用数据库：我们平时把数据以文件的方式存放在硬盘里，但当数据量庞大的时候：文件大，操作效率很低下。所以，便有了很多种数据库软件(Mssql,Ora,DB2…)，它们代替我们做数据文件的操作(mdf,ndf,ldf)并提供高效的存储和检索等操作。还提供了很多接口给其他程序语言调用。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:1:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"为什么要使用数据库\r用文件保存数据与用数据库的优劣： 高效维护大量数据-检索/增/删/改 处理各个表之间的关系 压缩表数据 安全 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:2:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数据库的概念\rCatalog(分类)(又叫数据库DataBase,表空间TableSpace),不同类的数据应该放到不同的数据库中 便于对各个Catalog进行个性化管理 避免命名冲突3安全性更高 Table(表):书都放到书架上,碗都放到橱柜中,不同类型的资料放到不同的“格子”中，将这种区域叫做“表”(Table)。不同的表根据放的数据不同进行空间的优化，找起来也方便。 列(Column)、字段(Field) 主键(Primary Key)：主键就是一个表中每个数据行的唯一标识。不会有重复值的列才能当主键。一个表可以没有主键，但是会非常难以处理，因此没有特殊理由表都要设定主键 主键有两种选用策略：业务主键和逻辑主键。业务主键是使用有业务意义的字段做主键，比如身份证号、银行账号等；逻辑主键是使用没有任何业务意义的字段做主键，完全给程序看的，业务人员不会看的数据。因为很难保证业务主键不会重复（身份证号重复）、不会变化（帐号升位），因此推荐用逻辑主键。 外键(Foreign Key)—记录表与表的关联 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:3:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"SQLSERVER管理\r需要安装SQLServer2005或者SQLServer2008，若要使用SQLServer管理工具进行开发还要安装SQL Server Management Studio，还可以使用VisualStudio进行管理 使用免费的SQL Server Express版本，Express版本的服务器名称. \\SQLEXPRESS，对于开发人员来讲和其他版本没有区别。 SQLServer的两种验证方式：用户名验证和Windows验证，开发时用Windows验证就行。 开发人员关注点在开发上,而不是配置/备份等之上,那是DBA做的事情。 创建数据库，创建表，设置主键 SQLServer2008中：编辑200行；SQLServer2005中：打开表。 常用字段类型：bit(可选值0、1)、datetime、int、varchar、nvarchar（可能含有中文用nvarchar） Nvarchar(50)、Nvarchar(MAX) varchar、nvarchar 和char(n)的区别： char(n)不足长度n的部分用空格填充。Var：Variable，可变的。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:4:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"SQL语句入门\rSQL语句是和DBMS“交谈”专用的语句，不同DBMS都认SQL语法 SQL语句中字符串用单引号。 SQL语句是大小写不敏感的,不敏感指的是SQL关键字,字符串值还是大小写敏感的 创建表、删除表不仅可以手工完成,还可以执行SQL语句完成,在自动化部署、数据导入中用的很多,CREATE TABLE T_Person(Id int NOT NULL,Name nvarchar(50),Age int NULL)、Drop table T_Person1 简单的Insert语句。INSERT INTO T_Person(Id,Name,Age) VALUES(1,'Jim',20) （*） SQL主要分DDL（数据定义语言）和DML（数据操作语言）两类。Create Table、Drop Table、Alter Table等属于DDL，Select、Insert、Update、Delete等属于DML ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:5:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"主键的选择\rSQLServer中两种常用的主键数据类型：int（或bigint）+标识列(又称自动增长字段);uniqueidentifier(又称Guid、UUID) 用标识列实现字段自增可以避免并发等问题，不要开发人员控制自增。用标识列的字段在Insert的时候不用指定主键的值。将字段的“是标识列”设置为“是”，一个表只能有一个标识列。 Guid算法是一种可以产生唯一标识的高效算法，它使用网卡MAC、地址、纳秒级时间、芯片ID码等算出来的，这样保证每次生成的GUID永远不会重复，无论是同一个计算机上还是不同的计算机。在公元3400年以前产生的GUID与任何其他产生过的GUID都不相同。SQLServer中生成GUID的函数newid()，.Net中生成Guid的方法：Guid.NewGuid()，返回是Guid类型。 （*）Int自增字段的优点：占用空间小、无需开发人员干预、易读；缺点：效率低；数据导入导出的时候很痛苦。 （*）Guid的优点：效率高、数据导入导出方便；缺点占用空间大、不易读。 业界主流倾向于使用Guid。 Globally Unique Identifier(全球唯一标识符),也称作 UUID(Universally Unique IDentifier) GUID：用于指示产品的唯一性安装。是通过特定算法产生的一个二进制长度为128位的数字。在空间上和时间上具有唯一性，保证同一时间不同地方产生的数字不同。在公元3400年以前产生的UUID/GUID与任何其他产生过的UUIDs/GUIDs都不相同 GUID的长度固定，并且相对而言较短小，非常适合于排序、标识和存储。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:6:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"新增\r新增表和参数 CREATE TABLE T_Employee (FNumber VARCHAR(20),FName VARCHAR(20),FAge INT,FSalary NUMERIC(10,2),PRIMARY KEY (FNumber)); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('DEV001','Tom',25,8300); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('DEV002','Jerry',28,2300.80); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('SALES001','John',23,5000); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('SALES002','Kerry',28,6200); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('SALES003','Stone',22,1200); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('HR001','Jane',23,2200.88); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('HR002','Tina',25,5200.36); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('IT001','Smith',28,3900); INSERT INTO T_Employee(FNumber,FAge,FSalary) VALUES('IT002',27,2800); 插入一列 ALTER TABLE T_Employee ADD FSubCompany VARCHAR(20); UPDATE T_Employee SET FSubCompany='Beijing',FDepartment='Development' WHERE FNumber='DEV001'; Insert语句可以省略表名后的列名，但是不推荐 如果插入的行中有些字段的值不确定，那么Insert的时候不指定那些列即可。 可以给字段默认值，如果Guid类型主键的默认值设定为newid()就会自动生成，很少这么干 主键： insert into Person3(Name,Age) values('lily',38); insert into Person4(Id,Name,Age) values(newid(),'tom',30); ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:7:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"更新\r更新一个列:UPDATE T_Person Set Age=30 更新多个列:UPDATE T_Person Set Age=30,Name=‘tom’ 更新一部分数据： UPDATE T_Person Set Age=30 where Name=‘tom’，用where语句表示只更新Name是’tom’的行，注意SQL中等于判断用单个=，而不是== Where中还可以使用复杂的逻辑判断UPDATE T_Person Set Age=30 where Name=‘tom’ or Age\u003c25，or相当于C#中的||（或者） update Person1 set NickName=N'二十岁' where (Age\u003e20 and Age\u003c30) or(Age=80) Where中可以使用的其他逻辑运算符：or、and、not、\u003c、\u003e、\u003e=、\u003c=、!=（或\u003c\u003e）等 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:8:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"删除\r删除表中全部数据：DELETE FROM T_Person。 Delete只是删除数据，表还在，和Drop Table不同。 Delete 也可以带where子句来删除一部分数据：DELETE FROM T_Person WHERE FAge \u003e 20 Truncate 删除所有行并重置标识 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:9:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"检索\r执行备注中的代码创建测试数据表。 简单的数据检索 ：SELECT * FROM T_Employee 只检索需要的列 ：SELECT FNumber FROM T_Employee 、SELECT FName,FAge FROM T_Employee 列别名：SELECT FNumber AS 编号,FName AS 姓名,FAge AS Age111 FROM T_Employee 使用where检索符合条件的数据：SELECT FName FROM T_Employee WHERE FSalary\u003c5000。故事：新员工的数据检索噩梦。 还可以检索不与任何表关联的数据：select 1+1;select newid();select getdate(); ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:10:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数据汇总\rSQL聚合函数：MAX（最大值）、MIN（最小值）、AVG （平均值）、SUM （和）、COUNT（数量） 大于25岁的员工的最高工资 ： SELECT MAX(FSalary) FROM T_Employee WHERE FAge\u003e25 最低工资和最高工资： SELECT MIN(FSalary),MAX(FSalary) FROM T_Employee ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:11:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"排序\rORDER BY子句位于SELECT语句的末尾，它允许指定按照一个列或者多个列进行排序，还可以指定排序方式是升序（从小到大排列，ASC）还是降序（从大到小排列，DESC）。 按照年龄升序排序所有员工信息的列表： SELECT * FROM T_Employee ORDER BY FAge ASC 按照年龄从大到小排序，如果年龄相同则按照工资从大到小排序 ：SELECT * FROM T_Employee ORDER BY FAge DESC,FSalary DESC（多个排序条件） ORDER BY子句要放到WHERE子句之后 ：SELECT * FROM T_Employee WHERE FAge\u003e23 ORDER BY FAge DESC,FSalary DESC ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:12:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"通配过滤符\r通配符过滤关键字使用LIKE 。 单字符匹配的通配符为半角下划线“_”，它匹配单个出现的字符。 eg:以任意字符开头，剩余部分为“erry” SELECT * FROM T_Employee WHERE FName LIKE '_erry' 多字符匹配的通配符为半角百分号“%”，它匹配任意次数（零或多个）出现的任意字符。 “k%”匹配以“k”开头、任意长度的字符串 eg:检索姓名中包含字母“n”的员工信息 SELECT * FROM T_Employee WHERE FName LIKE '%n%' ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:13:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"空值处理\r数据库中，一个列如果没有指定值，那么值就为null，这个null和C#中的null，数据库中的null表示“不知道”，而不是表示没有。 因此select null+1结果是null，因为“不知道”加1的结果还是“不知道”。 SELECT * FROM T_Employee WHERE FNAME=null ； SELECT * FROM T_Employee WHERE FNAME!=null ； 都没有任何返回结果，因为数据库也“不知道”。 SQL中使用is null、is not null来进行空值判断： SELECT * FROM T_Employee WHERE FNAME is null ； SELECT * FROM T_Employee WHERE FNAME is not null ； ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:14:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"多值匹配\r删除多条数据 Delete T_Employee where FId in (21,22) SELECT FAge,FNumber,FName FROM T_Employee WHERE FAge IN (23,25,28) 范围值： SELECT * FROM T_Employee WHERE FAGE\u003e=23 AND FAGE \u003c=27 SELECT * FROM T_Employee WHERE FAGE BETWEEN 23 AND 27 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:15:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数据分组\r按照年龄进行分组统计各个年龄段的人数：SELECT FAge,Count(*) FROM T_Employee GROUP BY Fage GROUP BY子句必须放到WHERE语句的之后 没有出现在GROUP BY子句中的列是不能放到SELECT语句后的列名列表中的 (聚合函数中除外) 错误： SELECT FAge,FSalary FROM T_Employee GROUP BY FAge 正确： SELECT FAge,AVG(FSalary) FROM T_Employee GROUP BY FAge ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:16:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"对分组进行过滤\r在Where中不能使用聚合函数，必须使用Having，Having要位于Group By之后： SELECT FAge,COUNT(*) AS 人数 FROM T_Employee GROUP BY FAge HAVING COUNT(*)\u003e1 在分组的时候对分组后的成员进行过滤 注意Having中不能使用未参与分组的列，Having不能替代where。作用不一样，Having是对组进行过滤。having和where不会同时出现 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:16:1","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"限制结果集行数\rSELECT top 5 * FROM T_Employee order by FSalary Desc （*）检索按照工资从高到低排序检索从第六名开始一共三个人的信息 ： SELECT top 3 * FROM T_Employee WHERE FNumber NOT IN (SELECT TOP 5 FNumber FROM T_Employee ORDER BY FSalary DESC) ORDER BY FSalary DESC 该语句用来分页语句。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:17:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"去掉重复数据\r执行备注中的SQL语句，Alter和Insert单独执行 SELECT FDepartment FROM T_Employee SELECT DISTINCT FDepartment FROM T_Employee DISTINCT是对整个结果集进行数据重复处理的，而不是针对每一个列，因此下面的语句并不会只保留Fdepartment进行重复值处理：SELECT DISTINCT FDepartment,FSubCompany FROM T_Employee ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:18:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"联合结果集\rCREATE TABLE T_TempEmployee (FIdCardNumber VARCHAR(20),FName VARCHAR(20),FAge INT, PRIMARY KEY (FIdCardNumber)); INSERT INTO T_TempEmployee(FIdCardNumber,FName,FAge) VALUES('1234567890121','Sarani',33); INSERT INTO T_TempEmployee(FIdCardNumber,FName,FAge) VALUES('1234567890122','Tom',26); INSERT INTO T_TempEmployee(FIdCardNumber,FName,FAge) VALUES('1234567890123','Yalaha',38); INSERT INTO T_TempEmployee(FIdCardNumber,FName,FAge) VALUES('1234567890124','Tina',26); INSERT INTO T_TempEmployee(FIdCardNumber,FName,FAge) VALUES('1234567890125','Konkaya',29); INSERT INTO T_TempEmployee(FIdCardNumber,FName,FAge) VALUES('1234567890126','Fotifa',46); 简单的结果集联合： SELECT FNumber,FName,FAge FROM T_Employee UNION SELECT FIdCardNumber,FName,FAge FROM T_TempEmployee 基本的原则：每个结果集必须有相同的列数；每个结果集的列必须类型相容。 SELECT FNumber,FName,FAge,FDepartment FROM T_Employee UNION SELECT FIdCardNumber,FName,FAge,‘临时工，无部门' FROM T_TempEmployee ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:19:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"union all\rSELECT FName FROM T_Employee UNION SELECT FName FROM T_TempEmployee UNION 合并两个查询结果集，并且将其中完全重复的数据行合并为一条 SELECT FName FROM T_Employee UNION ALL SELECT FName FROM T_TempEmployee Union因为要进行重复值扫描，所以效率低，因此如果确定不要合并重复行，那么就用UNION ALL ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:19:1","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数字函数\rABS() ：求绝对值。 CEILING()：舍入到最大整数 。3.33将被舍入为4、2.89将被舍入为3、-3.61将被舍入为-3。 Ceiling→天花板 FLOOR()：舍入到最小整数。3.33将被舍入为3、2.89将被舍入为2、-3.61将被舍入为-4。 Floor→地板。 ROUND()：四舍五入。舍入到“离我半径最近的数” 。Round→“半径”。Round(3.1425,2)。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:20:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"string\rLEN() ：计算字符串长度，求字符 Datalength():求字节 LOWER() 、UPPER () ：转小写、大写 LTRIM()：字符串左侧的空格去掉 RTRIM () ：字符串右侧的空格去掉 LTRIM(RTRIM(’ bb ‘)) SUBSTRING(string,start_position,length) 参数string为主字符串，start_position为子字符串在主字符串中的起始位置，length为子字符串的最大长度。SELECT SUBSTRING('abcdef111',2,3) ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:20:1","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"日期\rGETDATE() ：取得当前日期时间 DATEADD (datepart , number, date )，计算增加以后的日期。参数date为待计算的日期；参数number为增量；参数datepart为计量单位，可选值见备注。DATEADD(DAY, 3,date)为计算日期date3天后的日期，而DATEADD(MONTH ,-8,date)为计算日期date8个月之前的日期 DATEDIFF ( datepart , startdate , enddate ) ：计算两个日期之间的差额。 datepart 为计量单位，可取值参考DateAdd。 统计不同工龄的员工的个数： select DateDiff(year,FInDate,getdate()),count(*) from T_Employee group by DateDiff(year,FInDate,getdate()) DATEPART (datepart,date)：返回一个日期的特定部分 统计员工的入职年份个数： select DatePart(year,FInDate),count(*) from T_Employee group by DatePart(year,FInDate) ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:20:2","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"类型转换函数\rCAST ( expression AS data_type) CONVERT ( data_type, expression) SELECT FIdNumber, RIGHT(FIdNumber,3) as 后三位, CAST(RIGHT(FIdNumber,3) AS INTEGER) as 后三位的整数形式, CAST(RIGHT(FIdNumber,3) AS INTEGER)+1 as 后三位加1, CONVERT(INTEGER,RIGHT(FIdNumber,3))/2 as 后三位除以2 FROM T_Person ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:21:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"空值处理函数\rISNULL(expression,value) ： 如果expression不为空则返回expression，否则返回value SELECT ISNULL(FName,'佚名') as 姓名 FROM\rT_Employee ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:22:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"case\r单值判断，相当于switch case CASE expression WHEN value1 THEN returnvalue1 WHEN value2 THEN returnvalue2 WHEN value3 THEN returnvalue3 ELSE defaultreturnvalue END 例子SELECT SELECT FName, (CASE FLevel WHEN 1 THEN 'VIP客户' WHEN 2 THEN '高级客户' WHEN 3 THEN '普通客户' ELSE '客户类型错误' END) as FLevelName FROM T_Customer select FName, ( case when FSalary\u003c2000 then '低收入' when FSalary\u003e=2000 and FSalary\u003c=5000 then '中等收入' else '高收入' end ) as 收入水平 from T_Employee SELECT FName, FWeight, (CASE WHEN FWeight\u003c40 THEN '瘦瘦' WHEN FWeight\u003e50 THEN '肥肥' ELSE 'ok' END) as isnormal FROM T_Person ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:23:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"索引index\r分为聚集索引和非聚集索引， 聚集索：聚集索引就相当于使用字典的拼音查找，因为聚集索引存储记录是物理上连续，即拼音a过后一定是b. 非聚集索引，就相当于使用字典的首部查找，逻辑连续，物理不连续。 全表扫描：对数据进行检索（select）效率最差的是全表扫描，就是一条条的找。 如果没有目录，查汉语字典就要一页页的翻，而有了目录只要查询目录即可。为了提高检索的速度，可以为经常进行检索的列添加索引，相当于创建目录。 创建索引的方式，在表设计器中点击右键，选择“索引/键”→添加→在列中选择索引包含的列。不能为空 使用索引能提高查询效率，但是索引也是占据空间的，而且添加、更新、删除数据的时候也需要同步更新索引，因此会降低Insert、Update、Delete的速度。只在经常检索的字段上(Where)创建索引。 （*）即使创建了索引，仍然有可能全表扫描，比如like、函数、类型转换等。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:24:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"表连接\r有客户表（T_Customers）和订单表（T_Orders）两个表，客户表字段为：Id、Name、Age，订单表字段为：Id、BillNo、CustomerId，订单表通过CustomerId关联客户表。测试数据见备注。 SELECT o.BillNo,c.Name,c.Age from T_Orders as o\rJOIN T_Customers as c on o.CustomerId=c.Id join是和哪个表连接，on后是连接的关系是什么。(多表) 要求显示所有年龄大于15岁的顾客购买的订单号、客户姓名、客户年龄。 要求显示年龄大于平均年龄的顾客购买的订单 （*）Inner Join、Left Join、Right Join ：T_Orders ：T_Customers select o.BillNo,c.Name,c.Age\rfrom T_Orders as o\rjoin T_Customers as c on o.CustomerId=c.Id这个语句是以 T_Orders表为准，在其后添加join表的内容。 select o.BillNo,c.Name\rfrom T_Orders as o\rjoin T_Customers as c\ron o.CustomerId=c.Id\rwhere c.Age\u003e15 select o.BillNo,c.Name,c.Age\rfrom T_Orders as o\rjoin T_Customers as c on o.CustomerId=c.Id\rwhere c.Age\u003e(select AVG(Age) from T_Customers) ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:25:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"子查询\r将一个查询语句做为一个结果集供其他SQL语句使用，就像使用普通的表一样，被当作结果集的查询语句被称为子查询。所有可以使用表的地方几乎都可以使用子查询来代替。SELECT * FROM(SELECT * FROM T2 where FAge\u003c30) 单值做为子查询：SELECT 1 AS f1,2,(SELECT MIN(FYearPublished) FROM T_Book),(SELECT MAX(FYearPublished) FROM T_Book) AS f4 只有返回且仅返回一行、一列数据的子查询才能当成单值子查询。下面的是错误的：SELECT 1 AS f1,2,(SELECT FYearPublished FROM T_Book) SELECT * FROM T_ReaderFavorite WHERE FCategoryId=(SELECT FId FROM T_Category WHERE FName='Story') 如果子查询是多行单列的子查询，这样的子查询的结果集其实是一个集合。 SELECT * FROM T_Reader WHERE FYearOfJoin IN\r(\rselect FYearPublished FROM T_Book\r) 限制结果集。返回第3行到第5行的数据（ ROW_NUMBER 不能用在where子句中，所以将带行号的执行结果作为子查询，就可以将结果当成表一样用了）： SELECT * FROM ( SELECT ROW_NUMBER() OVER(ORDER BY FSalary DESC) AS rownum, FNumber,FName,FSalary,FAge FROM T_Employee ) AS a WHERE a.rownum\u003e=3 AND a.rownum\u003c=5 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:26:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"视图概述\r视图是一张虚拟表，它表示一张表的部分数据或多张表的综合数据，其结构和数据是建立在对表的查询基础上 视图在操作上和数据表没有什么区别，但两者的差异是其本质是不同:数据表是实际存储记录的地方，然而视图并不保存任何记录，它存储的实际上是查询语句 相同的数据表，根据不同用户的不同需求，可以创建不同的视图（不同的查询语句） 优点： 筛选表中的行 防止未经许可的用户访问敏感数据 降低数据库的复杂程度 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:27:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"局部变量\r声明局部变量 DECLARE @变量名 数据类型 DECLARE @bookName varchar(20) DECLARE @bId int 赋值 SET @变量名 =值 –set用于普通的赋值 SELECT @变量名 = 值 –用于从表中查询数据并赋值 例如： SET @ bookName =‘家宝’ SELECT @ bookName=b_title FROM Book WHERE b_id=2 declare @money money --声明变量 set @money = 2000 –赋值 select @money – 查询变量值 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:28:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"变量种类\r变量分为： 局部变量：局部变量必须以标记@作为前缀 ，如@Age int 局部变量：先声明，再赋值 全局变量（系统变量）： 全局变量必须以标记@@作为前缀，如@@version 全局变量由系统定义和维护，我们只能读取，不能修改全局变量的值 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:29:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"if else\rIF(条件表达式) BEGIN --相当于C#里的{ 语句1 …… END --相当于C#里的} ELSE BEGIN 语句1 …… END declare @money money select @money=AVG(b_money) from Book if @money \u003e50 begin select 'A' select top 2 * from Book order by b_money desc end else begin select 'B' select top 2 * from Book order by b_money asc end ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:30:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"while循环\rWHILE(条件表达式) BEGIN --相当于C#里的{ 语句 …… BREAK END --相当于C#里的} declare @a int set @a=1 while(@a\u003c50 ) begin print str(@a) set @a=@a+1 end DECLARE @num int WHILE(1=1) --条件永远成立 BEGIN SELECT @num=COUNT(*) FROM T_Book WHERE FYearPublished\u003c2000--统计不达标本数 IF (@num\u003e0) UPDATE T_Book --每本加2元 SET FYearPublished=FYearPublished+2 ELSE BREAK--退出循环(只有一行语句可省begin-end) END SELECT * FROM T_Book ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:31:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"事务\r借钱问题： 假定钱从A转到B，至少需要两步： A的资金减少 然后B的资金相应增加 UPDATE bank SET uMoney=uMoney-1000 WHERE uName='家宝‘ @@error UPDATE bank SET uMoney=uMoney+1000 WHERE uName='奥巴马‘ @@error 查看结果： SELECT * FROM bank 会出问题：不好回滚 指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)–也就是由多个sql语句组成，必须作为一个整体执行 这些sql语句作为一个整体一起向系统提交，要么都执行、要么都不执行 语法步骤： 开始事务：BEGIN TRANSACTION 事务提交：COMMIT TRANSACTION 事务回滚：ROLLBACK TRANSACTION 判断某条语句执行是否出错： 全局变量@@ERROR； @@ERROR只能判断当前一条T-SQL语句执行是否有错，为了判断事务中所有T-SQL语句是否有错，我们需要对错误进行累计； 例：SET @errorSum=@errorSum+@@error BEGIN TRANSACTION /*--定义变量，用于累计事务执行过程中的错误--*/ DECLARE @errorSum INT SET @errorSum=0 --初始化为0，即无错误 /*--转账：张三的账户少1000元，李四的账户多1000元*/ UPDATE bank SET currentMoney=currentMoney-1000 WHERE customerName='张三' SET @errorSum=@errorSum+@@error UPDATE bank SET currentMoney=currentMoney+1000 WHERE customerName='李四' SET @errorSum=@errorSum+@@error --累计是否有错误 If @errorSum\u003e0 Begin rollback transaction select ‘失败’ End Else Begin commit transaction select ‘成功’ End ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:32:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"存储过程\r存储过程—就像数据库中运行方法(函数) 和C#里的方法一样，由存储过程名/存储过程参数组成/可以有返回结果。 前面学的if else/while/变量 等，都可以在存储过程中使用 优点： 执行速度更快，在数据库中保存的语句是编译过的 允许模块化程序设计 ，方法的复用 提高系统安全性，防止SQL注入 减少网络流通量，只要传输存储过程的名称 系统存储过程 由系统定义，存放在master数据库中 名称以“sp_”开头或”xp_”开头 自定义存储过程 由用户在自己的数据库中创建的存储过程 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:33:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"系统存储过程\rEXEC sp_databases EXEC sp_renamedb 'Northwind','Northwind1' EXEC sp_tables EXEC sp_columns stuInfo EXEC sp_help stuInfo EXEC sp_helpconstraint stuInfo EXEC sp_helpindex stuMarks EXEC sp_helptext 'view_stuInfo_stuMarks' EXEC sp_stored_procedures ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:34:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"创建存储过程\r定义存储过程的语法 CREATE PROC[EDURE] 存储过程名 @参数1 数据类型 = 默认值 OUTPUT, @参数n 数据类型 = 默认值 OUTPUT AS SQL语句 参数说明： 参数可选 参数分为输入参数、输出参数 输入参数允许有默认值 EXEC 过程名 [参数] 例子–编写分页存储过程 create procedure proGetPageData @pageIndex int, @pageSize int as declare @sqlStr varchar(300) set @sqlStr='select top '+str(@pageSize)+' * from Category where c_id not in(select top '+str((@pageIndex-1)*@pageSize)+' c_id from Category order by c_addtime)order by c_addtime' print @sqlStr EXEC(@sqlStr) execute proGetPageData 3,3 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:35:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"调用带参数的存储过程\r无参数的存储过程调用： Exec pro_GetAge 有参数的存储过程两种调用法： EXEC proGetPageData 60,55 —按次序 EXEC proGetPageData @labPass=55,@writtenPass=60 –参数名 参数有默认值时： EXEC proGetPageData –都用默认值 EXEC proGetPageData 1 –页容量(@pageSize)默认值 EXEC proGetPageData 1,5 –不用默认值 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:36:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"存储过程中使用输出参数\rcreate procedure [dbo].[proGetPageData2] –带输出参数的存储过程 @pageIndex int=1, @pageSize int=3, @pageCount int output, --总页数 @rowCount int output -- 总行数 as declare @sqlStr nvarchar(300),@sqlCount nvarchar(300) SET @sqlCount = 'SELECT @rowCount=COUNT(b_id),@pageCount=CEILING((COUNT(b_id)+0.0)/'+ CAST(@pageSize AS VARCHAR)+') FROM Book' print @sqlCount EXEC SP_EXECUTESQL @sqlCount,N'@rowCount INT OUTPUT,@pageCount INT OUTPUT',@rowCount OUTPUT,@pageCount OUTPUT set @sqlStr='select top '+str(@pageSize)+' * from Category where c_id not in(select top '+str((@pageIndex-1)*@pageSize)+' c_id from Category order by c_addtime)order by c_addtime' print @sqlStr EXEC(@sqlStr) declare @pc int declare @rc int exec [proGetPageData2] 1,3,@pc output,@rc output select @pc,@rc ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:36:1","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"触发器\r触发器是一种特殊类型的存储过程，它不同于前面介绍过的一般的存储过程。 一般的存储过程通过存储过程名称被直接调用，而触发器主要是通过事件进行触发而被执行。 触发器是一个功能强大的工具，在表中数据发生变化时自动强制执行。触发器可以用于SQL Server约束、默认值和规则的完整性检查，还可以完成难以用普通约束实现的复杂功能。 那究竟何为触发器？在SQL Server里面也就是对某一个表的一定的操作，触发某种条件，从而执行的一段程序。 触发器是一个特殊的存储过程。 常见的触发器有三种： 分别应用于Insert , Update , Delete 事件 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:37:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"常用语法\rCREATE TRIGGER triggerName ON Table for UPDATE|INSERT|DELETE AS begin … end ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:37:1","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"更新\rCREATE TRIGGER testForFun ON dbo.T_Category for UPDATE AS begin select * from dbo.T_Book end update dbo.T_Category set FName = 'Android2' where FId=3 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:37:2","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"删除\rCREATE TRIGGER testForDel ON dbo.Category for delete AS begin select * from book end delete Category set c_name = 'Android2' where c_id=3 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:37:3","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"在触发器中获取值\rSELECT * FROM INSERTED 对于更新触发器，旧记录值在DELETED中可用，新记录值在INSERTED中 DECLARE @OldValue int，@ NewValue int SELECT @OldValue = Column1 FROM DELETED SELECT @NewValue = Column1 FROM INSERTED 通过保持旧值和新值，您可以比较它们的状态。 ADO.NET\r程序要和数据库交互要通过ADO.Net 进行 通过ADO.Net就能在程序中执行SQL了。 ADO.Net中提供了对各种不同数据库的统一操作接口。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:37:4","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"ADO.NET的组成\r如果要执行增删改和单个值查询的时候，可以直接让【车间工人】去【中央仓库】做。 如果要从【中央仓库】查询多行货物的时候，有两种方式： 可以选择叫一辆【货运卡车】去搬，卡车可以一次性的都搬过来，但【生产车间】一下子用不了，所以卡车就把货先放在【车间临时仓库】，这样车间需要的时候直接拿就可以了。 可以让【车间工人】把自己的【摩托车】拿来，骑【摩托车】去仓库拿货，但每次只能拿一行货物，所以需要往返的拿很多次才能拿完。但因为每次只拿一行货物过来，车间就直接使用了，不必存到【车间临时仓库】里。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:38:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"Connection 类\r和数据库交互，你必须连接它。连接帮助指明数据库服务器、数据库名字、用户名、密码，和连接数据库所需要的其它参数。Connection对象会被Command对象使用，这样就能够知道是在哪个数据源上面执行命令。 与数据库交互的过程意味着你必须指明想要执行的操作。这是依靠Command对象执行的。你使用Command对象来发送SQL语句给数据库。Command对象使用Connection对象来指出与哪个数据源进行连接。你能够单独使用Command对象来直接执行命令，或者将一个Command对象的引用传递给DataAdapter，它保存了一组能够操作下面描述的一组数据的命令。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:39:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"Command对象\r成功于数据建立连接后,就可以用Command对象来执行查询、修改、插入、删除等命令; Command对象常用的方法有ExecuteReader方法、ExecuteScalar()方法和ExecuteNonQuery()方法;插入数据可用ExecuteNonQuery()方法来执行插入命令。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:40:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"DataReader类\r许多数据操作要求你只是读取一串数据。DataReader对象允许你获得从Command对象的SELECT语句得到的结果。考虑性能的因素，从DataReader返回的数据都是快速的且只是“向前”的数据流。这意味着你只能按照一定的顺序从数据流中取出数据。这对于速度来说是有好处的，但是如果你需要操作数据，更好的办法是使用DataSet。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:41:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"DataSet对象\rDataSet对象是数据在内存中的表示形式。它包括多个DataTable对象，而DataTable包含列和行，就象一个普通的数据库中的表。你甚至能够定义表之间的关系来创建主从关系（parent-child relationships）。DataSet是在特定的场景下使用――帮助管理内存中的数据并支持对数据的断开操作的。DataSet是被所有Data Providers使用的对象，因此它并不像Data Provider一样需要特别的前缀。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:42:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"DataAdapter类\r某些时候你使用的数据主要是只读的，并且你很少需要将其改变至底层的数据源。同样一些情况要求在内存中缓存数据，以此来减少并不改变的数据被数据库调用的次数。DataAdapter通过断开模型来帮助你方便的完成对以上情况的处理。当在一单批次的对数据库的读写操作的持续的改变返回至数据库的时候，DataAdapter 填充（fill）DataSet对象。DataAadapter包含对连接对象以及当对数据库进行读取或者写入的时候自动的打开或者关闭连接的引用。另外，DataAdapter包含对数据的SELECT、INSERT、UPDATE和DELETE操作的Command对象引用。你将为DataSet中的每一个Table都定义DataAadapter，它将为你照顾所有与数据库的连接。所有你将做的工作是告诉DataAdapter什么时候装载或者写入到数据库。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:43:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"DataTable类\rDataTable 是一个数据网格控件,理解成一张表就可以了。 DataTable的实例化以及添加列： DataTable dt = new DataTable(); dt.Columns.Add(\"ID\"); dt.Columns.Add(\"Name\"); DataRow dr = dt.NewRow(); object[] objs = { 1, \"Name\" }; dr.ItemArray = objs; dt.Rows.Add(dr); this.dataGridView1.DataSource = dt; ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:44:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"ADO.Net基础\r直接在项目中内嵌mdf文件的方式使用SQLServer数据库（新建→数据→基于服务的数据库）。mdf文件随着项目走，用起来方便，和在数据库服务器上创建数据库没什么区别，运行的时候会自动附加（Attach） 双击mdf文件会在“服务器资源管理器”中打开，管理方式和在Management Studio没有什么本质不同。要拷贝mdf文件需要关闭所有指向mdf文件的连接。 正式生产运行的时候附加到SQLServer上、修改连接字符串即可，除此之外没有任何的区别，在“数据库”节点上点右键“附加”；在数据库节点上→任务→分离就可以得到可以拷来拷去mdf文件。 用的时候要在控制台、WinForm项目中在Main函数最开始的位置加入备注中的代码。ASP.Net项目中不需要。 连接字符串：程序通过连接字符串 指定要连哪台服务器上的、哪个实例的哪个数据库、用什么用户名密码等。 项目内嵌mdf文件形式的连接字符串\"DataSource=.\\SQLEXPRESS;AttachDBFilename=|DataDirectory|\\Database1.mdf;Integrated Security=True;User Instance=True\"。“.\\SQLEXPRESS”表示“本机上的SQLEXPRESS实例”，如果数据库实例名不是SQLEXPRESS，则需要修改。“Database1.mdf”为mdf的文件名。 ADO.Net中通过SqlConnection类创建到SQLServer的连接，SqlConnection代表一个数据库连接，ADO.Net中的连接等资源都实现了IDisposable接口，可以使用using进行资源管理。执行备注中的代码如果成功了就ok。 using (SqlConnection conn = new SqlConnection(@\"Data Source=.\\SQLEXPRESS;AttachDBFilename=|DataDirectory|\\Database1.mdf;Integrated Security=True;User Instance=True\")) { conn.Open(); Console.WriteLine(\"连接成功！\"); } 增删改查 SqlCommand表示向服务器提交的一个命令（SQL语句等） , CommandText属性为要执行的SQL语句，ExecuteNonQuery方法执行一个非查询语句（Update、Insert、Delete等） using (SqlCommand cmd = conn.CreateCommand()) { cmd.CommandText = \"Insert into T_Users(UserName,Password) values('admin','888888')\"; cmd.ExecuteNonQuery(); } ExecuteNonQuery返回值是执行的影响行数 常犯错： string username='test'; .... cmd.CommandText = \"Insert into T_Users(UserName,Password) values(username,'888888')\"; ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:45:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"查询单个值\rSqlCommand的ExecuteScalar方法用于执行查询，并返回查询所返回的结果集中第一行的第一列，因为不能确定返回值的类型，所以返回值是object类型。 cmd.CommandText = \"select count(*) from T_Users\"; int i = Convert.ToInt32(cmd.ExecuteScalar()) cmd.CommandText = \"select getdate()\"; DateTime dt = Convert.ToDateTime(cmd.ExecuteScalar()); 得到自动增长字段的主键值，用@@identity(目前工作阶段任何资料表中所产生的最后一个识别值 )，用ExecuteScalar执行最方便 cmd.CommandText = “Insert into T_Users(UserName,Password) values(‘admin’,‘888888’); select @@identity;\"; int i = Convert.ToInt32(cmd.ExecuteScalar()); ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:46:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"查询多行值\r执行有多行结果集的用ExecuteReader SqlDataReader reader = cmd.ExecuteReader(); while (reader.Read()) { Console.WriteLine(reader.GetString(1)); } reader的GetString、GetInt32等方法只接受整数参数，也就是序号，用GetOrdinal方法根据列名动态得到序号 为什么用using。Close：关闭以后还能打开。 Dispose：直接销毁，不能再次使用。 using在出了作用域以后调用Dispose， SqlConnection、FileStream等的Dispose内部都会做这样的判断：判断有没有close，如果没有Close就先Close再Dispose。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:47:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"注入漏洞攻击\r登录判断：select * from T_Users where UserName=... and Password=...，将参数拼到SQL语句中。 构造恶意的Password：' or '1'='1 if (reader.Read()) { Console.WriteLine(\"登录成功\"); } else { Console.WriteLine(\"登录失败\"); } 防范注入漏洞攻击的方法：不使用SQL语句拼接，通过参数赋值 using (SqlCommand cmd = conn.CreateCommand()) { string password = \"' or '1'='1\"; cmd.CommandText = \"select * from T_Users where UserName='admin' and Password='\" + password+\"'\"; using (SqlDataReader reader = cmd.ExecuteReader()) { if (reader.Read()) { Console.WriteLine(\"登录成功\"); } else { Console.WriteLine(\"登录失败\"); } } } ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:48:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"查询参数\rSQL语句使用@UserName表示“此处用参数代替”，向SqlCommand的Parameters中添加参数 cmd.CommandText = \"select * from T_Users where UserName=@UserName and Password=@Password\"; cmd.Parameters.Add(new SqlParameter(\"UserName\",\"admin\")); cmd.Parameters.Add(new SqlParameter(\"Password\",password)); 参数在SQLServer内部不是简单的字符串替换，SQLServer直接用添加的值进行数据比较，因此不会有注入漏洞攻击。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:49:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"案例\rComboBox的显示值：Items.Add的参数是Object类型，也就是可以放任意数据类型的数据，可以设置DisplayMember属性设定显示的属性，通过SelectedItem属性取得到就是选择的条目对应的对象。例子。疑问：取出来的是Object，怎么能转换为对应的类型？变量名只是“标签”。显示的值和实际的对象不一样，在ASP.Net中也有相同的东西 创建一个ProvinceItem类，将数据填充在这个对象中添加到ComboBox中。 将连接字符串写在代码中的缺点：多次重复，违反了DRY（Don’t Repeat Yourself）原则；如果要修改连接字符串就要修改代码。将连接字符串写在App.Config中： 添加App.config文件（文件名不能改）：添加→新建项→常规→应用程序配置文件。App.config是.Net的通用配置文件，在ASP.Net中也能同样使用。 在App.config中添加connectionStrings段，添加一个add项，用name属性起一个名字（比如DbConnStr），connectionString属性指定连接字符串。 在“引用”节点上点右键“添加引用”，找到System.configuration。不是所有.Net中的类都能直接调用，类所在的Assembly要被添加到项目的引用中才可以。 ConfigurationManager.ConnectionStrings[\" DbConnStr “].ConnectionString得到连接字符串。 如何在部署的程序中修改配置。 \u003c?xml version=\"1.0\" encoding=\"utf-8\" ?\u003e \u003cconfiguration\u003e \u003cconnectionStrings\u003e \u003cadd name=\"conStr\" connectionString =\"server=.;database=SimpleArticle;Integrated Security=True;\"/\u003e \u003c/connectionStrings\u003e \u003c/configuration\u003e ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:50:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"多行查询\rSqlDataReader是连接相关的， SqlDataReader中的查询结果并不是放到程序中的，而是放在数据库服务器中，SqlDataReader只是相当于放了一个指针（游标），只能读取当前游标指向的行，一旦连接断开就不能再读取。这样做的好处就是无论查询结果有多少条，对程序占用的内存都几乎没有影响。 SqlDataReader对于小数据量的数据来说带来的只有麻烦，优点可以忽略不计。ADO.Net中提供了数据集的机制，将查询结果填充到本地内存中，这样连接断开、服务器断开都不影响数据的读取。 DataSet dataset = new DataSet(); SqlDataAdapter adapter = new SqlDataAdapter(cmd); adapter.Fill(dataset); SqlDataAdapter是DataSet和数据库之间沟通的桥梁。数据集DataSet包含若干表DataTable，DataTable包含若干行DataRow。foreach (DataRow row in dataset.Tables[0].Rows) row[\"Name\"]。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:51:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"SQL Helper\r封装一个SQLHelper类方便使用，提供ExecuteDataTable(string sql,params SqlParameter[] parameters)、ExecuteNonQuery(string sql,params SqlParameter[] parameters)、ExecuteScalar(string sql,params SqlParameter[] parameters)等方法。 网上有微软提供的最全的SQLHelper类，是Enterprise Library中的一部分。 sqlconnection在程序中一直保持它open可以吗？对于数据库来说，连接是非常宝贵的资源，一定要用完了就close、dispose。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:52:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"DataSet\r可以更新行row[“Name”] = “yzk”、删除行datatable.Rows.Remove()、新增行datatable. NewRow()。这一切都是修改的内存中的DataSet，没有修改数据库。 可以调用SqlDataAdapter的Update方法将对DataSet的修改提交到数据库，Update方法有很多重载方法，可以提交整个DataSet、DataTable或者若干DataRow。但是需要为SqlDataAdapter提供DeleteCommand、UpdateCommand、InsertCommand它才知道如何将对DataSet的修改提交到数据库，由于这几个Command要求的格式非常苛刻，因此开发人员自己写非常困难，可以用SqlCommandBuilder自动生成这几个Command，用法很简单：new SqlCommandBuilder(adapter)。查看生成的Command（没有直接赋值给SqlDataAdapter ，看SqlCommandBuilder的）。SqlCommandBuilder要求表必须有主键。 (*)通过DataRow的RowState可以获得行的状态（删除、修改、新增等）；调用DataSet的GetChanges()方法得到变化的结果集，降低传递的资源占用。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:53:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"可空数据\rC#中值类型（int、Guid、bool等）是不可以为空的，int i=null是错误的，因此int、bool等这些类型不能表示数据库中的“Null” 。因此C#提供了“可空类型”这种语法，只要在类型后加?就构成了可空的数据类型，比如int?、bool?，这样int? i=null 就可以了。解决数据库中int可以为null，而C#中int不能为null的问题。 判断可空类型是否为空，i==null或者i.HasValue；得到可空变量的值，int i1=(int)i.Value或者int i1=i.Value。 类型转换：不可空类型赋值给可空类型无需显式转换（一定成功），可空类型赋值给不可空类型则需显式转换（不一定成功）。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:54:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"弱类型DataSet的缺点\r只能通过列名引用，dataset.Tables[0].Rows[0][“Age”]，如果写错了列名编译时不会发现错误，因此开发时必须要记着列名。 int age = Convert.ToInt32(dataset.Rows[0][“Age”])，取到的字段的值是object类型，必须小心翼翼的进行类型转换，不仅麻烦，而且容易出错。 将DataSet传递给其他使用者，使用者很难识别出有哪些列可以供使用 运行时才能知道所有列名，数据绑定麻烦，无法使用Winform、ASP.Net的快速开发功能。 自己动手写强类型DataSet(类型化DataSet，TypedDataSet)，创建继承自DataSet的PersonDataSet类，封装出int? Age等属性和bool IsAgeNull等方法，向PersonDataSet中填充。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:55:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"VS自动生成强类型DataSet\r添加→新建项→数据集 将表从服务器资源管理器拖放到DataSet中。注意拖放过程是自动根据表结构生成强类型DataSet等类，没有把数据也拖过来，程序还是连的那个数据库，自动将数据库连接字符串写在了App.Config中。 代码中使用DataSet示例：CC_RecordTableAdapter adapter = new CC_RecordTableAdapter(); 如何得知Adapter的类名？选中DataSet中下半部分的Adapter，Name属性就是类名。需要右键点击类名→解析 取得所有的数据：adapter.GetData()，例子程序：遍历显示所有数据，i\u003cadapter.GetData().Count;adapter.GetData()[i].Age。 常见问题：类名敲不对，表名+TableAdapter，表名+DataTable，表名+Row，然后用“解析”来填充类名，别照着我的代码敲。 常见问题：类的内部定义的类要通过包含namespace的全名来引用，不能省略。类的内部定义的类就能避免同一个namespace下类不能重名的问题。 强类型DataSet其实就是一种代码生成器的实现机制（DataSetPersons.Designer.cs）， 调用的 ***TableAdapter等类都是VS自动生成的，可以看到的，不要手动改生成的类代码，改xsd即可。 GetData和Fill的区别。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:56:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"强类型强在哪\r像使用类的属性一样使用列名，dsPerson[0].Age，可以使用VS的自动提示功能，绝对不会写错列名，写错了编译通不过。 将强类型DataSet传递给其他人，使用者可以轻松确定有哪些列 int age = dsPerson[0].Age，列名的类型是明确的，避免类型转换的麻烦。 编译时就可以确定 名词：强类型DataSet（类型化DataSet），英文：Typed DataSet。 DataSet包含DataTable、DataTable包含DataRow，强类型DataSet同样如此。查看源代码看看VS帮我们做了什么 GetData返回是什么类型？每一行是什么类型？看类型定义即可得知。一般规律：表类型名：表名+DataTable，行类型名：表名+row，忘了也没关系：“转到定义”。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:57:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"更新DataSet\r调用Adapter的Update方法就可以将DataSet的改变保存到数据库。adapter.Update(datatable) 要调用Update方法更新必须设置数据库主键，后面的Delete也是如此。 常见错误：“当传递具有已修改行的 DataRow 集合时，更新要求有效的 UpdateCommand”，要为表设置主键。“谁都变了，唯有主键不会变”，程序要通过主键来定位要更新的行。忘了设主键怎么办？先到数据库中设置主键，然后在DataSet的对应DataTable上点右键，选择“配置”，在对话框中点击【完成】。好习惯：所有表都要设置主键！！！看看为什么会自动帮我们GetData、Update、Delete。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:58:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"其他问题\r插入新行，调用Insert方法。 增加字段怎么办？DataSet设计器中点【配置】，对话框中点【查询生成器】，勾选新增加的字段即可。删除字段同样如此。如果是高手也可以直接手改SQL语句。 要修改字段就要重新配置生成，这就是强类型DataSet的弱点，因此强类型DataSet不一定真的就是“强”，还是叫“类型化DataSet”(Typed DataSet)吧 常见错误：报错：数据为空。判断列的值为空的方法：Is**Null 为什么Select方法会填充、Update方法会更新，Insert方法会插入？没有多么神奇，看看Adapter的SelectCommand等属性，是那些SQL语句在起作用，如果有需要完全可以手工调整 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:59:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"增加新的SQL语句\r设计器的Adapter中点右键，选择“添加查询”→“使用SQL语句”，就可以添加多种类型的SQL语句。如果是“SELECT（返回行）”则SQL语句的列必须是对应DataSet类的父集合，生成两个方法：FillBy和GetBy，方法名根据查询语句的意义定，比如FillByAge，FillBy是将结果填充到现有DataSet，GetBy是将结果以DataSet方式返回，建议两个都生成，方便以后用。看看默认生成的GetData就明白了 GetDataById、IncAge “SELECT（返回单个值）”就是ExecuteScalar 对于增加的SQL语句在代码中是以方法的形式使用的。方法的参数类型、顺序就是VS猜测的，如果不正确或者需要调整只要选中对应的语句，然后在【属性】窗口中修改Parameters属性即可 增加新的SQL语句本质论，探寻源码：不能并发调用。 像使用普通类的方法一样使用Adapter。SQL语句不用再写在界面代码中。这就是一种数据访问层（DAL：Data Access Layer） ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:60:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"强类型DataSet其他\r通过查看生成的源代码的值，生成的强类型TableAdapter默认每次调用方法都是打开连接、执行、关闭连接，而如果操作之前连接已经打开则不会自动帮我们连接、关闭，因此如果想批量操作提高效率可以操作之前先自己Open，操作完毕再Close。经测试：插入三千条数据，不优化用了45秒，优化后只用一两秒。回答面试问题：如何优化访问数据库的效率。 常见错误：DataSet ds = new DataSet()；ds = GetData();变量名和对象。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:61:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数据绑定\rDataGridView绑定。拖放TableAdapter、DataSet、bindingSource，将bindingSource的DataSource设定为DataSet，设定DataMember属性，然后DataGridView绑定到bindingSource。在Load的时候调用TableAdapter的Fill方法将数据填充到DataSet。绑定：双方能同步感知对方的变化。 DataGridView绑定到BindingSource， BindingSource绑定到DataSet，所以DataGridView显示的是DataSet中的数据。 修改列标题。 将保存提交到数据库，在DataGridView中修改会同步反应到DataSet中，这样只要将DataSet Update到数据库就是“保存修改”，Update，保存前要dataGridView1.EndEdit(); dataGridView1.CommitEdit(DataGridViewDataErrorContexts.Commit);bindingsource1.EndEdit()已提交正在编辑的修改。 删除当前选择行：cCRecordBindingSource.RemoveCurrent()，只是删除DataSet中的数据，需要Update才能提交到数据库。 绑定单独控件，在控件属性的DataBindings中将属性绑定到BindingSource 的指定字段，这样控件中的值就会显示这个字段的值了 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:62:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"补充\r拖过来的控件是什么？控件就是控件类的对象，Winform中从Component类继承的类都可以拖到窗口中以控件的形式出来，本质上和new出来的对象没区别。控件的id就是变量名。 新建的强类型DataSet只有“生成”以后才会在工具箱中出现 并不是控件的所有属性都能绑定，只有显示在DataBindings节点下的属性才能绑定（*）只有标记了[Bindable(true)]的属性才能绑定。 只有移开焦点才会同步，并不是实时同步。 刷新查询窗口中的数据“执行SQL” BindingSource是做什么的？维持当前项。这就是为什么详细控件和DataGridView会联动。试试控件绑定到不同的BindingSource。 Adapter的作用是负责DataSet和数据库之间的数据传递。 绑定到ComboBox。给Person增加一个TypeId字段（表示是黄种人、白种人、黑种人还是其他人种）。ComboBox的绑定分为显示数据项的绑定、选中值的绑定两个，DataSource属性设定要数据项绑定的数据源，DisplayMember属性为显示的属性、ValueMember为值（通过SelectedValue取得）的属性；然后绑定SelectedValue属性到表的字段。 DataGridView中的ComboBox列：设定列的ColumnType为DataGridViewComboBoxColumn为，然后其他绑定和普通ComboBox一样，由于BindingSource是维持当前项，所以记住“专BindingSource专用” ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:63:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"Web","content":"CSS（层叠样式表）是用来美化页面用的，可以对页面元素进行更精细的设置，样式主要描述元素的字体颜色、背景颜色、边框等。 CSS主要有元素内联、页面嵌入和外部引用三种使用方式。CSS是描述元素的皮肤！ 元素内联，直接将样式写入元素的style属性中，\u003cinput type=\"text\" readonly=\"readonly\" style=\"background-color: #FF00FF\" /\u003e，**style=“color:Red;background-color: #FF00FF”**为元素内联，适用于样式没有可复用性的场合。 页面嵌入：在head中加入 \u003cstyle type=\"text/css\"\u003e input{border-color:Yellow;color:Red;} \u003c/style\u003e 表示页面中所有input都是采用指定的样式。适合于样式复用，减小页面体积 \u003cstyle type=\"text/css\"\u003e P { color:Red; font-weight:bold; } \u003c/style\u003e 所有的P标签都变成红色字体，加粗。 外部引用，将css内容写入css后缀的文件 div{background:yellow} 然后在页面中引用，在head中加入 \u003clink type=\"text/css\" rel=\"Stylesheet\" href=\"s1.css\" /\u003e 适合于多个页面共享css。 更变原则：就近原则 ","date":"2018-10-22","objectID":"/2018/10/web2-css/:0:0","tags":["Web","css"],"title":"自学 CSS","uri":"/2018/10/web2-css/"},{"categories":"Web","content":"常见样式\rcss计量单位：css中表示宽度、距离时有多种计量单位：px（像素）、30%（百分比）、em（相对单位）等。width:20px。 background-color:Red;背景颜色；color：文本颜色 复合样式 background border border-style:solid;边框风格，实线solid（默认是没有），还有dotted(点)等值；border-color：边框颜色；border-width：边框宽度(默认是0)。例子：style=\"border-color:Red;border-width:1px;border-style:dotted;\" display：元素是否显示，可选值none（不显示,不占地儿）、block （显示为块级元素，此元素前后会带有换行符。）、inline（显示为内联元素，元素前后没有换行符 ）等。 cursor，鼠标在元素上时显示的光标图标，可选值：cursor（默认光标）、pointer（超链接上的手）、text（输入Bean）、wait（忙沙漏）、help（帮助）等。还可以通过cursor:url(dinosau2.ani)使用ani、cur格式的自定义光标图片。 LI不显示圆点：LIST-STYLE-TYPE: none;一般设在li或者ul上 应用：图片：不显示边框，见备注 图片：不显示边框 IMG { border:0px;BORDER-BOTTOM: medium none; BORDER-LEFT: medium none; BORDER-TOP: medium none; BORDER-RIGHT: medium none } ","date":"2018-10-22","objectID":"/2018/10/web2-css/:1:0","tags":["Web","css"],"title":"自学 CSS","uri":"/2018/10/web2-css/"},{"categories":"Web","content":"例子 外部引用\r* { /* 所有的元素 */ margin:0; padding:0; color:Red; } body { background:red url(/images/back_image.GIF); } span { /* block 块 display:block;*/ cursor:pointer; color:Blue; text-decoration:underline; } input { color:Green; } li { /* 去掉ul前面的黑点 */ list-style-type:none; } ","date":"2018-10-22","objectID":"/2018/10/web2-css/:1:1","tags":["Web","css"],"title":"自学 CSS","uri":"/2018/10/web2-css/"},{"categories":"Web","content":"样式选择器\r对于非元素内联的样式需要定义样式选择器，通俗的说就是这个样式适合于哪些元素，三种：标签选择器、class选择器和id选择器。 标签选择器 input{border-color:Yellow;color:Red;}，对于指定的标签采用统一的样式 class选择器，以定义一个命名的样式，然后在用到它的时候设定元素的class属性为样式的名称，还可以同时设定多个class，名称之间加空格 .d1 { color:Red; width:100px; } .d2 { color:Blue; width:200px; } .d3 { color:Green; width:300px; } \u003cdiv class=\"d1\"\u003e 123123123 \u003c/div\u003e \u003cdiv class=\"d2\"\u003e abc \u003c/div\u003e \u003cdiv class=\"d3\"\u003e 啊打发 \u003c/div\u003e 样式名称开头加“.” .warning{background:Yellow;} .highlight{font-size:xx-large;cursor:help;} \u003ctable\u003e \u003ctr\u003e \u003ctd class=\"highlight\"\u003eaaa\u003c/td\u003e \u003ctd class=\"warning\"\u003ebb\u003c/td\u003e \u003ctd class=\"highlight warning\"\u003eccc\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e 标签+类选择器:通过指定标签来确定不同的类适用范围 label.name { background-color:Gray; } input.name { color:Blue; } \u003clabel for=\"name\" class=\"name\"\u003e用户名：\u003c/label\u003e \u003cinput class=\"name\" id=\"name\" type=\"text\" value=\"\" /\u003e id选择器：与类选择器不同的地方就是.改成了#。 #wrap { border:solid 1px blue; width:300px; height:300px; } \u003cdiv id=\"wrap\"\u003e main \u003c/div\u003e 包含选择器：设置div中strong标签的格式，div中所有strong div strong { color:Red; } \u003cstrong\u003e测试\u003c/strong\u003e \u003cdiv\u003e \u003cstrong\u003e这是左边栏\u003c/strong\u003e left \u003c/div\u003e 后代选择器：直接属于div的strong才会属于这个样式。 div strong { color:Red; } \u003cdiv\u003e \u003cstrong\u003e这是左边栏\u003c/strong\u003e left \u003c/div\u003e 组合选择器 ：多个标签一个样式，组合选择器可以使用类选择器.h3,.p,.span {} h3,p,span { color:Yellow; } \u003ch3\u003e标题3\u003c/h3\u003e \u003cp\u003e这是段落\u003c/p\u003e \u003cspan\u003e这是span\u003c/span\u003e 伪选择器：超链接使用 A:visited：超链接点击过的样式；A:visited {TEXT-DECORATION: none}下划线 A:active：选中超链接时的样式；A:active {TEXT-DECORATION: none} A:link：超链接未被访问时的状态；A:link {TEXT-DECORATION: none} A:hover：鼠标移到超链接时的状态。A:hover {TEXT-DECORATION: underline} a:visited { color:Gray; } a:link { color:Red; } a:hover { color:Black; font-style:italic; } a:active { color:Yellow; } \u003ca href=\"http://www.itcast.cn\"\u003e传智播客\u003c/a\u003e \u003ca href=\"http://www.csdn.com\"\u003ecsdn\u003c/a\u003e \u003ca href=\"http://www.cnbeta.com\"\u003ecnbeta\u003c/a\u003e \u003ca href=\"http://www.123.com\"\u003e123\u003c/a\u003e ","date":"2018-10-22","objectID":"/2018/10/web2-css/:1:2","tags":["Web","css"],"title":"自学 CSS","uri":"/2018/10/web2-css/"},{"categories":"Web","content":"布局\r布局的分类：表格布局，框架布局，div+css布局 表格布局：表格套表格 ，代码多，table显示很慢，一块块的显示就比较麻烦，显示圆角就比较麻烦 框架布局：多个页面来显示： Frameset 框架页里不能有body \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003c/head\u003e \u003cframeset rows=\"30%,*\"\u003e \u003cframe name=\"top\" src=\"top.htm\" noresize=\"noresize\"/\u003e \u003cframeset cols=\"20%,*\"\u003e \u003cframe name=\"left\" src=\"left.htm\" noresize=\"noresize\"/\u003e \u003cframe name=\"main\" src=\"main.htm\" noresize=\"noresize\"/\u003e \u003c/frameset\u003e \u003c/frameset\u003e left.html \u003cbody\u003e \u003cul\u003e \u003cli\u003e\u003ca href=\"1-注册页面.htm\" target=\"main\"\u003e注册\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"5-选择器.htm\" target=\"if\"\u003e登陆\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/body\u003e iframe 嵌入页面 \u003ciframe src=\"iframe.htm\" name=\"0\" width=\"0\" height=\"0\"\u003e\u003c/iframe\u003e \u003cbody\u003e adsfasdf asdf \u003ciframe src=\"1-注册页面.htm\" width=\"0\" height=\"0\"\u003e\u003c/iframe\u003e adsf \u003c/body\u003e main.html iframe：在一个页面中嵌入一个页面 \u003cbody\u003e \u003ciframe src=\"1-注册页面.htm\" width=\"500px\" height=\"200px\" name=\"if\"\u003e\u003c/iframe\u003e adsf \u003c/body\u003e div+css布局： 网页布局就是“这块内容显示在左边，那两块内容并排显示，那块内容漂浮在页面上”。 不要使用\u003ctable\u003e进行布局，因为：table可能会在所有tr、td加载完成以后才显示，所以加载完成之前界面是一片空白；用table布局会将布局方式写在html中，违反了“语义性”原则；用table会影响搜索引擎的抓取，不利于SEO。因此Table用来表达真是表格状数据的东西，布局用Div(层)+Css来做,Div用来圈定元素，CSS用来定义元素的位置。 Div+CSS就是将要布局的内容用\u003cdiv\u003e切成块，然后使用css描述每个块的大小、位置等。 布局最重要的一个属性就是float， \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003clink href=\"css/style.css\" rel=\"stylesheet\" type=\"text/css\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"wrap\"\u003e \u003cdiv id=\"head\"\u003e \u003cdiv id=\"logo\"\u003e \u003cimg src=\"images/back_image.GIF\" width=\"100px\" height=\"50px\" /\u003e\u003c/div\u003e \u003cdiv id=\"menu\"\u003e \u003cul\u003e \u003cli\u003e首页\u003c/li\u003e \u003cli\u003e播客\u003c/li\u003e \u003cli\u003e相册\u003c/li\u003e \u003cli\u003e关于\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv id=\"body\"\u003e \u003cdiv id=\"nav\"\u003e \u003cul\u003e \u003cli\u003e好好学习\u003c/li\u003e \u003cli\u003e天天向上\u003c/li\u003e \u003cli\u003e不要睡觉\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cdiv id=\"content\"\u003e内容\u003c/div\u003e \u003c/div\u003e \u003cdiv id=\"footer\"\u003e版权\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e * { margin:0px; padding:0px; } body { background-color:Gray; } #wrap { width:98%; height:500px; margin:0px auto; } #head { height:150px; background-color:Red; } #head #menu { margin:80px auto 0px auto; padding-left:200px; } #head #menu ul { width:400px; } #head #menu li { float:left; width:100px; list-style-type:none; } #body { height:800px; background-color:White; } #body #nav { /* 强制英文换行 word-break:break-all; */ /* 溢出后显示滚动条 */ overflow:auto; background-color:Blue; width:200px; float:left; } #body #nav ul { padding-top:100px; } #body #nav li { list-style-type:none; height:30px; padding-left:30px; } #body #content { background-color:Green; } ","date":"2018-10-22","objectID":"/2018/10/web2-css/:2:0","tags":["Web","css"],"title":"自学 CSS","uri":"/2018/10/web2-css/"},{"categories":"Web","content":"HTML(HyperText Markup Language)：描述网页长什么样子、有什么内容的一个文本。查看网页的描述内容（HTML）的方式：使用IE浏览器的话，在网页上点击右键，选择“查看源文件”。 ","date":"2018-10-17","objectID":"/2018/10/web1-html/:0:0","tags":["Web","Html"],"title":"自学 HTML","uri":"/2018/10/web1-html/"},{"categories":"Web","content":"主要构架\r\u003chtml\u003e\r\u003chead\u003e\r\u003ctitle\u003e我的第一个网页\u003c/title\u003e\r\u003c/head\u003e\r\u003cbody bgcolor=\"red\" background=\"bg.jpg\"\u003e\rHello world\r\u003c/body\u003e\r\u003c/html\u003e\r所有内容都在\u003chtml\u003e\u003c/html\u003e标签之内； \u003chead\u003e\u003c/head\u003e内放的是头部信息，是对页面的描述，不会直接显示在页面中，\u003chead\u003e内的\u003ctitle\u003e中设置的是页面的标题，\u003ctitle\u003e只能放在\u003chead\u003e中； \u003cbody\u003e是页面的主体，大部分显示内容都定义在这里； \u003cmeta\u003e标签，\u003cmeta\u003e有指定name和指定http-equiv两种用法，\u003cmeta name=\"名字\" content=\"值\" /\u003e、\u003cmeta http-equiv=\"名字\" content=\"值\" /\u003e两种用法 \u003cmeta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\" /\u003e指定网页编码 \u003cmeta http-equiv=\"Refresh\" content=\"3\" /\u003e 三秒钟后刷新此网页 \u003cmeta http-equiv=\"Refresh\" content=\"3;url=http://www.rupeng.com\" /\u003e 三秒钟后重定向到新网页。发帖成功后提示“发帖成功，即将转向帖子查看页面” \u003cmeta http-equiv=\"Cache-Control\" content=\"no-cache\" /\u003e 禁止浏览器缓存页面 ","date":"2018-10-17","objectID":"/2018/10/web1-html/:1:0","tags":["Web","Html"],"title":"自学 HTML","uri":"/2018/10/web1-html/"},{"categories":"Web","content":"基本语法\r\u003ch\u003e：标签，HTML定义了\u003ch1\u003e\u003c/h1\u003e到\u003ch6\u003e\u003c/h6\u003e六个h标签，分别表示不同大小的字体。 \u003cbr\u003e：回车 \u003cp\u003e：分段。\u003cp\u003e前后会有比较大的空白，而\u003cbr\u003e则没有。 \u003ccenter\u003e这是居中\u003c/center\u003e居中显示 \u003cb\u003e粗体\u003c/b\u003e：粗体 \u003ci\u003e斜体\u003c/i\u003e：斜体 \u003cfont\u003e\u003c/font\u003e：字体标签，\u003cfont color=\"red\"\u003e红色\u003c/font\u003e \u003cfont size=\"30\" color=\"red\"\u003e红色\u003c/font\u003e 特殊字符：\u0026lt;（小于号，less than）；\u0026gt;（大于号，greater than）；\u0026nbsp;（空格，no-break space） \u003chr\u003e： 横线 color size width align=left,center,right \u003cpre\u003e：预格式化 保持本色 \u003cbody bgcolor=\"#006699\"\u003e背景颜色 \u003ca href=\"http://www.rupeng.com\"\u003e如鹏网\u003c/a\u003e超链接 \u003ca href=\"http://www.rupeng.com\"\u003e\u003cimg src=\"http://www.rupeng.com/forum/templates/uchome/images/logo.gif\"/\u003e\u003c/a\u003e镶嵌图片； “/”表示网站根目录，“../”表示父目录，“../../”表示父目录的父目录 将\u003ca\u003e的target属性设定为\"_blank\"就可以在新窗口中打开超链接。 锚记：用name属性为\u003ca\u003e 起名字：\u003ca name=\"Last\"\u003e这里是最后\u003c/a\u003e。这样可以通过\u003ca href=\"#Last\"\u003e转到平台\u003c/a\u003e来跳转到超链接的部分。去往评论、回到正文 \u003cimg src=\"a.jpg\"/\u003e注意图片是链接的，不是插入的，所以如果Src指向的文件不存在了，就看不了了。 alt： 图片无法显示时的显示文本，鼠标方式去也会有悬浮提示“点击查看大图” border属性指定边框，border=“0\"不显示边框 width、height属性指定图片的显示大小，如果不指定则是图片的原始大小 不要以为把bmp后缀改为jpg就是改文件格式了 如果网页上要显示小图（比如缩略图），不要仅仅是把大图设定一下width、height来缩小，因为仍然会下载大图，会使得加载速度很慢。 列表：\u003cul\u003e\u003cli\u003e灌水区\u003c/li\u003e\u003cli\u003e版务区\u003c/li\u003e\u003cli\u003e原创贴图\u003c/li\u003e\u003c/ul\u003e。无序列表。 有序的列表\u003col\u003e\u003c/ol\u003e 表格：\u003ctable\u003e\u003c/table\u003e为表格，在内部通过\u003ctr\u003e创建行，\u003ctr\u003e内部通过\u003ctd\u003e 创建单元格。可以将table的border属性设为0来隐藏表格线。 填充、间距Cellpadding内容和表格边线之间的距离 cellspacing单元格之间的间距s \u003ctr\u003e的属性：align，水平对齐，可选值left、right、center；valign，垂直对齐，可选值top、middle、bottom。 \u003ctd\u003e也有align和valign。\u003ctr align=\"right\"\u003e\u003ctd\u003etom\u003c/td\u003e\u003ctd align=\"left\"\u003e20\u003c/td\u003e\u003ctd\u003e男\u003c/td\u003e\u003c/tr\u003e：子标签默认继承父标签的属性，如果自己单独指定了属性，则会覆盖父标签的属性。 rowspan、colspan进行单元格的合并 表头的td可以用th代替，这样就会表头粗体、居中显示 表单：\u003cform\u003e标签为表单标签。如果要把数据提交到服务器，则需要将\u003cinput\u003e、\u003ctextarea\u003e、\u003cselect\u003e等表单元素放到form中 \u003cinput\u003e是主要的表单元素，type的可选值：submit（提交按钮）、button（普通按钮）、checkbox（复选框）、file（文件选择框）、hidden（隐藏字段）、image（图片按钮）、password（密码框）、radio（单选按钮）、reset（重置按钮）、text（文本框）。\u003cinput type=\"file\" /\u003e submit：点击submit按钮表单就会被提交给服务器，中文IE下默认按钮文本为“提交查询”，可以设置value属性修改按钮的显示文本 text：size属性为宽度，value为值，maxlength为可以输入的最大长度，readonly只读。\u003cinput type=\"text\" readonly/\u003e（只写属性名，不写属性值）或者\u003cinput type=\"text\" readonly=\"readonly\" /\u003e checkbox：checked属性表示是否被选中，\u003cinput type=\"checkbox\" checked /\u003e或者\u003cinput type=\"checkbox\" checked=\"checked\" /\u003e(推荐)checked、readonly等这种只有一个可选值的属性都可以省略属性值。 radio：相同name属性的为一组，不同radio设定不同的value值，这样通过取指定name的值就可以知道谁被选中了，不用单独的判断。 file：使用file，则form的enctype必须设置为multipart、form-data、form method属性为POST（*），get。get：少量数据，post：大量数据。\u003cform action=\"Default.aspx\" method=\"post\"\u003e\u003c/form\u003e image：使用src属性指定图片的地址，用来实现美化的“登录按钮”。 Reset:重置 \u003cselect\u003e:用来创建类似于WinForm中的ComboBox或者ListBox 如果size属性大于1就是ListBox（size的值为显示出来的列表数量），否则就是ComboBox。 \u003cselect multiple\u003e或者\u003cselect multiple=\"multiple\"\u003e（推荐），那么就是可以多选的ListBox。 select中的项是\u003coption\u003e，\u003coption\u003e北京\u003c/option\u003e还可以设定项的值\u003coption value=\"1\"\u003e北京\u003c/option\u003e。 将一个option设置为选中：\u003coption selected\u003e333\u003c/option\u003e或者\u003coption selected=\"selected\"\u003e333\u003c/option\u003e(推荐)就可以将这个项设定为选择项 如何实现“不选择”，添加一个\u003coption value=\"-1\"\u003e--不选择--\u003coption\u003e，然后编程判断select选中的值如果是-1就认为是不选择。 select分组选项，可以使用optgroup对数据进行分组，分组本身不会被选择，无论对于下拉列表还是列表框都适用。备注 \u003ctextarea\u003e多行文本（也是表单元素）：\u003ctextarea\u003e文本\u003c/textarea\u003e，cols、rows属性表示行数和列数。 \u003clabel\u003e：在\u003cinput type=\"text\"\u003e前可以写普通的文本来修饰，但是单击修饰文本的时候input并不会得到焦点，而用label则可以，for属性指定要修饰的控件的id，\u003clabel for=\"txt1\" \u003easdfad\u003c/label\u003e 为被修饰的控件设置一个唯一的id \u003clabel for=\"ma\"\u003e婚否\u003c/label\u003e \u003cinput id=\"ma\" type=\"checkbox\" /\u003e fieldset：GroupBox效果，将控件划分一个区域，看起来更规整 \u003cfieldset\u003e \u003clegend\u003e常用\u003c/legend\u003e \u003cinput type=\"text\" /\u003e \u003c/fieldset\u003e 滚动文字 \u003cmarquee\u003e scrolldelay控制速度 播放声音、显示flash， \u003cobject classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\" codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,29,0\" width=\"760\" height=\"700\"\r\u003cparam name=\"movie\" value=\"light-bot-2205.swf\" /\r\u003cparam name=\"quality\" value=\"high\" /\r\u003cembed src=\"light-bot-2205.swf\" quality=\"high\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" type=\"application/x-shockwave-flash\" width=\"760\" height=\"700\"\u003e\u003c/embed\r\u003c/object\u003e\r调用wmp的插件\u003cembed src=\"coder.mp3\" loop=true autostart=true name=bgss width=\"460\" height=\"68\"\u003e 只能播放wav和mid格式，只支持ie div：层\u003cdiv\u003e\u003c/div\u003e将内容放到层中，就以将这些内容当成一个整体进行处理，比如整体隐藏、整体移动等。div非常强大和常用。类似于WinForm的Panel。 span:div是将内容放到一个矩形的区块中，会影响布局，而span只是把一段内容定义成一个整体进行操作，但不影响布局、显示。 ","date":"2018-10-17","objectID":"/2018/10/web1-html/:2:0","tags":["Web","Html"],"title":"自学 HTML","uri":"/2018/10/web1-html/"},{"categories":"Web","content":"备注\rxml：描述存的什么数据 XHTML:可扩展超文本置标语言（eXtensible HyperText Markup Language，XHTML） DHTML：动态HTML； 格式标签：\u003cp\u003e\u003c/p\u003e创建段落；\u003cbr /\u003e回车，也可以写成\u003cbr\u003e，在HTML中有一些标签可以不关闭，\u003cbr\u003e就是一个，这是和XML不同的地方（常考），但是为了遵循XHTML规范，推荐像XML一样严格关闭。\u003cbr/\u003e\u003cimg src=\"1.gif\"/\u003e 属性值：HTML中属性值即可以用单引号括起来、也可以用双引号括起来、甚至不用引号都可以（不推荐），单双要配对。 注释：HTML使用和XML一样的来做注释。 ","date":"2018-10-17","objectID":"/2018/10/web1-html/:3:0","tags":["Web","Html"],"title":"自学 HTML","uri":"/2018/10/web1-html/"},{"categories":"设计模式","content":"上一章中对薪水支付案例的用例和类做了详细的阐述，在本篇会介绍薪水支付案例包的划分和数据库，UI的设计。 ","date":"2018-10-10","objectID":"/2018/10/designpattern3-case2/:0:0","tags":["敏捷软件开发原则模式与实践","薪水支付"],"title":"敏捷软件开发原则模式与实践 薪水支付","uri":"/2018/10/designpattern3-case2/"},{"categories":"设计模式","content":"包的划分\r一个错误包的划分 为什么这个包是错误的： 如果对classifications更改就要影响payrolldatabase更改，还会迫使transactions更改，tansactions重新发布和编译测试就是不负责的，transactions没有共享封闭性，每个类都有自己变化的敏感，所以发布的频率非常高，是不合理的。 调整一下： 将具体类和具体类打包，抽象类和抽象类打包，交互类单独打包。这已经是一个比较好打包设计了。 类的组件应该要符合共同重用原则，payrolldamain中的类没有形成最小的可重用单元，transaction类不必和组件中的其他类一起重用，可以把transaction迁移到transactionapplication类中 这样的划分太精细了，是否有这样的必要需要整体来看。 最终包的结构： ","date":"2018-10-10","objectID":"/2018/10/designpattern3-case2/:1:0","tags":["敏捷软件开发原则模式与实践","薪水支付"],"title":"敏捷软件开发原则模式与实践 薪水支付","uri":"/2018/10/designpattern3-case2/"},{"categories":"设计模式","content":"数据库的设计\remplogee是核心 完成这个设计需要进行重构： 提取出payrolldatabase接口， public interface PayrollDatabase { void AddEmployee(Employee employee); Employee GetEmployee(int id); void DeleteEmployee(int id); void AddUnionMember(int id, Employee e); Employee GetUnionMember(int id); void RemoveUnionMember(int memberId); ArrayList GetAllEmployeeIds(); IList GetAllEmployees(); } 内存表实例： public class InMemoryPayrollDatabase : PayrollDatabase { private static Hashtable employees = new Hashtable(); private static Hashtable unionMembers = new Hashtable(); public void AddEmployee(Employee employee) { employees[employee.EmpId] = employee; } // etc... public Employee GetEmployee(int id) { return employees[id] as Employee; } public void DeleteEmployee(int id) { employees.Remove(id); } public void AddUnionMember(int id, Employee e) { unionMembers[id] = e; } public Employee GetUnionMember(int id) { return unionMembers[id] as Employee; } public void RemoveUnionMember(int memberId) { unionMembers.Remove(memberId); } public ArrayList GetAllEmployeeIds() { return new ArrayList(employees.Keys); } public IList GetAllEmployees() { return new ArrayList(employees.Values); } public void Clear() { employees.Clear(); unionMembers.Clear(); } } 数据库 public class SqlPayrollDatabase : PayrollDatabase { private SqlConnection connection; public SqlPayrollDatabase() { connection = new SqlConnection(\"Initial Catalog=Payroll;Data Source=localhost;user id=sa;password=abc\"); connection.Open(); } ~SqlPayrollDatabase() { connection.Close(); } public void AddEmployee(Employee employee) { //增加员工策略 SaveEmployeeOperation operation = new SaveEmployeeOperation(employee, connection); operation.Execute(); } public Employee GetEmployee(int id) { //数据库事务 LoadEmployeeOperation loadOperation = new LoadEmployeeOperation(id, connection); loadOperation.Execute(); return loadOperation.Employee; } public void DeleteEmployee(int id) { throw new NotImplementedException(); } public void AddUnionMember(int id, Employee e) { throw new NotImplementedException(); } public Employee GetUnionMember(int id) { throw new NotImplementedException(); } public void RemoveUnionMember(int memberId) { throw new NotImplementedException(); } public ArrayList GetAllEmployeeIds() { throw new NotImplementedException(); } public IList GetAllEmployees() { throw new NotImplementedException(); } } 如果插入雇佣记录成功，但是支付记录失败，为了解决这个问题而使用事务的方式。 public class SaveEmployeeOperation { private readonly Employee employee; private readonly SqlConnection connection; private string methodCode; private string classificationCode; private SqlCommand insertPaymentMethodCommand; private SqlCommand insertEmployeeCommand; private SqlCommand insertClassificationCommand; public SaveEmployeeOperation(Employee employee, SqlConnection connection) { this.employee = employee; this.connection = connection; } public void Execute() { PrepareToSavePaymentMethod(employee); PrepareToSaveClassification(employee); PrepareToSaveEmployee(employee); SqlTransaction transaction = connection.BeginTransaction(\"Save Employee\"); try { ExecuteCommand(insertEmployeeCommand, transaction); ExecuteCommand(insertPaymentMethodCommand, transaction); ExecuteCommand(insertClassificationCommand, transaction); transaction.Commit(); } catch(Exception e) { transaction.Rollback(); throw e; } } private void ExecuteCommand(SqlCommand command, SqlTransaction transaction) { if(command != null) { command.Connection = connection; command.Transaction = transaction; command.ExecuteNonQuery(); } } private void PrepareToSaveEmployee(Employee employee) { string sql = \"insert into Employee values (\" + \"@EmpId, @Name, @Address, @ScheduleType, \" + \"@PaymentMethodType, @PaymentClassificationType)\"; insertEmployeeCommand = new SqlCommand(sql); this.insertEmployeeCommand.Parameters.Add(\"@EmpId\", employee.EmpId); this.insertEmployeeCommand.Parameters.Add(\"@Name\", employee.Name); this.insertEmployeeCommand.Parameters.Add(\"@Address\", employee.Address); this.insertEmployeeCommand.Parameters.Add(\"@ScheduleType\", Schedu","date":"2018-10-10","objectID":"/2018/10/designpattern3-case2/:2:0","tags":["敏捷软件开发原则模式与实践","薪水支付"],"title":"敏捷软件开发原则模式与实践 薪水支付","uri":"/2018/10/designpattern3-case2/"},{"categories":"设计模式","content":"界面设计\r界面设计时最好使得业务行为和UI分离，这里使用model view presenter模式（MVP） model：实体层和数据库交互 view：界面层 presenter：业务处理层 MVP的作用是解耦界面、业务和实体的关系 在presenter中主动使用view，界面的形态都是由presenter去控制，就是在presenter中去注册view事件，当用户触发事件时，这个事件会通过view传递到presenter中，并通过presenter调用model数据方法，最后presenter 调用引用的view实例去改变界面的形态。 public class AddEmployeePresenter { private TransactionContainer transactionContainer; private AddEmployeeView view; private PayrollDatabase database; private int empId; private string name; private string address; private bool isHourly; private double hourlyRate; private bool isSalary; private double salary; private bool isCommission; private double commissionSalary; private double commission; public AddEmployeePresenter(AddEmployeeView view, TransactionContainer container, PayrollDatabase database) { this.view = view; this.transactionContainer = container; this.database = database; } public int EmpId { get { return empId; } set { empId = value; UpdateView(); } } public string Name { get { return name; } set { name = value; UpdateView(); } } public string Address { get { return address; } set { address = value; UpdateView(); } } public bool IsHourly { get { return isHourly; } set { isHourly = value; UpdateView(); } } public double HourlyRate { get { return hourlyRate; } set { hourlyRate = value; UpdateView(); } } public bool IsSalary { get { return isSalary; } set { isSalary = value; UpdateView(); } } public double Salary { get { return salary; } set { salary = value; UpdateView(); } } public bool IsCommission { get { return isCommission; } set { isCommission = value; UpdateView(); } } public double CommissionSalary { get { return commissionSalary; } set { commissionSalary = value; UpdateView(); } } public double Commission { get { return commission; } set { commission = value; UpdateView(); } } private void UpdateView() { if(AllInformationIsCollected()) view.SubmitEnabled = true; else view.SubmitEnabled = false; } public bool AllInformationIsCollected() { bool result = true; result \u0026= empId \u003e 0; result \u0026= name != null \u0026\u0026 name.Length \u003e 0; result \u0026= address != null \u0026\u0026 address.Length \u003e 0; result \u0026= isHourly || isSalary || isCommission; if(isHourly) result \u0026= hourlyRate \u003e 0; else if(isSalary) result \u0026= salary \u003e 0; else if(isCommission) { result \u0026= commission \u003e 0; result \u0026= commissionSalary \u003e 0; } return result; } public TransactionContainer TransactionContainer { get { return transactionContainer; } } public virtual void AddEmployee() { transactionContainer.Add(CreateTransaction()); } public Transaction CreateTransaction() { if(isHourly) return new AddHourlyEmployee( empId, name, address, hourlyRate, database); else if(isSalary) return new AddSalariedEmployee( empId, name, address, salary, database); else return new AddCommissionedEmployee( empId, name, address, commissionSalary, commission, database); } } public interface ViewLoader { void LoadPayrollView(); void LoadAddEmployeeView( TransactionContainer transactionContainer); } public class WindowViewLoader : ViewLoader { private readonly PayrollDatabase database; private Form lastLoadedView; public WindowViewLoader(PayrollDatabase database) { this.database = database; } public void LoadPayrollView() { PayrollWindow view = new PayrollWindow(); PayrollPresenter presenter = new PayrollPresenter(database, this); view.Presenter = presenter; presenter.View = view; // 相互关联 LoadView(view); } public void LoadAddEmployeeView( TransactionContainer transactionContainer) { AddEmployeeWindow view = new AddEmployeeWindow(); AddEmployeePresenter presenter = new AddEmployeePresenter(view, transactionContainer, database); view.Presenter = presenter; LoadView(view); } private void LoadView(Form view) { view.Show(); lastLoadedView = view; } /// \u003csummary\u003e /// 最新的form /// \u003c/summary\u003e public Form LastLoadedView { get { return lastLoadedView; } } } public class PayrollMain { public static void Main(string[] args) { PayrollDatabase database = new InMemoryPayrollDatabase(); WindowViewLoader viewLoader = new WindowViewLoader(database);","date":"2018-10-10","objectID":"/2018/10/designpattern3-case2/:3:0","tags":["敏捷软件开发原则模式与实践","薪水支付"],"title":"敏捷软件开发原则模式与实践 薪水支付","uri":"/2018/10/designpattern3-case2/"},{"categories":"设计模式","content":"单一职责原则(single responsibilities principle,SRP)\r原理：一个类应该只有一个变化 分离职责：如果不耦合的职责那么很简单，如果两个职责耦合，将两个职责抽象为接口，通过继承两个接口将依赖关系抽离处理啊 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:1:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"开放封闭原则(open close principle,OCP)\r软件实体(类，模块，函数等)应该是可以扩展的，但是不可修改 对扩展开放：当需求改变时，对模块可以扩展。 对修改封闭：对模块进行扩展时，不必改动模块的源代码或则二进制代码， 仅仅抽象出容易变化的部分。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:2:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"里氏替换原则(liskov substitution principle,LSP)\r子类型必须能够替换掉它的基类型。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:3:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"依赖倒置原则(dependence inversion principle,DIP)\r高层模块不应该依赖于底层模块，二者都应该依赖抽象 抽象不应该依赖细节，细节应该依赖抽象 为什么叫倒置，在传统软件开发中，总倾向于创建一些高层模块依赖底层模块，策略依赖细节的软件结构。一个良好的面向对象程序，对传统设计结构而言就被倒置了。 其实就是都依赖接口编程，高层依赖接口，细节依赖接口，这样模块的改动不会影响其他模块。比较好的模块设计： 模块和模块间的依赖都是依赖接口。 倒置不仅仅是依赖关系的倒置，也是接口所有权的倒置，通常会认为工具库应该拥有自己的接口，但其实应该是客户拥有接口，而它们的服务者应该是接口的派生。著名的 holly wood原则：“Don’t call us, we’ll call you”不要调用我们，我们会调用你，低层模块实现在高层模块中声明并被高层模块调用的接口 程序所有的依赖关系都应该终止与抽象 任何变量都不应该持有一个指向具体类的引用 任何类都不应该从具体类派生 任何方法都不应该重写它的任何基类中已经实现的方法。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:4:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"接口隔离原则(interface segregation principle,ISP)\r","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:5:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"接口会被污染:\r当借口的职责不再单一时，接口就很容易受到污染。 一个常见的例子：一个门，可能是关着也可能是开着，而且门类知道只是是开着还是关着。 常见的接口设计，现在需要实现自动报警，当门开着超过一定的时间就进行报警。常见的方法是关联timer类，实现报警。 这种方案就造成了接口污染，所有的门都必须依赖timeclient，同时还会出现门检测到时间超时，还未报警时，门关闭了，然后又被打开了，门变成了错误的报警 通过增加一个报警id,来区别每一次报警和客户端。 接口隔离原则：不应该强迫客户程序依赖并未使用的方法。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:5:1","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"隔离接口\r通过适配器原则，实现timer类对door类的引用隔离doorclient.这样仅仅增加了一个类，而将引用关系倒置。 创建一个派生自timer的timerclient对象，并把该对象请求委托给timerdoor。 这样就实现了timer和door的隔离，即使对timer进行更改也不会影响到door。timerdoor也不需要和timerclient一样的接口， 另一种方法是使用timerdoor来多重继承，door和timerclient， 这种方案没有多余的开销，只有当doortimeradapter对象所做的转换是必须的时候或则不同的时候需要不同的转换的时候，才需要使用适配器方法。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:5:2","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"例子：\rAMT的一个例子，输出信息要转换成不同的语言，输出信息要显示在桌面上， 把不同的事务处理方法封装在transaction上，这样每个事务的修改都会造成UI的修改，如果把接口分解成不通的单独接口，就可以避免 打包原则\r大型系统的设计非常依赖于好的组件设计，这样每个团队只要关注于单个组件而不需要关注整个系统。 但类经常会和其他类发生依赖关系，这些依赖关系也会跨越组件的边界。 在向组件中分配类时应该依据什么原则 应该使用什么设计原则来管理组件之间的关系 组件的设计应该先于类（自顶而下），还是设计应该先于组件（自底而上） 组件的实体以什么方式存在 组件创建好后，用于何种目的 组件和组件间的依赖关系：不能依赖具体类。只能是具体依赖抽象，抽象依赖抽象。这样就可以将影响将至最低。 前三个原则来指导如何将类划分到包中，后三个原则来管理包之间的耦合(稳定)。组件之间的耦合越稳定就越好 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:5:3","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"重用发布等价原则(reuse release equivalence principle,REP)\r重用粒度就是发布粒度：一个组件的重用粒度和发布粒度一样大，重用的任何东西必须被同时发布和跟踪， 重用性必然是基于组件的，所以可重用的组件必须包含可重用的类，因至少某些组件应该由一组可重用的类组成 一个类中的组件要么都是可重用的，要么都是不可重用的。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:6:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"共同重用原则(common reuse principle , crp)\r一个组件中所有的类都应该是共同重用的，如果重用了组件中的一个类，那么就要重用组件中的所有类。 这个原则可以帮助我们确定哪些类应该在一个组件中，相互之间没有紧密联系的类不应该在同一个组件中。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:7:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"共同封闭原则(common closure principle,ccp)\r组件中所有的类对同一种性质的变化应该是共同封闭的，一个变化若对一个封闭的组件产生影响，则将对该组件中所有的类产生影响，而对其他组件不产生影响。类似于单一职责原则。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:8:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"无环依赖原则\r在组件的关系图中不允许存在环。 解除依赖环的方法：提取抽象接口，通过实现接口来替换关联。关联和实现的依赖关系相反。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:9:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"稳定依赖原则\r朝着稳定的方向进行依赖。 被依赖的越多，该组件就越不可能改动，则越稳定。 稳定性度量： ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:10:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"稳定抽象原则\r组件的抽象程度与其稳定性。 中间连接线称为主序列。 到主序列的距离： 越为0 越好 有了度量和标准就让我们划分组件吧！！！ ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:11:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"这本书的实例非常好，给了我非常多的启发。主要讲了两个实例，咖啡机和薪水支付实例，咖啡机实例比较简单并没有用什么设计模式，薪水支付实例用了很多设计模式，包括后面的打包等。 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:0:0","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"咖啡机实例\r做一个使用咖啡机的软件，驱动接口已经被写好。 咖啡机的硬件包括： 加热器加热棒（开关） 保温盘加热棒（开关） 保温盘传感器（保温盘空，杯子空，杯子不空） 加热器传感器（有水，没水） 冲煮按钮（开关） 指示灯（开关） 减压阀门（开关） 咖啡机的冲煮流程： 咖啡机一次煮12杯咖啡， 咖啡加入过滤器，过滤器加入支架，支架放到咖啡机。 倒入12杯水到滤水器，按下冲煮，水杯加热至沸腾，水蒸气碰洒到过滤器，形成水滴到咖啡壶，咖啡壶发现有水保温， 拿走水杯，停止工作。 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:1:0","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"方案一\r建立一个咖啡机超类，关联各个硬件类。这个方案是非常丑陋的，这不是根据行为划分的，有些类，比如light没有任何变量，仅仅调用了驱动接口，这种类叫水蒸气类。没有意义 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:1:1","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"方案二\r按照行为来划分，要确定一些类有没有意义，只需要确定谁使用他们，而且要到业务底层去看。把问题的本质和细节分离，忘掉一切，最根本的问题是如何煮咖啡。如何煮咖啡，将热水倒到咖啡上，把冲泡好的咖啡收集起来。水从哪来？咖啡放到哪里？那么就有两个类：热水类和支架类，大大多数人会考虑热水流到支架中，这是比较错误的，软件的行为应该按照软件的行为给出而不是基于一些物理关系。还需要考虑用户界面，这样就有三个类。 谁使用 最根本的问题 软件行为而不是物理行为 用例\r按下冲煮，启动水流，支架做好准备，都准备好就开始煮咖啡 接受器具准备好没有 冲煮完成 咖啡喝完 Containment Vessel:支架和保温壶 Resume:恢复 a，b，c，d表示四种逻辑： a 表示：用户按下冲煮，确保支架中有咖啡壶放在保温杯上，热水器中已经加满了水，然后才开始煮咖啡 b 表示：如果正在股咖啡的过程中咖啡壶被拿走，则必须中断咖啡流，停止送热水，再次放回咖啡壶继续煮咖啡 c 表示：热水器中传感器告诉我们水用完了就停止煮咖啡，同时告诉用户和支架（保温盘）已经停止煮咖啡 d 表示：冲煮结束时并且一个空的咖啡壶放在支架上（保温盘），热水器应该知道这个消息，同时用户也应该知道这个消息 这样整个咖啡机的抽象就完成了，按职责划分，各司其职。这三个抽象类不能知道任何关于咖啡机的任何信息。这就是依赖倒置原则。 系统的控制流如何检测传感器呢？是选择线程还是轮询。最好的总是假设消息都是可以异步发送的，就像存在有独立的线程一样，把使用轮询还是线程的决策推迟到最后一刻。 这样设置了一个接口，main()程序就待在一个循环中，不停地一遍遍调用这个方法实现轮询。 public static void Main(string[] args) { CoffeeMakerAPI api = new M4CoffeeMakerAPI(); M4UserInterface ui = new M4UserInterface(api); M4HotWaterSOurce hws = new M4HotWaterSOurce(api); M4ContainmentVessel cv = new M4ContainmentVessel(api); ui.Init(hws,cv); hws.Init(ui,cv); cv.Init(hws,ui); while(true) { ui.Poll(); hws.Poll(); cv.Poll(); } } 依赖倒置，不允许高层的咖啡制作中依赖底层实现。 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:1:2","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"薪水支付实例\r该案例主要有做一个薪水支付系统，主要有三类员工 临时工：基本时薪，超过8小时加班时间1.5倍工资，每天有考勤卡，每周5结算。 正式员工：月薪，每个月最后一天结算。 经理：月薪，每月最后一天结算，有项目提成，每隔一周的周五结算，加入公会扣会费。 公会会费分服务费和会费：会费每周都有从薪水中扣除，服务费从下个月薪水中扣除。 薪水支付方式：可以选择支票邮寄到家，支票保存自取，直接存入银行账号。 薪水支付每天运行一次，在当天为相应的雇员进行支付，上一次支付到本次支付应付的数额。 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:2:0","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"用例：\r新增雇员：雇员号，姓名，地址。（零时工，正式员工，经理） 删除雇员：雇员号 登记考勤卡：雇员号，日期，小时 登记销售凭条：雇员号，日期，销售记录 登记公会服务费：公会成员，服务费用 更改雇员细则：更改姓名，更改地址，更改每小时报酬，更改薪水，更改提成，更改支付方式，加入公会，离开公会 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:2:1","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"设计类和结构：\r通过迭代的方式进行实现。数据库是实现细节，应该尽推迟数据库的设计。通过用例来推导出应该有哪些类。 从用例的角度设计\r新增雇员 Hourly:小时工 Commissioned：正式员工 Balarid：经理 把每一项工作划分为自己的类中。这样有可能会创建三个雇员类，但是分析一下就会发现变化的东西太多了，正式由于雇员变化的东西引发雇员类型的改变，只需要将变化的东西抽象出来，在更改雇员细则时改变这些变化的东西就可以改变雇员类型。 登记考勤卡 考勤卡和雇员应该是聚合的关系 登记销售凭条 销售凭条和雇员也应该是聚合的关系 登机工会服务费 工会服务费维护着工会会员的编号，因此系统必须要把工会成员和雇员标识联系起俩，推迟这一行为。公会成员和服务费也是聚合的关系 更改雇员细则 这是由多个更改策略组合而成。 最后各个类之间的关系 从程序运行的角度补充细节\r运行薪水支付系统：找到所有进行支付的雇员，确定扣款额，根据他们的支付方式支付。 抽象出变化的东西：雇员的支付类别抽象，支付时间抽象 工会服务费抽象。Affillation:联系 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:2:2","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"实现\r事务 事务是使用命令模式。 增加雇员事务，雇员有三个类型，所以使用模板模式来实现增加雇员，此处模板模式的唯一任务就是创建对象 public abstract class AddEmployeeTransaction : Transaction { private readonly int empid; private readonly string name; private readonly string address; public AddEmployeeTransaction(int empid, string name, string address, PayrollDatabase database) : base (database) { this.empid = empid; this.name = name; this.address = address; } protected abstract PaymentClassification MakeClassification(); protected abstract PaymentSchedule MakeSchedule(); public override void Execute() { PaymentClassification pc = MakeClassification(); PaymentSchedule ps = MakeSchedule(); PaymentMethod pm = new HoldMethod(); Employee e = new Employee(empid, name, address); e.Classification = pc; e.Schedule = ps; e.Method = pm; database.AddEmployee(e); } public override string ToString() { return String.Format(\"{0} id:{1} name:{2} address:{3}\", GetType().Name, empid, name,address); } } public class AddSalariedEmployee : AddEmployeeTransaction { private readonly double salary; public AddSalariedEmployee(int id, string name, string address, double salary, PayrollDatabase database) : base(id, name, address, database) { this.salary = salary; } protected override PaymentClassification MakeClassification() { return new SalariedClassification(salary); } protected override PaymentSchedule MakeSchedule() { return new MonthlySchedule(); } } 删除雇员 提供雇员id，去数据库删除雇员，没啥好说的。 考勤卡、销售凭条、服务费 考勤卡：需要参数，雇员id,日期，工作时间 public class TimeCard { private readonly DateTime date; private readonly double hours; public TimeCard(DateTime date, double hours) { this.date = date; this.hours = hours; } public double Hours { get { return hours; } } public DateTime Date { get { return date; } } } public class TimeCardTransaction : Transaction { private readonly DateTime date; private readonly double hours; private readonly int empId; public TimeCardTransaction(DateTime date, double hours, int empId, PayrollDatabase database) : base(database) { this.date = date; this.hours = hours; this.empId = empId; } public override void Execute() { Employee e = database.GetEmployee(empId); if (e != null) { HourlyClassification hc = e.Classification as HourlyClassification; if (hc != null) hc.AddTimeCard(new TimeCard(date, hours)); else throw new ApplicationException( \"Tried to add timecard to\" + \"non-hourly employee\"); } else throw new ApplicationException( \"No such employee.\"); } } 其他两种与这类似 更改雇员属性 更改雇员属性由多个事务集合而成 改名字事务： public abstract class ChangeEmployeeTransaction : Transaction { private readonly int empId; public ChangeEmployeeTransaction(int empId, PayrollDatabase database) : base (database) { this.empId = empId; } public override void Execute() { Employee e = database.GetEmployee(empId); if(e != null) Change(e); else throw new ApplicationException( \"No such employee.\"); } protected abstract void Change(Employee e); } public class ChangeNameTransaction : ChangeEmployeeTransaction { private readonly string newName; public ChangeNameTransaction(int id, string newName, PayrollDatabase database) : base(id, database) { this.newName = newName; } protected override void Change(Employee e) { e.Name = newName; } } 更改雇员类别 public abstract class ChangeClassificationTransaction : ChangeEmployeeTransaction { public ChangeClassificationTransaction(int id, PayrollDatabase database) : base (id, database) {} protected override void Change(Employee e) { e.Classification = Classification; e.Schedule = Schedule; } protected abstract PaymentClassification Classification { get; } protected abstract PaymentSchedule Schedule { get; } } public class ChangeHourlyTransaction : ChangeClassificationTransaction { private readonly double hourlyRate; public ChangeHourlyTransaction(int id, double hourlyRate, PayrollDatabase database) : base(id, database) { this.hourlyRate = hourlyRate; } protected override PaymentClassification Classification { get { return new HourlyClassification(hourlyRate); } } protected override PaymentSchedule Schedule { get { return new WeeklySchedule(","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:2:3","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"总结\r到目前为止基本功能已经实现，仅仅只是用了模板，空值，命令等设计模式，下一篇将会进一步使用更多的设计模式进行打包处理。 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:3:0","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"所看书籍是：敏捷软件开发_原则、模式与实践_C#版（美）马丁著，这本书写的非常棒，感谢作者。该归纳总结的过程按照我读的顺序写。 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:0:0","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"UML\r在建造桥梁，零件，自动化设备之前需要建模分析可行性，软件在编写之前也需要建立模型，看看类和逻辑的设计是否合理，这样的建模过程就是UML。 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:0","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"类图\r类图就是来描述一个类本身或和其他类的调用关系。 +public -private #protected 实现/泛化\r集成 实现接口 组合\r部分可以离开整体 聚合\r部分不能离开整体 关联\r持有对其他对象引用的实例变量 依赖\r局部变量/方法的参数或则静态方法的调用 注意 关系的强弱：泛化/实现\u003e组合\u003e聚合\u003e关联\u003e依赖 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:1","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"对象图\r表示系统执行的某个特定时刻的一组对象和关系，可以看成是内存快照。 该图大部分是从相应的类图中推导而来没啥用。 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:2","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"顺序图\r描述算法的实现，重点在于消息的顺序。比较常绘制的动态模型。 例子\r对象下面画有横线，类没有，对象名：类 垂下来的线为生命线 中间矩形垂下来的矩形：激活，表示一个函数的执行时间 虚线表示返回参与者并传回返回值 箭头：消息。返回值：消息名称（参数） 带圆圈的箭头：消息的参数 注意\r循环：框起来 [for each id in idlist] 容易被勿用和滥用 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:3","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"协作图\r描述算法的实现，重点在于对象之间的关系 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:4","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"状态图\r其实就是有限状态机（FSM）。 例子:\r实心黑球：初始伪状态，从这个状态开始运转 圆矩形：状态。上层放状态的名字，下层放一些特定动作和事件，表示进入或则退出时要做什么， 箭头：迁移。上面有触发该迁移的事件名称和要执行的动作 注意 entry和exit：标准事件，不管写不写都会触发 超状态：几个状态迁移时间相同时，可以组成一个超状态。迁移时会出发超状态的entry和exit ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:5","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"如何使用UML\r在使用UML的过程中，需要先通过行为优先的方式写出状态图，先是局部状态再是整体状态，抽象出会改变的，将每一种改变的类型实例化，中间再通过各种设计模式隔离 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:2:0","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"行为优先\r从项目的功能入手，用户的交互入手写出每一种功能，大体的类有了后，再抽象出会改变的类，通过设计模式隔离 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:2:1","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"检查结构\r检查每一种功能实现是否合理 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:2:2","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"想象代码\r想想出代码的样子做微调 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:2:3","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":null,"content":"关于我\r92年，儿子、丈夫、父亲，新时代农民工。 从事上位机开发多年，熟悉制药(层析超滤)和IVD(生化免疫)设备软件。 喜欢研究和学习各类技术，保持好奇心，持续探索。 熟悉的编程语言：C#,C,C++,Vue。 可以通过邮件978089234@qq.com与我联系！ Blog\r小时候夏天很长，长大了一年很短。每天都感觉很忙碌，却不知道在忙些什么。 想要记录些东西，表明那些年真的存在过。 写的文章，分享的想法观点可能早就有人写过，分享过。 没有关系，这算是自我的一种成长和探索，走一下别人走过的路，站在巨人的肩膀上，能不能看到不一样的风景？ ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]