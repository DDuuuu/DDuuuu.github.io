[{"categories":"LeeCode","content":"题目\r题目链接 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。 示例 1： 输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2： 输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3： 输入：nums = [], target = 0 输出：[-1,-1] 提示： 0 \u003c= nums.length \u003c= 105 -109 \u003c= nums[i] \u003c= 109 nums 是一个非递减数组 -109 \u003c= target \u003c= 109 ","date":"2022-11-16","objectID":"/2022/11/leecode34/:0:1","tags":["LeeCode","34","数组","查找第一个和最后一个位置"],"title":"LeeCode-34-数组-查找第一个和最后一个位置","uri":"/2022/11/leecode34/"},{"categories":"LeeCode","content":"解题\r二分法类似题，解题方案和前面两个相似 存在的变化，有重复数据，需要返回两个位置 尝试使用二分，找到值的序号后，向左，向右定位到上下限。 public int[] Search(int[] nums, int target) { //[left，right] var left = 0; var right = nums.Length - 1; var result = new int[] {-1, -1}; var mid = 0; while (left \u003c= right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { var min = mid; while (--min\u003e=left)//确定下限，使用遍历 { if(nums[min] != target) break; } result[0] = min + 1; var max = mid; while (++max \u003c= right)//确定上限，使用遍历 { if (nums[max] != target) break; } result[1] = max-1; break; } else if (target\u003cnums[mid]) { right = mid - 1; } else { left = mid + 1; } } return result; } 如果数组中的重复项比较多，中间使用遍历可以优化为二分，同时判定目标值是否在数组中也改成递归进行统一。 public int[] SearchPlus(int[] nums, int target) { var result = new int[] { -1, -1 }; if (nums.Length == 0) return result; //[left，right] var left = 0; var right = nums.Length - 1; var mid = 0; //遍历定位左右限，type 0:返回下限序号，1返回上限序号 ,2找到即返回, //返回[left right,index] int[] InnterSearch(int[] nums, int target, int left, int right, int type) { if (left \u003c= right) { mid = (left + right) \u003e\u003e 1; if (type == 2 \u0026\u0026 target == nums[mid]) { return new[] {left, right, mid}; } else if ( target \u003c nums[mid]||(type == 0 \u0026\u0026 target == nums[mid])) { right = mid - 1; } else if (target \u003e nums[mid] || (type == 1 \u0026\u0026 target == nums[mid])) { left = mid + 1; } return InnterSearch(nums, target, left, right, type); } if (type == 2)//不在数组中 { return new[] {left, right, -1}; } var index = type==1 ? left-1 : right+1; return new[] {left, right, nums[index] == target ? index : -1}; } var indexarray = InnterSearch(nums, target, left, right, 2);//数组中存在 if (indexarray[2] == -1) return result; result[0]= InnterSearch(nums, target, indexarray[0], indexarray[2], 0)[2];//找到下限 [left,mid]中二分 result[1] = InnterSearch(nums, target, indexarray[2], indexarray[1], 1)[2];//找到上限 [mid,right]中二分 return result; } InnterSearch方法承担了三个职责，目标值是否在数组中，寻找上限，寻找下限。导致内部实现用了很多的判定，看上去有点乱，通过字典封装判断逻辑，一目了然，如果以后需求变化，改动字典即可，尽可能满足开放封闭原则。 public int[] SearchPlusPro(int[] nums, int target) { var result = new int[] { -1, -1 }; if (nums.Length == 0) return result; //[left，right] var left = 0; var right = nums.Length - 1; var mid = 0; //遍历定位左右限，type 0:返回下限序号，1返回上限序号 ,2找到即返回, //返回[left right,index] var searchtypes = new Dictionary\u003cint, Func\u003cint[], int, int, int,int, int[]\u003e\u003e() { {//下限 0, (_nums, _target, _left, _right,_mid) =\u003e { if (_target \u003c= _nums[_mid]) { _right = _mid - 1; } else //target\u003enums[mid] { _left = _mid + 1; } return new []{_left,_right,-1}; } }, {//上限 1, (_nums, _target, _left, _right,_mid) =\u003e { if (_target \u003c _nums[_mid]) { _right = _mid - 1; } else //target\u003e=nums[mid] { _left = _mid + 1; } return new []{_left,_right,-1}; } }, {//找到立即返回 2, (_nums, _target, _left, _right,_mid) =\u003e { if (_target == _nums[_mid]) { return new[] {_left, _right, _mid}; } else if ( _target \u003c _nums[_mid]) { _right = _mid - 1; } else { _left = _mid + 1; } return new []{_left,_right,-1}; } } }; int[] InnterSearch(int[] nums, int target, int left, int right, int type) { if (left \u003c= right) { mid = (left + right) \u003e\u003e 1; var temresult = searchtypes[type](nums, target, left, right, mid); if (temresult[2] != -1) return temresult; return InnterSearch(nums, target, temresult[0], temresult[1], type); } return new[] {left, right, -1}; } var indexarray = InnterSearch(nums, target, left, right, 2);//数组中存在 if (indexarray[2] == -1) return result; result[0] = InnterSearch(nums, target, indexarray[0], indexarray[2], 0)[0];//找到下限 [left,mid]中二分 result[1] = InnterSearch(nums, target, indexarray[2], indexarray[1], 1)[1];//找到上限 [mid,right]中二分 return result; } ","date":"2022-11-16","objectID":"/2022/11/leecode34/:0:2","tags":["LeeCode","34","数组","查找第一个和最后一个位置"],"title":"LeeCode-34-数组-查找第一个和最后一个位置","uri":"/2022/11/leecode34/"},{"categories":"LeeCode","content":"网络解析\r网络解析有以下几种方式： 对数组使用两次二分查找上限和下限。 先判断目标在数组中，再使用二分查找上下限 public class Solution { public int[] SearchRange(int[] nums, int target) { if (nums.Length == 0) return new int[] { -1, -1 }; int l = binarySearch(nums, target, true); int r = binarySearch(nums, target, false) - 1; if (l \u003c= r \u0026\u0026 r \u003c nums.Length \u0026\u0026 nums[l] == target \u0026\u0026 nums[r] == target) return new int[] { l, r }; return new int[] { -1, -1 }; } int binarySearch(int[] nums,int target,bool lower) { int n = nums.Length; int l = 0, r = n - 1; while (l \u003c= r) { int m = (l + r) / 2; if (nums[m] \u003e target || (lower \u0026\u0026 nums[m] \u003e= target)) { r = m - 1; n = m; } else l = m + 1; } return n; } } public class Solution { public int[] SearchRange(int[] nums, int target) { int[] res = new int[2]; int left=0; int right = nums.Length-1; while(left\u003c= right) { int mid = left+(right-left)/2; if(nums[mid] \u003ctarget) { left = mid+1; }else if(nums[mid] \u003etarget) { right = mid-1; }else if (nums[mid]==target) { right = mid-1; } } if(left==nums.Length) { res[0] = -1; }else { res[0] = nums[left]==target?left:-1; } left=0; right = nums.Length-1; while(left\u003c= right) { int mid = left+(right-left)/2; if(nums[mid] \u003ctarget) { left = mid+1; }else if(nums[mid] \u003etarget) { right = mid-1; }else if (nums[mid]==target) { left = mid+1; } } if(left-1 \u003c0) { res[1] = -1; }else { res[1] = nums[left-1]==target?left-1:-1; } return res; } } ","date":"2022-11-16","objectID":"/2022/11/leecode34/:0:3","tags":["LeeCode","34","数组","查找第一个和最后一个位置"],"title":"LeeCode-34-数组-查找第一个和最后一个位置","uri":"/2022/11/leecode34/"},{"categories":"LeeCode","content":"题目\r题目链接 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例 1: 输入: nums = [1,3,5,6], target = 5 输出: 2 示例 2: 输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3: 输入: nums = [1,3,5,6], target = 7 输出: 4 提示: 1 \u003c= nums.length \u003c= 104 -104 \u003c= nums[i] \u003c= 104 nums 为 无重复元素 的 升序 排列数组 -104 \u003c= target \u003c= 104 解题\r","date":"2022-11-15","objectID":"/2022/11/leecode35/:0:0","tags":["LeeCode","35","数组","搜索插入位置"],"title":"LeeCode-35-数组-搜索插入位置","uri":"/2022/11/leecode35/"},{"categories":"LeeCode","content":"二分\r思考，排序数组，无重复，升序，规定时间复杂度，好像只有二分了，递归是否可以，因为递归也是Logn public int Search(int[] nums, int target) { //[left,right] var left = 0; var right = nums.Length - 1; var mid = 0; while (left \u003c= right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { left = mid; break; } else if (target\u003cnums[mid]) { right = mid - 1; } else { left = mid + 1; } } return left; } public int SearchPlus(int[] nums, int target) { //[right,left) var left = 0; var right = nums.Length; var mid = 0; while (left != right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { left = mid; break; } else if (target \u003c nums[mid]) { right = mid; } else { left = mid + 1; } } return left; } ","date":"2022-11-15","objectID":"/2022/11/leecode35/:1:0","tags":["LeeCode","35","数组","搜索插入位置"],"title":"LeeCode-35-数组-搜索插入位置","uri":"/2022/11/leecode35/"},{"categories":"LeeCode","content":"递归\rpublic int SearchPro(int[] nums, int target) { //[right,left] var left = 0; var right = nums.Length - 1; var mid = 0; int InnerCore(int[] nums, int target, int left, int right) { if (left \u003c= right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { return mid; } else if (target \u003c nums[mid]) { return InnerCore(nums, target, left, mid-1); } else { return InnerCore(nums, target, mid + 1, right); } } return left; } return InnerCore(nums,target,left,right); } public int SearchProPlus(int[] nums, int target) { //[right,left) var left = 0; var right = nums.Length; var mid = 0; int InnerCore(int[] nums, int target, int left, int right) { if (left != right) { mid = (left + right) \u003e\u003e 1; if (nums[mid] == target) { return mid; } else if (target \u003c nums[mid]) { return InnerCore(nums, target, left, mid); } else { return InnerCore(nums, target, mid + 1, right); } } return left; } return InnerCore(nums, target, left, right); } 网络解析\rpublic int SearchInsert(int[] nums, int target) { int searchIdx; int searchLower = 0, searchHigher = nums.Length - 1; int middle = 0; while (searchLower \u003c= searchHigher) { middle = searchLower + (searchHigher - searchLower) / 2; if (nums[middle] == target) { return middle; } if (nums[middle] \u003e target) { searchHigher = middle - 1; } else { searchLower = middle + 1; } } if (target \u003c= nums[middle]) return middle; if (target \u003e nums[middle]) return middle + 1; return -1; } public class Solution { public int SearchInsert(int[] nums, int target) { return Rank(nums,0,nums.Length - 1,target); } public int Rank(int[] arr,int left,int right,int target) { if(target \u003c arr[left]) return left; if(target \u003e arr[right]) return right + 1; int mid = (left + right)/2; if(target == arr[mid]) return mid; if(target\u003carr[mid]) return Rank(arr,left,mid-1,target); else return Rank(arr,mid+1,right,target); } } ","date":"2022-11-15","objectID":"/2022/11/leecode35/:2:0","tags":["LeeCode","35","数组","搜索插入位置"],"title":"LeeCode-35-数组-搜索插入位置","uri":"/2022/11/leecode35/"},{"categories":"LeeCode","content":"题目\r给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示: 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 解题\r如果使用遍历，最好情况O(1)，最坏情况O(n)。 使用二分法是O(logn)。 尝试使用二分，二分肯定有上下限和中间值，通过中间值和目标值比较，不断缩小上下限最后得到结果。 从中考虑While的判断是什么？ 上下限的范围怎么划定？ 初版： public int Search(int[] nums, int target) { var maxindex = nums.Length-1; var minindex = 0; var index = (maxindex + minindex) / 2; while (maxindex != minindex) { if (target == nums[index]) { break; } if (target \u003c nums[index]) { maxindex = index; } else { minindex = index+1; } index = (maxindex + minindex) / 2; } if (target == nums[index]) return index; return -1; } 测试用例通过了，但是有效率不高，有很多重复代码，改进一下 public int SearchPro(int[] nums, int target) { var maxindex = nums.Length - 1; var minindex = 0; var midindex=0; while (minindex\u003c=maxindex) { midindex = (maxindex + minindex) / 2; if (target == nums[midindex]) { return midindex; } if (target \u003c nums[midindex]) { maxindex = midindex - 1; } else { minindex = midindex + 1; } } return -1; } 最佳答案 public int StandardSearch(int[] nums, int target) { int left = 0, right = nums.Length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } if (nums[mid] \u003e target) { right = mid - 1; } else { left = mid + 1; } } return -1; } 对比： 想一下变量用left和right应该更简介一点。mid在循环体中声明，每次会在栈中创建新的临时变量。 网络解析\rtarget 是在一个在左闭右闭的区间里，也就是[left, right] ，这种就是上面的标准写法 while (left \u003c= right) 要使用 \u003c= ，因为left == right是有意义的，所以使用 \u003c= if (nums[middle] \u003e target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 target 是在一个在左闭右开的区间里，也就是[left, right) while (left \u003c right)，这里使用 \u003c ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] \u003e target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] public int SearchPlus(int[] nums, int target) { var maxindex = nums.Length; var minindex = 0; var midindex = 0; while (minindex \u003c maxindex) { midindex = (maxindex + minindex) / 2; if (target == nums[midindex]) { return midindex; } if (target \u003c nums[midindex]) { maxindex = midindex; } else { minindex = midindex+1; } } return -1; } ","date":"2022-11-14","objectID":"/2022/11/leecode704/:0:0","tags":["LeeCode","704","数组","二分查找"],"title":"LeeCode-704-数组-二分查找","uri":"/2022/11/leecode704/"},{"categories":"DotNet基础","content":"概述\r高性能的套接字编程围绕着两个方面：异步和复用。异步：高性能就是最大化计算机资源的利用，是不可能让线程有阻塞的，所以就有了各种异步模式。复用：计算机资源最好是能重复使用的，频繁的创建和销毁相同的对象也是对资源的浪费，所以就有了各种池和零拷贝；CPU在访问相邻资源的时候有特别的优势可以利用缓存区，所以池中对象尽量相邻创建。 Socket套接字编程历史悠久，发展出好几种方式，对应着DotNet异步编程的发展，分别：异步编程模式(Asynchronous Programming Model ,APM)、基于事件的异步模式(Event-based Asynchronous Pattern ,EAP)和基于任务的异步模式(Task-based Asynchronous Pattern,TAP)。 本文将简要介绍几种异步编程对应Socket的实现，每一种都写了一个简单的Socket服务端以供学习。 ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:1:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"面向连接的套接字\r套接字流程如下，在Accept，Read，Write，Connect和Disconnect方法均涉及到异步编程。为什么会异步，简单来说就是线程执行速度很快，网络传输的IO速度很慢，线程发出IO操作的指令后，不可能一直等待指令执行完。所以线程设置一个回调函数的入口地址，让IO执行完之后调用该入口地址，之后线程就去干其他事情了，等该IO调用该入口地址，线程再回来继续工作。 ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:2:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"阻塞式套接字\rSocket接口，下面是用阻塞方法创建的一个简单服务端。可以分析出该服务的性能是很差的，没有做任何的异步和复用。 //服务端 public static void Run(string m_ip, int m_port) { var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); var ip = IPAddress.Parse(m_ip); var endpoint = new IPEndPoint(ip, m_port); socket.Bind(endpoint); socket.Listen(0); socket.ReceiveTimeout = -1; //线程池中后台线程执行 Task.Run(() =\u003e { while (true) { var acceptSocket = socket.Accept();//线程阻塞等待连接请求队列 if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { //线程池中后台线程执行 Task.Run(() =\u003e { byte[] receiveBuffer = new byte[1024];//每一个连接都在重新创建缓冲区 int result = 0; do { if (acceptSocket.Connected) { result = acceptSocket.Receive(receiveBuffer, 0, receiveBuffer.Length, SocketFlags.None, out SocketError error);//线程阻塞等待缓冲区数据 if (error == SocketError.Success \u0026\u0026 result \u003e 0) { var recestr = Encoding.UTF8.GetString(receiveBuffer, 0, result); var Replaystr = $\"Server收到消息:{recestr};Server收到消息的时间:{DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss:fff\")}\"; var strbytes = Encoding.UTF8.GetBytes(Replaystr); acceptSocket.Send(strbytes, 0, strbytes.Length, SocketFlags.None);//线程阻塞等待发送完缓冲区数据 if (recestr.Contains(\"stop\")) { break; } } } else { break; } } while (result \u003e 0); }).ContinueWith((t) =\u003e { System.Threading.Thread.Sleep(1000); acceptSocket.Disconnect(false); acceptSocket.Dispose(); }); } } }).Wait(); } ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:3:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"异步编程模式(Asynchronous Programming Model ,APM)\rBeginXXX方法并不会阻塞线程，而EndXXX会，dotnet提供Task\u003cT\u003e.Factory.FromAsync可以将APM转成TAP模式异步模式以提高性能，下面提供一个示例，同时使用ArrayPool复用缓冲区，处理分包，粘包等问。 public static Socket Run(string m_ip, int m_port) { var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); var ip = IPAddress.Any; if (!string.IsNullOrEmpty(m_ip)) { ip = IPAddress.Parse(m_ip); } var endpoint = new IPEndPoint(ip, m_port); socket.Bind(endpoint); Console.WriteLine($\"[{DateTime.Now.GetFormString()}] Server Established localEndpoint:[{socket.LocalEndPoint.ToString()}]\"); socket.Listen(200); socket.ReceiveTimeout = -1; //后台线程执行 Task.Run(async () =\u003e { while (true) { var acceptSocket = await Task\u003cSocket\u003e.Factory.FromAsync( socket.BeginAccept(null,null) ,socket.EndAccept);//APM转TAP异步 if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { //后台线程来处理Receive逻辑 var task = Task.Run(async () =\u003e { byte[] buffer = ArrayPool\u003cbyte\u003e.Shared.Rent(1024);//从内存池中获取缓冲区 var bytesBuffered = 0; var bytesConsumed = 0; while (true) { if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { var temremaining = bytesBuffered - bytesConsumed; if (temremaining == 0)//缓存区全部解析完 { bytesBuffered = 0; bytesConsumed = 0; } else if (temremaining \u003c buffer.Length \u0026\u0026 temremaining \u003e 0)//最后一个包不完整，部分数据未解析 { var newbuffer = ArrayPool\u003cbyte\u003e.Shared.Rent(buffer.Length); Buffer.BlockCopy(buffer, bytesConsumed, newbuffer, 0, temremaining); ArrayPool\u003cbyte\u003e.Shared.Return(buffer); buffer = newbuffer; bytesBuffered = temremaining; bytesConsumed = 0; } else //包不够大，分包了 { var newbuffer = ArrayPool\u003cbyte\u003e.Shared.Rent(buffer.Length * 2); Buffer.BlockCopy(buffer, 0, newbuffer, 0, buffer.Length); ArrayPool\u003cbyte\u003e.Shared.Return(buffer); buffer = newbuffer; } var bytesRemaining = buffer.Length - bytesBuffered; try { var bytesread = await Task\u003cint\u003e.Factory.FromAsync( acceptSocket.BeginReceive(buffer, bytesBuffered, bytesRemaining, SocketFlags.None, null, null), acceptSocket.EndReceive);//APM转TAP异步 if (bytesread == 0) { break; } bytesbuffered += bytesread; var lineposition = -1; do { lineposition = array.indexof(buffer, (byte)0x23, bytesconsumed,bytesbuffered - bytesconsumed); if (lineposition \u003e= 0) { var lineLength = linePosition - bytesConsumed; ProcessLine(acceptSocket, buffer, bytesConsumed, bytesread); bytesConsumed += bytesread; } } while (linePosition \u003e= 0);//包解析 } catch (Exception e) { break; } } else { break; } } ArrayPool\u003cbyte\u003e.Shared.Return(buffer); }).ContinueWith((t) =\u003e { Console.WriteLine($\"[{DateTime.Now.GetFormString()}] ServerClient Disconnected localEndpoint:[{acceptSocket?.LocalEndPoint.ToString()}] remoteEndpoint:[{acceptSocket?.RemoteEndPoint.ToString()}]\"); acceptSocket?.Shutdown(SocketShutdown.Both); acceptSocket?.Close(); acceptSocket = null; }); } } }); return socket; } ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:4:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"基于事件异步的完成端口模型(Event-based Asynchronous Pattern ,EAP)\r目前应用最广的Socket模型，完成端口模型还是按照\"回调函数\"的方式进行来实现异步，其本质是线程池，该线程池的核心工作就是去调用IO操作完成时的回调函数。另外因为IO操作毕竟是慢速的操作，所以几个线程就已经足可以应付成千上万的输入输出完成操作的请求(前提就是你的回调函数做的工作要足够少)，所以这个模型的性能是非常高的。也是现在Windows平台上性能最好的输入输出模型。自定义构造了内存池，将一大块内存切分成一定数据量的连续小内存，分别分配给不同的SocketAsyncEventArgs对象以提高服务性能，非常巴适；目前看到的FastSocket,SuperSocket,TouchSocket,NewLife等网络框架均采用这种模式，最主要的原因是应用范围广。 框架 版本 .NET Core 1.0, Core 1.1, Core 2.0, Core 2.1, Core 2.2, Core 3.0, Core 3.1, 5, 6, 7 Preview 7 .NET Framework 2.0, 3.0, 3.5, 4.0, 4.5, 4.5.1, 4.5.2, 4.6, 4.6.1, 4.6.2, 4.7, 4.7.1, 4.7.2, 4.8 .NET Standard 1.3, 1.4, 1.6, 2.0, 2.1 UWP 10.0 Xamarin.iOS 10.8 Xamarin.Mac 3.0 public class MyIOCPSocket { private static int m_numConnections;//最大连接数 private static int m_receiveBufferSize;//接收缓存区数量 private static int m_sendBufferSize;//发送缓存区大小 private static byte[] m_receivebuffer;//接收缓存区 private static Stack\u003cint\u003e m_freeReceiveIndexPool;//可用的接收缓存索引栈 private static int m_currentReceiveIndex;//当前的接收缓存区索引 private static byte[] m_sendbuffer;//发送缓存区 private static Stack\u003cint\u003e m_freeSendIndexPool;//可用的发送缓存索引栈 private static int m_currentSendIndex;//当前的发送缓存区索引 private static Stack\u003cSocketAsyncEventArgs\u003e m_ReadPool;//接收SocketAsyncEventArgs池 private static Stack\u003cSocketAsyncEventArgs\u003e m_WritePool;//发送SocketAsyncEventArgs池 private static Semaphore m_maxNumberAcceptedClients;//最大连接锁 private static int m_numConnectedSockets;//连接的Socket数量 private static int m_totalBytesRead;//总的接收字节数 private static Socket listenSocket;//监听Socket public static void Run(string m_ip, int m_port, int numConnections, int m_receiveBuffer, int m_sentBuffer) { //初始化 m_numConnections = numConnections; m_receiveBufferSize = m_receiveBuffer; m_sendBufferSize = m_sentBuffer; m_receivebuffer = new byte[m_receiveBufferSize * m_numConnections]; m_freeReceiveIndexPool = new Stack\u003cint\u003e(); m_currentReceiveIndex = 0; m_sendbuffer = new byte[m_sendBufferSize * m_numConnections]; m_freeSendIndexPool = new Stack\u003cint\u003e(); m_currentSendIndex = 0; m_ReadPool = new Stack\u003cSocketAsyncEventArgs\u003e(m_numConnections); m_WritePool = new Stack\u003cSocketAsyncEventArgs\u003e(m_numConnections); m_maxNumberAcceptedClients = new Semaphore(m_numConnections, m_numConnections); m_numConnectedSockets = 0; m_totalBytesRead = 0; //接收缓存分配 for (int i = 0; i \u003c m_numConnections; i++) { var readEventArg = new SocketAsyncEventArgs(); readEventArg.Completed += new EventHandler\u003cSocketAsyncEventArgs\u003e(ReadWriteIOComleted); readEventArg.UserToken = new AsyncUserToken(); if (m_freeReceiveIndexPool.Count \u003e 0) { readEventArg.SetBuffer(m_receivebuffer, m_freeReceiveIndexPool.Pop(), m_receiveBufferSize); } else { if ((m_receiveBufferSize * m_numConnections - m_receiveBufferSize) \u003c m_currentReceiveIndex) { new ArgumentException(\"接收缓存设置异常\"); } readEventArg.SetBuffer(m_receivebuffer, m_currentReceiveIndex, m_receiveBufferSize); m_currentReceiveIndex += m_receiveBufferSize; } m_ReadPool.Push(readEventArg); //发送缓存分配 var writeEventArg = new SocketAsyncEventArgs(); writeEventArg.Completed += new EventHandler\u003cSocketAsyncEventArgs\u003e(ReadWriteIOComleted); writeEventArg.UserToken = new AsyncUserToken(); if (m_freeSendIndexPool.Count \u003e 0) { writeEventArg.SetBuffer(m_sendbuffer, m_freeSendIndexPool.Pop(), m_sendBufferSize); } else { if ((m_sendBufferSize * m_numConnections - m_sendBufferSize) \u003c m_currentSendIndex) { new ArgumentException(\"发送缓存设置异常\"); } writeEventArg.SetBuffer(m_sendbuffer, m_currentSendIndex, m_sendBufferSize); m_currentSendIndex += m_sendBufferSize; } m_WritePool.Push(writeEventArg); } //设置监听socket listenSocket = new Socket(new IPEndPoint(IPAddress.Parse(m_ip), m_port).AddressFamily, SocketType.Stream, ProtocolType.Tcp); //绑定端口 listenSocket.Bind(new IPEndPoint(IPAddress.Parse(m_ip), m_port)); listenSocket.Listen(100); StartAccept(null); Console.WriteLine(\"Press any key to terminate the server process....\"); Console.ReadKey(); } public static void ReadWriteIOComleted(object sender, SocketAsyncEventArgs e) { switch (e.LastOperation) { case SocketAsyncO","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:5:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"基于任务的异步模式(Task-based Asynchronous Pattern,TAP)\r相对于前几个模型，基于任务的网络模型是比较新的模型，但是性能是最好的，最主要的原因是微软提供了System.Net.Sockets.SocketTaskExtensions封装TAP的异步方法；System.IO.Pipelines管道模型，在 .NET 中执行高性能 I/O 更加容易。该管道可以实现流量控制和反压。PipeScheduler可以进行回调线程控制。PipeReader和PipeWriter封装了对内存数据的直接操作，实现零拷贝得以大大提供业务流的性能。可惜的是应用范围比较小，目前框架只支持2.1, 2.2, 3.0, 3.1, 5, 6, 7 Preview 7，Framework不支持。 private static Pipe pipe; public static Socket Run(string m_ip, int m_port) { //监听Socket var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); var ip = IPAddress.Parse(m_ip); var endpoint = new IPEndPoint(ip, m_port); socket.Bind(endpoint); //绑定端口和IP socket.Listen(200); //允许同时监听的队列 socket.ReceiveTimeout = -1; Task.Run(async () =\u003e { while (true) { var acceptSocket = await socket.AcceptAsync(); //TAP异步接收 if (acceptSocket != null \u0026\u0026 acceptSocket.Connected) { pipe = new Pipe(); var writer = pipe.Writer; var reader = pipe.Reader; var writetaskr = Task.Run(async () =\u003e { while (true) { var memory = writer.GetMemory(1024); try { //TAP 异步读取数据 int bytesRead = await acceptSocket.ReceiveAsync(memory, SocketFlags.None); if (bytesRead == 0) { break; } //告诉 PipeWriter 写入多少数据。 writer.Advance(bytesRead); } catch (Exception e) { break; } //刷新写入 FlushResult result = await writer.FlushAsync(); if (result.IsCompleted) { break; } } // 完成写入 await writer.CompleteAsync(); }).ContinueWith((t) =\u003e { acceptSocket?.Shutdown(SocketShutdown.Both); //acceptSocket?.Disconnect(true); acceptSocket?.Dispose(); acceptSocket = null; }); var readingtask= Task.Run(async() =\u003e { while (true) { try { //从管道中读取 ReadResult result = await reader.ReadAsync(); ReadOnlySequence\u003cbyte\u003e buffer = result.Buffer; while (TryReadLine(ref buffer, out ReadOnlySequence\u003cbyte\u003e line))//解析 { ProcessLine(acceptSocket, line); } //实际读了多少 reader.AdvanceTo(buffer.Start, buffer.End); //是否写已经结束 if (result.IsCompleted) { break; } } catch (Exception e) { break; } } await reader.CompleteAsync(); }).ContinueWith((t) =\u003e { acceptSocket?.Shutdown(SocketShutdown.Both); acceptSocket?.Dispose(); acceptSocket = null; } ); } } }); return socket; } ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:6:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"DotNet基础","content":"总结\r主要讲述在套接字编程中，如何实现异步和复用以提高性能。讲述了异步编程(APM)、基于事件的异步模型(EAP)和基于任务的异步模型(TAP)；复用方面从内存池(ArrayPool)，到自定义构建内存池(利用高速缓存)和完成端口池，再到最新的管道模型，实现零拷贝。 ","date":"2022-10-14","objectID":"/2022/10/dotnetbase1-socket/:7:0","tags":["DotNet基础","Socket"],"title":"DotNet基础 Socket","uri":"/2022/10/dotnetbase1-socket/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 TouchSocket提供插件方式的扩展，这种方式对原框架的耦合较小。用插件基类封装了底层框架中所有的插件扩展接口，插件子类重写对应的接口就可注入相关业务。框架插件的注入和调用通过PluginsManager进行管理。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:1:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"插件架构\r插件接口在框架中的位置可以在TouchSocket 封装和扩展查看，插件基类封装了所有接口。 下图为插件基类。 插件管理负责插件的注入和调用，通过一些扩展方法封装各种插件注入方式。 下图为插件管理： 插件的注入方式比较特别，通过反射方式找到类中所有插件接口并构造PluginMethod封装方法，该封装主要封装了异步方法，调用时会等待异步结果再进行返回。 ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:2:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"重连插件\r当客户端连接断开时，提供自动重连。 通过扩展方法提供注入接口: /// \u003csummary\u003e /// 使用断线重连。 /// \u003cpara\u003e该效果仅客户端在完成首次连接，且为被动断开时有效。\u003c/para\u003e /// \u003c/summary\u003e /// \u003cparam name=\"pluginsManager\"\u003e\u003c/param\u003e /// \u003cparam name=\"successCallback\"\u003e成功回调函数\u003c/param\u003e /// \u003cparam name=\"tryCount\"\u003e尝试重连次数，设为-1时则永远尝试连接\u003c/param\u003e /// \u003cparam name=\"printLog\"\u003e是否输出日志。\u003c/param\u003e /// \u003cparam name=\"sleepTime\"\u003e失败时，停留时间\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static IPluginsManager UseReconnection(this IPluginsManager pluginsManager, int tryCount = 10, bool printLog = false, int sleepTime = 1000, Action\u003cITcpClient\u003e successCallback = null) { var reconnectionPlugin = new ReconnectionPlugin\u003cITcpClient\u003e(client=\u003e { int tryT = tryCount; while (tryCount \u003c 0 || tryT-- \u003e 0) { try { if (client.Online) { return true; } else { client.Connect(); } successCallback?.Invoke(client); return true; } catch (Exception ex) { if (printLog) { client.Logger.Debug(LogType.Error, client, \"断线重连失败。\", ex); } Thread.Sleep(sleepTime); } } return true; }); pluginsManager.Add(reconnectionPlugin); return pluginsManager; } ReconnectionPlugin继承TcpPluginBase，并重写OnDisconnected方法。通过Task.Run异步执行。 /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"client\"\u003e\u003c/param\u003e /// \u003cparam name=\"e\"\u003e\u003c/param\u003e protected override void OnDisconnected(ITcpClientBase client, ClientDisconnectedEventArgs e) { base.OnDisconnected(client, e); if (client is ITcpClient tcpClient) { if (e.Manual) { return; } Task.Run(() =\u003e { while (true) { try { if (this.m_tryCon.Invoke((TClient)tcpClient)) { break; } } catch { } } }); } } 框架调用： 通过PluginsManager调用插件接口，注意如果e.Handled在重写的方法里置为true，将不会调用Client.DisConnected和Client.OnDisConnected。 private void PrivateOnDisconnected(ClientDisconnectedEventArgs e) { if (this.m_usePlugin) { this.PluginsManager.Raise\u003cITcpPlugin\u003e(\"OnDisconnected\", this, e); if (e.Handled) { return; } } this.OnDisconnected(e); } ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:3:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"扩展插件横切面接口\rHTTPPlugin插件扩展了HTTP协议的相关接口 在HttpSocketClient中重写HandleReceivedData方法调用插件横切面。 /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"byteBlock\"\u003e\u003c/param\u003e /// \u003cparam name=\"requestInfo\"\u003e\u003c/param\u003e protected override void HandleReceivedData(ByteBlock byteBlock, IRequestInfo requestInfo) { if (requestInfo is HttpRequest request) { this.OnReceivedHttpRequest(request); } } /// \u003csummary\u003e /// 当收到到Http请求时。覆盖父类方法将不会触发插件。 /// \u003c/summary\u003e protected virtual void OnReceivedHttpRequest(HttpRequest request) { HttpContextEventArgs args = new HttpContextEventArgs(new HttpContext(request)); switch (request.Method) { case TouchSocketHttpUtility.Get: { this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnGet\", this, args); break; } case TouchSocketHttpUtility.Post: { this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnPost\", this, args); break; } case TouchSocketHttpUtility.Put: { this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnPut\", this, args); break; } case TouchSocketHttpUtility.Delete: { this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnDelete\", this, args); break; } default: this.PluginsManager.Raise\u003cIHttpPlugin\u003e(\"OnReceivedOtherHttpRequest\", this, args); break; } } ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:4:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"总结\r介绍了TouchSocket插件扩展，包括插件架构，利用重写默认的TcpPluginBase的方法实现业务注入；扩展插件横切面接口，这需要重写ClientBase的相关方法实现。 ","date":"2022-09-17","objectID":"/2022/09/touchsocket7-plugs/:5:0","tags":["TouchSocket0.3.5","插件"],"title":"TouchSocket 插件","uri":"/2022/09/touchsocket7-plugs/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 TouchSocket的底层使用完成端口模型，基于事件的异步模式。关于完成端口模型的基础知识可以看Socket基础 。结合上篇横切面扩展(TouchSocket 封装和扩展)可以实现各种业务需求。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:1:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"Accept\r在TcpServer类中BeginListen方法，一个监听者用一个SocketAsyncEventArgs foreach (var networkMonitor in this.m_monitors) { SocketAsyncEventArgs e = new SocketAsyncEventArgs(); e.UserToken = networkMonitor.Socket; e.Completed += this.Args_Completed; if (!networkMonitor.Socket.AcceptAsync(e)) { this.OnAccepted(e); } } ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:2:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"Receive\r在SocketClient的BeginReceive方法中，缓存区使用了内存池进行复用，该内存池的细节可以看TouchSocket 字节池和待处理池，注意在处理完缓冲区后再HandleBuffer的finally中调用byteBlock的Dispose方法，将缓存区返回内存池，如果m_holding被设置为true，则由GC自己回收。 internal void BeginReceive(ReceiveType receiveType) { if (receiveType == ReceiveType.Auto) { SocketAsyncEventArgs eventArgs = new SocketAsyncEventArgs(); eventArgs.Completed += this.EventArgs_Completed; ByteBlock byteBlock = BytePool.GetByteBlock(this.BufferLength);//内存池获取缓冲区 eventArgs.UserToken = byteBlock; eventArgs.SetBuffer(byteBlock.Buffer, 0, byteBlock.Capacity); if (!this.m_mainSocket.ReceiveAsync(eventArgs)) { this.ProcessReceived(eventArgs); } } } private void HandleBuffer(ByteBlock byteBlock) { try { if (this.ClearType.HasFlag(ClearType.Receive)) { this.m_lastTick = DateTime.Now.Ticks; } if (this.OnHandleRawBuffer?.Invoke(byteBlock) == false) { return; } if (this.UsePlugin \u0026\u0026 this.PluginsManager.Raise\u003cITcpPlugin\u003e(\"OnReceivingData\", this, new ByteBlockEventArgs(byteBlock))) { return; } if (this.m_disposedValue) { return; } if (this.m_adapter == null) { this.Logger.Debug(LogType.Error, this, ResType.NullDataAdapter.GetDescription()); return; } this.m_adapter.ReceivedInput(byteBlock); } catch (System.Exception ex) { this.Logger.Debug(LogType.Error, this, \"在处理数据时发生错误\", ex); } finally { byteBlock.Dispose();//内存池回收 } } ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:3:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"Send\rSocketClient的SocketSend方法中使用Send同步方法发送，如果异步使用异步编程模式的BeginSend方法。 protected void SocketSend(byte[] buffer, int offset, int length, bool isAsync) { if (!this.m_online) { throw new NotConnectedException(ResType.NotConnected.GetDescription()); } if (this.HandleSendingData(buffer, offset, length)) { lock (this.m_sendLocker) { if (this.UseSsl) { this.m_workStream.Write(buffer, offset, length); } else { if (isAsync) { this.m_mainSocket.BeginSend(buffer, offset, length, SocketFlags.None, null, null); } else { while (length \u003e 0) { int r = this.m_mainSocket.Send(buffer, offset, length, SocketFlags.None); if (r == 0 \u0026\u0026 length \u003e 0) { throw new Exception(\"发送数据不完全\"); } offset += r; length -= r; } } } } if (this.ClearType.HasFlag(ClearType.Send)) { this.m_lastTick = DateTime.Now.Ticks; } } } ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:4:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"Connect\r在TcpClient的Connect方法中，使用异步编程模式的BeginConnect和EndConnect方法 /// \u003csummary\u003e /// 请求连接到服务器。 /// \u003c/summary\u003e public virtual ITcpClient Connect(int timeout = 5000) { if (this.m_online) { return this; } if (this.m_disposedValue) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_config == null) { throw new ArgumentNullException(\"配置文件不能为空。\"); } IPHost iPHost = this.m_config.GetValue\u003cIPHost\u003e(TouchSocketConfigExtension.RemoteIPHostProperty); if (iPHost == null) { throw new ArgumentNullException(\"iPHost不能为空。\"); } if (this.m_mainSocket != null) { this.m_mainSocket.Dispose(); } this.m_mainSocket = this.CreateSocket(iPHost); ClientConnectingEventArgs args = new ClientConnectingEventArgs(this.m_mainSocket); this.PrivateOnConnecting(args); var result = this.m_mainSocket.BeginConnect(iPHost.EndPoint, null, null);//APM if (result.AsyncWaitHandle.WaitOne(timeout)) { if (this.m_mainSocket.Connected) { this.m_mainSocket.EndConnect(result);//APM this.LoadSocketAndReadIpPort(); if (this.m_separateThreadSend) { this.m_asyncSender.SafeDispose(); this.m_asyncSender = new AsyncSender(this.m_mainSocket, this.m_mainSocket.RemoteEndPoint, this.OnSeparateThreadSendError); } this.BeginReceive(); this.m_online = true; this.PrivateOnConnected(new MsgEventArgs(\"连接成功\")); return this; } } this.m_mainSocket.Dispose(); throw new TimeoutException(); } ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:5:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"总结\r本篇讲述底层Socket实现，使用完成端口模型和内存池提高Socket性能。 ","date":"2022-09-16","objectID":"/2022/09/touchsocket6-socket/:6:0","tags":["TouchSocket0.3.5","Socket基础"],"title":"TouchSocket Socket基础","uri":"/2022/09/touchsocket6-socket/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 Socket模型中需要考虑对各种方法的封装，需要考虑对各种业务场景的扩展，在实现业务流的同时，针对业务流的各个横切面做扩展，甚至业务流本身可以被替换。常用的扩展方式有下面几种，并按耦合从高到低的顺序：继承/泛型，接口/委托/事件，插件/扩展方法。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-15","objectID":"/2022/09/touchsocket5-encapsulationextension/:1:0","tags":["TouchSocket0.3.5","封装和扩展"],"title":"TouchSocket 封装和扩展","uri":"/2022/09/touchsocket5-encapsulationextension/"},{"categories":"TouchSocket0.3.5","content":"Socket\rSocket模型如下图： TouchSocket封装。客户端所有接口封装成TCPClient；服务端将通讯部分桥接给SocketClient，外部接口封装成TCPServer，并通过泛型将SocketClient的类型传入；数据包封装成XXHandlingAdapter；参数设置TouchSocketConfig 可扩展的横切面，横切面主要有：虚方法用于继承重写，事件委托用于订阅，插件扩展方法用于插件扩展。 服务端： 客户端： ","date":"2022-09-15","objectID":"/2022/09/touchsocket5-encapsulationextension/:2:0","tags":["TouchSocket0.3.5","封装和扩展"],"title":"TouchSocket 封装和扩展","uri":"/2022/09/touchsocket5-encapsulationextension/"},{"categories":"TouchSocket0.3.5","content":"总结\r服务端封装成TCPServer,SocketClient；客户端封装成TCPClient，将通讯包封装成XXHandlingAdapter，参数设置封装TouchSocketConfig。 通过扩展方法/插件，事件/委托，虚方法提供横切面的扩展。 ","date":"2022-09-15","objectID":"/2022/09/touchsocket5-encapsulationextension/:3:0","tags":["TouchSocket0.3.5","封装和扩展"],"title":"TouchSocket 封装和扩展","uri":"/2022/09/touchsocket5-encapsulationextension/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 读写文件是应用中必不可少的操作，也是比较经典的问题。该问题一般要求： 允许多个读者对文件执行读操作。 只允许一个写者往文件中写信息。 任一写者写完前不允许其他读者或写者工作。 写者执行写操作前应让已有读者和写者全部退出。 实现要求的逻辑代码: //声明 Semaphore rwlock=1;//读写锁 int rcount=0;//读者数量 Semaphore countlock=1;//读者数量锁 Semaphore firstwlock=1;//写优先锁 //写逻辑 Write() { while(1) { firstwlock.WaitOne(); rwlock.WaitOne(); //Todo:写文件 rwlock.Set(); firstwlock.Set(); } } //读逻辑 Reader() { while(1) { firstwlock.WaitOne(); countlock.WaitOne(); if(rcount==0) rwlock.WaitOne(); rcount++; countlock.Set(); firstwlock.Set(); //Todo:读文件 countlock.WaitOne(); rcount--; if(rcount==0) rwlock.Set(); countlock.Set(); } } 下面看一下TouchSocket文件池解析: 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-14","objectID":"/2022/09/touchsocket4-filepool/:1:0","tags":["TouchSocket0.3.5","文件池"],"title":"TouchSocket 文件池","uri":"/2022/09/touchsocket4-filepool/"},{"categories":"TouchSocket0.3.5","content":"文件池FilePool\r池的作用是复用文件池中对于大文件缓存了文件句柄，对于小文件缓存了文件内容。这样多次对文件的操作就不需要频繁创建和销毁文件句柄。提高文件操作性能。 对于缓存元数据的封装为FileStorage，也是真正对文件操作的实现类。FilePool保存其字典进行复用。 为了便于对FileStorage的操作，将读写操作封装成FileStorageReader和FileStorageWriter 在写入文件时为了保存的实时写入状态，封装了TouchRpcFileStream，并将状态信息封装成TouchRpcFileInfo。 FilePool和FileStorage类中相关操作全部加锁以保证线程安全，并通过原子操作保证FileStorage引用数量 相关类图： 读写模式的互斥通过状态保证: /// \u003csummary\u003e /// 加载文件为读取流 /// \u003c/summary\u003e /// \u003cparam name=\"path\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static void LoadFileForRead(string path) { lock (m_locker) { if (string.IsNullOrEmpty(path)) { throw new System.ArgumentException($\"“{nameof(path)}”不能为 null 或空。\", nameof(path)); } path = Path.GetFullPath(path); if (pathStream.TryGetValue(path, out FileStorage storage)) { if (storage.Access != FileAccess.Read) { throw new Exception(\"该路径的文件已经被加载为写入模式。\"); } return; } if (FileStorage.TryCreateFileStorage(path, FileAccess.Read, out FileStorage fileStorage, out string msg)) { pathStream.TryAdd(path, fileStorage); } else { throw new Exception(msg); } } } 读写操作： /// \u003csummary\u003e /// 从指定位置，读取数据到缓存区。线程安全。 /// \u003c/summary\u003e /// \u003cparam name=\"stratPos\"\u003e\u003c/param\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"length\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public int Read(long stratPos, byte[] buffer, int offset, int length) { using (WriteLock writeLock = new WriteLock(this.m_lockSlim)) { if (this.m_disposedValue) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_fileAccess != FileAccess.Read) { throw new Exception(\"该流不允许读取。\"); } if (this.m_cache) { int r = (int)Math.Min(this.m_fileData.Length - stratPos, length); Array.Copy(this.m_fileData, stratPos, buffer, offset, r); return r; } else { this.m_fileStream.Position = stratPos; return this.m_fileStream.Read(buffer, offset, length); } } } /// \u003csummary\u003e /// 从指定位置，写入数据到存储区。线程安全。 /// \u003c/summary\u003e /// \u003cparam name=\"stratPos\"\u003e\u003c/param\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"length\"\u003e\u003c/param\u003e public void Write(long stratPos, byte[] buffer, int offset, int length) { using (WriteLock writeLock = new WriteLock(this.m_lockSlim)) { if (this.m_disposedValue) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_fileAccess != FileAccess.Write) { throw new Exception(\"该流不允许写入。\"); } this.m_fileStream.Position = stratPos; this.m_fileStream.Write(buffer, offset, length); this.m_fileStream.Flush(); } } ","date":"2022-09-14","objectID":"/2022/09/touchsocket4-filepool/:2:0","tags":["TouchSocket0.3.5","文件池"],"title":"TouchSocket 文件池","uri":"/2022/09/touchsocket4-filepool/"},{"categories":"TouchSocket0.3.5","content":"总结\r讲述了经典的读写问题，介绍了TouchSocket中FilePool的封装，该封装并不复杂，但我觉得一个简单且功能强大的设计才是一个优秀的设计。 ","date":"2022-09-14","objectID":"/2022/09/touchsocket4-filepool/:3:0","tags":["TouchSocket0.3.5","文件池"],"title":"TouchSocket 文件池","uri":"/2022/09/touchsocket4-filepool/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 池是高性能组件中必不可少的东西，池最主要的功能是复用，在软件中创建和销毁对象是有成本的，消耗的资源也特别多。在需要大量使用相同或相似对象的场景下使用池，需要使用对象时去池中取，用完之后再放回到池中，避免创建和销毁对象，从而提高软件的性能。 池在设计时要注意以下几点： 池中对象的存储尽量利用高速缓冲区，这样可以更快速访问对象。 池中对象可以用原型模式加以改造。 池中对象的使用需要注意内存泄漏问题。因为对象使用完并没有销毁。 TouchSocket用到很多的池，字节池 (BytePool)、等待处理池(WaitHandlePool)、文件池(FilePool)、对象池(ObjectPool)，本文介绍字节池和等待处理池 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:1:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"字节池BytePool\r字节数组的复用是非常常见的做法，在高速IO中一定可以看见它的身影，微软对其也进行了各种封装。 TouchSocket字节池保存所有创建的字节数组，并根据数组的长度将其放在字典中等待复用，相同长度的数组通过队列进行缓存，最终字节此的样子 private static readonly ConcurrentDictionary\u003clong, BytesQueue\u003e bytesDictionary = new ConcurrentDictionary\u003clong, BytesQueue\u003e(); long:表示数组长度 BytesQueue:表示该长度数组队列。内部就是private readonly ConcurrentQueue\u003cbyte[]\u003e bytesQueue = new ConcurrentQueue\u003cbyte[]\u003e(); 字节池并没有直接对外暴露字节数组，而是将其封装成ByteBlock，字节数组的装饰对象：ByteBlock，内部使用字节数组实现功能，并装饰Stream的对象。 写入数据可以自动扩容，扩容基数1.5倍。 m_needDis控制Dispose时字节数组是否返回给池中 /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e /// \u003cparam name=\"byteSize\"\u003e默认64K\u003c/param\u003e /// \u003cparam name=\"equalSize\"\u003e默认false\u003c/param\u003e public ByteBlock(int byteSize = 1024 * 64, bool equalSize = false) { this.m_needDis = true; this.m_buffer = BytePool.GetByteCore(byteSize, equalSize); this.m_using = true; } /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e /// \u003cparam name=\"bytes\"\u003e\u003c/param\u003e public ByteBlock(byte[] bytes) { this.m_buffer = bytes ?? throw new ArgumentNullException(nameof(bytes)); this.m_length = bytes.Length; this.m_using = true; } /// \u003csummary\u003e /// 扩容增长比，默认为1.5， /// min：1.5 /// \u003c/summary\u003e public static float Ratio { get =\u003e m_ratio; set { if (value \u003c 1.5) { value = 1.5f; } m_ratio = value; } } /// \u003csummary\u003e /// 读取数据，然后递增Pos /// \u003c/summary\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"length\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e /// \u003cexception cref=\"ObjectDisposedException\"\u003e\u003c/exception\u003e public override int Read(byte[] buffer, int offset, int length) { if (!this.m_using) { throw new ObjectDisposedException(this.GetType().FullName); } int len = this.m_length - this.m_position \u003e length ? length : this.CanReadLen; Array.Copy(this.m_buffer, this.m_position, buffer, offset, len); this.m_position += len; return len; } /// \u003csummary\u003e /// 写入 /// \u003c/summary\u003e /// \u003cparam name=\"buffer\"\u003e\u003c/param\u003e /// \u003cparam name=\"offset\"\u003e\u003c/param\u003e /// \u003cparam name=\"count\"\u003e\u003c/param\u003e /// \u003cexception cref=\"ObjectDisposedException\"\u003e\u003c/exception\u003e public override void Write(byte[] buffer, int offset, int count) { if (count == 0) { return; } if (!this.m_using) { throw new ObjectDisposedException(this.GetType().FullName); } if (this.m_buffer.Length - this.m_position \u003c count) { int need = this.m_buffer.Length + count - ((int)(this.m_buffer.Length - this.m_position)); int lend = this.m_buffer.Length; while (need \u003e lend) { lend = (int)(lend * m_ratio); } this.SetCapacity(lend, true); } Array.Copy(buffer, offset, this.m_buffer, this.m_position, count); this.m_position += count; this.m_length = Math.Max(this.m_position, this.m_length); } /// \u003csummary\u003e /// 重新设置容量 /// \u003c/summary\u003e /// \u003cparam name=\"size\"\u003e新尺寸\u003c/param\u003e /// \u003cparam name=\"retainedData\"\u003e是否保留元数据\u003c/param\u003e /// \u003cexception cref=\"ObjectDisposedException\"\u003e\u003c/exception\u003e public void SetCapacity(int size, bool retainedData = false) { if (!this.m_using) { throw new ObjectDisposedException(this.GetType().FullName); } byte[] bytes = new byte[size]; if (retainedData) { Array.Copy(this.m_buffer, 0, bytes, 0, this.m_buffer.Length); } BytePool.Recycle(this.m_buffer); this.m_buffer = bytes; } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"disposing\"\u003e\u003c/param\u003e protected sealed override void Dispose(bool disposing) { if (this.m_holding) { return; } if (this.m_needDis) { if (Interlocked.Decrement(ref this.m_dis) == 0) { GC.SuppressFinalize(this); BytePool.Recycle(this.m_buffer); this.Dis(); } } base.Dispose(disposing); } 该字节池具有如下特性 每隔1小时自动清理所有缓存的字节数组 最大缓存的不同字节数组的数量为100 回收的数组可以设置是否清零 缓存的最大字节数512M 缓存字节数组的范围1KB~20M 自动清理功能，每1个小时会自动清理池中所有的字节数组 static BytePool() { m_timer = new Timer((o) =\u003e { BytePool.Clear(); }, null, 1000 * 60 * 60, 1000 * 60 * 60);//1小时 m_keyCapacity = 100; m_autoZero = false; m_maxSize = 1024 * 1024 * 512;//512M SetBlockSize(1024, 1024 * 1024 * 20);//1KB~ 20M AddSizeKey(10240);//10KB } /// \u003csummary\u003e /// 清理 /// \u003c/summary\u003e public static void Clear() { bytesDictionary.Clear(); GC.Collect(); } /// \u003csummary\u003e /// 获取内存核心。获取的核心可以不用归还。 /// \u003c/summary\u003e /// \u003cparam name=\"byteSize\"\u003e\u003c/param\u003e /// \u003cparam na","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:2:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"等待处理池WaitHandlePool\u003cT\u003e\r该池的主要是为了复用WaitData\u003cT\u003e对象，该对象的功能是：交由外部系统处理对象并返回数据。当给外部系统发送命令，等待外部系统执行命令，并在规定时间内返回数据。 该功能的传统实现方式是： 创建命令队列，将所有已发送外部系统的命令装进命令队列中，同时记录命令的发送时间； 当外部系统返回数据时，去队列中找到对应的命令执行命令成功的方法；如果命令队列中没有对应的命令，调用未知数据处理方法； 设置定时器定期扫描命令队列，将超期没有接收到返回数据的命令移除，并调用对应命令异常执行方法； 该池的实现方式是构造WaitData\u003cT\u003e对象集合，发送命令前构建WaitData对象，发送完命令后该对象使用信号量阻塞发送命令的线程，当收到返回数据时，信号量置位继续执行，处理对应接收数据；信号量阻塞的时候可以设置阻塞时间，时间到则执行对应异常方法。 由于WaitData对象需要构建信号量，创建和销毁的代价比较大。WaitHandlePool构建 ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e waitQueue;队列保存空闲WaitData。 ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e waitQueue;保存所有已经使用WaitData。 /// \u003csummary\u003e /// 等待数据对象 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public class WaitData\u003cT\u003e : DisposableObject { private WaitDataStatus m_status; private readonly AutoResetEvent m_waitHandle; private T m_waitResult; /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e public WaitData() { this.m_waitHandle = new AutoResetEvent(false); } /// \u003csummary\u003e /// 状态 /// \u003c/summary\u003e public WaitDataStatus Status =\u003e this.m_status; /// \u003csummary\u003e /// 等待数据结果 /// \u003c/summary\u003e public T WaitResult =\u003e this.m_waitResult; /// \u003csummary\u003e /// 取消任务 /// \u003c/summary\u003e public void Cancel() { this.m_status = WaitDataStatus.Canceled; this.m_waitHandle.Set(); } /// \u003csummary\u003e /// 释放 /// \u003c/summary\u003e /// \u003cparam name=\"disposing\"\u003e\u003c/param\u003e protected override void Dispose(bool disposing) { this.m_status = WaitDataStatus.Disposed; this.m_waitResult = default; this.m_waitHandle.Dispose(); base.Dispose(disposing); } /// \u003csummary\u003e /// Reset。 /// 设置\u003csee cref=\"WaitResult\"/\u003e为null。然后重置状态为\u003csee cref=\"WaitDataStatus.Default\"/\u003e，waitHandle.Reset() /// \u003c/summary\u003e public bool Reset() { this.m_status = WaitDataStatus.Default; this.m_waitResult = default; return this.m_waitHandle.Reset(); } /// \u003csummary\u003e /// 使等待的线程继续执行 /// \u003c/summary\u003e public bool Set() { this.m_status = WaitDataStatus.SetRunning; return this.m_waitHandle.Set(); } /// \u003csummary\u003e /// 使等待的线程继续执行 /// \u003c/summary\u003e /// \u003cparam name=\"waitResult\"\u003e等待结果\u003c/param\u003e public bool Set(T waitResult) { this.m_waitResult = waitResult; this.m_status = WaitDataStatus.SetRunning; return this.m_waitHandle.Set(); } /// \u003csummary\u003e /// 加载取消令箭 /// \u003c/summary\u003e /// \u003cparam name=\"cancellationToken\"\u003e\u003c/param\u003e public void SetCancellationToken(CancellationToken cancellationToken) { if (cancellationToken.CanBeCanceled) { cancellationToken.Register(this.Cancel); } } /// \u003csummary\u003e /// 载入结果 /// \u003c/summary\u003e public void SetResult(T result) { this.m_waitResult = result; } /// \u003csummary\u003e /// 等待指定毫秒 /// \u003c/summary\u003e /// \u003cparam name=\"millisecond\"\u003e\u003c/param\u003e public WaitDataStatus Wait(int millisecond) { if (!this.m_waitHandle.WaitOne(millisecond)) { this.m_status = WaitDataStatus.Overtime; } return this.m_status; } } /// \u003csummary\u003e /// 等待处理数据 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public class WaitHandlePool\u003cT\u003e : IDisposable where T : IWaitResult { private readonly SnowflakeIDGenerator idGenerator; private readonly ConcurrentDictionary\u003clong, WaitData\u003cT\u003e\u003e waitDic; private readonly ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e waitQueue; /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e public WaitHandlePool() { this.waitDic = new ConcurrentDictionary\u003clong, WaitData\u003cT\u003e\u003e(); this.waitQueue = new ConcurrentQueue\u003cWaitData\u003cT\u003e\u003e(); this.idGenerator = new SnowflakeIDGenerator(4); } /// \u003csummary\u003e /// 销毁 /// \u003c/summary\u003e /// \u003cparam name=\"waitData\"\u003e\u003c/param\u003e public void Destroy(WaitData\u003cT\u003e waitData) { if (waitData.DisposedValue) { throw new ObjectDisposedException(nameof(waitData)); } if (this.waitDic.TryRemove(waitData.WaitResult.Sign, out _)) { waitData.Reset(); this.waitQueue.Enqueue(waitData); } } /// \u003csummary\u003e /// 释放 /// \u003c/summary\u003e public void Dispose() { foreach (var item in this.waitDic.Values) { item.Dispose(); } foreach (var item in this.waitQueue) { item.Dispose(); } this.waitDic.Clear(); this.waitQueue.Clear(); } /// \u003csummary\u003e /// 获取一个可等待对象 /// \u003c/summary\u003e /// \u003cparam name=\"result\"\u003e\u003c/param\u003e /// \u003cparam name=\"autoSign\"\u003e设置为false时，不会生成sign\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public WaitData\u003cT\u003e GetWaitData(T result, bool autoSign = true) { WaitData\u003cT\u003e waitData; if (this.waitQ","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:3:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"总结\r主要介绍了字节池和等待处理池，详细介绍了相关特性和业务功能的实现。对于等待处理池我觉得还可以使用TaskCompletionSource\u003cTResult\u003e来实现，消耗比信号量更小，同时是异步执行，不会阻塞线程。 ","date":"2022-09-10","objectID":"/2022/09/touchsocket3-bytespoolwaithandlepool/:4:0","tags":["TouchSocket0.3.5","字节池和待处理池"],"title":"TouchSocket 字节池和待处理池","uri":"/2022/09/touchsocket3-bytespoolwaithandlepool/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 容器现在已经成为各种组件的标配了，为什么容器这么火，确实是太好用了。 表面上容器解决的是耦合问题，实际上容器实现了框架对流程的控制。 表面的耦合问题：没有容器，高层逻辑想要实现某个具体功能，只能依赖某个具体类或者具体工厂。当变化越来越多，改动越来越大，具体类之间依赖关系就像麻绳。里氏替换和依赖倒置根本无法实现。容器的出现将所有的具体类都保存在容器中，实现依赖倒置和里氏替换，系统高层和底层实现解耦。 框架对流程的控制问题：框架实现了整个应用流程的编排，流程中肯定需要具体的执行类。一旦依赖某个执行类就无法应对变化，具体类和流程严重耦合。整个框架就像被焊死，无法应对任何变化。容器就像是活页，连接着具体类和框架流程，当具体类发生变化，对框架没有任何影响，这也就使得框架的应用范围更广，实现的功能更多，框架中任何部件都是可以改变的。 唯一不变的就是改变，如果没有改变，也就不需要任何模式了。我们痛恨变化，同时也热爱变化，在痛苦中追求无限可能。 言归正传，TouchSocket框架实现了一个简易版的依赖注入容器。一起来看一下。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index ","date":"2022-09-09","objectID":"/2022/09/touchsocket2-dependencyinjection/:1:0","tags":["TouchSocket0.3.5","依赖注入容器"],"title":"TouchSocket 依赖注入容器","uri":"/2022/09/touchsocket2-dependencyinjection/"},{"categories":"TouchSocket0.3.5","content":"依赖注入\r简单点，容器其实就是一个字典，一个包含一个key和具体类的字典，将框架中所有依赖具体类的地方换成key，当执行到key的时候去字典中根据key取出具体类就可以了。 当然字典也需要生成，就是在应用开始的时候根据需求构建出字典。以后即使变化，也只变化开始构建的部分，最大程度减少修改。 真正的容器就是将字典改造一下，既然由容器管理，就应该负责到底，管理具体类的生命周期，什么时候创建，什么时候销毁，怎么创建。 首先字典中的具体类需要改造一下，变成描述类。 生命周期分为:单例，瞬态，域。 /// \u003csummary\u003e /// 注入依赖对象 /// \u003c/summary\u003e public class DependencyDescriptor { /// \u003csummary\u003e /// 初始化一个单例实例。 /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"instance\"\u003e\u003c/param\u003e public DependencyDescriptor(Type fromType, object instance) { this.FromType = fromType; this.ToInstance = instance; this.Lifetime = Lifetime.Singleton; this.ToType = instance.GetType(); } /// \u003csummary\u003e /// 初始化一个完整的服务注册 /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"toType\"\u003e\u003c/param\u003e /// \u003cparam name=\"lifetime\"\u003e\u003c/param\u003e public DependencyDescriptor(Type fromType, Type toType, Lifetime lifetime) { this.FromType = fromType; this.Lifetime = lifetime; this.ToType = toType; } /// \u003csummary\u003e /// 实例类型 /// \u003c/summary\u003e public Type ToType { get; } /// \u003csummary\u003e /// 实例 /// \u003c/summary\u003e public object ToInstance { get; set; } /// \u003csummary\u003e /// 生命周期 /// \u003c/summary\u003e public Lifetime Lifetime { get; } /// \u003csummary\u003e /// 注册类型 /// \u003c/summary\u003e public Type FromType { get; } } /// \u003csummary\u003e /// 注入项的生命周期。 /// \u003c/summary\u003e public enum Lifetime { /// \u003csummary\u003e /// 单例对象 /// \u003c/summary\u003e Singleton, /// \u003csummary\u003e /// 以\u003csee cref=\"IScopedContainer\"/\u003e接口为区域实例单例。 /// \u003c/summary\u003e Scoped, /// \u003csummary\u003e /// 瞬时对象 /// \u003c/summary\u003e Transient } 字典中的key改成FromType+Name。 最终字典变成了 private readonly ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e registrations = new ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e();这样。 看一下怎么实现注入和解析的。下面是原代码，Resolve方法根据生命周期实现解析逻辑；Create方法负责创建，同时各种注入方式；Register实现构建字典。 该容器有一些特点： 在注入容器时，提供了一个Name，key被构建成FromType+Name。这样的好处是可以根据Name来获取具体类。 同时对于多态的问题，同一个接口的多个实现没有实现注入，只能通过Name来区别了。 如果FromType不是抽象类，不需要注入，也可以Resolve出来。 Resolve会根据所有构造函数参数的个数最多的那个构造函数。 可以使用DependencyInject，DependencyParamterInject特性进行控制。 实现了构造函数注入，属性注入和方法注入 /// \u003csummary\u003e /// IOC容器 /// \u003c/summary\u003e public class Container : IContainer { private readonly ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e registrations = new ConcurrentDictionary\u003cstring, DependencyDescriptor\u003e(); /// \u003csummary\u003e /// 初始化一个IOC容器 /// \u003c/summary\u003e public Container() { this.RegisterSingleton\u003cIContainer\u003e(this); } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public bool IsRegistered(Type fromType, string key = \"\") { return this.registrations.ContainsKey($\"{fromType.FullName}{key}\"); } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"descriptor\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e public void Register(DependencyDescriptor descriptor, string key = \"\") { string k = $\"{descriptor.FromType.FullName}{key}\"; this.registrations.AddOrUpdate(k, descriptor, (k, v) =\u003e { return descriptor; }); } /// \u003csummary\u003e /// \u003cinheritdoc/\u003e /// \u003c/summary\u003e /// \u003cparam name=\"fromType\"\u003e\u003c/param\u003e /// \u003cparam name=\"ps\"\u003e\u003c/param\u003e /// \u003cparam name=\"key\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public object Resolve(Type fromType, object[] ps = null, string key = \"\") { if (fromType == typeof(IScopedContainer)) { return this.GetScopedContainer(); } string k; DependencyDescriptor descriptor; if (fromType.IsGenericType) { Type type = fromType.GetGenericTypeDefinition(); k = $\"{type.FullName}{key}\"; if (this.registrations.TryGetValue(k, out descriptor)) { if (descriptor.Lifetime == Lifetime.Singleton) { if (descriptor.ToInstance != null) { return descriptor.ToInstance; } lock (descriptor) { if (descriptor.ToInstance != null) { return descriptor.ToInstance; } if (descriptor.ToType.IsGenericType) { return descriptor.ToInstance = this.Create(descriptor.ToType.MakeGenericType(fromType.GetGenericArguments()), ps); } else { return descriptor.ToInstance = this.Create(descriptor.ToType, ps); } } } if (descriptor.ToType.IsGenericType) { return this.Create(descriptor.ToType.MakeGenericType(fromType.GetGenericArguments()), ps); } el","date":"2022-09-09","objectID":"/2022/09/touchsocket2-dependencyinjection/:2:0","tags":["TouchSocket0.3.5","依赖注入容器"],"title":"TouchSocket 依赖注入容器","uri":"/2022/09/touchsocket2-dependencyinjection/"},{"categories":"TouchSocket0.3.5","content":"总结\r该容器虽然简单，但是足够使用，小巧紧致，非常值得学习。不需要注入直接解析对象的方式，虽然有点违反依赖倒置原则，但是在使用中确实是一个非常实用的功能。有一点缺陷是没有实现Dispose和瞬态对象的弱引用，当域生命周期结束的时候，Dispose容器同时销毁所有域创建出的瞬态对象。 ","date":"2022-09-09","objectID":"/2022/09/touchsocket2-dependencyinjection/:3:0","tags":["TouchSocket0.3.5","依赖注入容器"],"title":"TouchSocket 依赖注入容器","uri":"/2022/09/touchsocket2-dependencyinjection/"},{"categories":"TouchSocket0.3.5","content":"概述\r注意：该版本为TouchSocket 0.3.5,最新版已有较大改动。 该框架实现了广泛的Socket应用，NAT，各种RPC，文件传输，WebAPI，WebSocket，非常优秀的框架，学习一下，有问题可以相互探讨。 框架地址：https://github.com/RRQM/TouchSocket 文档地址：https://www.yuque.com/rrqm/touchsocket/index 本章主要介绍TouchSocket的主要特性之一：依赖属性 ","date":"2022-09-07","objectID":"/2022/09/touchsocket1-dependencyproperties/:1:0","tags":["TouchSocket0.3.5","依赖属性"],"title":"TouchSocket 依赖属性","uri":"/2022/09/touchsocket1-dependencyproperties/"},{"categories":"TouchSocket0.3.5","content":"依赖属性\r用过WPF都知道依赖属性，其是绑定，动画，样式的基础，提供了属性值，更改通知等功能，该框架中的依赖属性相当于简易版本，提供了应用的思路。 依赖属性可以看成是Key和Value的封装。依赖属性类：名称，所属类型，值类型和值，还包含了一个工厂方法，用来创建依赖属性，创建时可以提供初始值。 /// \u003csummary\u003e /// 依赖项属性 /// \u003c/summary\u003e [DebuggerDisplay(\"Name={Name},Type={ValueType}\")] public class DependencyProperty { /// \u003csummary\u003e /// 属性名称 /// \u003c/summary\u003e protected string m_name; /// \u003csummary\u003e /// 所属类型 /// \u003c/summary\u003e protected Type m_owner; /// \u003csummary\u003e /// 值类型 /// \u003c/summary\u003e protected Type m_valueType; private object m_value; /// \u003csummary\u003e /// 依赖项属性 /// \u003c/summary\u003e private DependencyProperty() { } /// \u003csummary\u003e /// 默认值 /// \u003c/summary\u003e public object DefauleValue =\u003e this.m_value; /// \u003csummary\u003e /// 属性名 /// \u003c/summary\u003e public string Name =\u003e this.m_name; /// \u003csummary\u003e /// 所属类型 /// \u003c/summary\u003e public Type Owner =\u003e this.m_owner; /// \u003csummary\u003e /// 值类型 /// \u003c/summary\u003e public Type ValueType =\u003e this.m_valueType; internal void DataValidation(object value) { if (value == null) { if (typeof(ValueType).IsAssignableFrom(this.m_valueType)) { throw new Exception($\"属性“{this.m_name}”赋值类型不允许出现Null\"); } } else if (!this.m_valueType.IsAssignableFrom(value.GetType())) { throw new Exception($\"属性“{this.m_name}”赋值类型与注册类型不一致，应当注入“{this.m_valueType}”类型\"); } } internal void SetDefauleValue(object value) { this.DataValidation(value); this.m_value = value; } /// \u003csummary\u003e /// 注册依赖项属性。 /// \u003cpara\u003e依赖属性的默认值，可能会应用于所有的\u003csee cref=\"IDependencyObject\"/\u003e\u003c/para\u003e /// \u003c/summary\u003e /// \u003cparam name=\"propertyName\"\u003e\u003c/param\u003e /// \u003cparam name=\"valueType\"\u003e\u003c/param\u003e /// \u003cparam name=\"owner\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e依赖项属性值，一般该值应该是值类型，因为它可能会被用于多个依赖对象。\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static DependencyProperty Register(string propertyName, Type valueType, Type owner, object value) { DependencyProperty dp = new DependencyProperty { m_name = propertyName, m_valueType = valueType, m_owner = owner }; dp.SetDefauleValue(value); return dp; } } 如何管理依赖属性，类中创建依赖属性，并设置和获取依赖属性的值。首先实现接口，可以获取和设置依赖属性的值，实现一个基类，实现该接口，所有包含依赖属性的类继承该基类，就可以实现操作依赖属性了。 该框架做了进一步扩展，在基类中添加了一个依赖属性字典，可以添加外部依赖属性。 也就是在基类中保存了一个Key，Value的字典，通过特定的Key获取到Value，在配置的时候特别有用，配置类Option/Config怎么应对变化，写组件的时候发现配置项多需要添加属性怎么办，修改配置项，违反开放封闭原则；使用继承，显得太重；增加一个配置类，还不如使用继承。 把配置项修改成字典，所有信息通过key,value保存，可以应对开放封闭原则。显然该框架就说这样干的，key是依赖属性，vlaue是依赖属性的值。 /// \u003csummary\u003e /// 依赖对象接口 /// \u003c/summary\u003e public interface IDependencyObject : System.IDisposable { /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e object GetValue(DependencyProperty dp); /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public T GetValue\u003cT\u003e(DependencyProperty dp); /// \u003csummary\u003e /// 设置依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e\u003c/param\u003e public DependencyObject SetValue(DependencyProperty dp, object value); } /// \u003csummary\u003e /// 依赖项对象. /// 线程安全。 /// \u003c/summary\u003e public class DependencyObject : DisposableObject, IDependencyObject, System.IDisposable { /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e public DependencyObject() { this.m_dp = new ConcurrentDictionary\u003cDependencyProperty, object\u003e(); } [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)] private readonly ConcurrentDictionary\u003cDependencyProperty, object\u003e m_dp; /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public object GetValue(DependencyProperty dp) { if (this.m_dp.TryGetValue(dp, out object value)) { return value; } else { return dp.DefauleValue; } } /// \u003csummary\u003e /// 获取依赖注入的值 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public T GetValue\u003cT\u003e(DependencyProperty dp) { try { return (T)this.GetValue(dp); } catch { return default; } } /// \u003csummary\u003e /// 设置依赖注入的值 /// \u003c/summary\u003e /// \u003cparam name=\"dp\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e\u003c/param\u003e public DependencyObject SetValue(DependencyProperty dp, object value) { dp.DataValidation(value); if (this.m_dp.ContainsKey(dp)) { this.m_dp[dp] = value; } els","date":"2022-09-07","objectID":"/2022/09/touchsocket1-dependencyproperties/:2:0","tags":["TouchSocket0.3.5","依赖属性"],"title":"TouchSocket 依赖属性","uri":"/2022/09/touchsocket1-dependencyproperties/"},{"categories":"TouchSocket0.3.5","content":"总结\r依赖属性这样的应用方式非常优秀，满足了扩展开放，单一职责。如果有其他的应用方式欢迎评论。 ","date":"2022-09-07","objectID":"/2022/09/touchsocket1-dependencyproperties/:3:0","tags":["TouchSocket0.3.5","依赖属性"],"title":"TouchSocket 依赖属性","uri":"/2022/09/touchsocket1-dependencyproperties/"},{"categories":"算法","content":"实现队列的一些思路\r数组的优劣： 读取：连续的地址空间，数组全部或者部分元素被连续存在CPU缓存里面，读取速度非常快。 插入/删除/扩容：插入和删除，需要修改该元素之前或之后所有元素的位置，扩容时需要重新找较大的内存块，将原数组中所有数据复制到新内存块中。这些操作都非常耗时。 链表的优劣： 读取：链表的节点分散在堆空间中，无法利用CPU缓存，读写速度比较慢，是数组的33倍 插入/删除/扩容：不需要改变原来元素的位置，仅仅修改节点信息即可。但是频繁的插入删除会导致堆中有大量碎片化内存。 链表每个节点不仅需要保存数据还需要保存下一个节点的位置。 较好的方式是结合数组和链表的优势，用链表节点将固定大小的数组连接起来组成大的内存块，即易于扩展又在一定范围内保持良好的访问速度。 在需要构建内存池，缓存队列等应用场景中均可使用此方法进行优化。 ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:1:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"队列接口\rpublic interface IQueue\u003cTItem\u003e : IEnumerable\u003cTItem\u003e, IDisposable { bool IsEmpty { get; } int Length { get; } void Enqueue(TItem item); TItem Dequeue(); } ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:2:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"基于数组的扩容队列\rpublic class SGResizingArrayQueue\u003cTItem\u003e : IQueue\u003cTItem\u003e { public SGResizingArrayQueue() { _first = 0; _last = 0; _items = new TItem[2]; } public IEnumerator\u003cTItem\u003e GetEnumerator() { if (!IsEmpty) { for (var i = _first; i \u003c _last; i++) { yield return _items[i]; } } } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } public void Dispose() { Dispose(true); } protected virtual void Dispose(bool disposing) { if (disposing) { if (!IsEmpty) { for (var i = _first; i \u003c _last; i++) { _items[i] = default; } _items = null; } } } private TItem[] _items; private int _first; private int _last; public bool IsEmpty =\u003e (_last - _first) == 0; public int Length =\u003e _last - _first; private void resize(int size) { var temitems = new TItem[size]; var temlength = Length; Array.Copy(_items, _first, temitems, 0, Length); _first = 0; _last = temlength; _items = temitems; } public void Enqueue(TItem item) { if (_last == _items.Length) resize(Length * 2); _items[_last++] = item; } public TItem Dequeue() { if (IsEmpty) return default; var item = _items[_first++]; if (Length \u003c _items.Length / 4) resize(_items.Length / 2); return item; } } ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:3:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"基于链表的扩容队列\rpublic class SGLinkedQueue\u003cTItem\u003e : IQueue\u003cTItem\u003e { private Node _first; private Node _last; private int _length; public SGLinkedQueue() { _length = 0; } private class Node { public TItem Item { set; get; } public Node Next { set; get; } } public IEnumerator\u003cTItem\u003e GetEnumerator() { if (!IsEmpty) { var temnode = _first; while (temnode != default) { var item = temnode.Item; temnode = temnode.Next; yield return item; } } } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } public void Dispose() { Dispose(true); } protected virtual void Dispose(bool disposing) { if (disposing) { if (!IsEmpty) { var temfirst = _first; while (temfirst != default) { temfirst.Item = default; temfirst = temfirst.Next; } _length = 0; } } } public bool IsEmpty =\u003e _length == 0; public int Length =\u003e _length; public void Enqueue(TItem item) { var temnode = _last; _last = new Node(); _last.Item = item; _last.Next = null; if (IsEmpty) _first = _last; else temnode.Next = _last; _length++; } public TItem Dequeue() { if (_length \u003e 0) { var temitem = _first.Item; _first = _first.Next; _length--; return temitem; } return default; } } ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:4:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"算法","content":"结合数组和链表的扩容队列\rclass SGArraySegment\u003cTItem\u003e { public TItem[] Array { get; private set; } public SGArraySegment\u003cTItem\u003e Next { get; set; } public int Offset { get; set; } public int End { get; set; } = -1; public SGArraySegment(TItem[] array) { Array = array; } public bool IsAvailable { get { return Array.Length \u003e (End + 1); } } public void Write(TItem value) { Array[++End] = value; } } class SGPipeQueue\u003cTItem\u003e : IValueTaskSource\u003cTItem\u003e, IDisposable { private const int _segmentSize = 5; private SGArraySegment\u003cTItem\u003e _first; private SGArraySegment\u003cTItem\u003e _current; private object _syncRoot = new object(); private static readonly ArrayPool\u003cTItem\u003e _pool = ArrayPool\u003cTItem\u003e.Shared; private ManualResetValueTaskSourceCore\u003cTItem\u003e _taskSourceCore; private bool _waiting = false; private bool _lastReadIsWait = false; private int _length; public SGPipeQueue() { SetBufferSegment(CreateSegment()); _taskSourceCore = new ManualResetValueTaskSourceCore\u003cTItem\u003e(); } SGArraySegment\u003cTItem\u003e CreateSegment() { return new SGArraySegment\u003cTItem\u003e(_pool.Rent(_segmentSize)); } void SetBufferSegment(SGArraySegment\u003cTItem\u003e segment) { if (_first == null) _first = segment; var current = _current; if (current != null) current.Next = segment; _current = segment; } public int Write(TItem target) { lock (_syncRoot) { if (_waiting) { _waiting = false; _taskSourceCore.SetResult(target); return _length; } var current = _current; if (!current.IsAvailable) { current = CreateSegment(); SetBufferSegment(current); } current.Write(target); _length++; return _length; } } public ValueTask\u003cTItem\u003e ReadAsync() { lock (_syncRoot) { if (TryRead(out TItem value)) { if (_lastReadIsWait) { _taskSourceCore.Reset(); _lastReadIsWait = false; } _length--; if (_length == 0) OnWaitTaskStart(); return new ValueTask\u003cTItem\u003e(value); } _waiting = true; _lastReadIsWait = true; _taskSourceCore.Reset(); OnWaitTaskStart(); return new ValueTask\u003cTItem\u003e(this, _taskSourceCore.Version); } } private bool TryRead(out TItem value) { var first = _first; if (first.Offset \u003c first.End) { value = first.Array[first.Offset]; first.Array[first.Offset] = default; first.Offset++; return true; } else if (first.Offset == first.End) { if (first == _current) { value = first.Array[first.Offset]; first.Array[first.Offset] = default; first.Offset = 0; first.End = -1; return true; } else { value = first.Array[first.Offset]; first.Array[first.Offset] = default; _first = first.Next; _pool.Return(first.Array); return true; } } value = default; return false; } protected virtual void OnWaitTaskStart() { } public virtual void Clear() { lock (_syncRoot) { if (_lastReadIsWait) { _taskSourceCore.Reset(); _lastReadIsWait = false; } var first = _first; if (first.Offset \u003c= first.End) { while (first != _current) { for (int i = first.Offset; i \u003c= first.End; i++) { first.Array[i] = default; } _first = first.Next; _pool.Return(first.Array); first = _first; } for (int i = first.Offset; i \u003c= first.End; i++) { first.Array[i] = default; } first.Offset = 0; first.End = -1; } } } public void Dispose() { lock (_syncRoot) { var segment = _first; while (segment != null) { _pool.Return(segment.Array); segment = segment.Next; } _first = null; _current = null; } } TItem IValueTaskSource\u003cTItem\u003e.GetResult(short token) { return _taskSourceCore.GetResult(token); } ValueTaskSourceStatus IValueTaskSource\u003cTItem\u003e.GetStatus(short token) { return _taskSourceCore.GetStatus(token); } void IValueTaskSource\u003cTItem\u003e.OnCompleted(Action\u003cobject?\u003e continuation, object? state, short token, ValueTaskSourceOnCompletedFlags flags) { _taskSourceCore.OnCompleted(continuation, state, token, flags); } } 该队列额外实现2个功能，以提高队列的性能： 异步出队列，当队列为空时，异步等待。 当压入队列时，如果发现有异步等待对象，则不进入队列，直接给等待对象。 ","date":"2022-06-14","objectID":"/2022/06/algorithm1-queuesandlinks/:5:0","tags":["算法","队列","链表"],"title":"算法 队列与链表","uri":"/2022/06/algorithm1-queuesandlinks/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 ","date":"2020-04-08","objectID":"/2020/04/prism22-source/:0:0","tags":["Prism源码解析","RegionContext"],"title":"Prism源码解析 RegionContext","uri":"/2020/04/prism22-source/"},{"categories":"Prism","content":"介绍\r","date":"2020-04-08","objectID":"/2020/04/prism22-source/:1:0","tags":["Prism源码解析","RegionContext"],"title":"Prism源码解析 RegionContext","uri":"/2020/04/prism22-source/"},{"categories":"Prism","content":"0 RegionContext\rPrism为Region构造了一个RegionContext，其功能和DataContext差不多。看看怎么实现的吧 首先声明 在RegionManager中定义一个依赖属性RegionContext, 值改变的时候更新RegionContext中的依赖属性 这个RegionContext就保存一个依赖属性对象实例，这个依赖属性用ObserableObject包装了一下，提供了一个获取实例的方法。 同时注意到这里面有一个关键的地方 view.SetValue(RegionContext.ObservableRegionContextProperty, (object) observableObject); 其实在view中还保存了ObservableRegionContextProperty依赖属性实例。 看一下依赖属性值改变怎么触发的 在Reion的VIew中其实是绑定了RegionContext依赖属性的ValeChanged事件。 看到这我就好奇为啥RegionManager中要有一个依赖属性，看着很多余啊？ 我注意到有一个行为SyncRegionContextWithHostBehavior， 目前还没看出来怎么用。 我注意到Region的行为中有一个BindRegionContextToDependencyObjectBehavior 行为 当Region的View改变时， 这个context是哪里来的呢？在这个行为中 第一次载入的时候，只要View的RegionContext值变化就会将新值给Region.Context。 只要有新的View添加进来就将Region.Context的值给View的RegionContext.ObservableRegionContextProperty依赖属性。 ","date":"2020-04-08","objectID":"/2020/04/prism22-source/:2:0","tags":["Prism源码解析","RegionContext"],"title":"Prism源码解析 RegionContext","uri":"/2020/04/prism22-source/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 ","date":"2020-04-06","objectID":"/2020/04/prism21-source/:0:0","tags":["Prism源码解析","导航"],"title":"Prism源码解析 导航","uri":"/2020/04/prism21-source/"},{"categories":"Prism","content":"介绍\rPrism提供了一个非常强大的功能导航，导航的意思就是指定对应的View显示。这个导航的强大之处有： 可以设置导航前后的动作 可以指定View实例的生命周期，可以是否导航到新的View实例 提供了确认导航接口。 导航前后均有相应的事件通知 提供了回退前进的导航功能 ","date":"2020-04-06","objectID":"/2020/04/prism21-source/:1:0","tags":["Prism源码解析","导航"],"title":"Prism源码解析 导航","uri":"/2020/04/prism21-source/"},{"categories":"Prism","content":"导航\r直接看代码 可以看到直接通过RequstNavigate来请求，参数是View的TypeName 转到了Region.RequestNavigate里 这边出现了NavigationService，几乎所有的导航功能都是在这个服务中实现的， 这边将导航的一些信息封装成NavigationContext, 在这出现了第一个功能，实现ICon’firm’NavigationRequest接口，确认导航。 最后来到了最重要的函数ExecuteNavigation 这个函数每一行都很重要，每一行都是一个功能。 调用OnNavigateFrom,可以在导航前做一些操作 获取导航内容，先从Region的View中找，没找到就到容器中找，然后添加到Region的View。 激活界面 创建条目，保存条目，主要用来进行前进后退 触发导航完成事件。 整个导航功能的顺序： ","date":"2020-04-06","objectID":"/2020/04/prism21-source/:2:0","tags":["Prism源码解析","导航"],"title":"Prism源码解析 导航","uri":"/2020/04/prism21-source/"},{"categories":"Prism","content":"总结\r​ Prism提供的这个导航功能非常强大，但是代码却不复杂，通过一些简单的接口，实现了非常强大的功能。 ","date":"2020-04-06","objectID":"/2020/04/prism21-source/:3:0","tags":["Prism源码解析","导航"],"title":"Prism源码解析 导航","uri":"/2020/04/prism21-source/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 ","date":"2020-04-05","objectID":"/2020/04/prism20-source/:0:0","tags":["Prism源码解析","事件聚合"],"title":"Prism源码解析 事件聚合","uri":"/2020/04/prism20-source/"},{"categories":"Prism","content":"0 介绍\r事件提供的是1对多的绑定，通过委托链实现对订阅者的调用，事件必须要通过发布者调用。同时事件订阅是强引用，事件订阅者的生命周期总是大于等于事件发布者。如果代码中事件很多就会充斥着各种事件的订阅，不利于维护。 Prism提供了EventAggregator器，可以在任何地方进行订阅，任何地方进行调用/发布，实例只对EventAggregator和事件类型有依赖，使用了弱引用，可以过滤消息，并可以控制回调函数线程。感觉很强大，实现应该挺复杂，但看到实现时有一种恍然大悟的感觉，喜欢这种简单而强大的实现。开始一探究竟吧！ ","date":"2020-04-05","objectID":"/2020/04/prism20-source/:1:0","tags":["Prism源码解析","事件聚合"],"title":"Prism源码解析 事件聚合","uri":"/2020/04/prism20-source/"},{"categories":"Prism","content":"1 整体框架\r先从整体框架解析一下吧。EventAggregator 发现这只是一个集合类，保存着事件类型和事件实例，还有一个线程上下文保证线程同步。 看一下EventBase，看来所有的订阅委托都是在着保存着，因为有一个IEventSubscription列表。EventSubscription因该是订阅委托的包装器。 看到有SubscriptionToken和DelegateReference， 这边终于看到Delegate的真正存放地点了。这边存放了弱引用，委托类型和MethodInfo。 看到这边理解了，通过一个集合保存事件，这个事件内部存储着所有订阅委托。 当我们向订阅发布的时候，只要从这个集合中获取对应的事件进行订阅发布。相通了是不是觉得自己也能写一个简单的事件聚合器呢？ ","date":"2020-04-05","objectID":"/2020/04/prism20-source/:2:0","tags":["Prism源码解析","事件聚合"],"title":"Prism源码解析 事件聚合","uri":"/2020/04/prism20-source/"},{"categories":"Prism","content":"2 具体代码\r来具体看看代码吧。 看到EventAggregator通过依赖注入，获取MessageSentEvent进行订阅。 保存了UI线程上下文和将事件类型和事件类型实例放到集合中，加锁，线程安全。 事件可以啥都没有但必须继承PubSubEvent，功能都在这里实现了。 threadOption默认是PublisherTHread，这里是说回调函数在什么线程执行，BackgroundThread就是Task创建的线程池线程，Dispatcher就是UI线程 内部订阅进行了校验（主要是委托不为空）和Token 看完订阅再来看看调用 在任何地方调用，还是去EventAggregator获取事件实例，然后调用其Publish 从这边可以看出就是依次调用列表中的委托，DispatcherEventSubscription 调用 BackgroundEventSubscription 调用 到现在还没有讲到Filter，来看看怎么实现过滤消息 在订阅的时候值接受含有Brian的消息 使用了泛型的订阅 使用了prcidate\u003c\u003e保存了filter委托， 在Publish主要就是在GetExecutionStrategy方法中 filter返回true触发订阅委托。 ","date":"2020-04-05","objectID":"/2020/04/prism20-source/:3:0","tags":["Prism源码解析","事件聚合"],"title":"Prism源码解析 事件聚合","uri":"/2020/04/prism20-source/"},{"categories":"Prism","content":"总结\r事件聚合提供了一个很好的思路，我们甚至可以利用事件聚合的思想实现事件聚合微服务组件。 ","date":"2020-04-05","objectID":"/2020/04/prism20-source/:4:0","tags":["Prism源码解析","事件聚合"],"title":"Prism源码解析 事件聚合","uri":"/2020/04/prism20-source/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 ","date":"2020-04-03","objectID":"/2020/04/prism19-source/:0:0","tags":["Prism源码解析","数据绑定和命令"],"title":"Prism源码解析 数据绑定和命令","uri":"/2020/04/prism19-source/"},{"categories":"Prism","content":"介绍\rWPF本身就支持通知、绑定和命令，实现ViewModel和VIew之间的通讯，但相对来说功能比较少，Prism扩充了这些功能并提供更加强有力，简洁的数据绑定和命令。 ","date":"2020-04-03","objectID":"/2020/04/prism19-source/:1:0","tags":["Prism源码解析","数据绑定和命令"],"title":"Prism源码解析 数据绑定和命令","uri":"/2020/04/prism19-source/"},{"categories":"Prism","content":"0 绑定通知\rWPF的绑定通知需要实现INotifyPropertyChanged接口，也就是实现一个属性改变事件，用来通知UI属性改变了，让UI更新。该事件需要一个事件参数new PropertyChangedEventArgs(propertyName)传入属性的名字，这样的调用方式比较繁琐。 Prism扩充了WPF的绑定通知。提供了BindableBase 实现了 INotifyPropertyChanged接口，并使用CallerMemberName获取属性名字。这样就解决了属性改变事件调用繁琐的问题。同时在内部还是对相等值进行了过滤。 简单愉快的调用吧 只需要使用SetProperty方法就可以自动更新UI了。 值得注意的是OnPropertyChanged还提供了对Expression的支持 也就是主动调用OnPropertyChanged(()=\u003ethis.PropertyName),也可以触发UI响应。 ","date":"2020-04-03","objectID":"/2020/04/prism19-source/:2:0","tags":["Prism源码解析","数据绑定和命令"],"title":"Prism源码解析 数据绑定和命令","uri":"/2020/04/prism19-source/"},{"categories":"Prism","content":"1 命令\r","date":"2020-04-03","objectID":"/2020/04/prism19-source/:3:0","tags":["Prism源码解析","数据绑定和命令"],"title":"Prism源码解析 数据绑定和命令","uri":"/2020/04/prism19-source/"},{"categories":"Prism","content":"DelegateCommand\rWPF命令和通知有点类似，命令需要实现ICommand接口，实现Execute方法，命令状态CanExecute和命令状态改变事件。并且WPF只实现了一个RoutedCommand。Prism提供了一个DelegateCommandBase命令基类实现ICommand，并扩充了子类DelegateCommand，大大简化了命令调用方式 看到在基类中有_synchronizationContext线程同步上下文，用来保证命令执行的时候线程同步。 重点关注一下子类中的几个方法 1.ExecuteDelegateCommand = new DelegateCommand(Execute, CanExecute); 这个命令声明方式，如果命令状态发生变化的时候需要主动调用RaiseCanExecuteChanged方法来触发命令状态改变事件。 2.DelegateCommandObservesProperty = new DelegateCommand(Execute, CanExecute).ObservesProperty(() =\u003e IsEnabled); 可以看到这种声明方式，提供了一个ObservesProperty方法，不需要显示调用命令状态改变事件。 3.DelegateCommandObservesCanExecute = new DelegateCommand(Execute).ObservesCanExecute(() =\u003e IsEnabled); 这种声明方法提供ObservesCanExecute方法，直接观测命令状态改变事件和属性。 ExecuteGenericDelegateCommand = new DelegateCommand(ExecuteGeneric).ObservesCanExecute(() =\u003e IsEnabled); 这是一个使用泛型带参数的声明方式， 看一下内部怎么实现这种简单而强大的功能 通过Expression，内部调用PropertyObserver.Observes()方法并将RaiseCanExecuteChaned方法传入。 在PropertyObserver将Expression保存在一个链表，并每个节点都订阅OnPropertyChanged事件。 ","date":"2020-04-03","objectID":"/2020/04/prism19-source/:3:1","tags":["Prism源码解析","数据绑定和命令"],"title":"Prism源码解析 数据绑定和命令","uri":"/2020/04/prism19-source/"},{"categories":"Prism","content":"CompositeCommand\rPrism还提供了一个CompositeCommand命令 这个命令的功能跟其名字一样，就是复合命令，命令集合。 将DelegateCommand实例放到其中，每当调用CompositeCommand调用的时候会调用它保存的所有命令， 命令集合中任何一个命令状态改变，都会触发CompositeCommand命令状态的改变事件，导致CompositeCommand检查集合中所有的命令状态，首先会检查IActiveAware，再检查命令状态，如果任何一个命令状态是False，都会导致组合命令返回False 来看一下源码 注意到，聚合命令也是通过线程上下文保持线程同步，同时看到有检测IActiveAware接口，这个接口是什么意思呢？其实就是查看该命令是否激活。这个接口有一个激活状态属性和一个激活状态改变事件， 只要界面主动调用UpdateCommand.IsActive = true;命令就会被激活并触发复合命令的激活状态改变回调函数 在复合命令的ShouldExcute方法中检查其激活状态，命令集合中没有激活命令，那么复合命令的执行状态也会改变。 命令执行和激活状态都是差不多的接口，有状态和状态改变事件组成，感觉很多地方都有相似的模式，有点像订阅模式，也有点像状态机，包括一些Collection和Storage. ","date":"2020-04-03","objectID":"/2020/04/prism19-source/:3:2","tags":["Prism源码解析","数据绑定和命令"],"title":"Prism源码解析 数据绑定和命令","uri":"/2020/04/prism19-source/"},{"categories":"Prism","content":"总结\r主要讲了下Prism提供的绑定通知和命令，学习到如何在WPF框架基础上做一些封装，如果可能甚至可以自己重新封装一些功能更强大的命令来兼容Prism。 ","date":"2020-04-03","objectID":"/2020/04/prism19-source/:4:0","tags":["Prism源码解析","数据绑定和命令"],"title":"Prism源码解析 数据绑定和命令","uri":"/2020/04/prism19-source/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 ","date":"2020-04-02","objectID":"/2020/04/prism18-source/:0:0","tags":["Prism源码解析","ViewModel注入"],"title":"Prism源码解析 ViewModel注入","uri":"/2020/04/prism18-source/"},{"categories":"Prism","content":"介绍\r介绍一个Prism的MVVM实现，主要介绍Prism如何在WPF上进行的一些封装，以实现MVVM。MVVM到底是什么呢？看一下这一幅经典的图 以前没有ViewModel这个概念，就是将Model传递到View显示，这样软件也可以工作，但却很混乱，一旦VIew要改动，一点点的改动都会造成很多代码需要改动，不利于维护。再者VIew层充斥着各种解析Model的代码，这些代码完全不属于View啊。平白无故的给View增加了很多职责。这是坏代码的味道。所以就有了ViewModel。ViewModel负责干什么，必须要干什么，其实ViewModel的职责就是将自己的数据绑定到View显示，同时数据变化需要通知View，View上客户的操作及时响应，至于数据怎么解析，从哪里获取，View的响应都应该方法后一层，可以是Controller，可以是Servicer,可以是Presenter。也就是业务逻辑尽量推到后一层。 试想一下，系统里的Model有很多，有数据库对应的数据库模型，有业务于对应的领域模型，有用于数据交互的DTO也是模型，那么对应的View有一个ViewModel也不觉得奇怪。 ","date":"2020-04-02","objectID":"/2020/04/prism18-source/:1:0","tags":["Prism源码解析","ViewModel注入"],"title":"Prism源码解析 ViewModel注入","uri":"/2020/04/prism18-source/"},{"categories":"Prism","content":"0 ViewModel定位\rMVVM的第一步就是要解决ViewModel的依赖注入问题，框架如何不着痕迹的将View对应的VIewModel注入到依赖属性DataContext。 还记得PrismApplicationBase类吗，就是继承Application，将整个Prism框架组件注入到Unity的那个类， 看到第一步是啥?ConfigureViewModelLocator,配置ViewModelLocator,急人之所急，Prism框架的第一步配置ViewModelLocator， 好吧，第一步就是设置ViewModelFactory，这个工厂就是通过View的类型和实例从Unity容器中获取ViewModel实例。 噢！这个View参数还没用上。 再来看看这个包含ViewModelFactory的ViewModelLocationProvider。 从这个名字我们可以大胆猜测，这个类应该是负责真正解析ViewModel的位置的，看到这个类的方法，有ViewModelFactory，有Register，有GetViewModelByXXX。 这个类中一个委托字段_defaultViewTypeToViewModelTypeResolver，从这个字段我们可以看出是默认VIewModel解析方式，可以看出就是把View完整类型名中的Views替换成ViewModels，然后返回Type，从这里面我们知道View的名字一定要含有Views，ViewModel一定要含有ViewModels。 好吧，知道了哪里解析的再来看看哪里调用的。 prism:ViewModelLocator.AutoWireViewModel=“True”，看到了，将ViewModelLocator的依赖属性AutoWireViewModel至为True，可以进一步推测ViewModelLocator里面肯定调用了ViewModelLocationProvider的相关方法以获得ViewModel的类型或实例。 依赖属性改变触发了AutoWireViewModelChanged方法，然后调用ViewModelLocationProvider.AutoWireViewModelChanged 先去查看两个字典，一个字典key是View是实例，另一个字典key是View的Type，都没有调用，然后调用ViewModelLocationProvider._defaultViewTypeToViewModelTypeResolver，也就是默认解析，在这边解析获得VIewModel的类型，然后通过默认工厂获得ViewModel实例。并绑定到VIew的DataContext。 至此，知道了整个默认VIewModel解析的全部过程，梳理一下 在程序开始向ViewModelLocationProvider中设置ViewModel类型工厂，也就是Unity。 ViewModelLocationProvider就是ViewModel获取的地方有两个字典都应该是存放viewmodel，有一个默认解析是通过View的type解析出ViewModel的type。 在Xaml中通过ViewModelLocator的依赖属性AutoWireViewModel调用ViewModelLocationProvider的AutoWireViewModelChanged来实现绑定。 ","date":"2020-04-02","objectID":"/2020/04/prism18-source/:2:0","tags":["Prism源码解析","ViewModel注入"],"title":"Prism源码解析 ViewModel注入","uri":"/2020/04/prism18-source/"},{"categories":"Prism","content":"1 自定义ViewModel定位\r通过0的介绍，想一下怎么自定义实现VIewModel定位，有几种方法， 提前向ViewModelLocationProvider的字典中添加ViewModel的类型 改变_defaultViewTypeToViewModelTypeResolver解析方式 修改工厂。这个不能从根本上改变。 这个例子用的是第二种。 在程序的开始重写ConfigureViewModelLocator方法，除了向ViewModelLocationProvider中添加ViewModelFactory外，还修改了_defaultViewTypeToViewModelTypeResolver解析方式。直接就通过View的type后面家长ViewModel，简单粗暴。 ","date":"2020-04-02","objectID":"/2020/04/prism18-source/:3:0","tags":["Prism源码解析","ViewModel注入"],"title":"Prism源码解析 ViewModel注入","uri":"/2020/04/prism18-source/"},{"categories":"Prism","content":"2 自定义ViewModel解析\r这种方法就是上面提到的1方法 提前向ViewModelLocationProvider的字典中添加ViewModel的类型 这张方法显然有很大的弊端，当程序中有很多View时怎么能手动添加呢，只能适用与特殊的View和ViewModel的解析，如Shell的VIewModel的解析。 这种解析方法也不用在意View和ViewModel的名字了。 ","date":"2020-04-02","objectID":"/2020/04/prism18-source/:4:0","tags":["Prism源码解析","ViewModel注入"],"title":"Prism源码解析 ViewModel注入","uri":"/2020/04/prism18-source/"},{"categories":"Prism","content":"总结\r从ViewModel的解析中，我们看到一种设计模式，View依赖ViewModelLocator，ViewModelLocator依赖ViewModelLocationProvider，ViewModelLocationProvider负责具体解析出对应的实例，相当于ViewModelRegistry，其中当然以有对工厂的依赖。 ","date":"2020-04-02","objectID":"/2020/04/prism18-source/:5:0","tags":["Prism源码解析","ViewModel注入"],"title":"Prism源码解析 ViewModel注入","uri":"/2020/04/prism18-source/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 ","date":"2020-04-01","objectID":"/2020/04/prism17-source/:0:0","tags":["Prism源码解析","Modules加载"],"title":"Prism源码解析 Modules加载","uri":"/2020/04/prism17-source/"},{"categories":"Prism","content":"介绍\r在软件开发过程中，总想组件式的开发方式，各个组件之间最好互不影响，独立测试。Prism的Modules很好的满足了这一点。 这个架构图很好了讲解了Prism的Modules的概念 Prism支持通过配置文件，文件夹，手动载入Module的方式，并且对Module的载入进行验证，包括重复和循环依赖验证 Prism加载模块的顺序 直接看源码吧 ","date":"2020-04-01","objectID":"/2020/04/prism17-source/:1:0","tags":["Prism源码解析","Modules加载"],"title":"Prism源码解析 Modules加载","uri":"/2020/04/prism17-source/"},{"categories":"Prism","content":"0、Modules加载\rModules的加载主要依靠ModuleCatalog来发现模块， 通过ModuleManager来加载模块并对模块进行验证以确保模块的加载顺序， ModuleInitializer负责模块的初始化，包括加载模块所必须的类和显示UI Elements等等。 在Prism.PrismApplicationBase 的Initialize方法中调用 创建目录 RegisterRequiredTypes方法中向容器注入ModuleManager，ModuleInitializer， 最后调用了InitializeModules方法，并在其中调用了ModuleManager的Run方法 看着两个名字就明白了，第一个是发现模块并验证模块，第二个是加载模块并初始化。 看一下ModuleCatalogBase的Initialize方法，果然 而验证就更加有意思了 重复性验证 通过模块名字ModuleNames来判断是否被加载过，，如果存在就抛出异常 加载顺序验证 同时看一下ModuleCatalogBase 每当items发生变化都会进行验证 发现验证完了来看一下ModuleManage的LoadModulesWhenAvailable方法 看到最终使用了ModuleInitializer来初始化Module。其过程通过Linq实现延迟加载技术。 在这个方法中发现Module必须实现IModle接口。并在这儿调用了RegisterTypes和OnInitialized方法。 模块的加载看完了，下面来看例子吧 ","date":"2020-04-01","objectID":"/2020/04/prism17-source/:2:0","tags":["Prism源码解析","Modules加载"],"title":"Prism源码解析 Modules加载","uri":"/2020/04/prism17-source/"},{"categories":"Prism","content":"1、通过AppSetting加载\r先看一下配置文件 在初始化时 看到重写了CreateModuleCatalog，前面已经介绍过ModuleCatalog就是控制Module发现和验证的。 可以看到section的名称必须是modules。 先解析Module依赖逻辑，最后调用AddModule方法 再ModuleAModule中载入相关的UIElement。 ","date":"2020-04-01","objectID":"/2020/04/prism17-source/:3:0","tags":["Prism源码解析","Modules加载"],"title":"Prism源码解析 Modules加载","uri":"/2020/04/prism17-source/"},{"categories":"Prism","content":"2、通过代码加载\r通过代码加载就更简单了，直接在ConfigureModuleCatalog方法中调用默认的ModuleCatalog加载相关的Module就可以了。 在ModuleAModule中代码不变 这其中的逻辑在0节中已经解释清楚了，就不在叙述。 ","date":"2020-04-01","objectID":"/2020/04/prism17-source/:4:0","tags":["Prism源码解析","Modules加载"],"title":"Prism源码解析 Modules加载","uri":"/2020/04/prism17-source/"},{"categories":"Prism","content":"3、通过目录加载\r通过目录加载，如果不看源码怎么设计，需要创建一个ModuleCatalog，在创建的时候将目录地址传入。在内部InnerLoad方法中找到对应目录，然后通过遍历程序集找到实现IModule接口的类，加载这个类就可以了。 看了下源码也正是这么做的 看了源码发现官方考虑了更多的问题，比如创建了AppDoamin来加载程序集以保证隔离和数据安全。甚至还为其创建了一个InnerModuleInfoLoader类来反射程序集 这样的指责分配非常好，我们甚至可以写一个通过网络来加载Module的ModuleCatalog类。 ","date":"2020-04-01","objectID":"/2020/04/prism17-source/:5:0","tags":["Prism源码解析","Modules加载"],"title":"Prism源码解析 Modules加载","uri":"/2020/04/prism17-source/"},{"categories":"Prism","content":"4、通过手动方式加载\r先在ConfigureModuleCatalog中将所有的Module加载进来，并将InitializationMode的方式设置为按需， 那么就可以在需要的时候利用LoadModule方法载入之前加载的Module 值得注意的是并没有提供卸载Module的接口。 ","date":"2020-04-01","objectID":"/2020/04/prism17-source/:6:0","tags":["Prism源码解析","Modules加载"],"title":"Prism源码解析 Modules加载","uri":"/2020/04/prism17-source/"},{"categories":"Prism","content":"总结\r这一篇介绍了下Modules加载的原理，其实就是 ModuleCatalog负责发现Module。 通过ModuleManager来加载模块并对模块进行验证以确保模块的加载顺序， ModuleInitializer负责模块的初始化，包括加载模块所必须的类和显示UI Elements等等。 下一篇开始将介绍MVVM的实现。 ","date":"2020-04-01","objectID":"/2020/04/prism17-source/:7:0","tags":["Prism源码解析","Modules加载"],"title":"Prism源码解析 Modules加载","uri":"/2020/04/prism17-source/"},{"categories":"Prism","content":"添加\rModuleManager负责对ModuleCatalog和ModuleInitializer的引用。 ModuleCatalog维护一个ModuleCatalogItemCollection和ModuleInfo的集合 ","date":"2020-04-01","objectID":"/2020/04/prism17-source/:8:0","tags":["Prism源码解析","Modules加载"],"title":"Prism源码解析 Modules加载","uri":"/2020/04/prism17-source/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 ","date":"2020-03-30","objectID":"/2020/03/prism16-source/:0:0","tags":["Prism源码解析","View的加载和控制"],"title":"Prism源码解析 View的加载和控制","uri":"/2020/03/prism16-source/"},{"categories":"Prism","content":"介绍\r上一篇讲了入了门，这一篇，让我们不多BB直接开始 ","date":"2020-03-30","objectID":"/2020/03/prism16-source/:1:0","tags":["Prism源码解析","View的加载和控制"],"title":"Prism源码解析 View的加载和控制","uri":"/2020/03/prism16-source/"},{"categories":"Prism","content":"4、ViewDiscovery\r在创建好Region后需要将View添加到Region中。先补充几个概念 在上一篇将了如何创建Region，现在让我们看看Region类是什么 private ViewsCollection views; private ViewsCollection activeViews; 这是一个View集合，集合改变会触发CollectionChanged事件 其完全依赖ObservableCollection对象 this.Behaviors = (IRegionBehaviorCollection) new RegionBehaviorCollection((IRegion) this); 这是一个行为集合，每当添加进行为的时候，会主动调用Attach（） PropertyChanged事件，每当Context,Name, RegionManager，会触发该事件 下面来看一个好玩的行为AutoPopulateRegionBehavior 可以看到这个行为对RegionViewRegistry有依赖，这个是通过构造注入的方式注入的。 该RegionViewRegistry保存着所有的View，是名副其实的Registry. 该Registry有一个事件ContentRegistered, 每当调用这个方法的时候就会触发这个事件。 不能跑偏了，回到AutoPopulateRegionBehavior 在行为Attach的时候，已经对RegionViewRegistry进行了订阅。 看看this.Region.Add() 这个ItemMetadataCollection的改变会影响Views和ActiveViews 首先它是一个ObservableCollection， 其次ViewCollection就是依赖ItemMetadataCollection创建的，所以改变自然会影响ViewCollection 那这个VIewCollection是怎么来影响界面的呢，这就要看看另一个行为RegionActiveAwareBehavior 至此可能会一头雾水，这讲了什么啊，一会是Region，一会是Behavior，到底想说什么啊？其实就是讲了View是如何被自动注入到对应的Region。 下面让我们跟着Samples中的ViewDiscovery并结合刚刚讲的源码梳理一下。 在程序开始的时候向行为工厂中注入了相应的行为 在创建Region的时候RegionAdapter向其添加了所有的行为 现在只需调用RegionManager.RegisterViewWithRegion方法就可以自动向Region中添加VIew并显现出来 可以看到就是调用RegionViewRegistry中Register’VIew’With’Region方法 下面就等着AutoPopulateRegionBehavior和RegionActiveAwareBehavior按照上面的方式工作就可以了。 可以看出为什么Region有这么强大的功能就是因为Prism给Region提供了很多的行为，行为作为WPF的一个特性，其作用是非常强大的。后面的View生命周期管理也是通过行为来完成的 ","date":"2020-03-30","objectID":"/2020/03/prism16-source/:2:0","tags":["Prism源码解析","View的加载和控制"],"title":"Prism源码解析 View的加载和控制","uri":"/2020/03/prism16-source/"},{"categories":"Prism","content":"5、ViewInjection\rView手动加载到Region，通过一个点击事件，通过RegionManager的Regions属性添加View 这个就更简单了，因为没有走RegionVIewRegistry，而是直接通过Region添加View，会直接添加到对应的RegionView上,然后通过RegionActiveAwareBehavior显示，上面有就不再详尽叙述了。 ","date":"2020-03-30","objectID":"/2020/03/prism16-source/:3:0","tags":["Prism源码解析","View的加载和控制"],"title":"Prism源码解析 View的加载和控制","uri":"/2020/03/prism16-source/"},{"categories":"Prism","content":"6、ViewActivationDeactivation\r激活或停用View 这个也不多BB直接看怎么调用 首先先用手动的方式向Region中添加两个View 就是两个方法Activate和Deactivate 这实现也太巧妙了吧，通过ItemMetadata直接影响了View和ActiveView，然后通过RegionActiveAwareBehavior行为实现。真帅 就不再叙述了。 ","date":"2020-03-30","objectID":"/2020/03/prism16-source/:4:0","tags":["Prism源码解析","View的加载和控制"],"title":"Prism源码解析 View的加载和控制","uri":"/2020/03/prism16-source/"},{"categories":"Prism","content":"总结\r本章主要讲了View的加载方式，可以手动加载，可以自动加载，并可以控制View的Activate和DeActivate。其主要实现都是依靠行为，也从侧面反映出行为的强大，行为能做的事情实在太多了。下一章会对Modules的实现进行介绍。 ","date":"2020-03-30","objectID":"/2020/03/prism16-source/:5:0","tags":["Prism源码解析","View的加载和控制"],"title":"Prism源码解析 View的加载和控制","uri":"/2020/03/prism16-source/"},{"categories":"Prism","content":"补充\r在创建Shell的时候，已经调用RegionManager.SetRegionName方法，然后触发RegionManager.OnSetRegionNameCallback方法 ","date":"2020-03-30","objectID":"/2020/03/prism16-source/:6:0","tags":["Prism源码解析","View的加载和控制"],"title":"Prism源码解析 View的加载和控制","uri":"/2020/03/prism16-source/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 ","date":"2020-03-29","objectID":"/2020/03/prism15-source/:0:0","tags":["Prism源码解析","Bootstrapper和Region的创建"],"title":"Prism源码解析 Bootstrapper和Region的创建","uri":"/2020/03/prism15-source/"},{"categories":"Prism","content":"介绍\r之前也研究过Prism框架但是一直没有深入理解，现在项目上想把一个Winform的桌面应用程序改造成WPF程序，同时我希望程序是可测试可维护架构良好的，Prism的这些设计理念正好符合我的需求，其主要用于WPF和Xamarin，用于构建松耦合，可维护，可测试的应用程序框架，在我看到源码后也深受启发，欢迎大家一起交流探讨。 Prism的整体架构 ","date":"2020-03-29","objectID":"/2020/03/prism15-source/:1:0","tags":["Prism源码解析","Bootstrapper和Region的创建"],"title":"Prism源码解析 Bootstrapper和Region的创建","uri":"/2020/03/prism15-source/"},{"categories":"Prism","content":"开始\r我将从官方的Samples的顺序，看介绍中的每个功能是怎么实现的。 Github地址 ","date":"2020-03-29","objectID":"/2020/03/prism15-source/:2:0","tags":["Prism源码解析","Bootstrapper和Region的创建"],"title":"Prism源码解析 Bootstrapper和Region的创建","uri":"/2020/03/prism15-source/"},{"categories":"Prism","content":"0、PrismApplicationBase\r首先介绍一下这个类，这是Startup，这个类中构建了所有的Prism功能和整体的框架。这个类中大多数的方法都是虚方法，可以重载加入自定义的一些功能，Prism也希望我们如此进行设计。 在整个Prism中，UnityContainer无处不再，它就是一个大的容器，保存着所有类，在需要的时候Resolver出来。 有两个字段，ContainerExtension就UnityContainer,当然也可以自定义其他的容器，在文章中都默认为UnityContainer容器，关于容器也给一个官方说明 ModuleCatalog是定义了加载Module的方式，模块是Prism的一大优势，给一张官方说明，意图胜千言 所有的一切都是从一个类开始PrismApplicationBase，在这个类中加载了Prism的所有功能。 看一下最重要的一个方法，正是在这个方法中完成了大部分功能，其主要工作就是将基础架构模块，RequireTypes，RegionAdapterMappings,RegionBehaviors,注入到相应的容器中。 下面几个方法感受一下 在PrismApplicationBase的子类中看一下 正如我前面所说，重写某个方法，先调用Base.Method,然后再加入自己功能 对于开发者来说必须重写的就两个方法 这个Shell就是主窗体，窗体的构成Prism的窗体都是由一个个Region构成，每个Region中都包含若干个View 创建主窗体和RegisterTypes方法，在第二个方法里可以加入我们所必须的一些基础构建，ContainerRegistry其实就是注册的Unity容器 下面让我们愉快的看例子吧。例子都在Prism-Samples-Wpf-master中一共29个，https://github.com/PrismLibrary/Prism-Samples-Wpf ","date":"2020-03-29","objectID":"/2020/03/prism15-source/:3:0","tags":["Prism源码解析","Bootstrapper和Region的创建"],"title":"Prism源码解析 Bootstrapper和Region的创建","uri":"/2020/03/prism15-source/"},{"categories":"Prism","content":"1、BootstrapperShell\r看着就是创建了一个Bootstraper然后Run了一下，通过容器创建了主窗体，Show了一下。 看一下如何实现的，其实文章都是在Bootstrapper中 看到这两个类是不是有一种恍然大悟的感觉，原来Bootstrapper是啥？就是将PrismApplicationBase中的方法全部从Application中抽出来，在这重新实现了一下，难道这就是单一职责原则？ 来看一下Run，这些方法太熟悉了吧。 日志怎么用，当然是创建然后记录了，所有的信息都放到资源里，创建的方式有很多种，选择最简单的一种new， BootStrapper的主要职责 ","date":"2020-03-29","objectID":"/2020/03/prism15-source/:4:0","tags":["Prism源码解析","Bootstrapper和Region的创建"],"title":"Prism源码解析 Bootstrapper和Region的创建","uri":"/2020/03/prism15-source/"},{"categories":"Prism","content":"2、Regions\r这个就是简单的创建一个Region 一目了然啊，就是在ContentControl中用RegionManager的依赖属性创建的一个Region。 用经典的三个问题来看看RegionManager，你是谁，你从哪里来，要到哪里去。 哦！小伙子你很张狂啊，很强大。看一眼把关了就可以了。 看一眼知道了有一个RegionName依赖属性，当这个属性变化的时候调用 IsInDesignMode就是判断是否在VS的设计模式，调用 哦，还是用了延迟加载，还是用容器创建的，Prism里几乎所有的类都是通过容器创建的 Behavior？WPF里面的行为就是服务啊，就是先把一个依赖属性存着，需要的时候盘它。去看看 很标准的服务。 使用了弱引用，很棒的设计，想想也是如此， 通过Load事件实现延迟加载，嗯，很棒，在界面载入的时候创建Region。 载入触发一次就好。很喜欢这个单词WireUp，缠绕，UnWire， 通过名字创建，到RegionAdapterMapping中找到RegionAdapter然后通过Adapter的Initialize创建。 RegionAdapterMapping就是RegionAdapter的集合 先创建Region，然后添加行为 都有哪些行为呢？ 创建Region工作完成啦。 看看官方文档关于Region ","date":"2020-03-29","objectID":"/2020/03/prism15-source/:5:0","tags":["Prism源码解析","Bootstrapper和Region的创建"],"title":"Prism源码解析 Bootstrapper和Region的创建","uri":"/2020/03/prism15-source/"},{"categories":"Prism","content":"3、CustomRegions\r想要自定义一个Regin，那肯定要创建一个RegionAdapter，自定义一个StackPanelRegionAdapter 通过刚刚的源码解读这些理解起来好像都不困难了。 ","date":"2020-03-29","objectID":"/2020/03/prism15-source/:6:0","tags":["Prism源码解析","Bootstrapper和Region的创建"],"title":"Prism源码解析 Bootstrapper和Region的创建","uri":"/2020/03/prism15-source/"},{"categories":"Prism","content":"总结\r通过源码探索了下Bootstapper，Region的创建及如何自定义一个RegionAdapter，轻轻揭开了Prism一点点面纱。后面还有很多的功能和想法，欢迎大家和我一起探讨学习。 ","date":"2020-03-29","objectID":"/2020/03/prism15-source/:7:0","tags":["Prism源码解析","Bootstrapper和Region的创建"],"title":"Prism源码解析 Bootstrapper和Region的创建","uri":"/2020/03/prism15-source/"},{"categories":"重构改善既有代码","content":"大型重构\r","date":"2019-11-15","objectID":"/2019/11/designpattern12-refactoring8/:1:0","tags":["重构改善既有代码","大型重构"],"title":"重构改善既有代码 大型重构","uri":"/2019/11/designpattern12-refactoring8/"},{"categories":"重构改善既有代码","content":"1、梳理并分解继承体系\rTease Apart Inheritance 就是让每个类的职责更明确更单一，当一个类的职责混乱时，通过绘制职责图来分离职责，并创建另一个超类，将相关的字段和方法都移动到另一个超类 动机 混乱的继承体系是一个严重的问题，会导致重复代码，而后者正是程序员生涯的致命毒药。还会使修改变得困难，因为特定问题的解决决策被坟山到了整个继承体系。 什么时候做 某个继承体系同时承担两项责任 怎么做 建立两个继承体系，并通过委托关系让其中一个可以调用另一个 首先识别出继承体系所承担的不同责任，然后建立一个二维表格（或则三位乃至四维表格），并以坐标轴标示不同的任务， 判断哪一项责任更重一些，并准备将它留在当前的继承体系中，准备将另一项责任移到另一个继承体系中。 使用抽象类方法从当前的超类提炼出一个新类，用以表示重要性稍低的责任，并在原超类中添加一个实例变量，用以保存新类的实例。 对应于原继承体系中的每个子类，创建上述新类的一个子类，在原继承体系的子类中，将前一步骤所添加的实例变量初始化为新建子类的实例。 针对原继承体系中的每个子类，使用搬移函数的方法迁移到与之对应的子类中。 ","date":"2019-11-15","objectID":"/2019/11/designpattern12-refactoring8/:1:1","tags":["重构改善既有代码","大型重构"],"title":"重构改善既有代码 大型重构","uri":"/2019/11/designpattern12-refactoring8/"},{"categories":"重构改善既有代码","content":"2、将过程化设计转化为对象设计\rConvert Procedural Design to Objects 动机 什么时候做 有一些传统过程化风格的代码 怎么做 将数据记录变成对象，将大块的行为分为小块，并将行为移入相关对象之中。 针对每一个记录类型，将其转变为只含访问函数的哑数据对象 针对每一处过程化风格，将该出的代码提炼到一个独立类中。 针对每一段长长的程序，试试提炼方法将长方法分解并将分解后的方法移动到相关的哑数据类。 ","date":"2019-11-15","objectID":"/2019/11/designpattern12-refactoring8/:1:2","tags":["重构改善既有代码","大型重构"],"title":"重构改善既有代码 大型重构","uri":"/2019/11/designpattern12-refactoring8/"},{"categories":"重构改善既有代码","content":"3、将领域和表诉/显示分离\rSeparate Domain from Presentation 动机 MVC模式最核心的价值在于，它将用户界面代码（即视图：亦即现今常说的展现层）和领域逻辑（即模型）分离了，展现类只含用以处理用户界面的逻辑：领域类包含任何与程序外观相关的代码，只含业务逻辑相关代码，将程序中这两块复杂的部分加以分离，程序未来的修改将变得更加容易，同时也使用同意业务逻辑的多种展现方式称为可能。 什么时候做 某些GUI类中包含了领域逻辑 怎么做 将领域逻辑分离出来，为它们建立独立的邻域类。 为每个窗口建立一个领域类， 如果窗口内含有一张表格，新建一个类来表示其中的行，再以窗口所对应之领域类中的一个集合来容纳所有行领域对象 检查窗口中的数据，如果数据只被用于UI，就把它留着，如果数据被领域逻辑使用，而且不显示与窗口上，我们就可以使用移动方法将它搬移到领域类中，如果数据同时被UI和领域逻辑使用，就对它实施复制被监视数据，使它同时存在于两处，并保持两处之间的同步。 展现类中的逻辑，实施提炼方法将展现逻辑从邻域逻辑中分开，一旦隔离了邻域逻辑，在运用搬移方法将它移到邻域类。 ","date":"2019-11-15","objectID":"/2019/11/designpattern12-refactoring8/:1:3","tags":["重构改善既有代码","大型重构"],"title":"重构改善既有代码 大型重构","uri":"/2019/11/designpattern12-refactoring8/"},{"categories":"重构改善既有代码","content":"4、提炼继承体系\rExtract Hierarchy 动机 一开始设计者只想以一个类实现一个概念，但随着设计方案的演化，最后可能一个类实现两个三乃至十个不同的概念。 什么时候做 有某个类做了太多的工作，其中一部分工作是以大量条件表达式完成的 怎么做 建立继承体系，以一个子类表示一种特殊情况。 有两种重构的手法 无法确定哪些地方会发生变化 不确定哪些地方会发生变化 鉴别出一中变化情况， 如果这种拜年话可能在对象声明周期的不同阶段而有不同体现就用提炼方法将它提炼为一个独立的类 针对这种变化情况，新建一个子类，并对原始类实施工厂方法替代构造函数，再次修改工厂方法，令它返回适当的子类实例。 将含有条件逻辑的函数，一个个复制到子类 有必要隔离函数中的条件逻辑和非条件逻辑。 删除超类中那些被所有子类覆写的函数本体，并将它们声明为抽象函数。 确定原始类中每一种变化 针对原始类中每一种变化情况，建立一个子类， 使用工厂方法替代构造函数将原始类的构造函数转变成工厂函数，并令它针对每一种变化情况返回适当的子类实例。 如果原始类中的各种变化情况是以类型码标示，使用子类替换类型码，如果那些变化情况在对象周期的不同阶段会有不同体现，使用状态和策略模式替换类型码 针对带有条件逻辑的函数，实施用多态替换条件如果非整个函数的行为有所变化，请先运行提炼方法将变化部分和不变部分分隔开来 ","date":"2019-11-15","objectID":"/2019/11/designpattern12-refactoring8/:1:4","tags":["重构改善既有代码","大型重构"],"title":"重构改善既有代码 大型重构","uri":"/2019/11/designpattern12-refactoring8/"},{"categories":"重构改善既有代码","content":"8 案例\r有一个影片商店客户端，需要计算每一个客户的消费，常客积分 客户customer 租赁rental 影片movie，普通Regular，儿童Children，新片Release Regular:2天内2元，大于2天1.5一天 Release:每天三元 Childrens:3天内1.5元，大于3天1.5一天 计费函数 ","date":"2019-11-15","objectID":"/2019/11/designpattern12-refactoring8/:2:0","tags":["重构改善既有代码","大型重构"],"title":"重构改善既有代码 大型重构","uri":"/2019/11/designpattern12-refactoring8/"},{"categories":"重构改善既有代码","content":"提炼方法\r这个计费函数太复杂 修改参数名 搬移方法 amountfor没有使用customer任何信息，只是使用了rental类的，将其搬移到rental类中 修改原customer中函数调用 ","date":"2019-11-15","objectID":"/2019/11/designpattern12-refactoring8/:2:1","tags":["重构改善既有代码","大型重构"],"title":"重构改善既有代码 大型重构","uri":"/2019/11/designpattern12-refactoring8/"},{"categories":"重构改善既有代码","content":"用查询替换临时变量\r用同样的方法来处理计算常客积分的部分 ","date":"2019-11-15","objectID":"/2019/11/designpattern12-refactoring8/:2:2","tags":["重构改善既有代码","大型重构"],"title":"重构改善既有代码 大型重构","uri":"/2019/11/designpattern12-refactoring8/"},{"categories":"重构改善既有代码","content":"使用多态替换Switch\r原来的switch,在rental类中 不要再另一个对象属性上使用switch，将其移动到方法中 移动过后 常客积分 继承机制 一个影片可以再生命周期内修改自己的分类，一个对象却不能再生命周期内修改自己所属的类，这里需要使用用状态或策略模式替换type，搬移方法到超类，用多态替换条件 提炼超类 修改原来movie中的getcharge方法， 首先getcharge移动方法 用多态替换getcharge方法 ","date":"2019-11-15","objectID":"/2019/11/designpattern12-refactoring8/:2:3","tags":["重构改善既有代码","大型重构"],"title":"重构改善既有代码 大型重构","uri":"/2019/11/designpattern12-refactoring8/"},{"categories":"重构改善既有代码","content":"1、字段上移\rPull Up Field 动机 减少重复 什么时候做 两个子类拥有相同的字段 怎么做 将该字段移至超类 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:1","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"2、函数上移\rPull Up Method 动机 滋生错误 避免重复 什么时候做 有些函数在各个子类中产生完全相同的结果 怎么做 将该函数移至超类 最烦的一点就是，被提升的函数可能会引用子类中出现的特性，如果被引用的是一个函数可以将这个函数一同提升至超类，或则在超类中建立一个抽象函数。 如果两个函数相似但不相同，可以先借助塑造模板函数。 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:2","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"3、构造函数本体上移\rPull Up Constructor Body 引用 如果重构过程过于复杂，可以考虑使用工厂方法。 什么时候做 在各个子类中拥有一些构造函数，它们的本体机会完全一致 怎么做 在超类中新建一个构造函数，并在子类构造函数中调用它。 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:3","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"4、函数下移\rPush Down Method 动机 把某些行为从超类移动到特定的子类中。 什么时候做 超类中某个函数只与部分子类有关 怎么做 将这个函数移到相关的那些子类中 如果移动的函数需要使用超类中的某个字段，则需要将超类中的字段的开放protected. ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:4","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"5、字段下移\rPush Down Field 动机 什么时候做 超类中的某个字段只被部分子类用到 怎么做 将这个字段移到需要它的那些子类去 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:5","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"6、提炼子类*？\rExtract Subclass 动机 类中的某些行为只被一部分实例用到，其他实例不需要，有时候这些行为上的差异是通过类型码分区的，可以使用子类替换类型码，或则使用状态或策略模式替代类型码。 抽象类和抽象子类则是委托和继承之间的抉择 抽象子类会更加容易，但是一旦对象建立完成，无法再改变与类型相关的行为。 什么时候做 类中的某些特性只被某些实例用到 怎么做 新建一个子类，将上面所说的那一部分特性移到子类中 为源类定一个新的子类 为这个新的子类提供构造函数 让子类构造函数接受与超类构造函数相同的参数，并通过super调用超类的构造函数。 用工厂替换构造函数 找出调用结果超类构造函数的所有地点，新建子类 下移方法和字段 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:6","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"7、提炼超类*？\rExtract Superclass 动机 什么时候做 两个类有相似特性 怎么做 为这两个类建立一个超类，将相同特性移至超类。 新建一个空白抽象类 上移字段和方法 先搬移字段 子类函数中有相同的签名，但函数体不同，可以抽象函数 如果方法中有相同算法，可以使用提炼算法，将其封装到同一个函数中。 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:7","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"8、提炼接口\rExtract Interface 动机 类之间彼此互用的方式有若干种，某一种客户只使用类责任区的一个特定子集。 某个类在不同环境下扮演截然不同的角色，使用接口就是一个好主意。 什么时候做 若干客户使用类接口中同一个子集，或者两个类的接口有部分相同 怎么做 将相同的子类提炼到一个独立接口中。 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:8","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"9、折叠继承关系\rCollapse Hierarchy 动机 什么时候做 超类和子类之间无太大区别 怎么做 将它们合为一体 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:9","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"10、塑造模板函数\rForm Template Method 动机 既避免重复也保持差异。 什么时候做 有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同。 怎么做 将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同的，然后将原函数上移至超类 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:10","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"11、以委托取代继承\rReplace Inheritance with Delegation 动机 超类中有许多操作并不真正适用于子类，这种情况下，你所拥有的接口并未真正反映出子类的功能。 什么时候做 某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据 怎么做 在子类中新建一个字段用以保存超类，调整子类函数，令它改而委托超类，然后去掉两者之间的继承关系。 在子类中新建一个字段，使其引用超类的实例 修改子类中的所有函数，让它们不再使用超类，转而使用上述那个受托字段。 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:11","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"12、以继承取代委托\rReplace Delegation with Inheritance 动机 如果并没有使用受托类的所有函数，就不应该使用用继承替换委托， 可以使用去除中间层的方法让客户端自己调用受托函数。 什么时候做 在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数。 怎么做 ","date":"2019-11-14","objectID":"/2019/11/designpattern11-refactoring7/:0:12","tags":["重构改善既有代码","处理继承关系"],"title":"重构改善既有代码 处理继承关系","uri":"/2019/11/designpattern11-refactoring7/"},{"categories":"重构改善既有代码","content":"所有的数据都应该隐藏起来。 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:0","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"1、函数改名\rRename Method 动机 将复杂的处理过程分解成小函数。 什么时候做 函数名称未能揭示函数的用途 怎么做 修改函数名称 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:1","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"2、添加参数\rAdd Parameter 动机 什么时候做 某个函数需要从调用端得到更多信息 在添加参数外常常还有其他的选择，只要有可能，其他选择都比添加参数要好（查询），因为它们不会增加参数列的长度，过长的参数列是一个不好的味道。 怎么做 为此函数添加一个对象参数，让该对象带进函数所需信息。 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:2","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"3、移除参数\rRemove Parameter 动机 可能经常添加参数却很少去除参数，因为多余的参数不会引起任何问题，相反以后可能还会用到它。请去除这些想法。 什么时候做 函数本体不需要某个参数 怎么做 将该参数去除。 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:3","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"4、将查询函数和修改函数分离\rSeparate Query from Modifier 动机 在多线程系统中，查询和修改函数应该被声明为synchronized(已同步化) 什么时候做 某个函数既返回对象状态值，又修改对象状态 任何有返回值的函数，都不应该又看得到的副作用。 常见的优化是将某个查询结果放到某个字段或集合中，后面如何查询，总是获得相同的结果。 怎么做 建立两个不同的函数，其中一个负责查询，另一个负责修改。 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:4","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"5、令函数携带参数\rParameterize 动机 去除重复代码 什么时候做 若干函数做了类似的工作，但在函数本体中却饱含了不同的值 怎么做 建立单一函数，以参数表达那些不同的值 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:5","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"6、以明确函数取代参数\rReplace Parameter with Explicit Methods 动机 避免出现条件表达式，接口更清楚，编译期间就可以检查， 如果在同一个函数中，参数是否合法还需要考虑 但是参数值不会对函数的行为有太多影响的话就不应该使用本项重构，如果需要条件判断的行为，可以考虑使用多态。 什么时候做 有一个函数，其中完全取决于参数值不同而采取不同行为 怎么做 针对该参数的每一个可能值，建立一个独立函数 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:6","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"7、保持对象完整\rPreserve While Object 动机 不适用完整对象会造成重复代码 事物都是有两面性，如果你传的是数值，被调用函数就只依赖于这些数值，如果传的是对象，就要依赖于整个对象。如果依赖对象会造成结构恶化。那么就不应该使用保持对象完整。 如果这个函数使用了另一个对象的多项数据，这可能以为着这个函数实际上应该定义在那些数据所属的对象上，应该考虑移动方法。 什么时候做 从某个对象中取出若干值，将它们作为某一次函数调用时的参数 怎么做 改为传递整个对象 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:7","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"8、以函数取代参数\rReplace Parameter with Methods 动机 尽可能缩减参数长度 什么时候做 对象调用某个函数，并将所有结果作为参数传递给另一个函数，而接受该参数的函数本省也能够调用前一个函数。 怎么做 让参数接受者去除该项参数，并直接调用前一个函数。 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:8","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"9、引入参数对象\rIntroduce Parameter Object 动机 特定的一组参数总是一起被传递，可能有好几个函数都使用这一组参数，这些函数可能隶属于同一个类，也可能隶属于不同的类。这样的参数就是所谓的数据泥团，可以运用一个对象包装所有的这些数据，再以该对象取代它们。 什么时候做 某些参数总是很自然地同时出现 怎么做 以一个对象取代这些参数 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:9","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"10、移除设值函数\rRemove Setting Method 动机 使用了设值函数就暗示了这个字段值可以被改变。 什么时候做 类中某个字段应该在对象创建时被设值，然后就不再改变。 怎么做 去掉该字段的所有设值函数。 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:10","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"11、隐藏函数\rHide Method 动机 面对一个过于丰富、提供了过多行为的接口时，就值得将非必要的取值函数和设置函数隐藏起来 什么时候做 有一个函数，从来没有被其他任何类用到 怎么做 将这个函数修改为private ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:11","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"12、以工厂函数取代构造函数\rReplace Constructor with Factory Method 动机 使用以工厂函数取代构造函数最显而易见的动机就是在派生子类的过程中以工厂函数取代类型码。 工厂函数也是将值替换成引用的方法。 什么时候做 希望在创建对象时不仅仅是做简单的构建动作 怎么做 将构造函数替换为工厂函数 使用工厂模式就使得超类必须知晓子类，如果想避免这个可以用操盘手模式，为工厂类提供一个会话层，提供对工厂类的集合对工厂类进行控制。 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:12","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"13、封装向下转型\rEncapsulate Downcast 动机 能不向下转型就不要向下转型，但如果需要向下转型就必须在该函数中向下转型。 什么时候做 某个函数返回对象，需要由函数调用者执行 向下转型 怎么做 将向下转型动作移到函数中 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:13","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"14、以异常取代错误码\rReplace Error Code with Exception 动机 代码可以理解应该是我们虔诚最求的目标。 什么时候做 某个函数返回一个特定的代码，用以表示某种错误情况 怎么做 改用异常 决定应该抛出受控(checked)异常还是非受控(unchecked)异常 如果调用者有责任在调用前检查必要状态，就抛出非受控异常 如果想抛出受控异常，可以新建一个异常类，也可以使用现有的异常类。 找到该函数的所有调用者，对它们进行相应调整。 如果函数抛出非受控异常，那么就调整调用者，使其在调用函数前做适当检查， 如果函数抛出受控异常，那么就调整调用者，使其在try区段中调用该函数。 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:14","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"15、以测试取代异常\rReplace Exception with Test 动机 在异常被滥用的时候 什么时候做 面对一个调用者可以预先检查的体哦阿健，你抛出一个异常 怎么做 修改调用者，使它在调用函数之前先做检查 ","date":"2019-11-13","objectID":"/2019/11/designpattern10-refactoring6/:0:15","tags":["重构改善既有代码","简化函数调用"],"title":"重构改善既有代码 简化函数调用","uri":"/2019/11/designpattern10-refactoring6/"},{"categories":"重构改善既有代码","content":"1、分解条件表达式\rDecompose Conditional 动机 复杂的条件逻辑是最常导致复杂度上升的地点之一， 什么时候做 有一个复杂的条件语句 怎么做 从if，then,else三个段落中分别提炼出独立函数 将其分解为多个独立函数，根据每个小块代码的用途分解而得的新函数命名。 很多人都不愿意去提炼分支条件，因为这些条件非常短，但是提炼之后函数的可读性很强，就像一段注释一样清楚明白。 ","date":"2019-11-12","objectID":"/2019/11/designpattern9-refactoring5/:0:1","tags":["重构改善既有代码","简化条件表达式"],"title":"重构改善既有代码 简化条件表达式","uri":"/2019/11/designpattern9-refactoring5/"},{"categories":"重构改善既有代码","content":"2、合并条件表达式\rConsolidate Conditional Expression 其实就是用一个小型函数封装一下，小型函数的名字可以作为注释。 动机 合并后的条件代码会使得检查的用意更加清晰，合并前和合并后的代码有着相同的效果。 什么时候做 有一系列条件测试，都得到相同结果 怎么做 将这些测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数。 ","date":"2019-11-12","objectID":"/2019/11/designpattern9-refactoring5/:0:2","tags":["重构改善既有代码","简化条件表达式"],"title":"重构改善既有代码 简化条件表达式","uri":"/2019/11/designpattern9-refactoring5/"},{"categories":"重构改善既有代码","content":"3、合并重复的条件片段\rConsolidate Duplicate Conditional Fragments 动机 什么时候做 在条件表达式的每个分支上都有着相同的一段代码 怎么做 将这段重复代码搬移到条件表达式之外。 ","date":"2019-11-12","objectID":"/2019/11/designpattern9-refactoring5/:0:3","tags":["重构改善既有代码","简化条件表达式"],"title":"重构改善既有代码 简化条件表达式","uri":"/2019/11/designpattern9-refactoring5/"},{"categories":"重构改善既有代码","content":"4、移除控制标记\rRemove Control Flag 动机 单一出口原则会迫使让妈中加入讨厌的控制标记，大大降低条件表达式的可读性， 什么时候做 在一系列布尔表达式中，某个变量带有\"控制标记\"(control flag)的作用 怎么做 以break语句或return语句取代控制标记 ","date":"2019-11-12","objectID":"/2019/11/designpattern9-refactoring5/:0:4","tags":["重构改善既有代码","简化条件表达式"],"title":"重构改善既有代码 简化条件表达式","uri":"/2019/11/designpattern9-refactoring5/"},{"categories":"重构改善既有代码","content":"5、以卫语句取代嵌套条件表达式\rReplace Nested Conditional with Guard Clauses 动机 单一出口的规则其实并不是那么有用，保持代码清晰才是最关键的。 什么时候做 函数中条件逻辑使人难以看清正常的执行路径 怎么做 使用卫语句表现所有特殊情况。 ","date":"2019-11-12","objectID":"/2019/11/designpattern9-refactoring5/:0:5","tags":["重构改善既有代码","简化条件表达式"],"title":"重构改善既有代码 简化条件表达式","uri":"/2019/11/designpattern9-refactoring5/"},{"categories":"重构改善既有代码","content":"6、以多态取代条件表达式\rReplace Conditional with Polymorphism 动机 如果需要根据对象的不同类型而采取不同的行为，多态使你不必编写明显的条件表达式。 同一组条件表达在程序许多地点出现，那么使用多态的收益是最大的。 什么时候做 有一个条件表达式，根据对象类型的不同而选择不同的行为 怎么做 将这个体哦阿健表示式的每个分支放进一个子类的覆写函数中，然后将原始函数声明为抽象函数。 ","date":"2019-11-12","objectID":"/2019/11/designpattern9-refactoring5/:0:6","tags":["重构改善既有代码","简化条件表达式"],"title":"重构改善既有代码 简化条件表达式","uri":"/2019/11/designpattern9-refactoring5/"},{"categories":"重构改善既有代码","content":"7、引入Null对象\rIntroduce Null Object 动机 多态的最根本好处就是不必要想对象询问你是什么类型而后根据得到的答案调用对象的某个行为，只管调用该行为就是了。 空对象一定是常量，它们的任何成分都不会发生变化，因此可以使用单例模式来实现它们。 什么时候做 需要再三检查对象是否为Null 怎么做 将null对象替换成null对象。 ","date":"2019-11-12","objectID":"/2019/11/designpattern9-refactoring5/:0:7","tags":["重构改善既有代码","简化条件表达式"],"title":"重构改善既有代码 简化条件表达式","uri":"/2019/11/designpattern9-refactoring5/"},{"categories":"重构改善既有代码","content":"8、引入断言\rIntroduce Assertion 动机 断言是一个条件表达式，应该总是为真，如果它失败，表示程序员犯了一个错误。因此断言的失败应该导致一个非受控异常（unchecked exception）。 加入断言永远不会影响程序的行为。 用它来检查一定必须为真的条件。 什么时候做 某一段代码需要对程序状态做出某种假设 怎么做 以断言明确表现这种假设 ","date":"2019-11-12","objectID":"/2019/11/designpattern9-refactoring5/:0:8","tags":["重构改善既有代码","简化条件表达式"],"title":"重构改善既有代码 简化条件表达式","uri":"/2019/11/designpattern9-refactoring5/"},{"categories":"重构改善既有代码","content":"**对于这个类的任何修改都应该通过该类的方法。类拥有一些数据却无所觉，拥有一些依赖无所觉是非常危险的。**所以才要封装字段，封装集合，监视数据，用对象替代数组，用对象替代集合，关联改动。 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:0","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"1、自封装字段\rSelf Encapsulate 动机 直接访问变量的好处：子类可以通过覆写一个函数而改变获取数据的途径，它还支持更灵活的数据管理方式，如延迟初始化等， 直接访问变量的好处：代码比较容易阅读， 优先选择直接访问的方式，直到这种访问方式带来麻烦位置。 什么时候需要自封装字段 直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。 怎么自封装 为这个字段建立取值/设值函数，并且只以这些函数来访问字段。 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:1","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"2、以对象取代数据值\rReplace Data Value with Object 动机 简单数据不再简单， 注意：原来的数据值是值对象，改成对象可能变成引用类型，这样面临的问题是多个实例就不是同一个对象。需要用将引用对象改成值对象方法， 什么时候需要对象取代 有一个数据项，需要与其他数据和行为一起使用才有意义。 怎么对象取代 为替换值新建一个新类，其中声明final字段，修改原字段的引用，都修改为对象。 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:2","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"3、将值对象改成引用对象\rChange Value to Reference 对于值类型来说，equals和==的功能是相等的都是比较变量的值、 对于引用类型来说，==是b比较两个引用是否相等，equals是比较的引用类型的内容是否相等，而使用equals是需要重写的，不然就是调用object中的equals 动机 值对象一般是基本数据类型，并不在意是否有副本的存在， 引用对象是否相等，直接使用==操作符 什么时候改引用 一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象 类的每个实例中的字段都是独立，就是值类型，每个实例都对应一个字段对象。 引用类型多个实例可以共用一个字段对象。不是所有 怎么改 创建简单工厂和注册表，工厂负责生产字段对象，注册表负责保存所有的字段对象 类实例通过工厂请求字段实例，工厂通过访问注册表返回字段实例引用。 例子 ​ 目前为止customer对象还是值对象，即使多个订单属于同一客户但每个order对象还是拥有自己的customer对象。 使用工厂方法替代构造函数 此时值对象才变成引用对象，多个实例间都共享同一个引用对象 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:3","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"4、将引用对象改成值对象\rChange Reference to value 这边引用对象改成值对象并不是说需要把引用类型改成基本类型，而是即使引用类型是不同副本，那么相同内容的引用内容也是相等（重写Equals()） 动机 如果引用对象开始变得难以使用，或许就应该将它改成值对象。 引用对象必须被某种方式控制，而且必须向其控制者请求适当的引用对象，会造成区域之间错综复杂的关联。 值对象应该是不可变的（无论何时，调用同一个对象的同一个查询函数都应该得到相同的结果），如果需要改变就需要重新创建一个所属类的实例，而不是在现有对象上修改。 什么时候更改 有一个引用对象，很小且不可变，而且不易管理。 怎么更改 检查重构目标是否为不可变对象，建立equals和hashcode方法 new Currency(“USD”).equals(new Currency(“USD”))；返回false。重写equal和hashcode使其返回true，这样对象就是值对象，不可变。 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:4","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"5、以对象取代数组\rReplace Array with Object 动机 数组是常见的组织数据的结构，只用于以某种顺序容纳一组相似对象。 什么时候需要取代 有一个数组，其中的元素各自代表不同的东西 怎么取代 将数组的每个不同意思都抽象称字段 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:5","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"6、复制被监视的数据\rDuplicate Observed Data 动机 一个分层良好的系统，用户界面和处理业务逻辑的代码分开 MVC模式 什么时候需要复制 有一些领域数据置身于GUI控件中，而邻域函数需要访问这些数据 怎么复制 将该数据复制到一个领域对象中，建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:6","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"7、将单向关联改成双向关联\rChange Unidirectional Association to Bidirectional 有点像观察者模式，控制者是订阅端，被控制者是主题，主题存在辅助函数，用于修改反向指针，订阅端调用辅助函数来修改反向指针。 动机 随着项目时间的推移需要双向关联 什么时候改动 两个类都需要使用对方特性，但其间中有一条单向连接 怎么实现 添加一个反向指针，并使修改函数能够同时更新两条连接。 在被引用的类中增加一个字段，保存反向指针。 控制端和被控制端 一对多的关系，可以使用**单一引用的一方(就是多的那一方)**承担控制者的角色。 对象是组成另一对象的部件，该部件负责控制关联关系。 如果两者都是引用对象，多对多，那么无所谓。 在被控端建立一个辅助函数，负责修改反向指针 如果既有的修改函数在控制端，让它负责控制修改反向指针 如果既有的修改函数在被控端，就在控制端建立一个控制函数，并让既有的修改函数调用这个新建的控制函数，来控制修改反向指针。 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:7","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"8、将双向关联改为单向关联\rChange Bidirectional Association to Unidirectional 动机 双向关联必须要符出代价，维护双向关联，确保对象被正确创建和删除而增加的复杂度。 双向关联还会造成僵尸对象，某个对象已经死亡却保留在系统中，因为它的引用还没有完全清楚。 双向关联也会迫使两个类之间有了依赖，对其中任一个类的修改，都可能引发另一个类的变化。 什么时候需要 两个类之间有双向关联，但其中一个类不再需要另一个的特性 怎么修改 去除不必要的关联 将私有字段去掉，需要依赖的函数，将依赖类作为参数传入，然后调用。 创建一个静态字典保存所有的依赖类，通过取值函数来获得字段遍历对比依赖的引用是否相同来获取依赖类。 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:8","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"9、以字面常量取代魔法数\rReplace Magic Number with Symbolic Constant 动机 什么时候取代 有一个字面数值，并带有特别含义 怎么取代 创造一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量。 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:9","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"10、封装字段\rEncapsulate Field 动机 数据声明为public被看做一种不好的做法，会降低模块化程度。 拥有该数据对象却毫无察觉，不是一件好事 什么时候封装 类中存在一个public字段 怎么封装 将原字段声明为private，并提供相应的访问函数 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:10","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"11、封装集合\rEncapsulate Collection 除非通过封装的集合类，不然没有任何实例能够修改这个集合。 动机 在一个类中使用集合并将集合给取值函数，但类不应该返回集合自身，因为这回让用户得以修改集合内容而对集合的使用者一无所知。 不应该为集合提供一个设值函数，但应该为集合添加/移除元素的函数，这样集合的拥有者就可以控制集合元素的添加和移除。 什么时候封装 有一个函数返回一个集合 怎么封装 让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:11","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"12、以数据类取代记录\rReplace Record with Data Class 动机 从数据库读取的记录，需要一个接口类，用来处理这些外来数据。 什么时候做 需要面对传统编程环境中的记录结构 怎么做 为该记录创建一个哑数据对象。 新建一个类，对于记录汇总的每一项数据，在新建的类中建立一个对应的private字段，并提供相应的取值和设值函数。 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:12","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"13、以类取代类型码\rReplace Type Code with Class 原来的类型码可能是int类型，建立一个类型码的类，所有的int转换成类型码的类，其实有点像创建一个枚举类型，然后用枚举类型取代int。 动机 类型码或枚举值很常见，但终究只是一个数值，如果是一个类就会进行类型检验，还可以为这个类提供工厂函数，保证只有合法的实例才会被创建出来。 如果有switch必须使用类型码，但任何switch都应该使用多态取代条件去掉。为了进行这样的重构还需要使用子类取代类型码，用状态或策略替换类型码。 什么时候做 类之中有一个数值类型码，但它并不影响类的行为 怎么做 以一个新的类替换该数值类型码 用以记录类型码的字段，其类型应该和类型码相同，还应该有对应的取值函数，还应该用一组静态变量保存允许被创建的实例，并以一个静态函数根据原本的类型码返回合适的实例。 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:13","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"14、以子类取代类型码\rReplace Type Code with Subclasses 动机 什么时候做 有一个不可变的类型码，它会影响类的行为 如果类型码会影响宿主类的行为，最好的做好就是用多态来处理变化行为。就是switch和if else结构。 类型码值在对象船舰之后发生变化，类型码宿主类已经拥有子类，这两种情况下就需要使用状态/策略设计模式 怎么做 以子类取代这个类型码 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:14","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"15、以State/Strategy取代类型码\rReplace Type Code with State/Strategy 每个状态有特定的数据和动作。 动机 什么时候做 有一个类型码，它会影响类的行为，但无法通过继承手法消除它 怎么做 ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:15","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"16、以字段取代子类\rReplace Subclass with Fields 动机 什么时候做 各个子类的唯一差别只在返回常量数据的函数身上 直接用该字段的不同值表示子类就可以了。 怎么做 修改这些函数，使它们返回超类中某个(新增字段，然后销毁子类) ","date":"2019-11-11","objectID":"/2019/11/designpattern8-refactoring4/:0:16","tags":["重构改善既有代码","重新组织数据"],"title":"重构改善既有代码 重新组织数据","uri":"/2019/11/designpattern8-refactoring4/"},{"categories":"重构改善既有代码","content":"在面向对象的设计中，决定把责任放在哪里。 先使用移动字段，在移动方法 ","date":"2019-11-10","objectID":"/2019/11/designpattern7-refactoring3/:0:0","tags":["重构改善既有代码","在对象之间搬移特性"],"title":"重构改善既有代码 在对象之间搬移特性","uri":"/2019/11/designpattern7-refactoring3/"},{"categories":"重构改善既有代码","content":"1、搬移函数\rMove Method 动机 一个类与另一个类高度耦合，就会搬移函数，通过这种手段，可以使得类更加简单。 什么时候搬移 有个函数与其所属类之外的另一个类有更多的交流。 当不能肯定是否需要移动一个函数，需要继续观察其他函数，先移动其它函数就会使决定变得容易一些。 怎么搬移 检查所有字段，属性和函数，考虑是否应该被搬移 在该函数最常用引用中建立一个有类似行为的新函数 将旧函数变成一个单纯的委托函数，或是将旧函数完全移除。 有多个函数使用这个需要搬移的特性，应考虑使用该特性的所有函数被一起搬移。 检查所有子类和超类，看看是否有该函数其他声明 如果目标函数使用了源类中的特性，可以将源对象的引用当作参数（多个参数或则存在方法需要调用），传给新建立的目标函数。 如果目标函数需要太多源类特性，就得进一步重构，会将目标函数分解并将其中一部分移回源类。 ","date":"2019-11-10","objectID":"/2019/11/designpattern7-refactoring3/:0:1","tags":["重构改善既有代码","在对象之间搬移特性"],"title":"重构改善既有代码 在对象之间搬移特性","uri":"/2019/11/designpattern7-refactoring3/"},{"categories":"重构改善既有代码","content":"2、搬移字段\rMove Field 动机 随着项目类的增加和扩充，有一些字段放在原来的类中已经不太合适 什么时候搬移 某个字段在另一个类中被更多的用到 怎么搬移 修改源字段的所有用户，令它们改用新字段 决定如何在源对象中引用目标对象，方法，新建字段引用 新类中自我封装SetValue, GetValue。 ","date":"2019-11-10","objectID":"/2019/11/designpattern7-refactoring3/:0:2","tags":["重构改善既有代码","在对象之间搬移特性"],"title":"重构改善既有代码 在对象之间搬移特性","uri":"/2019/11/designpattern7-refactoring3/"},{"categories":"重构改善既有代码","content":"3、提炼类*？\rExtract Class 动机 将复合类的职责提炼出新的类 或者需要将类的子类化，分解原来的类 什么时候提炼 某个类做了应该由两个类做的事 怎么提炼 建立一个新类，将相关的字段和函数从旧类搬移到新类 有可能需要一个双向连接， 但是在真正需要它之前，不要建立从新类往旧类的连接，如果建立起双向连接，检查是否可以将它改为单向连接。 ","date":"2019-11-10","objectID":"/2019/11/designpattern7-refactoring3/:0:3","tags":["重构改善既有代码","在对象之间搬移特性"],"title":"重构改善既有代码 在对象之间搬移特性","uri":"/2019/11/designpattern7-refactoring3/"},{"categories":"重构改善既有代码","content":"4、将类内联化\rInline Class 动机 一个类不再承担足够责任，不再由单独存在的理由。 什么时候内联 某个类没有做太多的事情 怎么内联 将这个类是多有特性搬移到另一个类中，然后移除原类 修改所有源类引用点，改而引用目标类 ","date":"2019-11-10","objectID":"/2019/11/designpattern7-refactoring3/:0:4","tags":["重构改善既有代码","在对象之间搬移特性"],"title":"重构改善既有代码 在对象之间搬移特性","uri":"/2019/11/designpattern7-refactoring3/"},{"categories":"重构改善既有代码","content":"5、隐藏“委托关系”\rHide Delegate 局限性是每当客户要使用受托类的新特性时，就必须在服务段添加一个简单委托函数，受托类的特性越来越多，这一过程会越来越痛苦。 简单委托关系 动机 封装意味着每个对象都应该尽可能少的了解系统的其他部分， 如果客户调用对象字段得到另一个对象，然后再调用后者的函数，那么客户就必须知道这一层关系。将委托关系隐藏起来不会波及客户。 什么时候隐藏 客户通过一个委托类来调用另一个对象 怎么隐藏 在服务类上建立客户所需的所有函数，用以隐藏委托关系 manager=john.getDepartment().getManager();隐藏=\u003emanager=john.getManager();隐藏了调用关系。 ","date":"2019-11-10","objectID":"/2019/11/designpattern7-refactoring3/:0:5","tags":["重构改善既有代码","在对象之间搬移特性"],"title":"重构改善既有代码 在对象之间搬移特性","uri":"/2019/11/designpattern7-refactoring3/"},{"categories":"重构改善既有代码","content":"6、移除中间人\rRemove Middle Man 与隐藏委托关系相反 动机 针对隐藏委托的局限性，当委托的方法越来越多时，服务类就完全变成一个中间人，此时应该让客户直接调用受托类。 什么时候移除 某个类做了过多的简单委托动作 怎么移除 让客户直接调用受托类 ","date":"2019-11-10","objectID":"/2019/11/designpattern7-refactoring3/:0:6","tags":["重构改善既有代码","在对象之间搬移特性"],"title":"重构改善既有代码 在对象之间搬移特性","uri":"/2019/11/designpattern7-refactoring3/"},{"categories":"重构改善既有代码","content":"7、引入外加函数\rIntroduce Foreign Method 动机 发现一个好用的工具类不能修改工具类，添加方法 但外加函数终归是权益之计， 什么时候需要引入外加函数 需要为提供服务的类增加一个函数，但无法修改这个类。 怎么引入 在客户类中建立一个函数，并以第一参数形式传入一个服务类实例 ","date":"2019-11-10","objectID":"/2019/11/designpattern7-refactoring3/:0:7","tags":["重构改善既有代码","在对象之间搬移特性"],"title":"重构改善既有代码 在对象之间搬移特性","uri":"/2019/11/designpattern7-refactoring3/"},{"categories":"重构改善既有代码","content":"8、引入本地扩展\rIntroduce Local Extension 动机 在不能修改的类中添加方法，方法的数量超过2个的时候外加函数难以控制，需要将函数组织到一起，通过两种标准对象技术：子类化和包装，子类化和包装叫做本地扩展。 在子类化和包装中优先选择子类， 使用包装会造成A=B，B不等于A的逻辑，子类等于包装类，包装类不等于子类 什么时候引入 需要为服务类提供一些额外函数，但无法修改类。 怎么引入 建立一个新类，使它包含这些额外函数，让这个扩展品成为源类的子类或包装类。 子类化方案，转型构造函数应该调用适当的超类构造函数 包装类方案，转型构造函数应该传入参数以实例变量的形式保存起来，用作接受委托的原对象。 ","date":"2019-11-10","objectID":"/2019/11/designpattern7-refactoring3/:0:8","tags":["重构改善既有代码","在对象之间搬移特性"],"title":"重构改善既有代码 在对象之间搬移特性","uri":"/2019/11/designpattern7-refactoring3/"},{"categories":"重构改善既有代码","content":"对函数的重构方法 ","date":"2019-11-09","objectID":"/2019/11/designpattern6-refactoring2/:0:0","tags":["重构改善既有代码","重新组织函数"],"title":"重构改善既有代码 重新组织函数","uri":"/2019/11/designpattern6-refactoring2/"},{"categories":"重构改善既有代码","content":"1、提炼函数\rExtractMethod 动机 每个函数的颗粒度都比较小，高层函数读起来就像是注释 颗粒度比较小覆写也比较容易 什么时候需要提炼函数 当函数体的语义与函数名称偏离的时候就需要提取 怎么提取 将代码提取出来用函数的意图来命名（做什么） 如果该代码段中有读取或改变临时变量 该临时变量在原函数中有没有使用， 优先考虑用查询取代临时变量 没有直接将临时变量的声明移植到函数体中 在函数体之前使用，作为参数传入 在函数体之后使用，作为函数返回值返回 之前之后都使用，作为参数传入，在作为返回值返回 如果临时变量非常多， 需要考虑这个函数体是否真的属于这个类 以查询替代临时变量 ","date":"2019-11-09","objectID":"/2019/11/designpattern6-refactoring2/:0:1","tags":["重构改善既有代码","重新组织函数"],"title":"重构改善既有代码 重新组织函数","uri":"/2019/11/designpattern6-refactoring2/"},{"categories":"重构改善既有代码","content":"2、内联函数\rInline Method 什么时候需要内联 当函数的本体和名称同样清楚易懂的时候 当有一大群组织不太合理的函数，想重构的时候，将一大群函数内联然后重新提取 有太多的间接层，所有函数似乎都是对另一个函数的简单委托 怎么内联 检查函数，确定它不具有多态。 找出该函数的所有引用点，用函数体替换（最好用文本查找的方式找） ","date":"2019-11-09","objectID":"/2019/11/designpattern6-refactoring2/:0:2","tags":["重构改善既有代码","重新组织函数"],"title":"重构改善既有代码 重新组织函数","uri":"/2019/11/designpattern6-refactoring2/"},{"categories":"重构改善既有代码","content":"3、内联临时变量\rInline Temp 动机 什么时候做 有一个临时变量，只被简单表达式赋值一次，而它妨碍其他重构手法 怎么做 ","date":"2019-11-09","objectID":"/2019/11/designpattern6-refactoring2/:0:3","tags":["重构改善既有代码","重新组织函数"],"title":"重构改善既有代码 重新组织函数","uri":"/2019/11/designpattern6-refactoring2/"},{"categories":"重构改善既有代码","content":"4、以查询取代临时变量*\rReplace Temp with Query 动机 临时变量是暂时的，如果这个临时变量需要被使用多次就考虑需要用查询取代，这边的查询可以直接使用.net中的属性。 临时变量会驱使函数变长，如果变成查询，类中的其他成员也可以访问。 什么时候需要查询取代 用一个临时变量保存其某一表达式的运算结果，需要一个查询函数取代临时变量 怎么取代 需要分解临时变量（临时变量被赋值超过一次），以查询取代临时变量，然后再替换临时变量 首先应该将查询设置为私有的，当日后需要的时候再开放保护。 不用考虑细微的性能问题，因为首先需要良好的架构才能使得程序正常运行。然后再考虑性能问题。 ","date":"2019-11-09","objectID":"/2019/11/designpattern6-refactoring2/:0:4","tags":["重构改善既有代码","重新组织函数"],"title":"重构改善既有代码 重新组织函数","uri":"/2019/11/designpattern6-refactoring2/"},{"categories":"重构改善既有代码","content":"5、引入解释性变量\rIntroduce Explaining Variable 在引入解释性变量之后，可以使用导出方法或者用查询取代临时变量将临时变量替换掉。 动机 使得复杂表达式可以阅读和管理 什么时候需要引入 有一个复杂的表达式 怎么引入 讲一个复杂表达式（或一部分）的结果放进一个临时变量，以此变量名称来解释表达式的用途 与提炼函数的区别 再提炼函数需要花费更大的工作量的时候 ","date":"2019-11-09","objectID":"/2019/11/designpattern6-refactoring2/:0:5","tags":["重构改善既有代码","重新组织函数"],"title":"重构改善既有代码 重新组织函数","uri":"/2019/11/designpattern6-refactoring2/"},{"categories":"重构改善既有代码","content":"6、分解临时变量\rSplit Temporary Variable 动机 如果一个临时变量承担太多的职责，会使得阅读者糊涂 什么时候分解 程序中有某个临时变量被赋值超过一次，它既不是循环变量也不是收集计算结果。 怎么分解 修改临时变量的名称并声明为常量 ","date":"2019-11-09","objectID":"/2019/11/designpattern6-refactoring2/:0:6","tags":["重构改善既有代码","重新组织函数"],"title":"重构改善既有代码 重新组织函数","uri":"/2019/11/designpattern6-refactoring2/"},{"categories":"重构改善既有代码","content":"7、移除对参数的赋值*\rRemove Assignments to Parameters 这边的是针对函数参数体成员 对参数的赋值的想法是比较危险的，一旦为参数进行赋值如果混淆值类型和引用类型非常容易产生不易察觉的错误。 动机 因为面向对象的方式，所以数值类型的改变并不会改变原来传入的值，但是引用类型就会变化 导致混用按值传递和按引用传递 什么时候移除 代码对函数的一个参数进行赋值时 怎么移除 通过建立一个临时变量，对临时变量进行修改，然后返回临时变量。 如果需要返回一大堆函数，可以将返回的一大堆函数变成一个单一的对象，或者为每个返回值设置一个独立函数。 还可以在函数的每个参数中增加一个const，这个方法只是在函数体较长的时候才可以使用。 ","date":"2019-11-09","objectID":"/2019/11/designpattern6-refactoring2/:0:7","tags":["重构改善既有代码","重新组织函数"],"title":"重构改善既有代码 重新组织函数","uri":"/2019/11/designpattern6-refactoring2/"},{"categories":"重构改善既有代码","content":"8、以函数对象取代函数\rReplace Method with Method Object 动机 小型函数优美动人 什么时候取代 有一个大型函数，对其中的局部变量的使用无法采用提炼方法的手段 怎么提取 建立一个新类，将所有的局部变量变成字段，然后将原函数体中的逻辑变成方法。 ","date":"2019-11-09","objectID":"/2019/11/designpattern6-refactoring2/:0:8","tags":["重构改善既有代码","重新组织函数"],"title":"重构改善既有代码 重新组织函数","uri":"/2019/11/designpattern6-refactoring2/"},{"categories":"重构改善既有代码","content":"9、替换算法\rSubstitute Algorithm 动机 发现一个算法的效率更高的时候 什么时候替换 想法把某个算法换成另一个更为清晰的算法 ","date":"2019-11-09","objectID":"/2019/11/designpattern6-refactoring2/:0:9","tags":["重构改善既有代码","重新组织函数"],"title":"重构改善既有代码 重新组织函数","uri":"/2019/11/designpattern6-refactoring2/"},{"categories":"重构改善既有代码","content":" 第一次做某件事情的时候尽管去做，第二次做类似的事会产生反感，第三次再做类似的事，你就应该重构。 小型函数优美动人 一个类最好是常量类，任何的改变都是调用该类本身的接口实现。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:0:0","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"0 坏代码的味道\r","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:0","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"1、重复代码\rDuplicated Code 同一类中的两个函数含有相同的表达式，提取到方法 互为兄弟的子类含有相同表达式，将两个子类的相同代码提取方法推入超类 如果有相似代码，通过提炼方法将相似和差异部分分割开，并使用疏凿模板方法，并将模板方法上移到超类中。 如果两个毫不相关的类出现重复代码，将重复代码提炼到一个提炼类中，两个类都使用这个提炼类。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:1","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"2、过长函数\rLong Method 间接层所能带来的全部利益——解释能力、共享能力、选择能力 小函数的价值是巨大的 每当感觉需要注释来说明什么的时候，就需要把说明的东西写进一个独立函数中，并以其用途命名。 函数内有大量的临时变量和参数。需要运用提炼方法，可以将临时变量作为参数传入，也可以使用以查询替代临时变量，当方法参数特别多的时候可以提炼参数类，传递参数类实体。如果这么做还有很多的参数，那么就应该用方法对象来取代方法了。 选择提炼哪一段代码 寻找注释，有注释的地方都在提醒你需要提炼方法了，注释名称就是很好的方法名 条件表达式和循环也是型号，可以用 分解条件表达式，循环应该将循环中的代码提炼到独立函数中。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:2","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"3、过大的类\rLarge Class 如果单个类做太多是事情，往往会导致出现太多的实例变量，一旦如此，重复代码就接踵而至了。 可以使用提炼类将几个变量和方法提炼出来，如果数个变量存在着相同的前缀或字尾，就以为着有机会可以把它们提炼到某个组件中。如果这个组件适合一个子类，还可以使用提炼子类。 如果一个拥有太多代码，可以先确定客户端如何使用它们，然后运用提炼接口，为每一种使用方法提炼出一个接口，这可以看清楚如何分解这个类。 如果超大类是一个GUI类，可以把数据和行为移到一个独立的领域对象去，可能需要两边保留一些重复代码，并保持两边同步。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:3","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"4、过长的参数列\rLong Parameter List 如果向已有的对象发出一条请求就可以取代一个参数，那么就可以使用用方法取代参数方法。 还可以使用保持整个对象，传递整个对象， 提炼参数对象 造成函数关联需要慎重考虑 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:4","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"5、发散式变化\rDivergent Chane 软件再怎么说就应该是软的，一旦需要修改，希望能够跳到系统的某一点，只在该处做修改。如果不能的化就有一种刺鼻味道了。 某个类经常因为不同原因在不同不同方向上发生变化发散式变化就出现了， 一旦出现这种发散式变化那么就需要将对象分解成多个对象或者会更好，当出现多个类后还可以提炼超类等。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:5","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"6、霰弹式修改\rShotgun Surgery 正对某一项变化需要在许多不同类种做出需要小修改，所面临的味道就是霰弹式修改， 这种情况应该使用移动方法和移动字段，把所有修改的代码放进同一个类，如果没有现存的类可以按值这些代码就创造一个，使用内联类可以将一系列相关行为放进同一个类。 这也可能造成少量的发散式变化， ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:6","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"7、依恋情结\rFeature Envy 对象技术的全部要点在于：这是一种将数据和对数据的操作行为包装在一起的技术，有一中经典的气味是:函数对某个类的兴趣高于对自己所处类的兴趣。 使用移动方法把某些方法移动带它该去的地方，有的时候还需要提炼方法 如果某个函数需要需要几个类的功能，判断哪个类拥有最多被此函数使用的数据，然后就把这个函数和那些数据摆在一起，可以先将函数分解成多个较小函数分别置于不同地点。 将总是一起变化的东西放在一块，数据和引用这些数据的行为总是一起变化的。 策略和访问者模式可以轻松修改函数行为，付出了多一层的代价 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:7","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"8、数据泥团\rData Clumps 数据项会成群结队出现。 如果删除总舵数据中的一项，其他数据有没有失去意义，如果它们不再有意义，就是一个明确的信号，应该产生一个新对象。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:8","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"9、基本类型偏执\rPrimitive Obsession 结构类型允许你将数据组织成有意义的形式，对象的极大价值在于打破了横亘于基本数据和较大类之间的界限。 积极的使用使用对象替换数据值，用类替换类型码，用状态/策略模式替代类型码 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:9","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"10、swithc惊悚现身\rSwitch Statements 面向对象程序的最明显特征就是少用switch，使用switch的问题在于重复，在修改上，如果switch散布于不同地点，就要添加新的case子句 如果看到switch语句的时候需要考虑用多态来替换它，问题在于多态出现在哪儿 使用提炼函数将switch提炼到独立函数中，再用移动方法将它搬移到需要多态性的类中，用子类替代类型码或者使用state/strategy替代类型码，完成之后再用使用多态替代条件。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:10","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"11、平行继承体系\rParallel Inheritance Hierarchies 如果为某个类增加一个子类的时候必须要为另一类相应增加一个子类。 如果某个继承体系的类名称前缀和两一个继承体系的类的名称前缀完全相同 让一个继承体系的实例引用另一个继承体系的实例，再使用移动方法和字段，就可以将引用端的继承体系消除。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:11","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"12、冗赘类\rLazy Class 创建的每个类都有人去理解它维护它，如果一个类不值得其身价就应该消失。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:12","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"13、夸夸其谈的未来性\rSpeculative Generality 总有一天需要做这件事，企图以各式各样的勾子和特殊情况来处理一些非必要事情会造成程序难以理解。不需要 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:13","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"14、令人迷惑的暂时字段\rTemporary Field 某个实例变量仅为某种特定情况而设置。 使用提炼类给这些孤儿创造一个家，然后把所有和这个变量相关的代码都放进这个新家，还可以使用空对象方法创建一个空对象。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:14","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"15、过度耦合的消息链\rMessage Chains 一个对象请求一个对象，然后后者请求另一个对象，等等 使用隐藏委托。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:15","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"16、中间人\rMiddle Man 对象的基本特征之一就是封装，对外部世界隐藏内部细节，封装往往伴随着委托，但有可能过度使用委托，移除中间人 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:16","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"17、狎昵关系\rInappropriate Intimacy 两个类过于亲密，移动方法和字段让他们划清界限。如果划清不了就使用提炼类让他们融为一体吧 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:17","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"18、异曲同工类\rAlternative Classes with Different Interfaces 重命名方法，提炼子类 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:18","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"19、不完美的库类\rIncomplete Library Class 给库类加入新的方法，外部方法和本地扩展。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:19","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"20、纯稚的数据类\rData Class 不会说话的数据容器一定被其他类过分的操控着，运用封装字段封装，移动设置方法，移动方法，提炼方法。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:20","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"21、被拒绝的遗赠\rRefused Bequest 子类不愿全部继承，为这个子类创建一个兄弟类，在运用下移方法和字段把用不到的函数下推给那个兄弟，这样一来，超类就只持有所有子类共享的东西。 用委托替换继承 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:21","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"重构改善既有代码","content":"22、过多注释\rComments 提炼方法。 ","date":"2019-11-08","objectID":"/2019/11/designpattern5-refactoring1/:1:22","tags":["重构改善既有代码","坏代码的味道"],"title":"重构改善既有代码 坏代码的味道","uri":"/2019/11/designpattern5-refactoring1/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 要成功将Prism应用程序移植到生产环境中，您需要计划部署作为应用程序设计过程的一部分。本主题介绍了为部署准备组合或模块化应用程序所需执行的注意事项和操作，以及为将应用程序提供给用户所需执行的操作。 ","date":"2019-07-06","objectID":"/2019/07/prism14-deploying/:0:0","tags":["Prism","Deploying"],"title":"Prism Deploying","uri":"/2019/07/prism14-deploying/"},{"categories":"Prism","content":"部署应用程序\rWPF Prism应用程序可以由可执行文件和任意数量的附加DLL组成。主要的可执行文件是shell应用程序项目。一些额外的DLL将是应用程序的模块。可能有一些额外的DLL只是应用程序的shell和模块使用的共享程序集。此外，您可能拥有一组与应用程序一起部署的资源或内容文件。 要部署WPF Prism应用程序，您有三种选择： “XCopy部署” ClickOnce部署 Windows Installer部署 “XCopy部署”用作通过某种文件复制操作进行手动部署的通用术语，可能包括也可能不包括使用XCOPY命令行工具。如果选择以这种方式部署应用程序，则由您手动打包文件并将其移动到目标计算机。只要保持shell应用程序可执行文件，模块DLL和内容文件的预期文件夹结构和相对位置，应用程序就可以运行了。 通常，需要更自动的部署方式，以确保将事物放置在正确的位置，并且用户可以轻松访问以运行应用程序。为方便起见，您可以选择使用ClickOnce或Windows Installer（.msi文件），具体取决于应用程序存在哪些其他安装要求。 是否使用ClickOnce或Windows Installer的决定经常被误解。ClickOnce并非旨在成为一种通用的部署技术。它适用于需要在客户端计算机上进行低影响安装的应用程序。如果您的应用程序需要在安装时进行计算机范围的更改 - 例如安装驱动程序，与其他应用程序集成，安装服务以及超出仅运行可执行文件范围的其他内容，则ClickOnce可能不是适当的部署选择。但是，如果您在客户端计算机上进行了轻量级安装，并且希望从WPF应用程序的网络部署和更新中受益，则ClickOnce可能是一个很好的选择。 要为应用程序创建Windows Installer部署包（.msi文件），您有多种选择，包括Visual Studio安装项目，Windows Installer XML（WiX）项目或众多第三方安装程序创建产品。 ","date":"2019-07-06","objectID":"/2019/07/prism14-deploying/:0:1","tags":["Prism","Deploying"],"title":"Prism Deploying","uri":"/2019/07/prism14-deploying/"},{"categories":"Prism","content":"使用ClickOnce部署WPF Prism应用程序\rClickOnce是Windows Presentation Foundation（WPF）或Windows Forms部署机制，自2.0版以来一直是.NET Framework的一部分。ClickOnce支持从部署服务器通过网络自动部署和更新WPF应用程序。WPF Prism应用程序可以使用ClickOnce来获取部署到客户端计算机的shell，模块和任何其他依赖项。Prism应用程序的主要挑战是ClickOnce的Visual Studio发布过程不会自动在已发布的应用程序中包含动态加载的模块。 使用ClickOnce部署WPF应用程序需要两个步骤。首先，您必须从Visual Studio发布应用程序，然后才能将其部署到客户端计算机。发布应用程序会生成两个清单（部署清单和应用程序清单），并将应用程序文件复制到发布目录。然后可以将该发布文件夹移动到可能无法从开发者计算机直接访问的另一服务器，以使得已发布的应用程序可从已知位置和URL访问客户端计算机。将应用程序部署到客户端计算机只需要提供用户可以导航到的URL或链接。URL指向发布部署服务器上的部署清单。在浏览器中加载该URL时 客户端计算机上的ClickOnce下载清单指定的清单和应用程序文件。下载文件并将其存储在用户配置文件下后，ClickOnce然后启动该应用程序。如果将后续更新发布到部署服务器，ClickOnce可以自动检测这些更新，下载并应用它们，或者有一些设置允许您在应用程序启动后按需或在后台检测和应用更新。 当您发布具有动态加载模块的WPF Prism应用程序时，shell项目通常不会对动态加载的模块具有项目引用。因此，发布的ClickOnce应用程序清单也不包含这些模块文件，如果使用ClickOnce部署应用程序，则客户端计算机将无法获取模块文件。要解决此问题，您必须修改应用程序清单以包含shell应用程序项目未引用的模块文件。 ","date":"2019-07-06","objectID":"/2019/07/prism14-deploying/:0:2","tags":["Prism","Deploying"],"title":"Prism Deploying","uri":"/2019/07/prism14-deploying/"},{"categories":"Prism","content":"ClickOnce发布流程\r您可以使用名为Manifest Generating and Editing工具（Mage）的Windows软件开发工具包（SDK）工具或使用ClickOnce发布API的自定义工具从Visual Studio 2013发布ClickOnce应用程序。Visual Studio公开了ClickOnce发布所需的大部分功能。但是，对于管理服务器上的ClickOnce部署的IT管理员，可能无法使用或不需要Visual Studio。Mage旨在解决ClickOnce的大多数常见管理任务; 它是一个轻量级的.NET Framework基于Windows的应用程序，可以提供给您的管理员。但是，Mage需要太多详细步骤（按正确顺序执行）才能成功完成常见任务，例如修改应用程序清单中列出的应用程序文件。为了使这些任务更简单， Manifest Manager Utility示例实用程序演示了如何使用ClickOnce发布API以更简单的方式管理部署和应用程序清单。此实用程序用于在单个用户界面（UI）中更新应用程序清单文件列表和部署清单设置，本主题后面的部分将介绍其用法，以便初步部署和更新Prism应用程序。Manifest Manager Utility使用Microsoft.Build.Tasks.Deployment命名空间中公开的API 来加载，操作和保存ClickOnce部署的已修改清单文件。您可以下载Manifest Manager Utility来自Codeplex的Prism社区网站。要了解发布和更新使用动态模块加载的WPF Prism应用程序所涉及的具体步骤，请参阅WPF Prism部署动手实验：使用ClickOnce发布和更新。 下图显示了ClickOnce应用程序发布的典型结构，基于Visual Studio在使用ClickOnce发布应用程序时生成部署文件夹的方式。它包含应用程序的根文件夹，其中包含默认部署清单（.application文件）。默认部署清单通常指向Visual Studio生成的最近发布的版本，但可以将其更改为指向管理员选择的任何版本。根文件夹还包含Setup.exe引导程序，它允许您在使用ClickOnce部署应用程序之前部署可能需要运行安装程序或可执行文件的应用程序的先决条件。然后有一个特定于应用程序的文件的子文件夹，在其下为您发布的每个版本获取单独的子文件夹。发布版本是部署清单文件中的单独项目设置和条目，用于对部署作为整体进行版本控制，而不是包含的程序集的各个程序集版本。ClickOnce使用发布版本来确定何时可以从已安装ClickOnce应用程序的客户端获得更新。 ","date":"2019-07-06","objectID":"/2019/07/prism14-deploying/:0:3","tags":["Prism","Deploying"],"title":"Prism Deploying","uri":"/2019/07/prism14-deploying/"},{"categories":"Prism","content":"ClickOnce发布文件夹结构\r在每个发布版本的应用程序文件文件夹下，您拥有可用于将特定版本部署到客户端计算机的部署清单（.application文件）的另一个副本，或者可以将其复制到根文件夹以导致服务器端回滚到以前的版本。除了任何依赖库（例如Prism模块程序集）和资源文件之外，应用程序可执行文件也将位于此文件夹中，并且在由Visual Studio发布时将自动以.deploy文件扩展名为后缀。这样做是为了简化发布Web服务器上的文件扩展名映射，这样您就不必下载.dll，.exe以及组成应用程序的大量其他潜在文件类型。 应用程序清单（.exe.manifest）文件也包含在此文件夹中，并由部署清单引用。它包含应用程序组成的文件列表，每个文件都有哈希值，以帮助进行变更检测; 它还包含应用程序运行所需的权限列表，因为如果需要，ClickOnce可以在部分信任AppDomain中启动应用程序。 如果使用Mage或自定义工具手动生成或更新ClickOnce应用程序发布，则不限于此文件夹和文件结构。对于任何特定的ClickOnce发布，依赖链包括以下内容： 它包括一个部署清单，通过嵌入的代码库URL指向应用程序清单。 它包括一个应用程序清单，其中包含每个应用程序文件的相对路径。这些文件必须位于应用程序清单所在的同一文件夹或子文件夹中。 它包括应用程序文件本身，通常在文件名后附加.deploy文件扩展名，以简化将这些文件映射到部署服务器上的MIME类型。下载文件后，ClickOnce会自动剥离客户端上的.deploy文件扩展名。 ","date":"2019-07-06","objectID":"/2019/07/prism14-deploying/:0:4","tags":["Prism","Deploying"],"title":"Prism Deploying","uri":"/2019/07/prism14-deploying/"},{"categories":"Prism","content":"ClickOnce部署和更新过程\r通过ClickOnce将应用程序实际部署到用户几乎总是通过在部署服务器上提供已发布应用程序的部署清单的URL或超链接来启动。用户可以单击超链接或在浏览器中输入地址，并调用ClickOnce部署过程。将清单和应用程序文件下载到客户端计算机后，将启动该应用程序。有一些ClickOnce选项允许您在初始部署期间安装应用程序以供脱机使用，或者您可以要求用户每次都使用链接或URL启动应用程序。将新版本的应用程序发布到部署服务器时，ClickOnce可以自动或手动检查更新，并在下次启动应用程序时下载并应用更新。 ","date":"2019-07-06","objectID":"/2019/07/prism14-deploying/:0:5","tags":["Prism","Deploying"],"title":"Prism Deploying","uri":"/2019/07/prism14-deploying/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 在构建大型复杂WPF应用程序时，常见的方法是将功能划分为离散模块程序集。还希望最小化这些模块之间静态引用的使用，这可以通过使用委托命令，区域上下文，共享服务和事件聚合器来实现。这允许模块被独立地开发，测试，部署和更新，并且它迫使松散耦合的通信。本主题提供有关何时使用委托命令和路由命令以及何时使用事件聚合器和.NET框架事件的指导。 在模块之间进行通信时，了解方法之间的差异非常重要，这样您才能最好地确定在特定方案中使用哪种方法。Prism Library提供以下通信方法： 解决方案指挥。在期望用户交互立即采取行动时使用。 地区背景。使用此选项可在主机区域中的主机和视图之间提供上下文信息。这种方法有点类似于DataContext，但它不依赖于它。 共享服务。呼叫者可以在服务上调用一种方法，该方法将事件引发给消息的接收者。如果以上都不适用，请使用此选项。 事件聚合。用于在没有直接的动作反应期望的情况下跨视图模型，演示者或控制器进行通信。 ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:0","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"Solution Commanding\r如果您需要响应用户手势，例如单击命令调用程序（例如，按钮或菜单项），并且您希望基于业务逻辑启用调用程序，请使用命令。 Windows Presentation Foundation（WPF）提供RoutedCommand，它擅长将命令调用程序（如菜单项和按钮）与命令处理程序连接，命令处理程序与具有键盘焦点的可视树中的当前项相关联。 但是，在复合方案中，命令处理程序通常是视图模型，在可视树中没有任何关联元素，或者不是焦点元素。为了支持这种情况，Prism库提供了DelegateCommand，它允许您在执行命令时调用委托方法，而CompositeCommand允许您组合多个命令**。这些命令与内置的RoutedCommand不同**，后者将在可视树上上下路由命令执行和处理。这允许您在可视树中的某个点触发命令并在更高级别处理它。 该CompositeCommand是一个实现ICommand的，以便它可以被绑定到调用者。CompositeCommands可以连接到几个子命令; 调用CompositeCommand时，也会调用子命令。 CompositeCommands支持启用。CompositeCommands侦听每个连接命令的CanExecuteChanged事件。然后它会引发此事件通知其调用者。调用者通过在CompositeCommand上调用CanExecute来对此事件做出反应。然后，CompositeCommand通过在每个子命令上调用CanExecute来再次轮询其所有子命令。如果对CanExecute的任何调用返回false，则CompositeCommand将返回false，从而禁用调用者。 这对于跨模块通信有何帮助？基于Prism库的应用程序可能具有在shell中定义的全局CompositeCommands，它们具有跨模块的含义，例如Save，Save All和Cancel。然后，模块可以使用这些全局命令注册其本地命令并参与其执行。 注意： DelegateCommand和CompositeCommand*可以在Prism.Commands命名空间中找到，该命名空间位于Prism.Core NuGet包中。* 关于WPF路由事件和路由命令 路由事件是一种事件，可以在元素树中的多个侦听器上调用处理程序，而不是仅通知直接订阅该事件的对象。WPF路由命令通过可视树中的UI元素传递命令消息，但树外的元素将不会接收这些消息，因为它们仅从聚焦元素或明确声明的目标元素向上或向下冒泡。路由事件可用于通过元素树进行通信，因为事件的事件数据会持续到路由中的每个元素。一个元素可能会更改事件数据中的某些内容，并且该更改可用于路径中的下一个元素。 因此，您应该在以下方案中使用WPF路由事件：在公共根目录中定义公共处理程序或定义您自己的自定义控件类。 ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:1","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"创建委托命令\r要创建委托命令，请在视图模型的构造函数中实例化DelegateCommand字段，然后将其作为ICommand属性公开。 // ArticleViewModel.cs public class ArticleViewModel : BindableBase { private readonly ICommand showArticleListCommand; public ArticleViewModel(INewsFeedService newsFeedService, IRegionManager regionManager, IEventAggregator eventAggregator) { this.showArticleListCommand = new DelegateCommand(this.ShowArticleList); } public ICommand ShowArticleListCommand { get { return this.showArticleListCommand; } } } ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:2","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"创建复合命令\r要创建复合命令，请在构造函数中实例化CompositeCommand字段，向其中添加命令，然后将其作为ICommand属性公开。 public class MyViewModel : BindableBase { private readonly CompositeCommand saveAllCommand; public ArticleViewModel(INewsFeedService newsFeedService, IRegionManager regionManager, IEventAggregator eventAggregator) { this.saveAllCommand = new CompositeCommand(); this.saveAllCommand.RegisterCommand(new SaveProductsCommand()); this.saveAllCommand.RegisterCommand(new SaveOrdersCommand()); } public ICommand SaveAllCommand { get { return this.saveAllCommand; } } } ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:3","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"使命令在全球范围内可用\r通常，要创建全局可用命令，请创建DelegateCommand或CompositeCommand的实例，并通过静态类公开它。 public static class GlobalCommands { public static CompositeCommand MyCompositeCommand = new CompositeCommand(); } 在您的模块中，将子命令与全局可用命令相关联。 GlobalCommands.MyCompositeCommand.RegisterCommand(command1); GlobalCommands.MyCompositeCommand.RegisterCommand(command2); ***注意：*要提高代码的可测试性，可以使用代理类访问全局可用的命令并在测试中模拟该代理类。 ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:4","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"绑定到全局可用命令\r以下代码示例演示如何将按钮绑定到WPF中的命令。 \u003cButton Name=\"MyCompositeCommandButton\" Command=\"{x:Static local:GlobalCommands.MyCompositeCommand}\"\u003eExecute My Composite Command\u003c/Button\u003e 注意：另一种方法是将命令作为资源存储在Application.Resources部分的App.xaml文件中。然后，在视图中 - 必须在设置该资源后创建 - 您可以设置*Command =“{Binding MyCompositeCommand，Source = {StaticResource GlobalCommands}}”*以向命令添加调用者。 ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:5","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"Region Context\r在很多情况下，您可能希望在托管区域的视图和区域内的视图之间共享上下文信息。例如，类似主细节的视图显示业务实体并公开区域以显示该业务实体的其他详细信息。Prism Library使用名为RegionContext的概念来共享区域主机与区域内加载的任何视图之间的对象，如下图所示。 根据具体情况，您可以选择共享单条信息（例如标识符）或共享模型。视图可以检索RegionContext，然后注册更改通知。视图还可以更改RegionContext的值。有几种方法可以公开和使用RegionContext： 您可以将RegionContext公开给可扩展应用程序标记语言（XAML）中的区域。 您可以将RegionContext公开给代码中的区域。 您可以从区域内的视图中使用RegionContext。 注意：如果该视图是DependencyObject，则Prism Library当前仅支持从区域内的视图中使用RegionContext*。如果您的视图不是DependencyObject（例如，您正在使用WPF自动数据模板并直接在区域中添加视图模型），请考虑创建自定义RegionBehavior以将RegionContext转发到视图对象。* 关于数据上下文属性 数据上下文是一种允许元素从其父元素继承有关用于绑定的数据源的信息的概念。子元素自动继承其父元素的DataContext。数据沿着可视化树向下流动。 ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:6","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"共享服务\r跨模块通信的另一种方法是通过共享服务。加载模块后，模块会将其服务添加到服务定位器。通常，通过公共接口类型从服务定位器注册和检索服务。这允许模块使用其他模块提供的服务，而无需对模块进行静态引用。服务实例在模块之间共享，因此您可以共享数据并在模块之间传递消息。 在Stock Trader参考实施（Stock Trader RI）中，Market模块提供了IMarketFeedService的实现。Position模块通过使用shell应用程序的依赖注入容器来使用这些服务，该容器提供服务位置和解析。所述IMarketFeedService是指由其他模块被消耗，因此它可以在找到StockTraderRI.Infrastructure共同组装，但该接口的具体实现并不需要被共享的，所以它是市场模块中直接定义，并且可以是独立于其他模块更新。 要查看这些服务如何导出到MEF，请参阅MarketFeedService.cs和MarketHistoryService.cs文件，如以下代码示例所示。Position模块的ObservablePosition通过构造函数依赖注入接收IMarketFeedService服务。 // MarketFeedService.cs [Export(typeof(IMarketFeedService))] [PartCreationPolicy(CreationPolicy.Shared)] public class MarketFeedService : IMarketFeedService, IDisposable { ... } 这有助于跨模块通信，因为服务使用者不需要对提供服务的模块的静态引用。此服务可用于在模块之间发送或接收数据。 注意：某些依赖项注入容器允许使用属性注册依赖项，如此示例所示。其他容器可以使用显式注册。在这些情况下，注册通常在模块加载期间发生，此时Prism调用IModule.Initialize方法。有关更多信息，请参阅模块化应用程序开 ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:7","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"Event Aggregation\rPrism库提供了一种事件机制，可以在应用程序中松散耦合的组件之间进行通信。该机制基于事件聚合器服务，允许发布者和订阅者通过事件进行通信，但仍然没有彼此直接引用。 该EventAggregator提供组播发布/订阅功能。这意味着可以有多个发布者引发相同的事件，并且可以有多个订阅者收听同一事件。考虑使用EventAggregator跨模块发布事件，以及在业务逻辑代码（如控制器和演示者）之间发送消息时。 Stock Trader RI的一个例子就是点击Process Order按钮并顺序处理订单; 在这种情况下，其他模块需要知道订单已成功处理，以便他们可以更新他们的视图。 使用Prism Library创建的事件是键入的事件。这意味着您可以在运行应用程序之前利用编译时类型检查来检测错误。在Prism库中，EventAggregator允许订阅者或发布者定位特定的EventBase。事件聚合器还允许多个发布者和多个订阅者，如下图所示。 关于.NET Framework事件 如果不要求松散耦合，则使用.NET Framework事件是组件之间通信的最简单，最直接的方法。.NET Framework中的事件实现了Publish-Subscribe模式，但是要订阅对象，您需要直接引用该对象，在复合应用程序中，该对象通常驻留在另一个模块中。这导致紧密耦合的设计。因此，.NET Framework事件用于模块内的通信，而不是模块之间的通信。 如果使用.NET Framework事件，则必须非常小心内存泄漏，尤其是如果您有一个非静态或短期组件，它可以在静态或长寿命的事件上订阅事件。如果您没有取消订阅订阅者，则发布者将保留该订阅者，这将阻止第一个订阅者被垃圾收集。 ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:8","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"IEventAggregator\r所述EventAggregator类被提供作为在容器中的服务，并且可以通过检索IEventAggregator接口。事件聚合器负责定位或构建事件以及保留系统中事件的集合。 public interface IEventAggregator { TEventType GetEvent\u003cTEventType\u003e() where TEventType : EventBase; } 该EventAggregator构建事件在其第一次访问，如果它尚未建立。这使发布者或订阅者无需确定事件是否可用。 ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:9","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"PubSubEvent\r连接发布者和订阅者的真正工作是由PubSubEvent类完成的。这是Prism库中包含的EventBase类的唯一实现。此类维护订户列表并处理订阅者的事件调度。 所述PubSubEvent类是一个一般类，需要将其定义为一般类型的有效载荷类型。这有助于在编译时强制发布者和订阅者提供成功事件连接的正确方法。以下代码显示了PubSubEvent类的部分定义。 注意： PubSubEvent可以在Prism.Events命名空间中找到，该命名空间位于Prism.Core NuGet包中。 // PubSubEvent.cs public class PubSubEvent\u003cTPayload\u003e : EventBase { ... public SubscriptionToken Subscribe(Action\u003cTPayload\u003e action); public SubscriptionToken Subscribe(Action\u003cTPayload\u003e action, ThreadOption threadOption); public SubscriptionToken Subscribe(Action\u003cTPayload\u003e action, bool keepSubscriberReferenceAlive) public SubscriptionToken Subscribe(Action\u003cTPayload\u003e action, ThreadOption threadOption, bool keepSubscriberReferenceAlive) public virtual SubscriptionToken Subscribe(Action\u003cTPayload\u003e action, ThreadOption threadOption, bool keepSubscriberReferenceAlive); public virtual SubscriptionToken Subscribe(Action\u003cTPayload\u003e action, ThreadOption threadOption, bool keepSubscriberReferenceAlive, Predicate\u003cTPayload\u003e filter); public virtual void Publish(TPayload payload); public virtual void Unsubscribe(Action\u003cTPayload\u003e subscriber); public virtual bool Contains(Action\u003cTPayload\u003e subscriber) ... } ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:10","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"创建和发布事件\r以下各节介绍如何创建，发布和订阅PubSubEvent使用IEventAggregator接口。 创建一个事件\r所述**PubSubEvent **旨在是为应用程序或模块的特定事件的基类。TPayLoad是事件有效负载的类型。有效负载是在事件发布时将传递给订阅者的参数。 例如，以下代码显示了股票交易者参考实现（Stock Trader RI）中的TickerSymbolSelectedEvent。有效负载是包含公司符号的字符串。请注意此类的实现是如何为空。 public class TickerSymbolSelectedEvent : PubSubEvent\u003cstring\u003e{} 注意：在复合应用程序中，事件通常在多个模块之间共享，因此它们在公共位置定义。在Stock Trader RI中，这是在StockTraderRI.Infrastructure项目中完成的。 发布活动\r发布者通过从EventAggregator检索事件并调用Publish方法来引发事件。要访问EventAggregator，可以通过向类构造函数添加类型为IEventAggregator的参数来使用依赖项注入。 以下代码演示了如何发布TickerSymbolSelectedEvent。 this.eventAggregator.GetEvent\u003cTickerSymbolSelectedEvent\u003e().Publish(\"STOCK0\"); ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:11","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"订阅活动\r订阅者可以使用PubSubEvent类上提供的一个Subscribe方法重载来登记事件。有几种方法可以订阅PubSubEvents。使用以下标准来帮助确定最适合您需求的选项： 如果您需要能够在收到事件时更新UI元素，请订阅以在UI线程上接收事件。 如果您需要过滤事件，请在订阅时提供过滤器委托。 如果您对事件有性能问题，请考虑在订阅时使用强引用的委托，然后手动取消订阅PubSubEvent。 如果以上都不适用，请使用默认订阅。 以下部分描述了这些选项。 订阅UI线程\r订阅者通常需要更新UI元素以响应事件。在WPF中，只有UI线程可以更新UI元素。 默认情况下，订阅者在发布者的线程上接收事件。如果发布者从UI线程发送事件，则订阅者可以更新UI。但是，如果发布者的线程是后台线程，则订阅者可能无法直接更新UI元素。在这种情况下，订户需要使用Dispatcher类在UI线程上安排更新。 Prism Library提供的PubSubEvent可以通过允许订阅者在UI线程上自动接收事件来提供帮助。订阅者在订阅期间指示此信息，如以下代码示例所示。 public void Run() { ... this.eventAggregator.GetEvent\u003cTickerSymbolSelectedEvent\u003e().Subscribe(ShowNews, ThreadOption.UIThread); ); } public void ShowNews(string companySymbol) { this.articlePresentationModel.SetTickerSymbol(companySymbol); } ThreadOption有以下选项： PublisherThread。使用此设置可在发布商的主题上接收活动。这是默认设置。 BackgroundThread。使用此设置在.NET Framework线程池线程上异步接收事件。 UIThread。使用此设置可在UI线程上接收事件。 注意：为了让PubSubEvents在UI线程上发布给订阅者，必须首先在UI线程上构造EventAggregator*。* 订阅过滤\r订阅者可能不需要处理已发布事件的每个实例。在这些情况下，订户可以使用过滤器参数。的滤波器参数的类型的**System.Predicate **和是当事件被发布，以确定是否已发布的事件的有效载荷的一组具有调用的回调订户要求的标准相匹配的被执行的委托。如果有效负载不满足指定的条件，则不执行订户回调。 通常，此过滤器作为lambda表达式提供，如以下代码示例所示。 FundAddedEvent fundAddedEvent = this.eventAggregator.GetEvent\u003cFundAddedEvent\u003e(); fundAddedEvent.Subscribe(FundAddedEventHandler, ThreadOption.UIThread, false, fundOrder =\u003e fundOrder.CustomerId == this.customerId); 注：该订阅方法返回类型的订阅令牌Prism.Events.SubscriptionToken*可用于以后删除订阅的事件。当您使用匿名委托或lambda表达式作为回调委托时，或者使用不同的过滤器订阅相同的事件处理程序时，此标记特别有用。* ***注意：*建议不要在回调委托中修改有效负载对象，因为多个线程可能同时访问有效负载对象。您可以使有效负载不可变，以避免并发错误。 订阅使用强引用\r如果您在短时间内提出多个事件并注意到它们的性能问题，则可能需要使用强委托引用进行订阅。如果您这样做，则需要在处置订户时手动取消订阅该事件。 默认情况下，PubSubEvent维护对订阅者处理程序的弱委托引用，并对订阅进行过滤。这意味着PubSubEvent所持有的引用不会阻止订阅者的垃圾收集。使用弱委托引用可以使订户免于取消订阅并允许正确的垃圾收集。 但是，维护此弱委托引用比相应的强引用要慢。对于大多数应用程序，此性能不会很明显，但如果您的应用程序在短时间内发布大量事件，则可能需要对PubSubEvent使用强引用。如果您确实使用了强委托引用，则订阅者应该取消订阅，以便在不再使用订阅对象时启用正确的垃圾回收。 要使用强引用进行订阅，请在Subscribe方法上使用keepSubscriberReferenceAlive参数，如以下代码示例所示。 FundAddedEvent fundAddedEvent = eventAggregator.GetEvent\u003cFundAddedEvent\u003e(); bool keepSubscriberReferenceAlive = true; fundAddedEvent.Subscribe(FundAddedEventHandler, ThreadOption.UIThread, keepSubscriberReferenceAlive, fundOrder =\u003e fundOrder.CustomerId == _customerId); 所述keepSubscriberReferenceAlive参数的类型的布尔： 设置为true时，事件实例会保留对订户实例的强引用，从而不允许它进行垃圾回收。有关如何取消订阅的信息，请参阅本主题后面的“ 取消订阅事件 ”一节。 当设置为false（省略此参数时的默认值）时，事件维护对订户实例的弱引用，从而允许垃圾收集器在没有其他引用时配置订阅者实例。收集订户实例后，将自动取消订阅该事件。 默认订阅\r对于最小订阅或默认订阅，订阅者必须提供具有接收事件通知的适当签名的回调方法。例如，TickerSymbolSelectedEvent的处理程序要求该方法采用字符串参数，如以下代码示例所示。 public TrendLineViewModel(IMarketHistoryService marketHistoryService, IEventAggregator eventAggregator) { ... eventAggregator.GetEvent\u003cTickerSymbolSelectedEvent\u003e().Subscribe(this.TickerSymbolChanged); } public void TickerSymbolChanged(string newTickerSymbol) { MarketHistoryCollection newHistoryCollection = this.marketHistoryService.GetPriceHistory(newTickerSymbol); this.TickerSymbol = newTickerSymbol; this.HistoryCollection = newHistoryCollection; } 取消订阅活动\r如果您的订户不再想要接收活动，您可以使用订阅者的处理程序取消订阅，也可以使用订阅令牌取消订阅。 以下代码示例演示如何直接取消订阅处理程序。 FundAddedEvent fundAddedEvent = this.eventAggregator.GetEvent\u003cFundAddedEvent\u003e(); fundAddedEvent.Subscribe(FundAddedEventHandler, ThreadOption.PublisherThread); fundAddedEvent.Unsubscribe(FundAddedEventHandler); 以下代码示例演示如何取消订阅订阅令牌。令牌作为Subscribe方法的返回值提供。 FundAddedEvent fundAddedEvent = this.eventAggregator.GetEvent\u003cFundAddedEvent\u003e(); subscriptionToken = fundAddedEvent.Subscribe(FundAddedEventHandler, ThreadOption.UIThread, false, fundOrder =\u003e fundOrder.CustomerId == this.customerId); fundAddedEvent.Unsubscribe(subscriptionToken); ","date":"2019-07-05","objectID":"/2019/07/prism13-communication/:0:12","tags":["Prism","Communication"],"title":"Prism Communication","uri":"/2019/07/prism13-communication/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 当用户与富客户端应用程序交互时，其用户界面（UI）将不断更新以反映用户正在处理的当前任务和数据。随着用户与应用程序内的各种任务交互并完成各种任务，UI可能会随着时间发生相当大的变化。应用程序协调这些UI更改的过程通常称为导航。本主题描述如何使用Prism库实现复合Model-View-ViewModel（MVVM）应用程序的导航。 通常，导航意味着删除UI中的某些控件，同时添加其他控件。在其他情况下，导航可以意味着更新一个或多个现有控件的视觉状态 - 例如，一些控件可以被简单地隐藏或折叠，而其他控件被显示或扩展。类似地，导航可能意味着控件显示的数据被更新以反映应用程序的当前状态 - 例如，在主 - 细节场景中，详细视图中显示的数据将基于当前选择的项目进行更新在主视图中。所有这些场景都可以被视为导航，因为更新了用户界面以反映用户的当前任务和应用程序的当前状态。 应用程序内的导航可以由用户与UI的交互（通过鼠标事件或其他UI手势）或由于内部逻辑驱动的状态改变而从应用程序本身引起。在某些情况下，导航可能涉及非常简单的UI更新，不需要自定义应用程序逻辑。在其他情况下，应用程序可以实现复杂的逻辑以编程方式控制导航以确保强制执行某些业务规则 - 例如，应用程序可能不允许用户离开某个表单而不首先确保输入的数据是正确的。 在Windows Presentation Foundation（WPF）应用程序中实现所需的导航行为通常可以相对简单，因为它提供了对导航的直接支持。但是，在使用Model-View-ViewModel（MVVM）模式的应用程序中或在使用多个松散耦合模块的复合应用程序中实现导航可能更复杂。棱镜提供了在这些情况下实施导航的指导。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:0","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"prism Navigation\r导航定义为应用程序通过其与应用程序或内部应用程序状态更改进行交互而更改其UI的过程。 UI更新可以通过在应用程序的可视树中添加或删除元素，或者通过对可视树中的现有元素应用状态更改来完成。WPF是一个非常灵活的平台，通常可以使用这种方法实现特定的导航场景。但是，最适合您应用的方法取决于多种因素。 Prism区分了前面描述的两种导航方式。通过对可视树中的现有控件的状态更改完成的导航被称为基于状态的导航。通过从可视树中添加或移除元素来完成的导航被称为基于视图的导航。Prism提供了实现两种导航样式的指导，重点关注应用程序使用Model-View-ViewModel（MVVM）模式将UI（封装在视图中）与表示逻辑和数据（封装在视图中）分开的情况模型）。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:1","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"基于状态的导航\rState-Based Navigation 在基于状态的导航中，表示UI的视图可以通过视图模型中的状态更改或通过视图本身内的用户交互来更新。在这种导航方式中，不是用另一个视图替换视图，而是更改视图的状态。根据视图状态的更改方式，更新的UI可能会让用户感觉像导航一样。 这种导航方式适用于以下情况： 视图需要以不同的样式或格式显示相同的数据或功能。 视图需要根据视图模型的基础状态更改其布局或样式。 视图需要在视图的上下文中启动与用户的有限模态或非模态交互。 这种导航方式不适用于UI必须向用户呈现不同数据或用户必须执行不同任务的情况。在这些情况下，最好实现单独的视图（和视图模型）来表示数据或任务，然后使用基于视图的导航在它们之间导航，如本主题后面所述。类似地，如果实现导航所需的UI状态更改的数量过于复杂，则这种导航方式不适合，因为视图的定义可能变得很大并且难以维护。在这种情况下，最好通过使用基于视图的导航在不同的视图中实现导航。 以下部分描述了可以使用基于状态的导航的典型情况。这些部分中的每一部分都涉及基于状态的导航快速入门，它实现了即时消息传递式应用程序，允许用户管理和与其联系人聊天。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:2","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"以不同的格式或样式显示数据\rDisplaying Data in Different Formats or Styles 您的应用程序可能经常需要向用户显示相同的数据，但格式或样式不同。在这种情况下，您可以在视图中使用基于状态的导航在不同样式之间切换，可能使用它们之间的动画过渡。例如，基于状态的导航快速入门允许用户选择联系人的显示方式 - 简单文本列表或头像（图标）。用户可以通过单击“列表”按钮或“头像”按钮在这些可视表示之间切换。该视图提供了两个表示之间的动画过渡，如下图所示。 联系基于状态的导航快速入门中的视图导航\rContact view navigation in the State-Based Navigation QuickStart 由于视图呈现的是相同的数据，但是在不同的可视化表示中，视图模型不需要参与表示之间的导航。在这种情况下，导航完全在视图本身内处理。这种方法为UI设计人员提供了很大的灵活性，可以设计出引人注目的用户体验，而无需更改应用程序的代码。 混合行为提供了在视图中实现此导航样式的好方法。基于状态的导航QuickStart应用程序使用Blend的DataStateBehavior数据绑定到单选按钮，在使用可视状态管理器定义的两个可视状态之间切换，一个按钮将联系人显示为列表，一个按钮将联系人显示为图标。 \u003cei:DataStateBehavior Binding=\"{Binding IsChecked, ElementName=ShowAsListButton}\" Value=\"True\" TrueState=\"ShowAsList\" FalseState=\"ShowAsIcons\"/\u003e 当用户单击“ 联系人”或“ 头像”单选按钮时，可视状态在ShowAsList可视状态和ShowAsIcons可视状态之间切换。还使用可视状态管理器定义这些状态之间的翻转过渡动画。 当用户切换到当前所选联系人的详细信息视图时，基于状态的导航快速入门应用程序会显示此类导航的另一个示例。下图显示了此示例。 基于状态的导航快速入门中的“联系人详细信息”视图\r同样，这可以使用Blend DataStateBehavior轻松实现; 但是，这次它被绑定到视图模型上的ShowDetails属性，该属性使用翻转过渡动画在ShowDetails和ShowContacts视觉状态之间切换。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:3","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"Reflecting Application State\r类似地，应用程序中的视图有时可能需要根据对内部应用程序状态的更改来更改其布局或样式，而内部应用程序状态又由视图模型上的属性表示。基于状态的导航快速入门中显示了此方案的示例，其中使用ConnectionStatus属性在Chat视图模型类上表示用户的连接状态。当用户的连接状态发生变化时，将通知视图（通过属性更改通知事件），允许视图在适当的位置直观地表示当前连接状态，如下图所示。 基于状态的导航快速入门中的连接状态表示\rConnection state representation in the State-Based Navigation QuickStart 为实现此目的，视图定义绑定到视图模型的ConnectionStatus属性的DataStateBehavior数据，以在适当的可视状态之间切换。 \u003cei:DataStateBehavior Binding=\"{Binding ConnectionStatus}\" Value=\"Available\" TrueState=\"Available\" FalseState=\"Unavailable\"/\u003e 请注意，用户可以通过UI或应用程序根据某些内部逻辑或事件更改连接状态。例如，如果用户在特定时间段内没有与视图交互或者当用户的日历指示他或她在会议中时，应用程序可以移动到“不可用”状态。基于状态的导航快速入门通过使用计时器随机切换连接状态来模拟此场景。更改连接状态后，将更新视图模型上的属性，并通过属性更改事件通知视图。然后更新UI以反映当前连接状态。 前面的所有示例都涉及在视图中定义视觉状态，以及由于用户与视图的交互或视图模型定义的属性更改而在视图之间切换。此方法允许UI设计器在视图中实现类似导航的可视行为，而无需替换视图或要求对应用程序代码进行任何代码更改。当需要视图以不同的样式或布局呈现相同的数据时，此方法是合适的。它不适用于向用户呈现不同数据或应用程序功能或导航到应用程序的不同部分的情况。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:4","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"与用户交互\r通常，应用程序需要以有限的方式与用户交互。在这些情况下，通常更适合在当前视图的上下文中与用户交互，而不是导航到新视图。例如，在基于状态的导航快速入门中，用户可以通过单击“ 发送消息”按钮向联系人发送消息。然后，视图将显示一个弹出窗口，允许用户键入消息，如下图所示。因为与用户的这种交互是有限的并且逻辑上发生在父视图的上下文中，所以它可以容易地实现为基于状态的导航。 使用弹出窗口与用户交互\r使用基于状态的导航快速入门中的弹出窗口与用户交互要实现此行为，基于状态的导航快速入门实现SendMessage命令，该命令绑定到“ **发送消息”**按钮。调用此命令时，视图模型将与视图交互以显示弹出窗口。这是使用实现MVVM模式中描述的交互请求模式实现的。 以下代码示例显示了基于状态的导航QuickStart应用程序中的视图如何响应视图模型提供的SendMessageRequest交互请求对象。收到请求事件后，SendMessageChildWindow将显示为弹出窗口。 \u003cprism:InteractionRequestTrigger SourceObject=\"{Binding SendMessageRequest}\"\u003e \u003cprism:PopupWindowAction IsModal=\"True\"\u003e \u003cprism:PopupWindowAction.WindowContent\u003e \u003cvs:SendMessagePopupView /\u003e \u003c/prism:PopupWindowAction.WindowContent\u003e \u003c/prism:PopupWindowAction\u003e \u003c/prism:InteractionRequestTrigger\u003e ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:5","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"基于视图的导航\r虽然基于状态的导航对于前面概述的场景可能很有用，但是应用程序中的导航通常通过将应用程序UI中的一个视图替换为另一个视图来实现。在Prism中，这种导航方式称为基于视图的导航。 根据应用程序的要求，此过程可能相当复杂，需要仔细协调。以下是在实现基于视图的导航时经常需要解决的常见挑战： 导航的目标 - 要添加或移除的视图的容器或主机控件 - 可以在添加或移除视图时以不同方式处理导航，或者它们可以以不同方式可视地表示导航。在许多情况下，导航目标将是简单的Frame或ContentControl，导航视图将简单地显示在这些控件中。但是，在许多情况下，导航操作的目标是不同类型的容器控件，例如TabControl或ListBox控件。在这些情况下，导航可能需要激活或选择现有视图，或者添加新视图是一种特定方式。 应用程序还经常必须定义如何识别要导航到的视图。例如，在Web应用程序中，要导航到的页面通常由统一资源标识符（URI）直接标识。在客户端应用程序中，可以通过类型名称，资源位置或以各种不同方式来标识视图。此外，在由松散耦合的模块组成的复合应用程序中，视图通常将在单独的模块中定义。需要以不会在模块之间引入紧密耦合和依赖关系的方式识别单个视图。 在识别视图之后，必须仔细协调实例化和初始化新视图的过程。在使用MVVM模式时，这尤其重要。在这种情况下，视图和视图模型可能需要在导航操作期间通过视图的数据上下文进行实例化并相互关联。在应用程序利用依赖注入容器（例如Unity应用程序块（Unity）或托管可扩展性框架（MEF））的情况下，视图和/或视图模型（以及其他依赖类）的实例化可能必须使用特定的构造机制来实现。 MVVM模式提供了应用程序的UI与其表示和业务逻辑之间的分离。但是，应用程序的导航行为通常会跨越应用程序的UI和表示逻辑部分。用户通常会在视图中启动导航，并且视图将作为导航的结果进行更新，但通常还需要从视图模型中启动或协调导航。在整个视图和视图模型中清晰地分离应用程序的导航行为的能力是一个需要考虑的重要方面。 应用程序通常还需要将参数或上下文传递给视图，以便可以正确初始化它。例如，如果用户导航到视图以更新特定客户的详细信息，则必须将客户的ID或数据传递给视图，以便它可以显示正确的信息。 许多应用程序还必须仔细协调导航，以确保遵守某些业务规则。例如，在远离视图导航之前可能会提示用户，以便他们可以纠正任何无效数据，或者提示他们提交或放弃他们在该视图中所做的任何数据更改。此过程需要在先前视图和新视图之间进行仔细协调。 最后，大多数现代应用程序允许用户轻松地向后（或向前）导航到先前显示的视图。类似地，一些应用程序使用一系列视图或表单实现其工作流，并允许用户向前或向后导航，在完成任务并一次提交所有更改之前添加或更新数据。这些场景需要某种日记（或历史）机制，以便可以存储，重放或预定义导航序列。 Prism通过扩展Prism的区域机制来支持导航，为这些挑战提供支持和指导。以下部分提供了Prism区域的简要概述，并描述了它们如何扩展以支持基于视图的导航。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:6","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"Prism Region概述\rPrism Region旨在通过允许应用程序的整体UI以松散耦合的方式构建来支持复合应用程序（即，由多个模块组成的应用程序）的开发。区域允许在模块中定义的视图显示在应用程序的UI中，而无需模块明确了解应用程序的整体UI结构。它们允许轻松更改应用程序UI的布局，从而允许UI设计人员为应用程序选择最合适的UI设计和布局，而无需更改模块本身。 Prism Region基本上named placeholders，在其中可以显示视图。通过简单地向其添加RegionName附加属性，应用程序UI中的任何控件都可以声明为区域，如此处所示。 \u003cContentControl prism:RegionManager.RegionName=\"MainRegion\" ... /\u003e 对于指定为区域的每个控件，Prism创建一个Region对象来表示区域，并创建一个RegionAdapter对象，该对象管理视图在指定控件中的放置和激活。Prism Library 为大多数常见的WPF控件提供RegionAdapter实现。您可以创建自定义RegionAdapter以支持其他控件，或者在需要定义自定义行为时。该RegionManager类提供给接入地区的应用程序中的对象。 在许多情况下，区域控件将是一个简单的控件，例如ContentControl，它可以一次显示一个视图。在其他情况下，Region控件将是一个能够同时显示多个视图的控件，例如TabControl或ListBox控件。 区域适配器管理关联区域内的视图列表。这些视图中的一个或多个将根据其定义的布局策略显示在区域控件中。可以为视图分配一个名称，该名称可用于稍后检索该视图。区域适配器管理区域内视图的活动状态。活动视图是选定视图或最顶视图 - 例如，在TabControl中，活动视图是显示在所选选项卡中的视图; 在ContentControl中，活动视图是当前显示为控件内容的视图。 **注意：**在导航期间，视图的活动状态很重要。通常，您希望活动视图参与导航，以便它可以在用户导航之前保存数据，或者可以确认或取消导航操作。 先前版本的Prism允许以两种方式在区域中显示视图。第一种称为视图注入，允许以编程方式在区域中显示视图。此方法对于动态内容很有用，根据应用程序的表示逻辑，要在区域中显示的视图会频繁更改。 通过Region类的Add方法支持视图注入。下面的代码示例演示如何通过RegionManager类获取对Region对象的引用，并以编程方式向其添加视图。在此示例中，使用依赖项注入容器创建视图。 IRegionManager regionManager = ...; IRegion mainRegion = regionManager.Regions[\"MainRegion\"]; InboxView view = this.container.Resolve\u003cInboxView\u003e(); mainRegion.Add(view); 第二种方法称为视图发现，它允许模块针对区域名称注册视图类型。每当显示具有指定名称的区域时，将自动创建指定视图的实例并在该区域中显示。此方法对于相对静态的内容很有用，其中要在区域中显示的视图不会更改。 通过RegionManager类上的RegisterViewWithRegion方法支持视图发现。此方法允许您指定在显示命名区域时将调用的回调方法。以下代码示例显示了在首次显示主区域时如何创建视图（通过依赖项注入容器）。 IRegionManager regionManager = ...; regionManager.RegisterViewWithRegion(\"MainRegion\", () =\u003e container.Resolve\u003cInboxView\u003e()); 有关Prism区域支持的详细概述以及有关如何利用视图注入和发现来利用区域组成应用程序UI的信息，请参阅编写用户界面。本主题的其余部分描述了如何扩展区域以支持基于视图的导航，以及如何解决前面描述的各种挑战。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:7","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"基本区域导航\r视图注入和视图发现都可以被认为是有限形式的导航 - 视图注入是一种显式的，程序化的导航形式，而视图发现是一种隐式或延迟导航的形式。但是，在Prism 4.0中，基于URI和可扩展的导航机制，区域已经扩展到支持更一般的导航概念。 区域内的导航意味着将在该区域内显示新视图。要显示的视图通过URI标识，默认情况下，URI指的是要创建的视图的名称。您可以使用INavigateAsync接口定义的RequestNavigate方法以编程方式启动导航。 注意：尽管名称如此，但INavigateAsync接口并不代表在单独的后台线程上执行的异步导航。相反，INavigateAsync接口表示执行伪异步导航的能力。该RequestNavigate方法可以返回同步导航操作完成之后，或者它可以返回而导航操作仍悬而未决，如在用户需要确认导航的情况。通过允许您在导航期间指定回调和延续，Prism提供了一种机制来启用这些方案，而无需在后台线程上导航的复杂性。 INavigateAsync接口由Region类实现，允许您在该区域内启动导航。 IRegion mainRegion = ...; mainRegion.RequestNavigate(new Uri(\"InboxView\", UriKind.Relative)); 您也可以拨打RequestNavigate的方法RegionManager，它允许你指定要驾驶的区域的名称。这个方便的方法获取对指定区域的引用，然后调用RequestNavigate方法，如上面的代码示例所示。 IRegionManager regionManager = ...; regionManager.RequestNavigate(\"MainRegion\", new Uri(\"InboxView\", UriKind.Relative)); 默认情况下，导航URI指定在容器中注册的视图的名称。 使用MEF，您只需导出具有指定名称的视图类型即可。 [Export(\"InboxView\")] public partial class InboxView : UserControl { ... } 在导航期间，指定视图通过容器或MEF以及其对应的视图模型和其他相关服务和组件进行实例化。在实例化视图之后，将其添加到指定区域并激活（本主题后面将更详细地描述激活）。 **注意：**前面的描述说明了视图优先导航，其中URI指的是视图类型的名称，因为它是随容器导出或注册的。使用视图优先导航，依赖视图模型将创建为视图的依赖项。另一种方法是使用视图模型优先导航，其中导航URI指的是视图模型类型的名称，因为它是随容器导出或注册的。当视图定义为数据模板时，或者您希望独立于视图定义导航方案时，查看模型优先导航非常有用。 该RequestNavigate方法还允许您指定一个回调方法，或委托，当导航完成后，将被调用。 private void SelectedEmployeeChanged(object sender, EventArgs e) { ... regionManager.RequestNavigate(RegionNames.TabRegion, \"EmployeeDetails\", NavigationCompleted); } private void NavigationCompleted(NavigationResult result) { ... } 所述NavigationResult类定义了提供有关导航操作信息的属性。该结果属性指示导航是否成功。如果导航成功，则Result属性为true。如果导航失败，通常是因为在IConfirmNavigationResult.ConfirmNavigationRequest方法中返回’continuationCallBack（false）’ ，则Result属性将为false。如果由于异常导致导航失败，则Result属性将为false并且为Errorproperty提供对导航期间抛出的任何异常的引用。的语境属性提供给导航URI，它包含任何参数，并且向协调导航操作导航服务的引用。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:8","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"查看和查看模型参与导航\r通常，应用程序中的视图和视图模型将要参与导航。该INavigationAware接口支持这个。您可以在视图上或（更常见地）视图模型上实现此接口。通过实现此界面，您的视图或视图模型可以选择参与导航过程。 注意：在下面的描述中，尽管在视图之间导航期间引用了对此接口的调用，但应注意，无论是由视图还是视图模型实现，都将在导航期间调用INavigationAware接口。在导航过程中，Prism会检查视图是否实现了INavigationAware接口; 如果是，它会在导航期间调用所需的方法。Prism还会检查设置为视图的DataContext的对象是否实现了此接口; 如果是，它会在导航期间调用所需的方法。 此界面允许视图或视图模型参与导航操作。所述INavigationAware接口定义了三个方法。 public interface INavigationAware { bool IsNavigationTarget(NavigationContext navigationContext); void OnNavigatedTo(NavigationContext navigationContext); void OnNavigatedFrom(NavigationContext navigationContext); } 该IsNavigationTarget方法允许现有的（显示的）视图或视图模型，以指示它是否能够处理所述导航请求。在您可以重复使用现有视图来处理导航操作或导航到已存在的视图时，这非常有用。例如，可以更新显示客户信息的视图以显示不同的客户信息。有关使用此方法的详细信息，请参阅本主题后面的“ 导航到现有视图 ”一节。 该OnNavigatedFrom和的OnNavigatedTo方法是导航操作期间调用。如果区域中当前活动的视图实现此接口（或其视图模型），则在导航发生之前调用其OnNavigatedFrom方法。该OnNavigatedFrom方法允许一个视图保存任何状态，或为它的失活或去除从UI制备，例如，以保存用户已经到web服务或数据库所作的任何更改。 如果新创建的视图实现此接口（或其视图模型），则在导航完成后调用其OnNavigatedTo方法。所述的OnNavigatedTo方法允许新显示的视图初始化自身，可能使用传递给它上的导航URI任何参数。有关详细信息，请参阅下一节“ 导航期间传递参数”。 在实例化，初始化并添加到目标区域之后，它将成为活动视图，并且停用先前视图。有时您会希望从区域中删除已停用的视图。Prism提供IRegionMemberLifetime接口，允许您指定是否要从区域中删除已停用的视图或仅将其标记为已停用，从而控制区域内视图的生命周期。 public class EmployeeDetailsViewModel : IRegionMemberLifetime { public bool KeepAlive { get { return true; } } } 所述IRegionMemberLifetime接口定义的单个只读属性，的KeepAlive。如果此属性返回false，则在停用视图时将从该区域中删除该视图。由于该区域不再具有对视图的引用，因此它有资格进行垃圾回收（除非应用程序中的某些其他组件维护对它的引用）。您可以在视图或视图模型类上实现此接口。虽然IRegionMemberLifetime接口主要用于在激活和取消激活期间管理区域内视图的生命周期，但在目标区域中激活新视图后，还会在导航期间考虑KeepAlive属性。 注意：可以显示多个视图的区域（例如使用ItemsControl或TabControl的区域）将同时显示非活动视图和活动视图。从这些类型的区域中删除非活动视图将导致视图从UI中移除。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:9","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"导航期间传递参数\r要在应用程序中实现所需的导航行为，通常需要在导航请求期间指定其他数据，而不仅仅是目标视图名称。所述NavigationContext对象提供对导航URI，并在其内被指定的或外部的任何参数。您可以从IsNavigationTarget，OnNavigatedFrom和OnNavigatedTo方法中访问NavigationContext。 Prism提供NavigationParameters类以帮助指定和检索导航参数。该NavigationParameters类维护名称-值对，每个参数列表。您可以使用此类将参数作为导航URI的一部分传递或传递对象参数。 以下代码示例演示如何将单个字符串参数添加到NavigationParameters实例，以便将其附加到导航URI。 Employee employee = Employees.CurrentItem as Employee; if (employee != null) { var navigationParameters = new NavigationParameters(); navigationParameters.Add(\"ID\", employee.Id); _regionManager.RequestNavigate(RegionNames.TabRegion, new Uri(\"EmployeeDetailsView\" + navigationParameters.ToString(), UriKind.Relative)); } 此外，您可以通过将对象参数添加到NavigationParameters实例并将其作为RequestNavigate方法的参数传递来传递对象参数。这在以下代码中显示。 Employee employee = Employees.CurrentItem as Employee; if (employee != null) { var parameters = new NavigationParameters(); parameters.Add(\"ID\", employee.Id); parameters.Add(\"myObjectParameter\", new ObjectParameter()); regionManager.RequestNavigate(RegionNames.TabRegion, new Uri(\"EmployeeDetailsView\", UriKind.Relative), parameters); } 您可以使用NavigationContext对象上的Parameters属性检索导航参数。此属性返回NavigationParameters类的实例，该类提供索引器属性以允许轻松访问各个参数，而不管它们是通过查询还是通过RequestNavigate方法传递。 public void OnNavigatedTo(NavigationContext navigationContext) { string id = navigationContext.Parameters[\"ID\"]; ObjectParameter myParameter = navigationContext.Parameters[\"myObjectParameter\"]; } ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:10","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"导航到现有视图\r通常，在导航期间重复使用，更新或激活应用程序中的视图更合适，而不是由新视图替换。这通常是您导航到相同类型的视图但需要向用户显示不同信息或状态的情况，或者当UI中已有适当视图但需要激活（即，选择或制作）时最顶部）。 对于第一个场景的示例，假设您的应用程序允许用户使用EditCustomer视图编辑客户记录，并且用户当前正在使用该视图编辑客户ID 123.如果客户决定编辑客户的客户记录ID 456，用户可以直接导航到EditCustomer视图并输入新的客户ID。然后，EditCustomer视图可以检索新客户的数据并相应地更新其UI。 第二种情况的示例是应用程序允许用户一次编辑多个客户记录。在这种情况下，应用程序在选项卡控件中显示多个EditCustomer视图实例 - 例如，一个用于客户ID 123，另一个用于客户ID 456.当用户导航到EditCustomer视图并输入客户ID 456时，相应的视图将是激活（即，将选择其相应的选项卡）。如果用户导航到EditCustomer视图并输入客户ID 789，则将创建一个新实例并显示在选项卡控件中。 由于各种原因，导航到现有视图的能力很有用。更新现有视图通常更有效，而不是使用相同类型的新实例替换它。同样，激活现有视图而不是创建重复视图可提供更一致的用户体验。此外，无需多少自定义代码即可无缝处理这些情况，这意味着应用程序更易于开发和维护。 棱镜支持通过前面描述的两种方案IsNavigationTarget on方法INavigationAware接口。在导航期间，在与目标视图类型相同的区域中的所有视图上调用此方法。在前面的示例中，视图的目标类型是EditCustomer视图，因此将在当前位于该区域中的所有现有EditCustomer视图实例上调用IsNavigationTarget方法。Prism从视图URI确定目标类型，它假定它是目标类型的短类型名称。 注意：要使Prism确定目标视图的类型，导航URI中的视图名称应与实际目标类型的短类型名称相同。例如，如果您的视图由MyApp.Views.EmployeeDetailsView类实现，则导航URI中指定的视图名称应为EmployeeDetailsView。这是Prism提供的默认行为。您可以通过实现自定义内容加载器类来自定义此行为; 您可以通过实现IRegionNavigationContentLoader接口或从RegionNavigationContentLoader类派生来实现此目的。 IsNavigationTarget方法的实现可以使用NavigationContext参数来确定它是否可以处理导航请求。所述NavigationContext对象提供对导航URI和导航参数。在前面的示例中，EditCustomer视图模型中此方法的实现将当前客户ID与导航请求中指定的ID进行比较，如果匹配则返回true。 public bool IsNavigationTarget(NavigationContext navigationContext) { string id = navigationContext.Parameters[\"ID\"]; return _currentCustomer.Id.Equals(id); } 如果IsNavigationTarget方法始终返回true，则无论导航参数如何，都将始终重用该视图实例。这允许您确保在特定区域中仅显示特定类型的一个视图。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:11","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"确认或取消导航\r您经常会发现在导航操作期间需要与用户进行交互，以便用户可以确认或取消它。例如，在许多应用中，用户可以在输入或编辑数据的过程中尝试导航。在这些情况下，您可能想要询问用户是否要在继续离开页面之前保存或丢弃已输入的数据，或者用户是否想要完全取消导航操作。Prism通过IConfirmNavigationRequest接口支持这些场景。 所述IConfirmNavigationRequest接口从所述派生INavigationAware接口并添加ConfirmNavigationRequest方法。通过在视图或视图模型类上实现此接口，您允许它们以允许用户与用户交互的方式参与导航序列，以便用户可以确认或取消导航。您将经常使用交互请求对象（如高级MVVM方案中所述）来显示确认弹出窗口。 注意：该ConfirmNavigationRequest方法称为活动视图或视图模型，类似于OnNavigatedFrom前面描述的方法。 该ConfirmNavigationRequest方法提供了两个参数，如前文所述当前导航背景下，当你想要导航，继续，你可以调用回调方法的参考。因此，回调称为延续回调。您可以存储对continuation回调的引用，以便应用程序在完成与用户交互后调用它。如果您的应用程序通过交互请求对象与用户交互，您可以将调用链接到交互请求中的回调的连续回调。下图说明了整个过程。 以下步骤总结了使用InteractionRequest对象确认导航的过程： 导航操作通过RequestNavigate调用启动。 如果视图或视图模型实现IConfirmNavigation，则调用ConfirmNavigationRequest。 视图模型引发交互请求事件。 视图显示确认弹出窗口并等待用户的响应。 当用户关闭弹出窗口时，将调用交互请求回调。 调用继续回调以继续或取消挂起的导航操作。 导航操作已完成或取消。 为了说明这一点，请查看View-Switching Navigation Quick Start。此应用程序使用户能够使用ComposeEmailView和ComposeEmailViewModel类撰写新电子邮件。视图模型类实现IConfirmNavigation接口。如果用户导航（例如通过单击“ 日历”按钮），则在编写电子邮件时，将调用ConfirmNavigationRequest方法，以便视图模型可以确认与用户的导航。为了支持这一点，视图模型类定义了交互请求，如以下代码示例所示。 public class ComposeEmailViewModel : NotificationObject, IConfirmNavigationRequest { . . . private readonly InteractionRequest\u003cConfirmation\u003e confirmExitInteractionRequest; public ComposeEmailViewModel(IEmailService emailService) { . . . this.confirmExitInteractionRequest = new InteractionRequest\u003cConfirmation\u003e(); } public IInteractionRequest ConfirmExitInteractionRequest { get { return this.confirmExitInteractionRequest; } } } 在ComposeEmailView类中，定义了交互请求触发器，并将数据绑定到视图模型上的ConfirmExitInteractionRequest属性。当进行交互请求时，将向用户显示简单的弹出窗口。 \u003cUserControl.Resources\u003e \u003cDataTemplate x:Key=\"ConfirmExitDialogTemplate\"\u003e \u003cTextBlock HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" Text=\"{Binding}\"/\u003e \u003c/DataTemplate\u003e \u003c/UserControl.Resources\u003e \u003cGrid x:Name=\"LayoutRoot\" Background=\"White\"\u003e \u003cei:Interaction.Triggers\u003e \u003cprism:InteractionRequestTrigger SourceObject=\"{Binding ConfirmExitInteractionRequest}\"\u003e \u003cprism:PopupWindowAction IsModal=\"True\" CenterOverAssociatedObject=\"True\"/\u003e \u003c/prism:InteractionRequestTrigger\u003e \u003c/ei:Interaction.Triggers\u003e ... 在ConfirmNavigationRequest对方法ComposeEmailVewModel类，如果用户尝试导航而电子邮件正在被由被调用。此方法的实现调用先前定义的交互请求，以便用户可以确认或取消导航操作。 void IConfirmNavigationRequest.ConfirmNavigationRequest( NavigationContext navigationContext, Action\u003cbool\u003e continuationCallback) { . . . this.confirmExitInteractionRequest.Raise( new Confirmation {Content = \"...\", Title = \"...\"}, c =\u003e {continuationCallback(c.Confirmed);}); } 当用户单击确认弹出窗口中的按钮以确认或取消操作时，将调用交互请求的回调。此回调只调用continuation回调，传入Confirmed标志的值，并导致导航继续或被取消。 注意：应该注意，在引发交互请求事件之后，立即返回ConfirmNavigationRequest方法，以便用户可以继续与应用程序的UI交互。当用户单击弹出窗口上的“ **确定”**或“ **取消”**按钮时，将生成交互请求的回调方法，该方法又调用继续回调以完成导航操作。在UI线程上调用所有方法。使用此技术，不需要后台线程。 使用此机制，您可以控制导航请求是立即执行还是延迟执行，等待与用户的交互或某些其他异步交互（例如，作为Web服务请求的结果）。要启用导航，您只需调用continuation回调方法，传递true即表示它可以继续。同样，您可以传递false以指示应取消导航。 void IConfirmNavigationRequest.ConfirmNavigationRequest( NavigationContext navigationContext, Action\u003cbool\u003e continuationCallback) { continuationCallback(true); } 如果要延迟导航，可以存储对继续回调的引用，然后在与用户（或Web服务）的交互完成时调用。在您调用continuation回调之前，导航操作将处于暂挂状态。 如果用户同时启动另一个导航操作，则导航请求将被取消。在这种情况下，调用continuation回调没有任何效果，因为它所涉及的导航操作不再是最新的。同样，如果您决定不调用延续回调，则导航操作将处于暂挂状态，直到将其替换为新的导航操作。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:12","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"使用导航日志\r所述NavigationContext类提供进入该地区导航服务，它负责的区域内导航期间协调操作的序列。它提供对正在进行导航的区域以及与该区域相关联的导航日志的访问。区域导航服务实现IRegionNavigationService，其定义如下。 public interface IRegionNavigationService : INavigateAsync { IRegion Region {get; set;} IRegionNavigationJournal Journal {get;} event EventHandler\u003cRegionNavigationEventArgs\u003e Navigating; event EventHandler\u003cRegionNavigationEventArgs\u003e Navigated; event EventHandler\u003cRegionNavigationFailedEventArgs\u003e NavigationFailed; } 由于区域导航服务实现了INavigateAsync接口，因此您可以通过调用其RequestNavigate方法在父区域内启动导航。在Navigated 开始导航操作时引发事件。在导航中的区域内的导航结束时引发事件。该NavigationFailed如果导航过程中遇到的错误引发。 该Journal 属性提供与该区域相关的导航日记。导航日志实现IRegionNavigationJournal接口，其定义如下。 public interface IRegionNavigationJournal { bool CanGoBack { get; } bool CanGoForward { get; } IRegionNavigationJournalEntry CurrentEntry { get; } INavigateAsync NavigationTarget { get; set; } void Clear(); void GoBack(); void GoForward(); void RecordNavigation(IRegionNavigationJournalEntry entry); } 您可以在导航期间通过OnNavigatedTo方法调用获取并存储对视图中区域导航服务的引用。默认情况下，Prism提供了一个简单的基于堆栈的日志，允许您在区域内向前或向后导航。 您可以使用导航日志允许用户从视图本身进行导航。在以下示例中，视图模型实现了GoBack命令，该命令使用主机区域中的导航日志。因此，视图可以显示“ 后退”按钮，允许用户轻松导航回区域内的上一个视图。同样，您可以实现GoForward命令来实现向导样式工作流。 public class EmployeeDetailsViewModel : INavigationAware { ... private IRegionNavigationService navigationService; public void OnNavigatedTo(NavigationContext navigationContext) { navigationService = navigationContext.NavigationService; } public DelegateCommand\u003cobject\u003e GoBackCommand { get; private set; } private void GoBack(object commandArg) { if (navigationService.Journal.CanGoBack) { navigationService.Journal.GoBack(); } } private bool CanGoBack(object commandArg) { return navigationService.Journal.CanGoBack; } } 如果需要在该区域内实现特定的工作流模式，则可以为区域实现自定义日记。 **注意：**导航日志只能用于由区域导航服务协调的基于区域的导航操作。如果使用视图发现或视图注入来实现区域内的导航，则导航日志将不会在导航期间更新，也不能用于在该区域内向前或向后导航。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:13","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"选择退出导航日志\r使用“导航日志”时，显示中间页面（如启动画面，加载页面或对话框）非常有用。希望通过调用IRegionNavigationJournal.GoForward（）或IRegionNavigationJournal.GoBack（）来重新访问这些页面。通过实现IJournalAware接口可以实现此行为。 public interface IJournalAware { bool PersistInHistory(); } 通过在View或View Model上实现IJournalAware并从**PersistInHistory（）**返回false，Pages可以选择不添加到日志历史记录中。 public class IntermediaryPage : IJournalAware { public bool PersistInHistory() =\u003e false; } ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:14","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"使用WPF导航框架\rPrism区域导航旨在解决在使用MVVM模式和依赖注入容器（如Unity）或Managed Extensibility Framework的松散耦合的模块化应用程序中实现导航时可能遇到的各种常见场景和挑战。 （MEF）。它还旨在支持导航确认和取消，导航到现有视图，导航参数和导航日志。 通过支持Prism区域内的导航，它还支持在各种布局控件中进行导航，并支持在不影响其导航结构的情况下更改应用程序UI的布局。它还支持伪同步导航，允许在导航期间进行丰富的用户交互。 但是，棱镜区域导航并非旨在取代WPF的导航框架。相反，Prism区域导航被设计为与WPF导航框架并排使用。 WPF导航框架很难用于支持MVVM模式和依赖注入。它还基于Frame控件，在日记和导航UI方面提供类似的功能。您可以将WPF导航框架与Prism区域导航一起使用，但仅使用Prism区域实现导航可能更容易，也更灵活。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:15","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"区域导航序列\rThe Region Navigation Sequence 下图提供了导航操作期间操作顺序的概述。它仅供参考，以便您可以在导航请求期间查看棱镜区域导航的各种元素如何协同工作。 ","date":"2019-07-04","objectID":"/2019/07/prism12-navigation/:0:16","tags":["Prism","Navigation"],"title":"Prism 导航","uri":"/2019/07/prism12-navigation/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 复合应用程序用户界面（UI）由松散耦合的可视组件组成，这些组件称为View，通常包含在应用程序模块中，但它们并非必须如此。如果将应用程序划分为模块，则需要一些方法来松散地组合UI，但即使视图不在模块中，您也可以选择使用此方法。对用户而言，该应用程序提供了无缝的用户体验，并提供了完全集成的应用程序。 要构建UI，您需要一个体系结构，允许您创建由在运行时生成的松散耦合的可视元素组成的布局。此外，该体系结构应该为这些可视元素提供以松散耦合方式进行通信的策略。 可以使用以下范例之一构建应用程序UI： 表单的所有必需控件都包含在单个可扩展应用程序标记语言（XAML）文件中，在设计时组成表单。 表单的逻辑区域被分成不同的部分，通常是用户控件。部件由表单引用，表单在设计时组成。 表单的逻辑区域被分成不同的部分，通常是用户控件。表单中的部分未知，并在运行时动态添加到表单中。使用此方法的应用程序称为使用UI组合模式的复合应用程序。 股票交易者参考实施（股票交易者RI）是通过将来自不同模块的多个视图加载到由shell公开的区域组成的，如下图所示。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:0","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"UI布局概念\r复合应用程序中的根对象称为shell。shell充当应用程序的母版页。shell包含一个或多个regions。regions是将在运行时加载的内容的占位符。区域附加到UI元素，例如ContentControl，ItemsControl，TabControl或自定义控件，并管理UI元素的内容。区域内容可以自动或按需加载，具体取决于应用程序要求。 通常，区域的内容是视图。视图将您希望保留的UI的一部分封装为尽可能与应用程序的其他部分分离。您可以将视图定义为用户控件，数据模板甚至自定义控件。 区域管理视图的显示和布局。区域可以通过其名称以分离的方式访问，并支持动态添加或删除视图。区域附加到主机控件。将区域视为动态加载视图的容器。 以下部分介绍了复合应用程序开发的高级核心概念。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:1","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"shell\rshell是包含主UI内容的应用程序根对象。在Windows Presentation Foundation（WPF）应用程序中，shell是Window对象。 shell扮演master page的角色，为应用程序提供布局结构。shell包含一个或多个named regions，其中模块可以指定将显示的视图。它还可以定义某些顶级UI元素，例如背景，主菜单和工具栏。 shell定义了应用程序的整体外观。它可以定义在shell布局本身中存在和可见的样式和边框，还可以定义将应用于插入到shell中的视图的样式，模板和主题。 通常，shell是WPF应用程序项目的一部分。包含shell的程序集可能引用也可能不引用包含要在shell的区域中加载的视图的程序集。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:2","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"Views\rView是复合应用程序中UI构造的主要单元。您可以将视图定义为 user control，page，data template或custom control。视图将您希望保留的UI的一部分封装为尽可能与应用程序的其他部分分离。您可以根据封装或功能选择视图中的内容，也可以选择将某些内容定义为视图，因为您的应用程序中将包含该视图的多个实例。 由于WPF的内容模型，定义视图所需的Prism库没有特定的内容。定义视图的最简单方法是定义用户控件。要向UI添加视图，您只需要一种方法来构建它并将其添加到容器中。WPF提供了执行此操作的机制。Prism Library添加了定义可在运行时动态添加视图的区域的功能。 Composite Views\r支持特定功能的视图可能会变得复杂。在这种情况下，您可能希望将视图划分为多个子视图，并让父视图句柄通过将子视图用作部件来构建自身。应用程序可能会在设计时静态地执行此操作，或者它可能支持让模块在运行时通过包含的区域添加子视图。如果某个视图未在单个视图类中完全定义，则可以将其称为复合视图。在许多情况下，复合视图负责构建子视图和协调它们之间的交互。您可以使用Prism Library命令和事件聚合器设计从其兄弟视图及其父组合视图中更松散耦合的子视图。 视图和设计模式\r虽然Prism Library不要求您使用它们，但在实现视图时应考虑使用多种UI设计模式之一。Stock Trader RI和QuickStart演示了Model-View-ViewModel（MVVM）模式，作为在视图布局和视图逻辑之间实现清晰分离的一种方式。 建议使用MVVM UI设计模式，因为它非常适合Microsoft XAML平台。这些平台的依赖属性系统和富数据绑定堆栈使视图和视图模型能够以松散耦合的方式进行通信。 将逻辑与视图分离对于可测试性和可维护性非常重要，并且它改进了开发人员 - 设计人员的工作流程。 如果使用用户控件或自定义控件创建视图并将所有逻辑放在代码隐藏文件中，则您的视图可能难以测试，因为您必须创建视图实例以对逻辑进行单元测试。如果视图派生或依赖于将WPF组件作为其执行上下文的一部分运行，则这是一个问题。为了确保您可以在没有这些依赖关系的情况下单独测试视图逻辑，您需要能够创建视图的模型以删除执行上下文的依赖关系，这需要视图和逻辑的单独类。 如果将视图定义为数据模板，则没有与视图本身关联的代码。因此，您必须将关联逻辑放在其他位置。逻辑与可测试性所需的布局清晰分离也有助于使视图更易于维护。 注意：单元测试和UI自动化测试是两种不同类型的测试，具有不同的覆盖范围。* 单元测试最佳实践建议单独测试对象。要实现对象隔离，每个外部依赖项都需要一个模型或存根。然后针对该对象运行粒度单元测试。 UI自动化测试运行应用程序，将手势应用于UI，然后测试预期结果。此类测试验证UI元素是否正确连接到应用程序逻辑。 将逻辑与视图分开可以清晰地分离关注点。除了可测试性考虑因素之外，这种分离使设计人员能够独立于开发人员在UI上工作。有关MVVM的更多信息，请参阅实现MVVM模式。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:3","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"Commands, UI Triggers, Actions, and Behaviors\r在代码隐藏文件中使用其逻辑实现视图时，可以向服务UI交互添加事件处理程序。但是，使用MVVM时，视图模型无法直接处理UI引发的事件。要将UI手势事件路由到视图模型，您可以使用命令或UI触发器，操作和行为。 命令\r命令将语义和从执行命令的逻辑调用命令的对象分开。内置命令是指示操作是否可用的能力。UI中的命令是绑定到视图模型上的ICommand属性的数据。有关命令的详细信息，请参阅命令在实现MVVM模式。 UI Triggers, Actions, and Behaviors\r触发器，操作和行为是Microsoft.Expression.Interactivity命名空间的一部分，随Blend for Visual Studio 2013一起提供。它们也是Blend SDK的一部分。触发器，操作和行为提供了一个用于处理UI事件或命令的综合API，然后将它们路由到DataContext公开的ICommand属性方法。有关UI触发器，操作和行为的更多信息，请参阅在高级MVVM方案中实现MVVM模式和交互触发器和事件到命令的部分。 用户交互\r用户交互是应用程序向用户呈现的交互。这些交互通常是呈现给用户的弹出窗口。在MVVM场景中，可以从视图或视图模型生成这些用户交互。Prism为视图模型需要请求用户交互时的情况提供InteractionRequests和InteractionRequestTriggers，为触发指定事件时视图需要调用命令时提供InvokeCommandAction操作。 有关用户交互，示例以及如何使用它们的更多信息，请参阅Interactivity QuickStart。 数据绑定\r数据绑定是XAML平台最重要的框架功能之一。要在XAML平台上成功开发应用程序，您需要充分了解数据绑定。 数据绑定充分利用了依赖属性系统提供的内在更改通知。当与INotifyPropertyChanged接口的公共语言运行时（CLR）类实现结合使用时，更改通知将启用参与数据绑定的目标和源对象之间的无代码交互。 通过使用值转换器将一种类型转换为另一种类型，数据绑定可以使不同的目标和源类型与数据绑定。数据绑定在其管道中有多个验证挂钩，可用于验证用户输入。 强烈建议您阅读MSDN上的依赖项属性概述和数据绑定概述主题。完全了解这两个主题对于在Microsoft XAML平台上成功开发应用程序至关重要。有关数据绑定的更多信息，请参阅数据绑定在实现MVVM模式。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:4","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"Regions\r通过区域管理器，区域和区域适配器在Prism库中启用区域。接下来的部分将介绍它们如何协同工作。 Region Manager\r该RegionManager类负责创建和维护区域的集合主机控制。该RegionManager使用一个新的区域与主机控制相关联的特定控制适配器。下图显示了RegionManager设置的区域，控件和适配器之间的关系。 该RegionManager可以在代码中创建或XAML地区。所述RegionManager.RegionName附加属性是用来通过将附加属性到主机控制以在XAML的区域。 应用程序可以包含RegionManager的一个或多个实例。您可以指定要在其中注册区域的RegionManager实例。如果要在可视树中移动控件并且不希望在删除附加属性值时清除区域，则此选项非常有用。 所述RegionManager提供RegionContext附加属性，允许其区域共享数据。 Region Implementation\r区域是实现IRegion接口的类。术语区域表示可以保存UI中呈现的动态数据的容器。区域允许Prism库将包含在模块中的动态内容放置在UI容器中的预定义占位符中。 区域可以包含任何类型的UI内容。模块可以包含作为用户控件呈现的UI内容，与数据模板相关联的数据类型，自定义控件或这些的任何组合。这使您可以定义UI区域的外观，然后让模块将内容放在这些预定区域中。 区域可以包含零个或多个项目。根据区域管理的主机控件的类型，可以看到一个或多个项目。例如，ContentControl只能显示单个对象。但是，它所在的区域可以包含许多项目，ItemsControl可以显示多个项目。这允许区域中的每个项目在UI中可见。 在下图中，Stock Trader RI shell包含四个区域：MainRegion，MainToolbarRegion，ResearchRegion和ActionRegion。这些区域由应用程序中的各种模块填充 - 内容可以随时更改。 模块用户控制到区域映射\rModule User Control to Region Mapping 要演示模块和内容如何与区域关联，请参阅下图。它显示了WatchModule和NewsModule与shell中相应区域的关联。 所述MainRegion包含WatchListView用户控制，这被包含在WatchModule。所述ResearchRegion还包含ArticleView用户控制，这被包含在NewsModule。 在使用Prism Library创建的应用程序中，这样的映射将成为设计过程的一部分，因为设计人员和开发人员使用它们来确定在特定区域中建议的内容。这允许设计人员确定所需的总空间以及必须添加的任何其他项目，以确保内容在可允许的空间中可见。 Default Region Functionality\r虽然您不需要完全理解区域实现以使用它们，但了解控件和区域如何关联以及默认区域功能可能很有用：例如，区域如何定位和实例化视图，以及如何在视图时通知视图是活动视图，还是视图生命周期如何与激活相关联。 以下部分描述了区域适配器和区域行为。 Region Adapter\r要将UI控件公开为区域，它必须具有区域适配器。区域适配器负责创建区域并将其与控件相关联。这允许您使用IRegion接口以一致的方式管理UI控件内容。每个区域适配器都适应特定类型的UI控件。Prism库提供以下三种区域适配器： ContentControlRegionAdapter。此适配器适应System.Windows.Controls.ContentControl类型和派生类的控件。 SelectorRegionAdapter。此适配器适应从System.Windows.Controls.Primitives.Selector类派生的控件，例如System.Windows.Controls.TabControl控件。 ItemsControlRegionAdapter。此适配器适应System.Windows.Controls.ItemsControl类型和派生类的控件。 Region Behaviors\rPrismLibrary介绍了区域行为的概念。这些是可插拔(pluggable )组件，为区域提供了大部分功能。引入了区域行为以支持视图发现和区域上下文（在本主题后面描述），并创建在WPF和Silverlight中一致的API。此外，行为提供了扩展区域实施的有效方式。 区域行为是附加到区域的类，以为该区域提供附加功能。此行为附加到该区域，并在该区域的生命周期内保持活动状态。例如，当AutoPopulateRegionBehavior附加到某个区域时，它会自动实例化并添加针对具有该名称的区域注册的任何ViewType。对于该区域的生命周期，它会持续监视RegionViewRegistry以进行新注册。可以在系统范围或每个区域的基础上轻松添加自定义区域行为或替换现有行为。 下一节将介绍自动添加到所有区域的默认行为。一种行为SelectorItemsSourceSyncBehavior仅附加到从Selector派生的控件。 注册行为\r该RegionManagerRegistrationBehavior是负责确保该区域被注册到正确的RegionManager。当视图或控件作为另一个控件或区域的子项添加到可视树中时，控件中定义的任何区域都应该在父控件的RegionManager中注册。删除子控件后，注册的区域将取消注册。 Auto-Population Behavior\r有两个类负责实现视图发现。其中之一是AutoPopulateRegionBehavior。当它附加到某个区域时，它会检索在该区域名称下注册的所有视图类型。然后，它创建这些视图的实例并将它们添加到该区域。创建区域后，AutoPopulateRegionBehavior将监视RegionViewRegistry以查找该区域名称的任何新注册的视图类型。 如果您想要更多地控制视图发现过程，请考虑创建自己的IRegionViewRegistry实现和AutoPopulateRegionBehavior。 Region Context Behaviors\r区域上下文功能包含在两个行为中：SyncRegionContextWithHostBehavior和BindRegionContextToDependencyObjectBehavior。这些行为负责监视对区域所做的上下文的更改，然后将上下文与附加到视图的上下文依赖项属性同步。 Activation Behavior\r所述RegionActiveAwareBehavior负责通知的图，如果它是有效或无效。视图必须实现IActiveAware才能接收这些更改通知。此主动感知通知是单向的（它从行为传播到视图）。通过更改IActiveAware接口上的活动属性，视图不会影响其活动状态。 Region Lifetime Behavior\r所述RegionMemberLifetimeBehavior负责确定如果一个项目应该从区域时被去激活被移除。该RegionMemberLifetimeBehavior监控区域的ActiveViews收集发现的项目，过渡到非激活状态。该行为检查已删除的项目是否为IRegionMemberLifetime或RegionMemberLifetimeAttribute（按此顺序），以确定它是否应在删除时保持活动状态。 如果集合中的项是System.Windows.FrameworkElement，它还将检查其DataContext的IRegionMemberLifetime或RegionMemberLifetimeAttribute。 按以下顺序检查区域项： IRegionMemberLifetime.KeepAlive值 DataContext的IRegionMemberLifetime.KeepAlive值 RegionMemberLifetimeAttribute.KeepAlive值 DataContext的RegionMemberLifetimeAttribute.KeepAlive值 Control-Specific Behaviors\r所述SelectorItemsSourceSyncBehavior仅用于从导出的控制选择器，例如在一个WPF标签控制。它负责将区域中的视图与选择器的项同步，然后将区域中的活动视图与选择器的选定项同步。 Extending the Region Implementation\rPrism Library提供了扩展点，允许您自定义或扩展所提供API的默认行为。例如，您可以编写自己的区域适配器，区域行为或更改Navigation API分析URI的方式。有关扩展棱镜库的更多信息，请参阅扩展棱镜库。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:5","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"View Composition\r视图合成是视图的构建。在复合应用程序中，必须在运行时在应用程序UI中的特定位置显示来自多个模块的视图。要实现此目的，您需要定义视图的显示位置以及在这些位置创建和显示视图的方式。 可以通过视图发现自动创建和显示视图，也可以通过视图注入以编程方式显示视图。这两种技术决定了各个视图如何映射到应用程序UI中的命名位置。 View Discovery\r在视图发现中，您可以在RegionViewRegistry中在区域名称和视图类型之间建立关系。创建区域时，该区域将查找与该区域关联的所有ViewType，并自动实例化并加载相应的视图。因此，使用视图发现时，您无法明确控制何时加载和显示与区域对应的视图。 View Injection\r在视图注入中，您的代码获取对区域的引用，然后以编程方式向其中添加视图。通常，这在模块初始化或作为用户操作的结果时完成。您的代码将按名称查询RegionManager中的特定区域，然后将视图注入其中。通过视图注入，您可以更好地控制何时加载和显示视图。您还可以从该地区删除视图。但是，使用视图注入时，无法将视图添加到尚未创建的区域。 View Injection\rPrism Library 4.0包含导航API。Navigation API允许您将区域导航到URI，从而简化了视图注入过程。Navigation API实例化视图，将其添加到区域，然后激活它。此外，Navigation API允许导航回包含在区域中的先前创建的视图。有关导航API的更多信息，请参阅导航。 使用View Discovery与View Injection\r选择要用于区域的视图加载策略取决于应用程序要求和区域的功能。 在以下情况下使用视图发现： 需要或需要自动加载视图。 视图的单个实例将加载到该区域中。 在以下情况下使用视图注入： 您的应用程序使用导航API。 您需要对创建和显示视图的时间进行显式或程序控制，或者需要从区域中删除视图; 例如，作为应用程序逻辑或导航的结果。 您需要在区域中显示相同视图的多个实例，其中每个视图实例都绑定到不同的数据。 您需要控制添加视图的区域的哪个实例。例如，您要将客户详细信息视图添加到特定客户详细信息区域。（此方案需要实现作用域，如本主题后面所述。） ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:6","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"UI布局方案\r在复合应用程序中，来自多个模块的视图在运行时显示在应用程序UI中的特定位置。要实现此目的，您需要定义视图的显示位置以及在这些位置创建和显示视图的方式。 视图和将在其中显示的UI中的位置的分离允许应用程序的外观和布局独立于区域内出现的视图而发展。 下一节将介绍开发复合应用程序时将遇到的核心方案。适当时，Stock Trader RI的示例将用于演示该场景的解决方案。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:7","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"实现Shell\rshell是应用程序根对象，其中包含主UI内容。在Windows Presentation Foundation（WPF）应用程序中，shell是Window对象。 shell可以包含命名区域，其中模块可以指定将出现的视图。它还可以定义某些顶级UI元素，例如主菜单和工具栏。shell定义应用程序的整体结构和外观，类似于ASP.NET母版页控件。它可以定义在shell布局本身中存在和可见的样式和边框，还可以定义应用于插入到shell中的视图的样式，模板和主题。 作为应用程序体系结构的一部分，您不需要使用独特的shell来使用Prism库。如果要构建一个全新的复合应用程序，实现一个shell提供了一个定义良好的根和初始化模式，用于设置应用程序的主UI。但是，如果要将Prism Library功能添加到现有应用程序，则无需更改应用程序的基本体系结构即可添加shell。相反，您可以更改现有的窗口定义或控件，以添加可根据需要提取视图的区域。 您的应用程序中也可以有多个shell。如果您的应用程序旨在为用户打开多个顶级窗口，则每个顶级窗口都充当其包含的内容的shell。 股票交易员RI Shell\rWPF Stock Trader RI有一个shell作为主窗口。在下图中，将突出显示shell和视图。shell是Stock Trader RI启动时显示的主窗口，其中包含所有视图。它定义了模块添加其视图的区域以及一些顶级UI项目，包括CFI Stock Trader标题和Watch List撕下横幅。 Stock Trader RI中的shell实现由Shell.xaml及其代码隐藏文件Shell.xaml.cs及其视图模型ShellViewModel.cs提供。Shell.xaml包括作为shell一部分的布局和UI元素，包括模块添加其视图的区域的定义。 以下XAML显示了定义shell的结构和主要XAML元素。请注意，RegionName附加属性用于定义四个区域，窗口背景图像为shell提供背景。 \u003c!--Shell.xaml (WPF) --\u003e \u003cWindow x:Class=\"StockTraderRI.Shell\"\u003e \u003c!--shell background --\u003e \u003cWindow.Background\u003e \u003cImageBrush ImageSource=\"Resources/background.png\" Stretch=\"UniformToFill\"/\u003e \u003c/Window.Background\u003e \u003cGrid\u003e \u003c!-- logo --\u003e \u003cCanvas x:Name=\"Logo\" ...\u003e \u003cTextBlock Text=\"CFI\" ... /\u003e \u003cTextBlock Text=\"STOCKTRADER\" .../\u003e \u003c/Canvas\u003e \u003c!-- main bar --\u003e \u003cItemsControl x:Name=\"MainToolbar\" prism:RegionManager.RegionName=\"{x:Static inf:RegionNames.MainToolBarRegion}\"/\u003e \u003c!-- content --\u003e \u003cGrid\u003e \u003cControls:AnimatedTabControl x:Name=\"PositionBuySellTab\" prism:RegionManager.RegionName=\"{x:Static inf:RegionNames.MainRegion}\"/\u003e \u003c/Grid\u003e \u003c!-- details --\u003e \u003cGrid\u003e \u003cContentControl x:Name=\"ActionContent\" prism:RegionManager.RegionName=\"{x:Static inf:RegionNames.ActionRegion}\"/\u003e \u003c/Grid\u003e \u003c!-- sidebar --\u003e \u003cGrid x:Name=\"SideGrid\"\u003e \u003cControls:ResearchControl prism:RegionManager.RegionName=\"{x:Static inf:RegionNames.ResearchRegion}\" /\u003e \u003c/Grid\u003e \u003c/Grid\u003e \u003c/Window\u003e 在实施Shell代码隐藏文件是非常简单的。当引导程序创建Shell，它的依赖将被托管扩展框架（MEF）解决。shell具有单一依赖关系 - ShellViewModel -在构造期间注入，如以下示例所示。 // Shell.xaml.cs [Export] public partial class Shell : Window { public Shell() { InitializeComponent(); } [Import] ShellViewModel ViewModel { set { this.DataContext = value; } } } // ShellViewModel.cs [Export] public class ShellViewModel : BindableBase { // This is where any view model logic for the shell would go. } 代码隐藏文件中的最小代码说明了复合应用程序体系结构的强大功能和简单性以及shell与其组成视图之间的松散耦合。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:8","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"定义区域\r您可以通过定义具有命名位置的布局（称为区域）来定义视图的显示位置。区域充当将在运行时显示的一个或多个视图的占位符。模块可以在布局中的区域中定位和添加内容，而无需知道区域的显示方式和位置。这允许更改布局而不影响将内容添加到布局的模块。 通过将区域名称分配给WPF控件（在上一个Shell.xaml文件中显示的XAML中或代码中）来定义区域。可以通过区域名称访问区域。在运行时，视图将添加到命名的Region控件，然后根据视图实现的布局策略显示视图。例如，选项卡控件区域将以选项卡式排列其子视图。区域支持添加或删除视图。可以通过编程方式或自动方式在区域中创建和显示视图。在Prism Library中，前者通过视图注入实现，后者通过视图发现实现。这两种技术决定了各个视图如何映射到应用程序UI中的命名区域。 应用程序的shell定义了最高级别的应用程序布局; 例如，通过指定主要内容和导航内容的位置，如下图所示。这些高级视图中的布局类似地定义，允许以递归方式组合整个UI。 区域有时用于定义逻辑上相关的多个视图的位置。在这种情况下，区域控件通常是一个ItemsControl派生的控件，它将根据它实现的布局策略显示视图，例如以堆叠或选项卡式布局排列。 区域也可用于定义单个视图的位置; 例如，通过使用ContentControl。在这种情况下，区域控件一次只显示一个视图，即使多个视图映射到该区域位置也是如此。 股票交易者RI shell Regions\r当应用程序购买或出售股票时，股票交易者RI也会演示多视图布局。买/卖区域是一个列表样式区域，显示多个买入/卖出视图（OrderCompositeView）作为其列表的一部分，如下图所示。 shell的ActionRegion包含OrdersView。该OrdersView包含提交所有和取消所有按钮还有OrdersRegion。所述OrdersRegion附着到列表框，其显示多个控制OrderCompositeViews。 IRegion\r区域是实现IRegion接口的类。该区域是容纳控件显示内容的容器。以下代码显示了IRegion接口。 public interface IRegion : INavigateAsync, INotifyPropertyChanged { IViewsCollection Views { get; } IViewsCollection ActiveViews { get; } object Context { get; set; } string Name { get; set; } Comparison\u003cobject\u003e SortComparison { get; set; } IRegionManager Add(object view); IRegionManager Add(object view, string viewName); IRegionManager Add(object view, string viewName, bool createRegionManagerScope); void Remove(object view); void Deactivate(object view); object GetView(string viewName); IRegionManager RegionManager { get; set; } IRegionBehaviorCollection Behaviors { get; } IRegionNavigationService NavigationService { get; set; } } Adding a Region in XAML\r该RegionManager提供一个附加属性，您可以使用在XAML简单的区域生成。要使用附加属性，必须将Prism Library命名空间加载到XAML中，然后使用RegionName附加属性。以下示例显示如何在具有AnimatedTabControl的窗口中使用附加属性。 注意使用x：Static标记扩展来引用MainRegion字符串常量。这种做法消除了XAML中的魔术字符串。 \u003c!-- (WPF) --\u003e \u003cControls:AnimatedTabControl x:Name=\"PositionBuySellTab\" prism:RegionManager.RegionName=\"{x:Static inf:RegionNames.MainRegion}\"/\u003e Adding a Region by Using Code\r所述RegionManager可以直接在不使用XAML寄存器区域。以下代码示例演示如何从代码隐藏文件向控件添加区域。首先，获得对区域管理者的引用。然后，使用RegionManager静态方法SetRegionManager和SetRegionName，将该区域附加到UI的ActionContent控件，然后将该区域命名为ActionRegion。 IRegionManager regionManager = ServiceLocator.Current.GetInstance\u003cIRegionManager\u003e(); RegionManager.SetRegionManager(this.ActionContent, regionManager); RegionManager.SetRegionName(this.ActionContent, \"ActionRegion\"); ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:9","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"Displaying Views in a Region When the Region Loads\r使用视图发现方法，模块可以为特定的命名位置注册视图（视图模型或表示模型）。在运行时显示该位置时，将自动创建并在其中显示已为该位置注册的所有视图。 模块使用注册表注册视图。父视图查询此注册表以发现为命名位置注册的视图。发现它们之后，父视图会将这些视图添加到占位符控件中，从而将这些视图放在屏幕上。 加载应用程序后，将通知组合视图以处理已添加到注册表的新视图的放置。 下图显示了视图发现方法。 Prism Library定义了一个标准注册表RegionViewRegistry，用于注册这些命名位置的视图。 要显示区域中的视图，请使用区域管理器注册视图，如以下代码示例所示。您可以直接向区域注册视图类型，在这种情况下，视图将由依赖项注入容器构造，并在加载托管区域的控件时添加到区域。 // View discovery this.regionManager.RegisterViewWithRegion(\"MainRegion\", typeof(EmployeeView)); （可选）您可以提供一个返回要显示的视图的委托，如下一个示例所示。区域管理器将在创建区域时显示视图。 // View discovery this.regionManager.RegisterViewWithRegion(\"MainRegion\", () =\u003e this.container.Resolve\u003cEmployeeView\u003e()); UI Composition QuickStart在EmployeeModule ModuleInit.cs文件中有一个演练，演示了如何使用RegisterViewWithRegion方法。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:10","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"Displaying Views in a Region Programmatically\r在视图注入方法中，视图以编程方式添加或由管理它们的模块从命名位置删除。要启用此功能，应用程序将在UI中包含命名位置的注册表。模块可以使用注册表查找其中一个位置，然后以编程方式将视图注入其中。为了确保可以类似地访问注册表中的位置，每个命名位置都遵循用于注入视图的公共接口。下图显示了视图注入方法。 Prism库定义了一个标准注册表RegionManager和一个标准接口IRegion，用于访问这些位置。 要使用视图注入向区域添加视图，请从区域管理器中获取区域，然后调用Add方法，如以下代码所示。使用视图注入时，仅在将视图添加到区域后才会显示视图，这可能在加载模块或用户操作完成预定义操作时发生。 // View injection IRegion region = regionManager.Regions[\"MainRegion\"]; var ordersView = container.Resolve\u003cOrdersView\u003e(); region.Add(ordersView, \"OrdersView\"); region.Activate(ordersView); 除了Stock Trader RI之外，UI Composition QuickStart还有一个实现视图注入的演练。 Region Navigation\rPrism Library 5.0包含导航API，它提供了丰富且一致的API，用于在WPF应用程序中实现导航。 区域导航是视图注入的一种形式。处理导航请求时，它将尝试在可以满足请求的区域中查找视图。如果找不到匹配的视图，它会调用应用程序容器来创建对象，然后将对象注入目标区域并激活它。 Stock Trader RI ArticleViewModel的以下代码示例说明了如何发起导航请求。 this.regionManager.RequestNavigate(RegionNames.SecondaryRegion, new Uri(\"/NewsReaderView\", UriKind.Relative)); 有关区域导航的更多信息，请参阅导航。视图切换导航快速入门和基于状态的导航快速入门也是实现应用程序导航的示例。 Ordering Views in a Region\r无论是使用视图发现还是查看注入，应用程序都可能需要命令视图在TabControl，ItemsControl或显示多个活动视图的任何其他控件中的显示方式。默认情况下，视图按其注册顺序显示并添加到区域中。 构建复合应用程序时，通常会从不同的模块注册视图。声明模块之间的依赖关系有助于缓解问题，但是当模块和视图没有任何真正的相互依赖关系时，声明人工依赖会不必要地耦合模块。 为了允许视图参与自己的排序，Prism库提供了ViewSortHint属性。此属性包含字符串Hint属性，该属性允许视图声明在区域中如何排序的提示。 显示视图时，Region类使用默认视图排序例程，该例程使用提示对视图进行排序。这是一个简单的区分大小写的排序。具有sort hint属性的视图在没有排序的视图之前排序。此外，没有属性的那些按照添加到区域的顺序显示。 如果要更改视图的排序方式，Region类提供了一个SortComparison属性，您可以使用自己的Comparison \u003c object \u003e委托方法设置该属性。值得注意的是，区域的Views和ActiveViews属性的顺序会反映在UI中，因为诸如ItemsControlRegionAdapter之类的适配器直接绑定到这些属性。自定义区域适配器可以实现自己的排序和过滤器，它将覆盖区域命令视图的方式。 View Switching QuickStart演示了一种简单的编号方案，用于对左侧导航区域中的视图进行排序。以下代码示例显示应用于每个导航项视图的ViewSortHint。 [Export] [ViewSortHint(\"01\")] public partial class EmailNavigationItemView { ... } [Export] [ViewSortHint(\"02\")] public partial class CalendarNavigationItemView { ... } [Export] [ViewSortHint(\"03\")] public partial class ContactsDetailNavigationItemView { ... } [Export] [ViewSortHint(\"04\")] public partial class ContactsAvatarNavigationItemView { ... } ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:11","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"在多个区域之间共享数据\rPrism Library提供了多种方法来在视图之间进行通信，具体取决于您的方案。区域管理器提供RegionContext属性作为这些方法之一。 当您想要共享父视图和区域中托管的子视图之间的上下文时，RegionContext非常有用。RegionContext是附加属性。您可以在区域控件上设置上下文的值，以便可以使该区域控件中显示的所有子视图都可以使用它。区域上下文可以是任何简单或复杂的对象，也可以是数据绑定值。该RegionContext可以与任一视图中发现或视图注射使用。 注意： WPF中的DataContext属性用于设置视图的本地数据上下文。它允许视图使用数据绑定与视图模型，本地演示者或模型进行通信。RegionContext用于在多个视图之间共享上下文，而不是单个视图的本地视图。它提供了一种在多个视图之间共享上下文的简单机制。 以下代码显示了如何在XAML中使用RegionContext附加属性。 \u003cTabControl AutomationProperties.AutomationId=\"DetailsTabControl\" prism:RegionManager.RegionName=\"{x:Static local:RegionNames.TabRegion}\" prism:RegionManager.RegionContext=\"{Binding Path=SelectedEmployee.EmployeeId}\" ...\u003e 您还可以在代码中设置RegionContext，如以下示例所示。 RegionManager.Regions[\"Region1\"].Context = employeeId; 要在视图中检索RegionContext，请使用RegionContext类的GetObservableContext静态方法。它将视图作为参数传递，然后访问其Value属性，如以下代码示例所示。 private void GetRegionContext() { this.Model.EmployeeId = (int)RegionContext.GetObservableContext(this).Value; } 所述的值RegionContext可以从视图中通过简单地分配一个新的值到它的改变值属性。通过订阅GetObservableContext方法返回的ObservableObject上的PropertyChanged事件，可以选择通过视图通知RegionContext的更改。这允许在更改RegionContext时保持多个视图同步。以下代码示例演示了订阅PropertyChanged事件。 ObservableObject\u003cobject\u003e viewRegionContext = RegionContext.GetObservableContext(this); viewRegionContext.PropertyChanged += this.ViewRegionContext_OnPropertyChangedEvent; private void ViewRegionContext_OnPropertyChangedEvent(object sender, PropertyChangedEventArgs args) { if (args.PropertyName == \"Value\") { var context = (ObservableObject\u003cobject\u003e) sender; int newValue = (int)context.Value; } } 注意：该RegionContext被设置为在该区域托管内容对象上附加属性。这意味着内容对象必须从DependencyObject派生。在前面的示例中，视图是一个可视控件，最终从DependencyObject派生。 如果选择使用WPF数据模板来定义视图，则内容对象将表示ViewModel或PresentationModel。如果视图模型或表示模型需要检索RegionContext，则需要从DependencyObject基类派生。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:12","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"创建区域的多个实例\r只有视图注入才能使用范围区域。如果您需要视图以拥有自己的区域实例，则应使用它们。定义具有附加属性的区域的视图会自动继承其父级的RegionManager。通常，这是在shell窗口中注册的全局RegionManager。如果应用程序创建该视图的多个实例，则每个实例都会尝试使用父RegionManager注册其区域。RegionManager只允许唯一命名的区域; 因此，第二次注册会产生错误。 相反，使用作用域区域，以便每个视图都有自己的RegionManager，其区域将使用该RegionManager而不是父RegionManager注册，如下图所示。 要为视图创建本地RegionManager，请指定在将视图添加到区域时应创建新的RegionManager，如以下代码示例所示。 IRegion detailsRegion = this.regionManager.Regions[\"DetailsRegion\"]; View view = new View(); bool createRegionManagerScope = true; IRegionManager detailsRegionManager = detailsRegion.Add(view, null, createRegionManagerScope); 该添加方法将返回新RegionManager该视图可以保留进一步访问本地范围。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:13","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"创建视图\r应用程序的可视化表示形式可以采用多种形式，包括用户控件，自定义控件和数据模板等。对于Stock Trader RI，用户控件通常用于表示主窗口上的不同部分，但这不是标准。在您的应用程序中，您应该使用您最熟悉的方法，这种方法适合您作为设计师的工作方式。无论应用程序中的主要可视化表示如何，您都将不可避免地在整体设计中使用用户控件，自定义控件和数据模板的组合。下图显示了Stock Trader RI使用这些不同项目的位置。此图还可作为以下部分的参考，这些部分描述了每个项目。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:14","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"用户控件\rBlend for Visual Studio 2013和Visual Studio 2013都为创建用户控件提供了丰富的支持。因此，建议使用这些工具创建的用户控件使用Prism Library创建UI内容。如本主题前面所述，Stock Trader RI广泛使用它们来创建将插入区域的内容。所述WatchListView.xaml用户控制是包含内部的简单的用户界面表示的一个很好的例子WatchModule。此控件是一个非常简单的控件，使用此模型可以直接创建。 自定义控件\r在某些情况下，用户控制太有限。在这些情况下，自定义布局或可扩展性比创建的简便性更重要。这是自定义控件有用的地方。在Stock Trader RI中，饼图控件就是一个很好的例子。该控制由来自头寸的数据组成，并显示整个投资组合的图表。与用户控件相比，这种类型的控件比创建用户控件更具挑战性，与用户控件相比，它在Blend for Visual Studio 2013和Visual Studio 2013中的视觉设计支持有限。 数据模板\r数据模板是大多数类型的数据驱动应用程序的重要组成部分。基于列表的控件的数据模板的使用在整个股票交易者RI中很普遍。在许多情况下，您可以使用数据模板来创建完整的可视化表示，而无需创建任何类型的控件。该ResearchRegion使用数据模板显示的文章，并与一个联合项目的风格，提供了的选择项目的指示。 Visual Studio 2013和Visual Studio 2013的Blend具有对数据模板的完全可视化设计支持。 资源\r样式，资源字典和控件模板等资源可以分散在整个应用程序中。复合应用程序尤其如此。在考虑放置资源的位置时，请特别注意UI元素与所需资源之间的依赖关系。Stock Trader RI解决方案（如下图所示）包含指示资源可以存在的各个区域的标签。 Application Resources\r通常，应用程序资源是整个应用程序可用的资源。这些资源往往集中在根应用程序上，但它们也可以在模型或控件的类型基础上提供默认样式。例如，文本框样式应用于根应用程序中的文本框类型。除非在模块或控件级别覆盖样式，否则此样式将可用于应用程序中的所有文本框。 Module Resources\r模块资源与根应用程序资源的作用相同，因为它们可以应用于模块中的所有项目。使用此级别的资源可以在整个模块中提供一致的外观，并且还允许在跨越一个或多个可视组件的更具体实例中重用。模块级别的资源使用应包含在单个模块中。在UI元素显示不正确时，创建模块之间的依赖关系可能导致难以找到的问题。 Control Resources\r控制资源通常包含在控制库中，可供控制库中的所有控件使用。这些资源往往具有最有限的范围，因为控制库通常包含非常特定的控件，并且不包含用户控件。（在使用Prism Library创建的应用程序中，用户控件通常放在使用它们的模块中。） ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:15","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"UI设计指南\r本主题的目标是为正在使用Prism Library和WPF构建应用程序的XAML设计人员和开发人员提供一些高级指导。本主题描述UI布局，可视化表示，数据绑定，资源和表示模型。阅读本主题后，您应该高度了解如何基于Prism库设计应用程序的UI，以及一些可以帮助您在复合应用程序中创建可维护UI的技术。 设计用户界面的指南\r使用Prism Library创建的复合应用程序的布局建立在WPF的标准主体上 - 布局使用包含相关项的面板的概念。但是，对于复合应用程序，各种面板内的内容是动态的，在设计时不知道。这迫使设计人员和开发人员创建可以包含布局内容的页面结构，然后分别设计适合布局的每个元素。作为设计人员或开发人员，这意味着您必须考虑Prism库中的两个主要布局概念：容器组合和区域。 容器组成\r容器组合实际上只是WPF本身提供的包含模型的扩展。术语容器可以表示任何元素，包括窗口，页面，用户控件，面板，自定义控件，控件模板或数据模板，它们可以包含其他元素。 您可视化UI的方式因实现而异，但您会发现突出的重复主题。您将创建包含固定内容和动态内容的窗口，页面或用户控件。固定内容将包含包含UI元素的整体结构，动态内容将放置在区域内。 例如，WPF Stock Trader RI有一个名为Shell.xaml的启动窗口，其中包含应用程序的整体结构。下图显示了Blend for Visual Studio 2013中加载的shell。请注意，只有UI的固定部分可见。当应用程序加载时，shell的其余部分由模块动态插入到各个区域中。 在这种类型的应用程序中，设计时体验有点受限，但是您知道内容将在运行时放置在不同区域这一事实是您需要设计的。要查看此示例，请将下一个插图中主页面的设计器视图与其后的插图中的运行时视图进行比较。在设计器视图中，页面大多是空的。与运行时视图对比，其中存在包含具有位置数据的选项卡控件的位置区域，以及与所选股票相关的趋势线，饼图和新闻区域。设计器视图和运行时视图之间的差异表明了设计人员和开发人员在创建使用Prism Library构建的应用程序时所面临的挑战。 在设计时间内无法看到物品; 因此，确定它们的大小以及它们如何适应应用程序的整体外观有点困难。在为容器创建布局时，请考虑以下事项： 是否有任何大小限制会限制内容的大小？如果有，请考虑使用支持滚动的容器。 考虑使用扩展器和ScrollViewer组合，以适应大量动态内容需要适应受限区域的情况。 密切关注内容随着屏幕内容的增长而扩大的程度，以确保应用程序的外观在任何分辨率下都具有吸引力。 股票交易者RI主窗口在Blend for Visual Studio 2013 在运行时间的股票交易商RI主窗口 在设计时查看复合应用程序\r前面的两个图说明了使用在运行时组成的高级视图的挑战之一。复合应用程序中的每个UI元素必须单独设计。这使得很难直观地看出复合页面或窗口在运行时的外观。要在组合状态下可视化组合视图，可以使用包含要测试的视图的所有UI元素的页面或窗口创建测试项目。 此外，请考虑在Blend for Visual Studio 2013和Visual Studio 2013中使用设计时样本数据功能，以使用数据填充UI元素。使用数据模板，列表控件，图表或图形时，设计时数据非常有用。有关更多信息，请参阅设计时样本数据指南部分。 布局\r在设计复合应用程序的布局时，请考虑以下事项： shell定义了应用程序的主要布局。布局的每个区域都是一个区域，应保留为空容器。不要在设计时将内容放在区域内，因为内容将在运行时加载到那里。 shell应包含背景，标题和页脚。将shell视为ASP.NET母版页。 充当区域的控制容器与它们包含的视图分离。因此，您应该能够在不修改控件的情况下更改视图的大小，并且应该能够在不修改视图的情况下更改控件的大小。定义视图大小时应考虑以下事项： 如果视图将在多个区域中使用，或者如果不确定将在何处使用，请使用动态宽度和高度进行设计。 如果视图具有固定大小，则shell的区域应使用动态大小。 如果shell区域具有固定大小，则视图应使用动态大小。 视图可能需要固定的高度和动态宽度。这方面的一个例子是位于Stock Trader RI侧栏的PositionPieChart视图。 其他视图可能需要动态高度和宽度**。例如，StockTrader RI侧栏中的NewsReader视图。高度本身取决于标题的长度，宽度应始终适应区域的大小（侧边栏宽度）。这同样适用于PositionSummaryView**视图，其中网格的宽度应适应屏幕大小，高度应适应网格中的行数。 视图通常应具有透明背景，允许shell背景提供应用程序视觉背景。 始终使用命名资源来分配颜色，画笔，字体和字体大小，而不是直接在XAML中分配属性值。这使得应用程序维护更容易。它还允许应用程序在运行时响应资源字典中的更改。 动画\r在shell或视图中使用动画时，请考虑以下事项： 您可以为shell的布局设置动画，但您必须单独为其内容和视图设置动画。 分别设计和动画每个视图。 使用柔和或温和的动画来提供UI元素被带入视图或从视图中移除的视觉线索。这为应用程序提供了抛光的外观和感觉。 Blend for Visual Studio 2013提供了丰富的行为，简化功能，以及基于可视状态更改或事件动画和转换UI元素的出色编辑体验。有关更多信息，请参阅MSDN上的VisualStateManager类。 运行时优化\r请考虑以下有关性能优化的提示： 将任何公共资源放在App.xaml文件或合并字典中以避免重复样式。 设计时优化\r以下部分描述了设计时方案，并提供了充分利用设计时体验的解决方案。 Large Solutions with Many XAML Resources\r在具有许多XAML资源的大型应用程序中，可视化设计器的加载时间可能会受到影响，有时会显着影响。这种性能下降的存在是因为可视化设计器必须解析所有合并的XAML资源。此问题的解决方案是将所有XAML资源移动到另一个解决方案，编译该解决方案，然后从大型解决方案引用新的XAML资源DLL。由于XAML资源位于二进制引用的程序集中，因此可视化设计器不会解析XAML资源，从而提高了设计时性能。将XAML资源移动到外部程序集时，您可能需要考虑为您的资源公开ComponentResourceKeys。有关更多信息，请参阅MSDN上的ComponentResourceKey标记扩展。 XAMLAssets\rXAML是一种功能强大且富有表现力的语言，用于创建图像，图表，绘图和三维场景等资源。一些开发人员和设计人员更喜欢创建XAML资产，而不是使用.ico，.jpg或.png图像文件。他们更喜欢XAML方法的一个原因是利用XAML渲染的分辨率独立性。另一个是他们可以使用一个工具集Blend for Visual Studio 2013来创建所有必需的资产并设计他们的应用程序。 如果解决方案具有许多这些资产，则可能会影响设计时可视化设计器的加载。将资产移动到单独的DLL可以解决性能问题。移动资产还可以跨多个解决方案重用。 Visual Designers and Referenced Assemblies\r将XAML资源和资产移动到二进制引用程序集的一个令人遗憾的副作用是，Blend for 2013和Visual Studio 2013属性编辑器不会列出位于二进制引用程序集中的资源。这意味着您将无法从工具提供的其中一个资源选择器中选择命名资源。相反，您需要输入资源的名称。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:16","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"创建设计友好视图的指南\r以下是设计人员友好（也称为可混合或可**工具）应用程序的一些特征： 它通过使用Visual Studio和Blend设计器提供了高效的编辑体验。 它是启用工具的。例如，它允许您使用绑定构建器。 它在需要时提供设计时样本数据。 它允许在设计时执行代码，而不会导致未处理的异常。 在编辑会话期间多次执行以下操作。非设计友好的用户代码将导致这些操作中的一个或多个失败，从而降低开发人员或设计人员的工作效率和创造力。 设计表面动作： 构造对象 加载对象 设置属性值 执行设计表面手势 使用控件作为根元素 在另一个控件内部托管控件 重复打开，关闭和重新打开XAML文件 重建项目 重塑设计师 绑定构建器操作： 发现DataContext 列出可用的数据源 列出数据源类型属性 设计时样本数据操作： 使用设计图面上的控件正确显示样本数据 编码设计时间\r为了给您丰富的设计时体验，Visual Studio和Blend设计人员在设计时实例化对象并运行代码。但是，在实例化之前尝试访问引用类型的代码导致的空引用异常会导致高百分比的加载失败和不必要的设计时异常。 下表列出了设计时体验不佳的主要原因。通过避免以下问题并使用这些技术来缓解这些问题，您的设计时体验和生产力将大大提高，开发人员到设计人员的工作流程将更加顺畅。 用户代码中避免使用此功能 Visual Studio 2013 混合Visual Studio 2013 在设计时旋转多个线程。例如，在构造函数中实例化和启动Timer或在设计时启动Loaded事件。 使用在设计时导致堆栈溢出的控件。 使用尝试递归加载自身的控件。 在转换器或数据模板选择器中抛出空引用异常。 在构造函数中抛出null引用或其他异常。这些是由：使用调用业务或数据层的代码在设计时从数据库或网络返回数据。在引导或容器初始化代码运行之前，尝试使用MEF，控制反转（IoC）或服务定位器来解决依赖关系。 在控件或用户控件的Loaded事件中抛出空引用或其他异常。当您对运行时可能为真的控件状态进行假设但在设计时不正确时会发生这种情况。 尝试在设计时访问Application或Application.Current对象。 创建非常大的项目。 减少设计时用户代码中的问题\r一些防御性编码实践将消除上表中描述的大多数问题。但是，在您可以缓解设计时用户代码中的问题之前，您必须了解您的应用程序控件和代码是由设计人员在未初始化的应用程序域中单独执行的。在这种情况下，未初始化意味着通常的启动，引导或初始化代码尚未运行。 当您的应用程序在运行时执行时，将运行App.xaml.cs或App.xaml.vb中的启动代码。如果您的应用程序的其余部分依赖于此代码，则此代码将不会在设计时执行。如果您在代码中没有预料到这一点，则会发生不必要的异常。（这就是为什么在设计时尝试在用户代码中访问Application或Application.Current对象会导致异常。）为了缓解这些问题： 永远不要假设引用的对象将在设计时代码中实例化。在可以在设计时执行的代码中，始终在访问任何引用对象之前执行空检查。 如果您的代码访问Application或Application.Current对象，请在访问对象之前执行空引用检查。 如果构造函数或Loaded事件处理程序需要运行访问数据库或调用网络的复杂代码或代码，请考虑以下解决方案之一： 将代码包装在一个检查中，该检查通过调用System.ComponentModel DesignerProperties方法DesignerProperties.GetIsInDesignMode来确定代码是否在设计时运行。 而不是直接在构造函数或Loaded事件处理程序中运行代码，抽象调用接口后面的类，然后使用许多技术之一在设计时，运行时和测试时以不同方式解析该依赖项。 例如，不是直接调用数据服务来检索数据，而是将数据服务调用包装在通过接口公开方法的类中。然后，在设计时，使用模拟或设计时对象解析接口。 了解用户控制代码何时在设计时执行\rBlend和Visual Studio都使用设计器窗格中显示的根对象的模型。这对于提供所需的设计体验是必要的。因为根对象是模拟的，所以它的构造函数和Loaded事件代码不会在设计时执行。但是，场景中的其余控件正常构造，并且它们的Loaded事件就像在运行时一样被引发。 在下图中，将不执行根Windows构造函数和已加载事件代码。子用户控件构造函数和Loaded事件代码将被执行。 这些概念很重要，尤其是在构建在运行时动态构建的复合应用程序或应用程序时。 大多数应用程序视图都是独立编码和设计 因为它们是独立设计的，所以它们通常是设计器中的根对象。因此，它们的构造函数和Loaded事件代码永远不会执行。 但是，如果您使用相同的用户控件并将其作为另一个控件的子项放置在设计图面上，则曾经隔离的用户控件代码现在正在设计时执行。如果您没有遵循上述减轻设计时代码问题的做法，那么现在托管的用户控件可能会变得不友好并导致设计器加载问题。 设计时属性\r内置的“d：”设计时属性为成功的设计时工具体验提供了平稳的道路。 我们需要解决的问题是如何在设计时为Binding Builder工具提供形状。在这种情况下，形状是Binding Builder可以反映的实例化类型，然后在构建绑定时列出这些属性以供选择。 形状也由设计时样本数据提供。样本数据包含在“设计时样本数据指南”一节中。 以下部分描述了如何使用d：DataContext属性和d：DesignInstance标记扩展。 属性和标记扩展中的“d：”是设计属性所属的设计命名空间的别名。有关更多信息，请参阅WPDN主题，WPF设计器中的设计时属性。 无法在用户代码中创建或扩展“d：”属性和标记扩展; 它们只能在XAML中使用。“d：”属性和标记扩展名未编译到您的应用程序中; 它们仅由Visual Studio和Blend工具使用。 d：DataContext属性\rd：DataContext，为控件及其子控件指定设计时数据上下文。指定d：DataContext时，应始终为设计时DataContext提供与运行时DataContext相同的形状。 如果为控件指定了DataContext和d：DataContext，则工具将使用d：DataContext。 d：DesignInstance标记扩展\r如果标记扩展对您来说是新手，请在MSDN上阅读标记扩展和WPF XAML。 d：DesignInstance返回一个实例化的Type（“shape”），您希望将其指定为绑定到设计器中控件的数据源。该类型不需要是可创建的以用于建立形状。下表说明了d：DesignInstance标记扩展属性。 标记扩展属性 定义 类型 要创建的类型的名称。Type是构造函数中的默认参数。 IsDesignTimeCreatable Can the specified Type be created? If false, a faux Type will be created rather than the real Type. The default is false. CreateList If true, returns a generic list of the specified Type. The default is false. Typical d:DataContext Scenario\rThe following three code examples demonstrate a repeatable pattern for wiring up views and view models and enabling the designer’s tooling. The PersonViewModel is a dependency that the PersonView has at run time. While the view model in the example is incredibly simple, real-world view models typically have one or more external dependencies that must be resolved, and those dependencies are typically injected into their constructor. 当PersonView被构造，其依赖PersonViewModel将建及其依赖由MEF或依赖注入容器解决。 注意：如果视图模型没有需要解析的外部依赖项，则可以在视图的XAML中实例化视图模型，并且不需要其DataContext和d：DataContext。 // PersonViewModel.cs [Export] public class PersonViewModel { public String FirstName { get; set; } public String LasName { get; set; } } // PersonView.xaml.cs [Export] public partial class PersonView : UserControl { public PersonView() { InitializeComponent(); } [Import] public PersonViewModel ViewModel { get { ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:17","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"Using Design-Time Sample Data\r如果使用可视化设计工具（如Blend或Visual Studio 2013），则设计时样本数据变得非常重要。视图可以填充数据和图像，使设计任务更容易，更快速地完成。这样可以提高生产力和创造力。 包含数据模板的空列表控件将不可见，除非它们填充了数据，使编辑空控件的任务更耗时，因为您需要运行应用程序以查看上次编辑在运行时的外观。 示例数据源\r您可以使用以下任何来源的示例数据： 混合Visual Studio 2013 XML示例数据 混合Visual Studio 2013和Visual Studio 2013 XAML示例数据 XAML资源 码 以下各小节介绍了每个来源的数据。 混合XML示例数据\rBlend使您能够快速创建XML模式并填充相应的XML文件。这是在不依赖任何项目类的情况下完成的。 此类示例数据的目的是让设计人员快速启动他们的项目，而无需等待开发人员或应用程序类可供使用之前。 虽然Blend和Visual Studio设计器都支持大多数示例数据，但XML示例数据是Blend功能，并且不在Visual Studio设计器中呈现。 注意： XML样本数据文件在构建时不会编译或添加到程序集中; 但是，XML模式将编译到构建的程序集中。 Visual Studio 2013和Visual Studio 2013 XAML示例数据的混合\r从Expression Blend 4和Visual Studio 2010开始，添加了d：DesignData标记扩展，以启用XAML样本数据的设计时加载。 示例数据XAML文件包含实例化一个或多个类型的XAML，并为属性分配值。 d：DesignData具有Source属性，该属性将统一资源标识符（URI）提取到位于项目中的示例数据XAML文件。的d：DesignData标记扩展加载XAML文件，解析它，然后返回一个对象图。对象图可以由d：DataContext属性，CollectionViewSource d：DesignSource属性或DomainDataSource d：DesignData属性使用。 d：DesignData标记扩展克服的挑战之一是它可以为不可创建的用户类型创建样本数据。例如，无法在代码中创建WCF富Internet应用程序（RIA）服务实体派生对象。此外，开发人员可能拥有自己的类型，这些类型不可创建，但仍希望拥有这些类型的示例数据。 您可以通过在解决方案资源管理器中设置示例数据文件上的Build Action属性来更改d：DesignData处理示例数据文件的方式，如下所示： Build Action = DesignData - 将创建虚拟类型 Build Action = DesignDataWithDesignTimeCreatableTypes - 将创建真实类型 当Blend用于为类创建示例数据时，它会创建一个XAML示例数据文件，并将Build Action设置为DesignData。如果需要实际类型，请在Visual Studio中打开解决方案，并将示例数据文件的Build Action更改为DesignDataWithDesignTimeCreatableTypes。 ***注意：**在下图中，“ **自定义工具”*属性为空。这是样本数据正常工作所必需的。默认情况下，Blend正确地将此属性设置为空。 *使用Visual Studio 2013添加示例数据文件时，通常会添加新的资源字典项并从那里进行编辑。在这种情况下，您必须设置“ **构建操作”**并清除“ **自定义工具”*属性。 Expression Blend提供了用于快速创建和绑定XAML样本数据的工具。可以在Visual Studio 2013设计器中使用和查看XAML示例数据，如下图所示。 生成样本数据后，数据将显示在“数据”窗格中，如下图所示。 然后，您可以将其拖到视图的根元素（例如UserControl）上，并将其设置为d：DataContext属性。您还可以将样本数据集合拖放到项目控件上，Blend会将示例数据连接到控件。 注意：XAML示例数据文件不会编译到构建的程序集中或包含在构建的程序集中。 XAML资源\r您可以在XAML中创建实例化所需类型的资源，然后将该资源绑定到DataContext或列表控件。 此技术可用于快速创建用于编辑数据模板的丢弃样本数据，该数据模板在没有样本数据的情况下编辑需要更长时间。 Code\r如果您更喜欢在代码中创建示例数据，则可以编写一个类，该类公开将样本数据返回给其使用者的属性或方法。例如，您可以编写一个Customers类，该类在其默认的空构造函数中填充了Customer类的多个实例。每个Customer实例也将设置适当的属性值。 可用于使用前面描述的示例数据类的一种技术是使用d：DataContext，d：DesignInstance组合，确保将d： DesignInstance IsDesignTimeCreatable属性设置为True。IsDesignTimeCreatable必须为True的原因是您希望执行customer构造函数，以便运行填充该类的代码。如果将客户视为虚假类型，则客户代码将永远不会运行，并且工具只能发现“形状”。 以下XAML示例实例化Customers类，然后将其设置为d：DataContext。此Grid的子控件可以使用Customers类公开的数据。 \u003cGrid d:DataContext=\"{d:DesignInstance local:Customers, IsDesignTimeCreatable=True}\"\u003e ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:18","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"UI布局关键决策\r当您开始复合应用程序项目时，您需要做出一些UI设计决策，这些决策以后很难更改。通常，这些决策是应用程序范围的，它们的一致性有助于开发人员和设 以下是重要的UI布局决策： 确定应用程序流程并相应地定义区域。 确定加载每个区域将使用的视图类型。 确定是否要使用区域导航API。 确定要使用的UI设计模式（MVVM，演示模型等）。 确定样本数据策略。 ","date":"2019-07-03","objectID":"/2019/07/prism11-region/:0:19","tags":["Prism","Region"],"title":"Prism Region","uri":"/2019/07/prism11-region/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 上一个主题描述了如何通过将应用程序的用户界面（UI），表示逻辑和业务逻辑分成三个独立的类（View，ViewModel和Model）来实现ModelViewViewModel（MVVM）模式的基本元素，实现这些类之间的交互（通过数据绑定，命令和数据验证接口），并实施处理构造和连接的策略。本主题描述了一些复杂的场景，并描述了MVVM模式如何支持它们。下一节将介绍如何将命令链接在一起或与子视图关联，以及如何扩展命令以支持自定义要求。 “ 使用依赖注入容器”（例如Unity应用程序块（Unity））或使用托管可扩展性框架（MEF）时，“ 高级构造和连接 ”一节提供了有关处理构造和连接的指导。最后一节描述了如何通过提供单元测试应用程序的视图模型和模型类以及测试行为的指导来测试MVVM应用程序。 ","date":"2019-07-02","objectID":"/2019/07/prism10-advancemvvm/:0:0","tags":["Prism","高级MVVM"],"title":"Prism 高级MVVM","uri":"/2019/07/prism10-advancemvvm/"},{"categories":"Prism","content":"命令\r命令提供了一种将命令的实现逻辑与其UI表示分开的方法。数据绑定或行为提供了一种方法，用于声明性地将视图中的元素与视图模型提供的命令相关联。的部分中，命令和实施MVVM模式描述了如何命令可以作为命令对象或在视图模型命令的方法来实现，以及它们是如何可以从控制在视图中通过使用调用的内置命令由某些控件提供的属性。 WPF路由命令：应该注意的是，MVVM模式中作为命令对象或命令方法实现的命令与WPF的路由命令的内置实现略有不同。WPF路由命令通过在UI树中的元素（特别是逻辑树）路由来传递命令消息。因此，命令消息在UI树中从聚焦元素向上或向下路由到显式指定的目标元素; 默认情况下，它们不会路由到UI树之外的组件，例如与视图关联的视图模型。但是，WPF路由命令可以使用视图代码隐藏中定义的命令处理程序将命令调用转发到视图模型类。 复合命令\r在许多情况下，视图模型定义的命令将绑定到关联视图中的控件，以便用户可以直接从视图中调用该命令。但是，在某些情况下，您可能希望能够从应用程序UI的父视图中的控件调用一个或多个视图模型上的命令。 例如，如果您的应用程序允许用户同时编辑多个项目，您可能希望允许用户使用应用程序工具栏或功能区中的按钮所代表的单个命令来保存所有项目。在这种情况下，Save All命令将调用每个项目的视图模型实例实现的每个Save命令，如下图所示。 Prism通过CompositeCommand类支持这种情况。 所述CompositeCommand类表示从多个子指令构成的指令。调用复合命令时，将依次调用其每个子命令。在需要在UI中将一组命令表示为单个命令或者要调用多个命令来实现逻辑命令的情况下，它非常有用。 例如，CompositeCommand类用于股票交易者参考实现（Stock Trader RI），以实现买入/卖出视图中的“ 全部提交”按钮所代表的SubmitAllOrders命令。当用户单击“ 全部提交”按钮时，将执行由各个买/卖交易定义的每个SubmitCommand。 该CompositeCommand类维护子类的命令（列表DelegateCommand实例）。在执行该方法CompositeCommand类只是调用执行每个反过来子命令的方法。在CanExecute方法同样调用CanExecute每个子命令的方法，但是如果有子命令不能执行时，CanExecute方法将返回错误。换句话说，默认情况下，只有在可以执行所有子命令时才能执行CompositeCommand。 注册和取消子命令\r使用RegisterCommand和UnregisterCommand方法注册或取消注册子命令。例如，在Stock Trader RI中，每个买/卖订单的提交和取消命令都使用SubmitAllOrders和CancelAllOrders复合命令进行注册，如以下代码示例所示（请参阅OrdersController类）。 // OrdersController.cs commandProxy.SubmitAllOrdersCommand.RegisterCommand( orderCompositeViewModel.SubmitCommand ); commandProxy.CancelAllOrdersCommand.RegisterCommand( orderCompositeViewModel.CancelCommand ); 注意：前面的commandProxy对象提供对Submit和Cancel复合命令的实例访问，这些命令是静态定义的。有关更多信息，请参阅类文件StockTraderRICommands.cs。 在活动子视图上执行命令\rExecuting Commands on Active Child Views 通常，您的应用程序需要在应用程序的UI中显示子视图的集合，其中每个子视图将具有相应的视图模型，而该视图模型又可以实现一个或多个命令。复合命令可用于表示应用程序UI中子视图实现的命令，并有助于协调从父视图中调用它们的方式。为了支持这些场景，Prism CompositeCommand和DelegateCommand类被设计为与Prism区域一起使用。 Prism的Regin（区域，在Composing接口）提供了一种方法用于子视图与在应用程序的UI逻辑占位符相关联。它们通常用于将子视图的特定布局与其逻辑占位符及其在UI中的位置分离。区域基于附加到特定布局控件的命名占位符。下图显示了一个示例，其中每个子视图都已添加到名为EditRegion的区域，并且UI设计器已选择使用Tab控件来布局该区域内的视图。 父视图级别的复合命令通常用于协调如何调用子视图级别的命令。在某些情况下，您将需要执行所有显示视图的命令，如前面所述的Save All命令示例中所示。在其他情况下，您将希望仅在活动视图上执行该命令。在这种情况下，复合命令将仅对被视为活动的视图执行子命令; 它不会在非活动的视图上执行子命令。例如，您可能希望在应用程序的工具栏或功能区上实现缩放命令，该命令仅导致当前活动项目被缩放，如下图所示。 为了支持这种情况，Prism提供了IActiveAware接口。所述IActiveAware接口定义的IsActive属性，返回True时实施者是活动的，以及一个IsActiveChanged每当激活状态改变时引发事件。 您可以在子视图或视图模型上实现IActiveAware接口。它主要用于跟踪区域内子视图的活动状态。视图是否处于活动状态由区域适配器确定，该适配器协调特定区域控件内的视图。对于前面显示的Tab控件，有一个区域适配器，例如，它将当前所选选项卡中的视图设置为活动状态。 该DelegateCommand类还实现了IActiveAware接口。可以将CompositeCommand配置为通过为构造函数中的monitorCommandActivity参数指定True来评估子DelegateCommands的活动状态（除了CanExecute状态）。当此参数设置为true，CompositeCommand类将在确定CanExecute方法的返回值以及在Execute方法中执行子命令时考虑每个子DelegateCommand的活动状态。 当monitorCommandActivity参数为true时，CompositeCommand类会出现以下行为： CanExecute。仅在可以执行所有活动命令时返回true。根本不会考虑不活动的子命令。 执行。执行所有活动命令。根本不会考虑不活动的子命令。 您可以使用此功能来实现前面描述的示例。通过在子视图模型上实现IActiveAware接口，当您的子视图对该区域变为活动或非活动时，将通知您。当子视图的活动状态更改时，您可以更新子命令的活动状态。然后，当用户调用缩放复合命令时，将调用活动子视图上的缩放命令。 集合中的命令\r在视图中显示项目集合时经常遇到的另一种常见情况是，您需要将集合中每个项目的UI与父视图级别（而不是项目级别）的命令相关联。 例如，在下图所示的应用程序中，视图显示ListBox控件中的项集合，用于显示每个项的数据模板定义了一个Delete按钮，允许用户从集合中删除单个项。 因为该视图模型实现的删除命令，面临的挑战是要连接的删除按钮在每个项目的用户界面中，对删除由视图模型实现的命令。之所以出现这种困难是因为ListBox中每个项的数据上下文引用了集合中的项而不是实现Delete命令的父视图模型。 解决此问题的一种方法是使用ElementName绑定属性将数据模板中的按钮绑定到父视图中的命令，以确保绑定相对于父控件而不是相对于数据模板。以下XAML说明了这种技术。 \u003cGrid x:Name=\"root\"\u003e \u003cListBox ItemsSource=\"{Binding Path=Items}\"\u003e \u003cListBox.ItemTemplate\u003e \u003cDataTemplate\u003e \u003cButton Content=\"{Binding Path=Name}\" Command=\"{Binding ElementName=root, Path=DataContext.DeleteCommand}\" /\u003e \u003c/DataTemplate\u003e \u003c/ListBox.ItemTemplate\u003e \u003c/ListBox\u003e \u003c/Grid\u003e 数据模板中按钮控件的内容绑定到集合中项目的Name属性。但是，按钮的命令通过根元素的数据上下文绑定到Delete命令。这允许按钮在父视图级别而不是在项目级别绑定到命令。您可以使用CommandParameter属性指定要应用命令的项目，也可以实现命令以对当前所选项目进行操作（通过CollectionView）。 ","date":"2019-07-02","objectID":"/2019/07/prism10-advancemvvm/:0:1","tags":["Prism","高级MVVM"],"title":"Prism 高级MVVM","uri":"/2019/07/prism10-advancemvvm/"},{"categories":"Prism","content":"交互触发器和命令\rInteraction Triggers and Commands 另一种命令方法是使用Blend for Visual Studio 2013交互触发器和InvokeCommandAction操作。 \u003cButton Content=\"Submit\" IsEnabled=\"{Binding CanSubmit}\"\u003e \u003ci:Interaction.Triggers\u003e \u003ci:EventTrigger EventName=\"Click\"\u003e \u003ci:InvokeCommandAction Command=\"{Binding SubmitCommand}\"/\u003e \u003c/i:EventTrigger\u003e \u003c/i:Interaction.Triggers\u003e \u003c/Button\u003e 此方法可用于您可以附加交互触发器的任何控件。如果要将命令附加到未实现ICommandSource接口的控件，或者要在默认事件以外的事件上调用命令，则此功能特别有用。同样，如果需要为命令提供参数，可以使用CommandParameter属性。 下面显示了如何使用配置为侦听ListBox的SelectionChanged事件的Blend EventTrigger 。发生此事件时，InvokeCommandAction将调用SelectedCommand。 \u003cListBox ItemsSource=\"{Binding Items}\" SelectionMode=\"Single\"\u003e \u003ci:Interaction.Triggers\u003e \u003ci:EventTrigger EventName=\"SelectionChanged\"\u003e \u003ci:InvokeCommandAction Command=\"{Binding SelectedCommand}\" /\u003e \u003c/i:EventTrigger\u003e \u003c/i:Interaction.Triggers\u003e \u003c/ListBox\u003e 启用命令的控件与行为 支持命令的WPF控件允许您以声明方式将控件挂接到命令。当用户以特定方式与控件交互时，这些控件将调用指定的命令。例如，对于Button控件，将在用户单击按钮时调用该命令。与命令关联的此事件是固定的，无法更改。 行为还允许您以声明方式将控件连接到命令。但是，行为可以与控件引发的一系列事件相关联，并且它们可以用于在视图模型中有条件地调用关联的命令对象或命令方法。换句话说，行为可以解决许多与启用命令的控件相同的场景，并且它们可以提供更大程度的灵活性和控制。 您需要选择何时使用启用命令的控件以及何时使用行为以及要使用的行为类型。如果您希望使用单一机制将视图中的控件与视图模型中的功能相关联或者为了保持一致性，则可以考虑使用行为，即使对于本身支持命令的控件也是如此。 如果您只需要使用启用命令的控件来调用视图模型上的命令，并且如果您对调用命令的默认事件感到满意，则可能不需要行为。同样，如果您的开发人员或UI设计人员不使用Blend for Visual Studio 2013，您可能会支持启用命令的控件（或自定义附加行为），因为Blend行为需要额外的语法。 ","date":"2019-07-02","objectID":"/2019/07/prism10-advancemvvm/:0:2","tags":["Prism","高级MVVM"],"title":"Prism 高级MVVM","uri":"/2019/07/prism10-advancemvvm/"},{"categories":"Prism","content":"将EventArgs参数传递给命令\r当您需要调用命令以响应位于视图中的控件引发的事件时，您可以使用Prism的InvokeCommandAction。Prism的InvokeCommandAction与Blend SDK中的同名类有两种不同。首先，Prism InvokeCommandAction根据命令的CanExecute方法的返回值更新关联控件的启用状态。其次，Prism InvokeCommandAction使用从父触发器传递给它的EventArgs参数，如果未设置**CommandParameter，**则将其传递给关联的命令。 有时你需要一个参数传递给来自父触发，如EventArgs作为EventTrigger参数。在这种情况下，您不能使用Blend的InvokeCommandAction操作。 在下面的代码中，您可以看到Prism的InvokeCommandAction具有一个名为TriggerParameterPath的属性，该属性用于指定作为命令参数传递的参数的成员（可能是嵌套的）。在以下示例中，SelectionChanged EventArgs 的AddedItems属性将传递给SelectedCommand命令。 \u003cListBox Grid.Row=\"1\" Margin=\"5\" ItemsSource=\"{Binding Items}\" SelectionMode=\"Single\"\u003e \u003ci:Interaction.Triggers\u003e \u003ci:EventTrigger EventName=\"SelectionChanged\"\u003e \u003c!-- This action will invoke the selected command in the view model and pass the parameters of the event to it. --\u003e \u003cprism:InvokeCommandAction Command=\"{Binding SelectedCommand}\" TriggerParameterPath=\"AddedItems\" /\u003e \u003c/i:EventTrigger\u003e \u003c/i:Interaction.Triggers\u003e \u003c/ListBox\u003e ","date":"2019-07-02","objectID":"/2019/07/prism10-advancemvvm/:0:3","tags":["Prism","高级MVVM"],"title":"Prism 高级MVVM","uri":"/2019/07/prism10-advancemvvm/"},{"categories":"Prism","content":"处理异步交互\rHandling Asynchronous Interactions 您的视图模型通常需要与应用程序中的服务和组件进行交互，这些服务和组件是异步通信而不是同步通信。如果您通过网络与Web服务或其他资源交互，或者您的应用程序使用后台任务执行计算或I / O，则尤其如此。异步执行这些操作可确保您的应用程序保持响应，这对于提供良好的用户体验至关重要。 当用户启动异步请求或后台任务时，很难预测响应何时到达（或者即使它将到达），并且通常很难预测它将返回什么线程。因为UI只能在UI线程中更新，所以通常需要通过在UI线程上调度请求来更新UI。 ","date":"2019-07-02","objectID":"/2019/07/prism10-advancemvvm/:0:4","tags":["Prism","高级MVVM"],"title":"Prism 高级MVVM","uri":"/2019/07/prism10-advancemvvm/"},{"categories":"Prism","content":"检索数据并与Web服务交互\rRetrieving Data and Interacting with Web Services 在与Web服务或其他远程访问技术交互时，您将经常遇到IAsyncResult模式。在此模式中，您可以使用BeginGetQuestionnaire和EndGetQuestionnaire等方法，而不是调用GetQuestionnaire等方法。要启动异步调用，请调用BeginGetQuestionnaire。要在调用目标方法时获取结果或确定是否存在异常，请在调用完成时调用EndGetQuestionnaire。 要确定何时调用EndGetQuestionnaire，您可以轮询完成或（最好）在调用BeginGetQuestionnaire期间指定回调。使用回调方法，当目标方法的执行完成时，将调用您的回调方法，允许您从那里调用EndGetQuestionnaire，如此处所示。 IAsyncResult asyncResult = this.service.BeginGetQuestionnaire(GetQuestionnaireCompleted, null); // object state, not used in this example private void GetQuestionnaireCompleted(IAsyncResult result) { try { questionnaire = this.service.EndGetQuestionnaire(result); } catch (Exception ex) { // Do something to report the error. } } 需要注意的是，在调用End方法（在本例中为EndGetQuestionnaire）时，将引发在执行请求期间发生的任何异常。您的应用程序必须处理这些，并且可能需要通过UI以线程安全的方式报告它们。如果您不处理这些，线程将结束，您将无法处理结果。 由于响应通常不在UI线程上，如果您计划修改任何会影响UI状态的内容，则需要使用线程Dispatcher或SynchronizationContext对象将响应分派给UI线程。在WPF中，您通常会使用调度程序。 在下面的代码示例中，异步检索Questionnaire对象，然后将其设置为QuestionnaireView的数据上下文。您可以使用调度程序的CheckAccess方法来查看您是否在UI线程上。如果不是，则需要使用BeginInvoke方法在UI线程上执行请求。 var dispatcher = System.Windows.Deployment.Current.Dispatcher; if (dispatcher.CheckAccess()) { QuestionnaireView.DataContext = questionnaire; } else { dispatcher.BeginInvoke( () =\u003e { Questionnaire.DataContext = questionnaire; }); } Model-View-ViewModel参考实现（MVVM RI）显示了如何使用类似于前面示例的基于IAsyncResult的服务接口的示例。它还包装服务，为消费者提供更简单的回调机制，并处理调用者对调用者线程的调度。例如，以下代码示例显示了问卷的检索。 this.questionnaireRepository.GetQuestionnaireAsync( (result) =\u003e { this.Questionnaire = result.Result; }); 返回的结果对象将包装检索到的结果以及可能发生的错误。以下代码示例显示了如何评估错误。 this.questionnaireRepository.GetQuestionnaireAsync( (result) =\u003e { if (result.Error == null) { this.Questionnaire = result.Result; ... } else { // Handle error. } }); ","date":"2019-07-02","objectID":"/2019/07/prism10-advancemvvm/:0:5","tags":["Prism","高级MVVM"],"title":"Prism 高级MVVM","uri":"/2019/07/prism10-advancemvvm/"},{"categories":"Prism","content":"用户交互模式\r通常，应用程序需要在继续操作之前通知用户事件的发生或要求确认。这些交互通常是简短的交互，旨在简单地告知应用程序应用程序的更改或从中获取简单的响应。这些交互中的一些可以对用户呈现模态，例如当显示对话框或消息框时，或者它们对于用户可能看起来是非模态的，例如当显示Toast通知或弹出窗口时。 在这些情况下，有多种方法可以与用户进行交互，但是在基于MVVM的应用程序中以保持关注点清晰分离的方式实现它们可能具有挑战性。例如，在非MVVM应用程序中，您经常在UI的代码隐藏文件中使用MessageBox类来简单地提示用户进行响应。在MVVM应用程序中，这不合适，因为它会破坏视图和视图模型之间关注点的分离。 就MVVM模式而言，视图模型负责启动与用户的交互以及消费和处理任何响应，而视图负责使用适当的任何用户体验实际管理与用户的交互。保持视图模型中实现的表示逻辑与视图实现的用户体验之间的关注点分离有助于提高可测试性和灵活性。 在MVVM模式中实现这些类型的用户交互有两种常用方法。一种方法是实现视图模型可以使用的服务来启动与用户的交互，从而保持其在视图的实现上的独立性。另一种方法使用视图模型引发的事件来表达与用户交互的意图，以及视图中绑定到这些事件并管理交互的可视方面的组件。以下各节将介绍这些方法中的每一种。 使用交互服务\r在该方法中，视图模型依赖于交互服务组件以通过消息框发起与用户的交互。此方法通过将交互的可视实现封装在单独的服务组件中来支持关注点和可测试性的清晰分离。通常，视图模型依赖于交互服务接口。它经常通过依赖注入或服务定位器获取对交互服务实现的引用。 在视图模型引用交互服务之后，它可以在必要时以编程方式请求与用户的交互。交互服务实现交互的可视方面，如下图所示。根据用户界面的实现要求，在视图模型中使用接口引用允许使用不同的实现。例如，可以提供WPF的交互服务的实现，允许更多地重用应用程序的表示逻辑。 模态交互（例如，在执行可以继续之前向用户呈现MessageBox或模态弹出窗口以获取特定响应的位置）可以使用阻塞方法调用以同步方式实现，如以下代码示例所示。 var result = interactionService.ShowMessageBox( \"Are you sure you want to cancel this operation?\", \"Confirm\", MessageBoxButton.OK ); if (result == MessageBoxResult.Yes) { CancelRequest(); } 然而，这种方法的一个缺点是它迫使同步编程模型。另一种异步实现允许视图模型提供回调以在完成交互时执行。以下代码说明了这种方法。 非模态交互 interactionService.ShowMessageBox( \"Are you sure you want to cancel this operation?\", \"Confirm\", MessageBoxButton.OK, result =\u003e { if (result == MessageBoxResult.Yes) { CancelRequest(); } }); 通过允许实现模态和非模态交互，异步方法在实现交互服务时提供了更大的灵活性。例如，在WPF中，MessageBox类可用于实现与用户的真正模态交互。 使用交互请求对象\r在MVVM模式中实现简单用户交互的另一种方法是允许视图模型通过与视图中的行为耦合的交互请求对象直接向视图本身发出交互请求。交互请求对象封装交互请求的详细信息及其响应，并通过事件与视图进行通信。视图订阅这些事件以启动交互的用户体验部分。视图通常会将交互的用户体验封装在与视图模型提供的交互请求对象数据绑定的行为中，如下图所示。 这种方法提供了一种简单但灵活的机制，可以保持视图模型和视图之间的清晰分离 - 它允许视图模型封装应用程序的表示逻辑，包括任何所需的用户交互，同时允许视图完全封装视觉互动的各个方面。可以轻松测试视图模型的实现，包括通过视图与用户的预期交互，并且UI设计器在通过使用封装不同用户的不同行为选择如何在视图中实现交互时具有很大的灵活性互动的经验。 此方法与MVVM模式一致，使视图能够反映它在视图模型上观察到的状态更改，并使用双向数据绑定来实现两者之间的数据通信。在交互请求对象中封装交互的非可视元素，以及使用相应的行为来管理交互的可视元素，与命令对象和命令行为的使用方式非常相似。 这种方法是Prism采用的方法。Prism Library通过IInteractionRequest接口和InteractionRequest 类直接支持此模式。所述IInteractionRequest接口定义的事件来发起的相互作用。视图中的行为绑定到此接口并订阅它公开的事件。所述InteractionRequest 类实现IInteractionRequest接口和定义了两个Raise方法来允许视图模型发起交互，并指定为请求的上下文中，并且任选地，一个回调委托。 从ViewModel启动交互请求\r所述InteractionRequest 类坐标的交互请求期间视图模型的与该视图的相互作用。所述抬起方法允许视图模型来启动交互和指定一个上下文对象，交互完成后调用的回调方法。上下文对象允许视图模型将数据和状态传递给视图，以便在与用户交互期间使用它。如果指定了回调方法，则上下文对象将被传递回视图模型; 这允许用户在交互期间进行的任何更改都传递回视图模型。 public interface IInteractionRequest { event EventHandler\u003cInteractionRequestedEventArgs\u003e Raised; } public class InteractionRequest\u003cT\u003e : IInteractionRequest where T : INotification { public event EventHandler\u003cInteractionRequestedEventArgs\u003e Raised; public void Raise(T context) { this.Raise(context, c =\u003e { }); } public void Raise(T context, Action\u003cT\u003e callback) { var handler = this.Raised; if (handler != null) { handler( this, new InteractionRequestedEventArgs( context, () =\u003e { if (callback != null) callback(context); } )); } } } Prism提供预定义的上下文类，支持常见的交互请求场景。该INotification接口用于所有上下文对象。当交互请求用于通知用户应用程序中的重要事件时。它提供了两个属性 - Title和Content- 将显示给用户。通常，通知是单向的，因此预计用户不会在交互期间更改这些值。该通知类是这个接口的默认实现。 所述IConfirmation接口扩展了INotification接口，增加了第三属性Confirmed -其用于表示用户已确认或拒绝该操作。在确认类，所提供的IConfirmation实现，用于实现MessageBox用户想获得一个Yes/No风格的交互。您可以定义实现INotification接口的自定义上下文类，以封装支持交互所需的任何数据和状态。 要使用InteractionRequest 类，视图模型类将创建InteractionRequest 类的实例，并定义只读属性以允许视图对其进行数据绑定。当视图模型想要发起请求时，它将调用Raise方法，传入上下文对象和（可选）回调委托。 public InteractionRequestViewModel() { this.ConfirmationRequest = new InteractionRequest\u003cIConfirmation\u003e(); ... // Commands for each of the buttons. Each of these raise a different interaction request. this.RaiseConfirmationCommand = new DelegateCommand(this.RaiseConfirmation); ... } public InteractionRequest\u003cIConfirmation\u003e ConfirmationRequest { get; private set; } private void RaiseConfirmation() { this.ConfirmationRequest.Raise( new Confirmation { Content = \"Confirmation Message\", Title = \"Confirmation\" }, c =\u003e { InteractionResultMessage = c.Confirmed ? \"The user accepted.\" : \"The user cancelled.\"; }); } 交互性快速入门示出了如何IInteractionRequest接口和**InteractionRequest **类用于实现视图和视图模型（参见InteractionRequestVi","date":"2019-07-02","objectID":"/2019/07/prism10-advancemvvm/:0:6","tags":["Prism","高级MVVM"],"title":"Prism 高级MVVM","uri":"/2019/07/prism10-advancemvvm/"},{"categories":"Prism","content":"Advanced Construction and Wire-Up\r要成功实现MVVM模式，您需要完全理解视图，模型和视图模型类的职责，以便您可以在正确的类中实现应用程序的代码。实现正确的模式以允许这些类进行交互（通过数据绑定，命令，交互请求等）也是一个重要的要求。最后一步是考虑如何在运行时实例化视图，视图模型和模型类并将它们相互关联。 如果在应用程序中使用依赖项注入容器，则选择适当的策略来管理此步骤尤为重要。托管可扩展性框架（MEF）和Unity应用程序块（Unity）都提供了指定视图，视图模型和模型类之间的依赖关系以及在运行时由容器实现它们的能力。 通常，您将视图模型定义为视图的依赖项，以便在构造视图时（使用容器）它自动实例化所需的视图模型。反过来，视图模型所依赖的任何组件或服务也将由容器实例化。成功实例化视图模型后，视图会将其设置为其数据上下文。 使用MEF创建视图和视图模型\r使用MEF，您可以使用import属性指定视图对视图模型的依赖性，并且可以指定要通过export属性实例化的具体视图模型类型。您可以通过属性或构造函数参数将视图模型导入视图。 例如，StockTrader参考实现中的Shell视图声明了视图模型的只写属性以及import属性。实例化视图时，MEF会创建相应导出视图模型的实例并设置属性值。setter属性将视图模型指定为视图的数据上下文，如此处所示。 [Import] ShellViewModel ViewModel { set { this.DataContext = value; } } 定义并导出视图模型，如此处所示。 [Export] public class ShellViewModel : BindableBase { ... } 另一种方法是在视图上定义导入构造函数，如此处所示。 public Shell() { InitializeComponent(); } [ImportingConstructor] public Shell(ShellViewModel viewModel) : this() { this.DataContext = viewModel; } 然后，视图模型将由MEF实例化，并作为参数传递给视图的构造函数。 注意：您可以在MEF和Unity中使用属性注入或构造函数注入; 但是，您可能会发现属性注入更简单，因为您不必维护两个构造函数。设计时工具（如Visual Studio和Expression Blend）要求控件具有默认的无参数构造函数，以便在设计器中显示它们。您定义的任何其他构造函数应确保调用默认构造函数，以便可以通过InitializeComponent方法正确初始化视图。* 使用Unity创建视图和视图模型\r使用Unity作为依赖注入容器与使用MEF类似，并且支持基于属性和基于构造函数的注入。主要区别在于通常不会在运行时隐式发现类型; 相反，他们必须在容器中注册。 通常，您在视图模型上定义接口，以便视图模型的特定具体类型可以与视图分离。例如，视图可以通过构造函数参数定义其对视图模型的依赖性，如此处所示。 public Shell() { InitializeComponent(); } public Shell(ShellViewModel viewModel) : this() { this.DataContext = viewModel; } 注意：默认的无参数构造函数是允许视图在设计时工具中工作所必需的，例如Visual Studio和Blend for Visual Studio 2013。 或者，您可以在视图上定义只写视图模型属性，如此处所示。Unity将实例化所需的视图模型，并在实例化视图后调用setter属性。 public Shell() { InitializeComponent(); } [Dependency] public ShellViewModel ViewModel { set { this.DataContext = value; } } 视图模型类型已在Unity容器中注册，如此处所示。 IUnityContainer container; container.RegisterType\u003cShellViewModel\u003e(); 然后可以通过容器实例化视图，如此处所示。 IUnityContainer container; var view = container.Resolve\u003cShell\u003e(); Creating the View and View Model Using an External Class\r通常，您会发现定义控制器或服务类以协调视图的实例化和视图模型类很有用。此方法可以与依赖项注入容器（如MEF或Unity）一起使用，或者在视图显式创建其所需的视图模型时使用。 在您的应用程序中实现导航时，此方法特别有用。在这种情况下，控制器与UI中的占位符控件或区域相关联，并且它协调视图的构造和放置到该占位符或区域中。 例如，服务类可用于使用容器构建视图并在主页面中显示它们。在此示例中，视图由视图名称指定。通过在UI服务上调用ShowView方法启动导航，如此简单示例所示。 private void NavigateToQuestionnaireList() { // Ask the UI service to go to the \"questionnaire list\" view. this.uiService.ShowView(ViewNames.QuestionnaireTemplatesList); } UI服务与应用程序的UI中的占位符控件相关联; 它封装了所需视图的创建，并在UI中协调其外观。所述ShowView所述的UIService创建（使得其视图模型和其他依赖可以实现）通过所述容器中的视图的一个实例，并然后显示它在适当的位置，如下所示。 public void ShowView(string viewName) { var view = this.ViewFactory.GetView(viewName); this.MainWindow.CurrentView = view; } 注意：Prism为区域内的导航提供广泛的支持。区域导航使用与前一种方法非常相似的机制，区域管理器负责协调特定区域中视图的实例化和放置。欲了解更多信息，请参见基于视图导航，在导航。 ","date":"2019-07-02","objectID":"/2019/07/prism10-advancemvvm/:0:7","tags":["Prism","高级MVVM"],"title":"Prism 高级MVVM","uri":"/2019/07/prism10-advancemvvm/"},{"categories":"Prism","content":"测试MVVM应用程序\r从MVVM应用程序测试模型和视图模型与测试任何其他类相同，并且可以使用相同的工具和技术 - 例如单元测试和模拟框架。但是，有一些测试模式是典型的模型和视图模型类，可以从标准测试技术和测试助手类中受益。 测试INotifyPropertyChanged实现\r实现INotifyPropertyChanged接口允许视图对模型和视图模型中发生的更改做出反应。这些更改不仅限于控件中显示的域数据; 它们还用于控制视图，例如视图模型状态，可以启动动画或禁用控件。 简单案例\r可以通过将事件处理程序附加到PropertyChanged事件并检查在为属性设置新值之后是否引发事件来测试可以由测试代码直接更新的属性。辅助类（如PropertyChangeTracker类）可用于附加处理程序并收集结果; 这可以避免编写测试时的重复性任务。以下代码示例显示了使用此类助手类的测试。 var changeTracker = new PropertyChangeTracker(viewModel); viewModel.CurrentState = \"newState\"; CollectionAssert.Contains(changeTracker.ChangedProperties, \"CurrentState\"); 作为保证INotifyPropertyChanged接口实现的代码生成过程的结果的属性（例如模型设计者生成的代码中的属性）通常不需要进行测试。 Computed and Non-Settable Properties\r当测试代码无法设置属性时 - 例如具有非公共设置器的属性或只读，计算属性 - 测试代码需要激发测试对象导致属性及其相应通知的更改。但是，测试的结构与更简单的情况相同，如下面的代码示例所示，其中模型对象的更改会导致视图模型中的属性发生更改。 var changeTracker = new PropertyChangeTracker(viewModel); var question = viewModel.Questions.First() as OpenQuestionViewModel; question.Question.Response = \"some text\"; CollectionAssert.Contains(changeTracker.ChangedProperties, \"UnansweredQuestions\"); Whole Object Notifications\r实现INotifyPropertyChanged接口时，允许对象使用null或空字符串作为已更改的属性名称引发PropertyChanged事件，以指示对象中的所有属性可能已更改。这些案例可以像通知各个属性名称的案例一样进行测试。 ","date":"2019-07-02","objectID":"/2019/07/prism10-advancemvvm/:0:8","tags":["Prism","高级MVVM"],"title":"Prism 高级MVVM","uri":"/2019/07/prism10-advancemvvm/"},{"categories":"Prism","content":"测试INotifyDataErrorInfo实现\r有几种机制可用于使绑定能够执行输入验证，例如在设置属性时抛出异常，实现IDataErrorInfo接口以及实现INotifyDataErrorInfo接口。实现INotifyDataErrorInfo接口允许更复杂，因为它支持指示每个属性的多个错误并执行异步和跨属性验证; 因此，它也需要最多的测试。 测试INotifyDataErrorInfo实现有两个方面：测试验证规则是否正确实现，并测试接口实现的要求，例如当GetErrors方法的结果不同时引发ErrorsChanged事件。 测试验证规则\r验证逻辑通常很容易测试，因为它通常是一个自包含的过程，其输出取决于输入。对于与验证规则关联的每个属性，应该对使用有效值，无效值，边界值等的验证属性名称调用GetErrors方法的结果进行测试。如果共享验证逻辑，就像使用数据注释的验证属性以声明方式表示验证规则一样，更详尽的测试可以集中在共享验证逻辑上。另一方面，必须彻底测试自定义验证规则。 // Invalid case var notifyErrorInfo = (INotifyDataErrorInfo)question; question.Response = -15; Assert.IsTrue(notifyErrorInfo.GetErrors(\"Response\").Cast\u003cValidationResult\u003e().Any()); // Valid case var notifyErrorInfo = (INotifyDataErrorInfo)question; question.Response = 15; Assert.IsFalse(notifyErrorInfo.GetErrors(\"Response\").Cast\u003cValidationResult\u003e().Any()); 跨属性验证规则遵循相同的模式，通常需要更多测试来适应不同属性的值组合。 测试INotifyDataErrorInfo实现的要求\r除了为GetErrors方法生成正确的值之外，INotifyDataErrorInfo接口的实现必须确保正确引发ErrorsChanged事件，例如GetErrors的结果不同时。此外，HasErrors属性必须反映实现该接口的对象的整体错误状态。 实现INotifyDataErrorInfo接口没有强制方法。但是，依赖于累积验证错误并执行必要通知的对象的实现通常是首选，因为它们更易于测试。这是因为没有必要验证每个验证属性上的每个验证规则是否满足INotifyDataErrorInfo接口的所有成员的要求（当然，因为错误管理对象已经过适当测试）。 测试接口要求至少应包括以下验证： 该HasErrors属性反映对象的整体错误状态。如果其他属性仍具有无效值，则为此属性设置有效值不会导致此属性发生更改。 所述ErrorsChanged当通过在结果为一个变化反映了一个属性更改错误状态，事件被引发GetErrors方法。错误状态更改可能从有效状态（即无错误）变为无效状态，反之亦然，或者它可能从无效状态变为不同的无效状态。GetErrors的更新结果可用于ErrorsChanged事件的处理程序。 在测试INotifyPropertyChanged接口的实现时，辅助类（例如MVVM示例项目中的NotifyDataErrorInfoTestHelper类）通常通过处理重复的内务操作和标准检查来更轻松地为INotifyDataErrorInfo接口的实现编写测试。在实现接口时，它们特别有用，而不依赖于某种可重用的错误管理器。以下代码示例显示了此类型的帮助程序类。 var helper = new NotifyDataErrorInfoTestHelper\u003cNumericQuestion, int?\u003e( question, q =\u003e q.Response); helper.ValidatePropertyChange( 6, NotifyDataErrorInfoBehavior.Nothing); helper.ValidatePropertyChange( 20, NotifyDataErrorInfoBehavior.FiresErrorsChanged | NotifyDataErrorInfoBehavior.HasErrors | NotifyDataErrorInfoBehavior.HasErrorsForProperty); helper.ValidatePropertyChange( null, NotifyDataErrorInfoBehavior.FiresErrorsChanged | NotifyDataErrorInfoBehavior.HasErrors | NotifyDataErrorInfoBehavior.HasErrorsForProperty); helper.ValidatePropertyChange( 2, NotifyDataErrorInfoBehavior.FiresErrorsChanged); 测试异步服务调用\r在实现MVVM模式时，视图模型通常会异步调用服务上的操作。对调用这些操作的代码的测试通常使用模拟或存根作为实际服务的替代。 用于实现异步操作的标准模式提供了有关线程的不同保证，在该线程中发生有关操作状态的通知。虽然基于事件的异步设计模式保证在适合应用程序的线程上调用事件的处理程序，但IAsyncResult设计模式不提供任何此类保证，强制发起调用的视图模型代码以确保任何更改会影响视图发布到UI线程。 处理线程问题需要更复杂，因此通常更难以测试代码。它通常还要求测试本身是异步的。当保证在UI线程中发生通知时，或者因为使用了基于标准事件的异步模式，或者因为视图模型依赖于服务访问层来将通知编组到适当的线程，所以可以简化测试并且可以基本上发挥作用一个“UI线程的调度程序”。 服务被模拟的方式取决于用于实现其操作的异步事件模式。如果使用基于方法的模式，则使用标准模拟框架创建的服务接口的模拟通常就足够了，但如果使用基于事件的模式，则基于实现添加和删除处理程序的方法的自定义类进行模拟对于服务事件通常是首选。 以下代码示例显示了对使用mocks for services在UI线程中通知的异步操作成功完成时的相应行为的测试。在此示例中，测试代码在进行异步服务调用时捕获视图模型提供的回调。然后，测试通过调用回调来模拟测试后期调用的完成。此方法允许测试使用异步服务的组件，而不会使测试异步。 questionnaireRepositoryMock .Setup( r =\u003e r.SubmitQuestionnaireAsync( It.IsAny\u003cQuestionnaire\u003e(), It.IsAny\u003cAction\u003cIOperationResult\u003e\u003e())) .Callback\u003cQuestionnaire, Action\u003cIOperationResult\u003e\u003e( (q, a) =\u003e callback = a); uiServiceMock .Setup(svc =\u003e svc.ShowView(ViewNames.QuestionnaireTemplatesList)) .Callback\u003cstring\u003e(viewName =\u003e requestedViewName = viewName); submitResultMock .Setup(sr =\u003e sr.Error) .Returns\u003cException\u003e(null); CompleteQuestionnaire(viewModel); viewModel.Submit(); // Simulate callback posted to the UI thread. callback(submitResultMock.Object); // Check expected behavior – request to navigate to the list view. Assert.AreEqual(ViewNames.QuestionnaireTemplatesList, requestedViewName); ***注意：*使用此测试方法仅执行被测对象的功能; 它不测试代码是否是线程安全的。 ","date":"2019-07-02","objectID":"/2019/07/prism10-advancemvvm/:0:9","tags":["Prism","高级MVVM"],"title":"Prism 高级MVVM","uri":"/2019/07/prism10-advancemvvm/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 Model-View-ViewModel（MVVM）模式可帮助您将应用程序的业务和表示逻辑与其用户界面（UI）完全分离。在应用程序逻辑和UI之间保持清晰的分离有助于解决许多开发和设计问题，并使您的应用程序更容易测试，维护和发展。它还可以极大地改善代码重用机会，并允许开发人员和UI设计人员在开发应用程序的各个部分时更轻松地进行协作。 使用MVVM模式，应用程序的UI以及底层表示和业务逻辑被分成三个独立的类：视图(view)，它封装了UI和UI逻辑; 视图模型(viewmodel)，它封装了表示逻辑和状态; 模型（model）封装了应用程序的业务逻辑和数据。 Prism包含示例和参考实现，展示如何在Windows Presentation Foundation（WPF）应用程序中实现MVVM模式。Prism Library还提供了可以帮助您在自己的应用程序中实现模式的功能。这些功能体现了实现MVVM模式的最常见实践，旨在支持可测试性并与Expression Blend和Visual Studio配合使用。 ","date":"2019-07-01","objectID":"/2019/07/prism9-mvvm/:0:0","tags":["Prism","MVVM"],"title":"Prism MVVM","uri":"/2019/07/prism9-mvvm/"},{"categories":"Prism","content":"Class Responsibilities and Characteristics\r类的责任和特征 MVVM模式是Presentation Model模式的近似变体，经过优化以利用WPF的一些核心功能，例如数据绑定，数据模板，命令和行为。 在MVVM模式中，视图封装了UI和任何UI逻辑，视图模型封装了表示逻辑和状态，模型封装了业务逻辑和数据。视图通过数据绑定，命令和更改通知事件与视图模型交互。视图模型查询，观察和协调模型的更新，转换，验证和聚合数据，以便在视图中显示。 下图显示了三个MVVM类及其交互。 MVVM类及其交互\r与所有分离的表示模式一样，有效使用MVVM模式的关键在于理解将应用程序代码分解为正确类的适当方式，以及理解这些类在各种场景中交互的方式。以下部分描述了MVVM模式中每个类的职责和特征。 视图类\r视图的职责是定义用户在屏幕上看到的内容的结构和外观。理想情况下，视图的代码隐藏只包含一个调用InitializeComponent方法的构造函数。在某些情况下，代码隐藏可能包含UI逻辑代码，该代码实现了在可扩展应用程序标记语言（XAML）中表达难以或低效的视觉行为，例如复杂的动画，或者当代码需要直接操作视觉元素时部分观点。您不应该在视图中放置任何需要进行单元测试的逻辑代码。通常，视图的代码隐藏中的逻辑代码将通过UI自动化测试方法进行测试。 在WPF中，视图中的数据绑定表达式将根据其数据上下文进行评估。在MVVM中，视图的数据上下文设置为视图模型。视图模型实现视图可以绑定的属性和命令，并通过更改通知事件通知视图状态的任何更改。视图与其视图模型之间通常存在一对一的关系。 通常，视图是Control- derived或UserControl派生的类。但是，在某些情况下，视图可以由数据模板表示，该数据模板指定用于在显示对象时可视地表示对象的UI元素。使用数据模板，可视化设计人员可以轻松定义视图模型的呈现方式，也可以修改其默认的可视化表示，而无需更改底层对象本身或用于显示它的控件的行为。 可以将数据模板视为没有任何代码隐藏的视图。它们旨在绑定到特定的视图模型类型，只要需要在UI中显示一个。在运行时，将自动实例化由数据模板定义的视图，并将其数据上下文设置为相应的视图模型。 在WPF中，您可以在应用程序级别将数据模板与视图模型类型相关联。然后，无论何时在UI中显示，WPF都会自动将数据模板应用于指定类型的任何视图模型对象。这称为隐式数据模板。数据模板可以与使用它的控件一起定义，也可以在父视图外的资源字典中定义，并以声明方式合并到视图的资源字典中。 总而言之，该视图具有以下主要特征： 视图是可视元素，例如窗口，页面，用户控件或数据模板。视图定义视图中包含的控件及其可视布局和样式。 视图通过其DataContext属性引用视图模型。视图中的控件是绑定到视图模型公开的属性和命令的数据。 视图可以自定义视图和视图模型之间的数据绑定行为。例如，视图可以使用值转换器来格式化要在UI中显示的数据，或者它可以使用验证规则来向用户提供额外的输入数据验证。 视图定义并处理UI视觉行为，例如可以从视图模型中的状态更改或通过用户与UI的交互触发的动画或过渡。 视图的代码隐藏可以定义UI逻辑以实现在XAML中难以表达的视觉行为，或者需要直接引用视图中定义的特定UI控件。 视图模型类\rMVVM模式中的视图模型封装了视图的表示逻辑和数据。它没有直接引用视图或有关视图的特定实现或类型的任何知识。视图模型实现视图可以绑定数据的属性和命令，并通过更改通知事件通知视图任何状态更改。视图模型提供的属性和命令定义UI提供的功能，但视图确定如何呈现该功能。 视图模型负责协调视图与所需的任何模型类的交互。通常，视图模型和模型类之间存在一对多关系。视图模型可以选择直接将模型类公开给视图，以便视图中的控件可以直接将数据绑定到它们。在这种情况下，需要设计模型类以支持数据绑定和相关的更改通知事件。有关此方案的详细信息，请参阅本主题后面的“ 数据绑定 ”一节。 视图模型可以转换或操纵模型数据，以便视图可以轻松地使用它。视图模型可以定义其他属性以专门支持视图; 这些属性通常不属于模型的一部分（或不能添加到模型中）。例如，视图模型可以组合两个字段的值以使视图更容易呈现，或者它可以计算具有最大长度的字段的输入剩余字符数。视图模型还可以实现数据验证逻辑以确保数据一致性。 视图模型还可以定义视图可以用于在UI中提供视觉变化的逻辑状态。视图可以定义反映视图模型状态的布局或样式更改。例如，视图模型可以定义指示数据异步提交到Web服务的状态。视图可以在此状态期间显示动画，以向用户提供视觉反馈。 通常，视图模型将定义可在UI中表示并且用户可以调用的命令或操作。一个常见示例是视图模型提供允许用户将数据提交到Web服务或数据存储库的Submit命令。视图可以选择用按钮表示该命令，以便用户可以单击按钮来提交数据。通常，当命令变得不可用时，其关联的UI表示将被禁用。命令提供了一种封装用户操作并将其与UI中的可视表示清晰分离的方法。 总而言之，视图模型具有以下关键特征： 视图模型是非可视类，不是从任何WPF基类派生的。它封装了支持应用程序中的用例或用户任务所需的表示逻辑。视图模型可以独立于视图和模型进行测试。 视图模型通常不直接引用视图。它实现了视图可以绑定数据的属性和命令。它通过INotifyPropertyChanged和INotifyCollectionChanged接口通过更改通知事件通知视图任何状态更改。 视图模型协调视图与模型的交互。它可以转换或操作数据，以便视图可以轻松使用它，并可以实现模型上可能不存在的其他属性。它还可以通过IDataErrorInfo或INotifyDataErrorInfo接口实现数据验证。 视图模型可以定义视图可以在视觉上向用户表示的逻辑状态。 注意：查看或查看模型？ 很多时候，确定应该实现某些功能的地方并不明显。一般的经验法则是：任何与屏幕上UI的特定视觉外观有关并且可以在以后重新设置样式的内容（即使您当前没有计划重新设置样式）也应该进入视图; 对应用程序的逻辑行为很重要的任何内容都应该进入视图模型。此外，由于视图模型应该不具有视图中特定可视元素的明确知识，因此以编程方式操作视图中的可视元素的代码应驻留在视图的代码隐藏中或封装在行为中。同样，检索或操作要通过数据绑定在视图中显示的数据项的代码应驻留在视图模型中。 模型类\rMVVM模式中的模型封装了业务逻辑和数据。业务逻辑被定义为与应用程序数据的检索和管理有关的任何应用程序逻辑，并确保强制执行确保数据一致性和有效性的任何业务规则。为了最大化重用机会，模型不应包含任何特定于用例或特定于用户任务的行为或应用程序逻辑。 通常，模型表示应用程序的客户端域模型。它可以基于应用程序的数据模型和任何支持业务和验证逻辑来定义数据结构。该模型还可以包括支持数据访问和缓存的代码，尽管通常使用单独的数据存储库或服务。通常，模型和数据访问层是作为数据访问或服务策略的一部分生成的，例如ADO.NET实体框架，WCF数据服务或WCF RIA服务。 通常，模型实现了可以轻松绑定到视图的工具。这通常意味着它通过INotifyPropertyChanged和INotifyCollectionChanged接口支持属性和集合更改通知。表示对象集合的模型类通常派生自ObservableCollection 类，该类提供INotifyCollectionChanged接口的实现。 该模型还可以通过IDataErrorInfo（或INotifyDataErrorInfo）接口支持数据验证和错误报告。该IDataErrorInfo的和INotifyDataErrorInfo接口使WPF数据绑定时通知值发生改变，这样的UI可以更新。它们还支持UI层中的数据验证和错误报告。 注意：如果您的模型类没有实现所需的接口，该怎么办？ 有时您需要使用未实现INotifyPropertyChanged，INotifyCollectionChanged，IDataErrorInfo或INotifyDataErrorInfo接口的模型对象。在这些情况下，视图模型可能需要包装模型对象并将所需的属性公开给视图。这些属性的值将由模型对象直接提供。视图模型将为它公开的属性实现所需的接口，以便视图可以轻松地将数据绑定到它们。 该模型具有以下主要特征： 模型类是非可视类，它封装了应用程序的数据和业务逻辑。他们负责管理应用程序的数据，并通过封装所需的业务规则和数据验证逻辑来确保其一致性和有效性。 模型类不直接引用视图或视图模型类，也不依赖于它们的实现方式。 模型类通常通过INotifyPropertyChanged和INotifyCollectionChanged接口提供属性和集合更改通知事件。这允许它们在视图中容易地数据绑定。表示对象集合的模型类通常派生自**ObservableCollection **类。 模型类通常通过IDataErrorInfo或INotifyDataErrorInfo接口提供数据验证和错误报告。 模型类通常与封装数据访问和缓存的服务或存储库结合使用。 View,ViewModel,Model互动\rMVVM模式通过将每个应用程序的用户界面，其表示逻辑以及业务逻辑和数据分离为单独的类，提供了清晰的分离。因此，在实现MVVM时，重要的是将应用程序的代码分解为正确的类，如上一节所述。 精心设计的视图，视图模型和模型类不仅会封装正确类型的代码和行为; 它们的设计也使它们可以通过数据绑定，命令和数据验证接口","date":"2019-07-01","objectID":"/2019/07/prism9-mvvm/:0:1","tags":["Prism","MVVM"],"title":"Prism MVVM","uri":"/2019/07/prism9-mvvm/"},{"categories":"Prism","content":"数据绑定\r数据绑定在MVVM模式中起着非常重要的作用。WPF提供强大的数据绑定功能。您的视图模型和（理想情况下）您的模型类应设计为支持数据绑定，以便它们可以利用这些功能。通常，这意味着它们必须实现正确的接口。 WPF数据绑定支持多种数据绑定模式。通过单向数据绑定，可以将UI控件绑定到视图模型，以便在呈现显示时它们反映基础数据的值。当用户在UI中修改基础数据时，双向数据绑定也将自动更新基础数据。 为确保在视图模型中数据发生更改时UI保持最新，它应实现相应的更改通知界面。如果它定义了可以绑定数据的属性，它应该实现INotifyPropertyChanged接口。如果视图模型表示集合，则它应实现INotifyCollectionChanged接口，或者从提供此接口实现的**ObservableCollection **类派生。这两个接口都定义了每当基础数据发生更改时引发的事件。引发这些事件时，将自动更新任何数据绑定控件。 在许多情况下，视图模型将定义返回对象的属性（反过来，可以定义返回其他对象的属性）。WPF数据绑定支持通过Path属性绑定到嵌套属性。因此，视图的视图模型返回对其他视图模型或模型类的引用是很常见的。视图可访问的所有视图模型和模型类应根据需要实现INotifyPropertyChanged或INotifyCollectionChanged接口。 以下部分描述了如何实现所需的接口以支持MVVM模式中的数据绑定。 实现INotifyPropertyChanged\r在视图模型或模型类中实现INotifyPropertyChanged接口允许它们在基础属性值更改时向视图中的任何数据绑定控件提供更改通知。实现此接口非常简单，如以下代码示例所示。 public class Questionnaire : INotifyPropertyChanged { private string favoriteColor; public event PropertyChangedEventHandler PropertyChanged; ... public string FavoriteColor { get { return this.favoriteColor; } set { if (value != this.favoriteColor) { this.favoriteColor = value; var handler = this.PropertyChanged; if (handler != null) { handler(this, new PropertyChangedEventArgs(\"FavoriteColor\")); } } } } } 由于需要在event参数中指定属性名称，因此在许多视图模型类上实现INotifyPropertyChanged接口可能是重复且容易出错的。Prism库提供了BindableBase基类，您可以从中派生以类型安全的方式实现INotifyPropertyChanged接口的视图模型类，如此处所示。 public abstract class BindableBase : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged; ... protected virtual bool SetProperty\u003cT\u003e(ref T storage, T value, [CallerMemberName] string propertyName = null) {...} protected void OnPropertyChanged\u003cT\u003e( Expression\u003cFunc\u003cT\u003e\u003e propertyExpression) {...} protected void OnPropertyChanged(string propertyName) {...} } 派生视图模型类可以通过调用SetProperty方法在setter中引发属性更改事件。所述的SetProperty方法检查被设定的值支持字段是否是不同的。如果不同，则更新后备字段并引发PropertyChanged事件。 下面的代码示例演示如何设置属性，并通过在OnPropertyChanged方法中使用lambda表达式同时发出另一个属性的更改。此示例来自Stock Trader RI。该TransactionInfo和TickerSymbol属性相关。如果TransactionInfo属性更改，则TickerSymbol也可能会更新。通过调用OnPropertyChanged的TickerSymbol中的setter属性TransactionInfo财产，二的PropertyChanged事件将提高，一个用于TransactionInfo，一个用于TickerSymbol。 public TransactionInfo TransactionInfo { get { return this.transactionInfo; } set { SetProperty(ref this.transactionInfo, value); this.OnPropertyChanged(() =\u003e this.TickerSymbol); } } **注意：**以这种方式使用lambda表达式会产生很小的性能成本，因为必须为每次调用计算lambda表达式。好处是，如果重命名属性，此方法可提供编译时类型安全性和重构支持。虽然性能成本很低，并且通常不会影响您的应用程序，但如果您有许多更改通知，则会产生成本。在这种情况下，您应该考虑使用非lambda方法重载。 通常，模型或视图模型将包含其值从模型或视图模型中的其他属性计算的属性。处理属性更改时，请务必同时为任何计算属性引发通知事件。 实现INotifyCollectionChanged\r您的视图模型或模型类可以表示项的集合，也可以定义一个或多个返回项集合的属性。在任何一种情况下，您可能希望在ItemsControl中显示集合，例如ListBox，或者在视图中的DataGrid控件中。这些控件可以是绑定到视图模型的数据，该视图模型表示集合或通过ItemSource属性返回集合的属性。 \u003cDataGrid ItemsSource=\"{Binding Path=LineItems}\" /\u003e 为了正确支持更改通知请求，视图模型或模型类（如果它表示集合）应实现INotifyCollectionChanged接口（除了INotifyPropertyChanged接口）。如果视图模型或模型类定义了返回对集合的引用的属性，则返回的集合类应实现INotifyCollectionChanged接口。 但是，实现INotifyCollectionChanged接口可能具有挑战性，因为它必须在集合中添加，删除或更改项目时提供通知。它不是直接实现接口，而是通常更容易使用或派生自已实现它的集合类。所述**的ObservableCollection **类提供这个接口的实现和通常用作任一个基类或执行该代表项的集合的性质。 如果需要为视图提供数据绑定的集合，并且不需要跟踪用户的选择或支持对集合中项目的过滤，排序或分组，则只需在视图模型上定义属性即可返回对**ObservableCollection **实例的引用。 public class OrderViewModel : BindableBase { public OrderViewModel( IOrderService orderService ) { this.LineItems = new ObservableCollection\u003cOrderLineItem\u003e( orderService.GetLineItemList() ); } public ObservableCollection\u003cOrderLineItem\u003e LineItems { get; private set; } } 如果获得对集合类的引用（例如，来自未实现INotifyCollectionChanged的其他组件或服务），则通常可以使用其中一个构造函数将该集合包装在**ObservableCollection 实例中，该构造函数采用IEnumerable 或List **参数。 注意：BindableBase可以在Prism.Mvvm命名空间中找到，该命名空间位于Prism.Core NuGet包中。 实现ICollectionView\r上面的代码示例演示如何实现一个简单的视图模型属性，该属性返回可以通过视图中的数据绑定控件显示的项集合。由于ObservableCollection 类实现了INotifyCollectionChanged接口，因此在添加或删除项目时，视图中的控件将自动更新以反映集合中的当前项目列表。 但是，您通常需要更精细地控制项目集合在视图中的显示方式，或者在视图模型本身内跟踪用户与显示的项目集合的交互。例如，您可能需要根据视图模型中实现的表示逻辑来过滤或排序项目集合，或者您可能需要跟踪视图中当前选定的项目，以便在视图模型中实现命令可以对当前选定的项目采取行动。 WPF通过提供实现ICollectionView接口的各种类来支持这些场景。此接口提供允许对集合进行过滤，排序或分组的属性和方法，并允许跟踪或更改当前选定的项目。WPF使用ListCollectionView类提供此接口的实现。 集合视图类通过包装","date":"2019-07-01","objectID":"/2019/07/prism9-mvvm/:0:2","tags":["Prism","MVVM"],"title":"Prism MVVM","uri":"/2019/07/prism9-mvvm/"},{"categories":"Prism","content":"命令\r除了提供对要在视图中显示或编辑的数据的访问之外，视图模型还可能定义可由用户执行的一个或多个动作或操作。在WPF中，用户可以通过UI执行的操作或操作通常被定义为命令。命令提供了一种方便的方法来表示可以轻松绑定到UI中的控件的操作或操作。它们封装了实现操作或操作的实际代码，并有助于使其与视图中的实际可视化表示分离。 当用户与视图交互时，用户可以以多种不同的方式直观地表示和调用命令。在大多数情况下，它们是通过鼠标单击调用的，但也可以通过快捷键按下，触摸手势或任何其他输入事件来调用它们。视图中的控件是绑定到视图模型命令的数据，以便用户可以使用控件定义的任何输入事件或手势来调用它们。视图中的UI控件与命令之间的交互可以是双向的。在这种情况下，可以在用户与UI交互时调用该命令，并且可以在启用或禁用基础命令时自动启用或禁用UI。 视图模型可以将命令实现为命令方法或命令对象（实现ICommand接口的对象）。在任何一种情况下，视图与命令的交互都可以以声明方式定义，而不需要在视图的代码隐藏文件中使用复杂的事件处理代码。例如，WPF中的某些控件本身支持命令并提供Command属性，该属性可以是绑定到视图模型提供的ICommand对象的数据。在其他情况下，命令行为可用于将控件与视图模型提供的命令方法或命令对象相关联。 **注意：**行为是一种功能强大且灵活的可扩展性机制，可用于封装交互逻辑和行为，然后可以与视图中的控件进行声明性关联。命令行为可用于将命令对象或方法与未专门设计用于与命令交互的控件相关联。 以下部分描述了如何在视图中实现命令，命令方法或命令对象，以及如何将它们与视图中的控件相关联。 实现基于任务的委托命令\r在许多情况下，命令使用长时间运行的事务调用代码，这些事务无法阻止UI线程。对于这种情况，你应该使用FromAsyncHandler的方法DelegateCommand类，它创建的新实例DelegateCommand从一个异步处理方法。 // DelegateCommand.cs public static DelegateCommand FromAsyncHandler(Func\u003cTask\u003e executeMethod, Func\u003cbool\u003e canExecuteMethod) { return new DelegateCommand(executeMethod, canExecuteMethod); } 例如，以下代码显示如何通过指定SignInAsync和CanSignIn视图模型方法的委托来构造表示登录命令的DelegateCommand实例。然后，该命令通过只读属性公开给视图，该属性返回对ICommand的引用。 // SignInFlyoutViewModel.cs public DelegateCommand SignInCommand { get; private set; } ... SignInCommand = DelegateCommand.FromAsyncHandler(SignInAsync, CanSignIn); ","date":"2019-07-01","objectID":"/2019/07/prism9-mvvm/:0:3","tags":["Prism","MVVM"],"title":"Prism MVVM","uri":"/2019/07/prism9-mvvm/"},{"categories":"Prism","content":"实现命令对象\r命令对象是实现ICommand接口的对象。该接口定义了一个Execute方法，它封装了操作本身，以及一个CanExecute方法，它指示是否可以在特定时间调用该命令。这两种方法都只使用一个参数作为命令的参数。对命令对象中的操作的实现逻辑的封装意味着它可以更容易地进行单元测试和维护。 实现ICommand接口非常简单。但是，您可以在应用程序中轻松使用此接口的许多实现。例如，您可以使用Blend for Visual Studio SDK中的ActionCommand类或Prism提供的DelegateCommand类。 注意：DelegateCommand可以在Prism.Commands命名空间中找到，该命名空间位于Prism.Core NuGet包中。 Prism DelegateCommand类封装了两个委托，每个委托引用在视图模型类中实现的方法。它继承自DelegateCommandBase类，该类通过调用这些委托来实现ICommand接口的Execute和CanExecute方法。您可以在DelegateCommand类构造函数中为视图模型方法指定委托，其定义如下。 // DelegateCommand.cs public class DelegateCommand\u003cT\u003e : DelegateCommandBase { public DelegateCommand(Action\u003cT\u003e executeMethod,Func\u003cT,bool\u003e canExecuteMethod ): base((o) =\u003e executeMethod((T)o), (o) =\u003e canExecuteMethod((T)o)) { ... } } 例如，以下代码示例显示如何通过为OnSubmit和CanSubmit视图模型方法指定委托来构造表示Submit命令的DelegateCommand实例。然后，该命令通过只读属性公开给视图，该属性返回对ICommand的引用。 public class QuestionnaireViewModel { public QuestionnaireViewModel() { this.SubmitCommand = new DelegateCommand\u003cobject\u003e( this.OnSubmit, this.CanSubmit ); } public ICommand SubmitCommand { get; private set; } private void OnSubmit(object arg) {...} private bool CanSubmit(object arg) { return true; } } 当在DelegateCommand对象上调用Execute方法时，它只是通过您在构造函数中指定的委托将调用转发到视图模型类中的方法。同样，调用CanExecute方法时，将调用视图模型类中的相应方法。构造函数中CanExecute方法的委托是可选的。如果未指定委托，则DelegateCommand将始终为CanExecute返回true。 该DelegateCommand类是一个泛型类型。type参数指定传递给Execute和CanExecute方法的命令参数的类型。在前面的示例中，command参数的类型为object。Prism还提供了非泛型版本的DelegateCommand类，以便在不需要命令参数时使用。 视图模型可以通过调用DelegateCommand对象上的RaiseCanExecuteChanged方法来指示命令的CanExecute状态的更改。这会导致引发CanExecuteChanged事件。UI中绑定到该命令的任何控件都将更新其启用状态以反映绑定命令的可用性。 可以使用ICommand接口的其他实现。Expression Blend SDK提供的ActionCommand类与前面描述的Prism的DelegateCommand类类似，但它仅支持单个Execute方法委托。Prism还提供了CompositeCommand类，它允许将DelegateCommands组合在一起执行。有关使用CompositeCommand类的更多信息，请参阅“ 高级MVVM方案 ”中的“复合命令” 。 从视图调用命令对象\r有许多方法可以将视图中的控件与视图模型提供的命令对象相关联。某些WPF控件，特别是ButtonBase派生控件，如Button或RadioButton，以及Hyperlink或MenuItem派生控件，可以通过Command属性轻松地将数据绑定到命令对象。WPF还支持将视图模型ICommand绑定到KeyGesture。 \u003cButton Command=\"{Binding Path=SubmitCommand}\" CommandParameter=\"SubmitOrder\"/\u003e 也可以使用CommandParameter属性选择性地定义命令参数。预期参数的类型在Execute和CanExecute目标方法中指定。当用户与该控件交互时，控件将自动调用目标命令，并且命令参数（如果提供）将作为参数传递给命令的Execute方法。在前面的示例中，按钮将在单击时自动调用SubmitCommand。此外，如果指定了CanExecute处理程序，则在CanExecute返回false时将自动禁用该按钮，如果返回true，将启用它。 另一种方法是使用Blend for Visual Studio 2013交互触发器和InvokeCommandAction行为。有关InvokeCommandAction行为以及将命令与事件关联的更多信息，请参阅“ 高级MVVM方案”中的“交互触发器和命令” 。 数据验证和错误报告\r通常需要您的视图模型或模型来执行数据验证并向视图发出任何数据验证错误信号，以便用户可以采取行动纠正它们。 WPF支持管理更改绑定到视图中控件的各个属性时发生的数据验证错误。对于与控件数据绑定的单个属性，视图模型或模型可以通过拒绝传入的错误值并抛出异常来表示属性设置器中的数据验证错误。如果数据绑定上的ValidatesOnExceptions属性为true，则WPF中的数据绑定引擎将处理该异常并向用户显示存在数据验证错误的可视提示。 但是，应尽可能避免以这种方式抛出属性异常。另一种方法是在视图模型或模型类上实现IDataErrorInfo或INotifyDataErrorInfo接口。这些接口允许您的视图模型或模型对一个或多个属性值执行数据验证，并向视图返回错误消息，以便可以通知用户错误。 实现IDataErrorInfo\r该IDataErrorInfo的接口提供了性能数据验证和错误报告的基本支持。它定义了两个只读属性：一个索引器属性，其属性名称为索引器参数，以及一个Error属性。两个属性都返回一个字符串值。 indexer属性允许视图模型或模型类提供特定于命名属性的错误消息。空字符串或空返回值向视图指示已更改的属性值有效。的错误属性允许视图模型或模型类，以提供对整个对象的错误消息。但请注意，WPF数据绑定引擎当前不会调用此属性。 所述IDataErrorInfo的时首先显示数据绑定属性索引器属性被访问，并且每当它随后被更改。因为为所有更改的属性调用了indexer属性，所以应该小心确保数据验证尽可能快速有效。 将视图中的控件绑定到要通过IDataErrorInfo接口验证的属性时，请将数据绑定上的ValidatesOnDataErrors属性设置为true。这将确保数据绑定引擎将请求数据绑定属性的错误信息。 \u003cTextBox Text=\"{Binding Path=CurrentEmployee.Name, Mode=TwoWay, ValidatesOnDataErrors=True, NotifyOnValidationError=True }\" /\u003e 实现INotifyDataErrorInfo\r该INotifyDataErrorInfo界面比更灵活IDataErrorInfo的接口。它支持属性的多个错误，异步数据验证，以及在对象的错误状态更改时通知视图的能力。 所述INotifyDataErrorInfo接口定义了一个HasErrors属性，该属性允许视图模型，以指示用于任何性质的误差（或多个误差）是否存在，和一个GetErrors方法，其允许视图模型返回错误消息的列表的特定属性。 所述INotifyDataErrorInfo接口还限定ErrorsChanged事件。这通过允许视图或视图模型通过ErrorsChanged事件指示特定属性的错误状态更改来支持异步验证方案。可以通过多种方式更改属性值，而不仅仅是通过数据绑定 - 例如，作为Web服务调用或后台计算的结果。该ErrorsChanged事件使得一旦数据验证错误已被确定视图模型告知错误的观点。 要支持INotifyDataErrorInfo，您需要维护每个属性的错误列表。Model-View-ViewModel参考实现（MVVM RI）演示了一种使用ErrorsContainer集合类来实现此目的的方法，该集合类跟踪对象中的所有验证错误。如果错误列表发生更改，它还会引发通知事件。以下代码示例显示了DomainObject（根模型对象），并使用ErrorsContainer类显示了INotifyDataErrorInfo的示例实现。 public abstract class DomainObject : INotif","date":"2019-07-01","objectID":"/2019/07/prism9-mvvm/:0:4","tags":["Prism","MVVM"],"title":"Prism MVVM","uri":"/2019/07/prism9-mvvm/"},{"categories":"Prism","content":"Construction and Wire-Up\rMVVM模式可以帮助您将UI与表示和业务逻辑和数据完全分离，因此在正确的类中实现正确的代码是有效使用MVVM模式的重要第一步。通过数据绑定和命令管理视图和视图模型类之间的交互也是需要考虑的重要方面。下一步是考虑如何在运行时实例化视图，视图模型和模型类并将它们相互关联。 **注意：**如果在应用程序中使用依赖项注入容器，则选择适当的策略来管理此步骤尤为重要。托管可扩展性框架（MEF）和Unity应用程序块（Unity）都提供了指定视图，视图模型和模型类之间的依赖关系以及使容器满足它们的能力。有关更高级的方案，请参阅高级MVVM方案。 通常，视图与其视图模型之间存在一对一的关系。视图和视图模型通过视图的数据上下文属性松散耦合; 这允许视图中的可视元素和行为是绑定到视图模型上的属性，命令和方法的数据。您将需要决定如何在运行时通过DataContext属性来管理视图的实例化以及查看模型类及其关联。 在构建和连接视图和视图模型时也必须小心，以确保保持松耦合。如前一节所述，视图模型理想情况下不应依赖于视图的任何特定实现。同样，理想情况下，视图应该不依赖于视图模型的任何特定实现。 **注意：**但是，应该注意，视图将隐式依赖于视图模型上的特定属性，命令和方法，因为它定义了数据绑定。如果视图模型未实现所需的属性，命令或方法，则数据绑定引擎将生成运行时异常，该异常将在调试期间显示在Visual Studio输出窗口中。 可以通过多种方式在运行时构建视图和视图模型并将其关联。适合您的应用程序的方法在很大程度上取决于您是首先创建视图还是视图模型，以及是以编程方式还是以声明方式创建视图模型。以下部分描述了在运行时可以创建视图和视图模型类以及相互关联的常用方法。 使用XAML创建视图模型\r也许最简单的方法是视图以声明方式在XAML中实例化其对应的视图模型。构造视图时，还将构造相应的视图模型对象。您还可以在XAML中指定将视图模型设置为视图的数据上下文。 \u003cUserControl.DataContext\u003e \u003cmy:MyViewModel/\u003e \u003c/UserControl.DataContext\u003e 创建此视图时，将自动构建MyViewModel的实例并将其设置为视图的数据上下文。此方法要求您的视图模型具有默认（无参数）构造函数。 视图的声明性构造和视图模型的分配具有以下优点：它很简单并且在诸如Microsoft Expression Blend或Microsoft Visual Studio的设计时工具中运行良好。此方法的缺点是视图具有相应视图模型类型的知识，并且视图模型类型必须具有默认构造函数。 以编程方式创建视图模型\r另一种方法是视图在其构造函数中以编程方式实例化其对应的视图模型实例。然后，它可以将其设置为其数据上下文，如以下代码示例所示。 public MyView() { InitializeComponent(); this.DataContext = new MyViewModel(); } 使用视图模型定位器创建视图模型\r创建视图模型实例并将其与视图关联的另一种方法是使用视图模型定位器。 Prism视图模型定位器具有AutoWireViewModel附加属性，在设置时调用ViewModelLocationProvider类中的AutoWireViewModelChanged方法来解析视图的视图模型。默认情况下，它使用基于约定的方法。 在Basic MVVM QuickStart中，MainWindow.xaml使用视图模型定位器来解析视图模型。 \u003cWindow x:Class=\"QuickStart.Views.MainWindow\" ... xmlns:prism=\"http://prismlibrary.com/\" prism:ViewModelLocator.AutoWireViewModel=\"True\"\u003e Prism的ViewModelLocator类有一个附加属性AutoWireViewMode l，当设置为true时，将尝试定位视图的视图模型，然后将视图的数据上下文设置为视图模型的实例。若要查找相应的视图模型，ViewModelLocationProvider首先尝试从ViewModelLocationProvider类的Register方法注册的任何映射中解析视图模型。如果使用此方法无法解析视图模型，例如，如果未创建映射，则ViewModelLocationProvider回归到基于约定的方法来解决正确的视图模型类型。此约定假定视图模型与视图类型在同一个程序集中，视图模型位于a。ViewModels子命名空间，该视图位于。查看子命名空间，该视图模型名称与视图名称对应，以“ViewModel”结尾。有关如何更改Prism的视图模型定位器约定的说明，请参阅附录D：扩展棱镜。 注意：ViewModelLocationProvider可以在Prism.Core NuGet包中的Prism.Mvvm命名空间中找到。ViewModelLocator可以在Prism.WPF NuGet包中的Prism.Mvvm命名空间中找到。 创建定义为数据模板的视图\r视图可以定义为数据模板并与视图模型类型相关联。数据模板可以定义为资源，也可以在显示视图模型的控件中内联定义。控件的“内容”是视图模型实例，数据模板用于直观地表示它。WPF将自动实例化数据模板，并在运行时将其数据上下文设置为视图模型实例。此技术是首先实例化视图模型，然后创建视图的情况的示例。 数据模板灵活轻便。UI设计人员可以使用它们轻松定义视图模型的可视化表示，而无需任何复杂的代码。数据模板仅限于不需要任何UI逻辑（代码隐藏）的视图。Microsoft Blend for Visual Studio 2013可用于可视化设计和编辑数据模板。 以下示例显示绑定到客户列表的ItemsControl。底层集合中的每个客户对象都是一个视图模型实例。客户的视图由内联数据模板定义。在以下示例中，每个客户视图模型的视图由一个StackPanel组成，其中标签和文本框控件绑定到视图模型上的Name属性。 \u003cItemsControl ItemsSource=\"{Binding Customers}\"\u003e \u003cItemsControl.ItemTemplate\u003e \u003cDataTemplate\u003e \u003cStackPanel Orientation=\"Horizontal\"\u003e \u003cTextBlock VerticalAlignment=\"Center\" Text=\"Customer Name: \" /\u003e \u003cTextBox Text=\"{Binding Name}\" /\u003e \u003c/StackPanel\u003e \u003c/DataTemplate\u003e \u003c/ItemsControl.ItemTemplate\u003e \u003c/ItemsControl\u003e 您还可以将数据模板定义为资源。以下示例显示了数据模板定义的资源，并通过StaticResource标记扩展应用于内容控件。 \u003cUserControl ...\u003e \u003cUserControl.Resources\u003e \u003cDataTemplate x:Key=\"CustomerViewTemplate\"\u003e \u003clocal:CustomerContactView /\u003e \u003c/DataTemplate\u003e \u003c/UserControl.Resources\u003e \u003cGrid\u003e \u003cContentControl Content=\"{Binding Customer}\" ContentTemplate=\"{StaticResource CustomerViewTemplate}\" /\u003e \u003c/Grid\u003e \u003c/UserControl\u003e 这里，数据模板包装了一个具体的视图类型。这允许视图定义代码隐藏行为。通过这种方式，数据模板机制可用于从外部提供视图和视图模型之间的关联。虽然前面的示例显示了UserControl资源中的模板，但它通常会放在应用程序的资源中以供重用。 ","date":"2019-07-01","objectID":"/2019/07/prism9-mvvm/:0:5","tags":["Prism","MVVM"],"title":"Prism MVVM","uri":"/2019/07/prism9-mvvm/"},{"categories":"Prism","content":"关键决定\r当您选择使用MVVM模式构建应用程序时，您将不得不做出某些难以在以后更改的设计决策。通常，这些决策是应用程序范围的，并且它们在整个应用程序中的一致使用将提高开发人员和设 以下总结了实现MVVM模式时最重要的决策： 确定查看和查看您将使用的模型构造的方法。您需要确定您的应用程序是首先构造视图还是视图模型，以及是否使用依赖注入容器，例如Unity或MEF。您通常希望这在整个应用程序范围内保持一致。有关详细信息，请参阅部分，建设和线向上，这个主题和部分先进施工和线向上，在高级MVVM方案。 确定是否将视图模型中的命令作为命令方法或命令对象公开。命令方法很容易公开，可以通过视图中的行为来调用。命令对象可以巧妙地封装命令和启用/禁用逻辑，并且可以通过行为或通过ButtonBase派生控件上的Command属性调用。为了使开发人员和设计人员更容易，最好将其作为应用程序范围内的选择。有关更多信息，请参阅本主题中的“ 命令 ”一节。 确定视图模型和模型如何向视图报告错误。您的模型可以支持IDataErrorInfo或INotifyDataErrorInfo。并非所有模型都需要报告错误信息，但对于那些模型，最好为开发人员提供一致的方法。有关详细信息，请参阅本主题中的“ 数据验证和错误报告 ”部分。 确定Microsoft Blend for Visual Studio 2013设计时数据支持对您的团队是否重要。如果您将使用Blend来设计和维护UI并希望查看设计时数据，请确保您的视图和视图模型提供的构造函数没有参数，并且您的视图提供了设计时数据上下文。或者，考虑使用Microsoft Blend for Visual Studio 2013提供的设计时功能，使用设计时属性，例如d：DataContext和d：DesignSource。有关更多信息，请参阅在编写用户界面中创建设计器友好视图的准则。 ","date":"2019-07-01","objectID":"/2019/07/prism9-mvvm/:0:6","tags":["Prism","MVVM"],"title":"Prism MVVM","uri":"/2019/07/prism9-mvvm/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 Modular Application Development Using Prism Library for WPF 模块化应用程序是一个应用程序，它被分成一组松散耦合的功能单元（命名模块），可以集成到更大的应用程序中。客户端模块封装了应用程序的整体功能的一部分，并且通常表示一组相关的问题。它可以包括一组相关组件，例如应用程序功能，包括用户界面和业务逻辑，或应用程序基础结构，例如用于记录或验证用户的应用程序级服务。模块彼此独立，但可以以松散耦合的方式彼此通信。使用模块化应用程序设计，您可以更轻松地开发，测试，部署和维护应用程序。 例如，考虑个人银行应用程序。用户可以访问各种功能，例如在账户之间转账，支付账单以及从单个用户界面（UI）更新个人信息。但是，在幕后，这些功能中的每一个都封装在一个离散模块中。这些模块相互通信，并与后端系统（如数据库服务器和Web服务）进行通信。应用服务集成了每个不同模块中的各种组件，并处理与用户的通信。用户看到的视图类似于单个应用程序的集成视图。 下图显示了具有多个模块的模块化应用程序的设计。 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:0","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"构建模块化应用程序的好处\r您可能已经使用程序集，接口和类构建了一个架构良好的应用程序，并采用了良好的面向对象设计原则。即便如此，除非非常小心，否则您的应用程序设计可能仍然是“单一的”（所有功能都在应用程序内以紧密耦合的方式实现），这可能使应用程序难以开发，测试，扩展和维护。 另一方面，模块化应用程序方法可以帮助您识别应用程序的大规模功能区域，并允许您独立开发和测试该功能。这可以使开发和测试更容易，但它也可以使您的应用程序更灵活，更容易在未来扩展。模块化方法的好处是它可以使您的整体应用程序架构更加灵活和可维护，因为它允许您将应用程序分解为可管理的部分。每个部分都封装了特定的功能，每个部分都通过清晰但松散耦合的通信渠道进行集成。 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:1","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"Prism对模块化应用程序开发的支持\rPrism为您的应用程序中的模块化应用程序开发和运行时模块管理提供支持。使用Prism的模块化开发功能可以节省您的时间，因为您不必实现和测试自己的模块化框架。Prism支持以下模块化应用程序开发功能： 用于注册命名模块和每个模块位置的模块目录; 您可以通过以下方式创建模块目录： 通过代码或可扩展应用程序标记语言（XAML）定义模块 通过发现目录中的模块，您可以加载所有模块，而无需在集中目录中明确定义 通过在配置文件中定义模块 模块的声明性元数据属性，以支持初始化模式和依赖性 与依赖注入容器集成以支持模块之间的松散耦合 对于模块加载： 依赖管理，包括重复和循环检测，以确保模块以正确的顺序加载，并且只加载和初始化一次 模块的按需和后台下载，以最大限度地减少应用程序启动时间; 其余模块可以在后台加载和初始化，也可以在需要时加载和初始化 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:2","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"核心概念\r本节介绍与Prism模块化相关的核心概念，包括IModule接口，模块加载过程，模块目录，模块之间的通信以及依赖注入容器。 IModule：模块化应用程序的构建块\r模块是功能和资源的逻辑集合，以可以单独开发，测试，部署和集成到应用程序中的方式打包。包可以是一个或多个程序集。每个模块都有一个中心类，负责初始化模块并将其功能集成到应用程序中。该类实现了IModule接口。 *注意：实现IModule接口的类的存在足以将包标识为模块。 该IModule的接口只有一个方法，名为初始化，您可以在其中实现的任何逻辑需要初始化和模块的功能集成到应用程序。根据模块的用途，它可以将视图注册到组合用户界面，为应用程序提供其他服务，或扩展应用程序的功能。以下代码显示了模块的最低实现。 public class MyModule : IModule { public void Initialize() { // Do something here. } } 模块寿命\rPrism中的模块加载过程包括以下内容： 注册/发现模块。在运行时为特定应用程序加载的模块在模块目录中定义。该目录包含有关要加载的模块，其位置以及加载顺序的信息。 加载模块。包含模块的程序集将加载到内存中。此阶段可能需要从某个远程位置或本地目录检索模块。 初始化模块。然后初始化模块。这意味着创建模块类的实例并通过IModule接口调用它们的Initialize方法。 下图显示了模块加载过程。 模块目录\r所述ModuleCatalog保存关于能够由应用程序使用的模块的信息。目录本质上是ModuleInfo类的集合。ModuleInfo类中描述了每个模块，该类记录了模块的其他属性中的名称，类型和位置。使用ModuleInfo实例填充ModuleCatalog有几种典型方法： 在代码中注册模块 在XAML中注册模块 在配置文件中注册模块 在磁盘上的本地目录中发现模块 您应该使用的注册和发现机制取决于您的应用程序需要什么。使用配置文件或XAML文件允许您的应用程序不需要引用模块。使用目录可以允许应用程序发现模块，而无需在文件中指定它们。 控制何时加载模块\rPrism应用程序可以尽快初始化模块，称为“可用时”，或者当应用程序需要它们时，称为“按需”。请考虑以下加载模块的准则： 运行应用程序所需的模块必须与应用程序一起加载，并在应用程序运行时进行初始化。 包含几乎总是在应用程序的典型使用中使用的功能的模块可以在后台加载并在可用时进行初始化。 可以按需加载和初始化包含很少使用的功能（或其他模块可选择依赖的支持模块）的模块。 考虑如何对应用程序进行分区，常见使用方案，应用程序启动时间以及下载的数量和大小，以确定如何配置模块以进行下载和初始化。 将模块与应用程序集成\rPrism提供以下类来引导您的应用程序：UnityBootstrapper或MefBootstrapper。这些类可用于创建和配置模块管理器以发现和加载模块。您可以覆盖配置方法，以在几行代码中注册XAML文件，配置文件或目录位置中指定的模块。 使用模块Initialize方法将模块与应用程序的其余部分集成。执行此操作的方式因应用程序的结构和模块的内容而异。以下是将模块集成到应用程序中的常见操作： 将模块的视图添加到应用程序的导航结构中。在使用视图发现或视图注入构建复合UI应用程序时，这很常见。 订阅应用程序级别的事件或服务。 使用应用程序的依赖注入容器注册共享服务。 在模块之间进行通信\r即使模块之间的耦合度较低，模块也可以相互通信。有几种松散耦合的通信模式，每种都有自己的优势。通常，这些模式的组合用于创建所得到的解决方案。以下是其中一些模式： 松散耦合的事件。模块可以广播已发生的特定事件。其他模块可以订阅这些事件，以便在事件发生时通知他们。松耦合事件是在两个模块之间建立通信的轻量级方式; 因此，它们很容易实现。但是，过于依赖事件的设计可能变得难以维护，尤其是如果必须协调许多事件以完成单个任务。在这种情况下，考虑共享服务可能更好。 共享服务。共享服务是可以通过公共接口访问的类。通常，共享服务位于共享程序集中，并提供系统范围的服务，例如身份验证，日志记录或配置。 共享资源。如果您不希望模块直接相互通信，您还可以通过共享资源（如数据库或一组Web服务）间接进行通信。 依赖注入和模块化应用程序\rUnity应用程序块（Unity）和托管可扩展性框架（MEF）等容器允许您轻松使用控制反转（IoC）和依赖注入，它们是强大的设计模式，有助于以松散耦合的方式组合组件。它允许组件获得对它们所依赖的其他组件的引用，而无需对这些引用进行硬编码，从而促进更好的代码重用和更高的灵活性。在构建松散耦合的模块化应用程序时，依赖注入非常有用。Prism旨在与用于组成应用程序中的组件的依赖注入容器无关。容器的选择取决于您，并且在很大程度上取决于您的应用要求和偏好。然而， 模式和实践Unity Application Block提供了一个功能齐全的依赖注入容器。它支持基于属性和基于构造函数的注入和策略注入，允许您透明地在组件之间注入行为和策略; 它还支持许多其他典型的依赖注入容器功能。 MEF（它是.NET Framework 4.5的一部分）通过支持基于依赖注入的组件组合提供对构建可扩展.NET应用程序的支持，并提供支持模块化应用程序开发的其他功能。它允许应用程序在运行时发现组件，然后以松散耦合的方式将这些组件集成到应用程序中。MEF是一个很好的可扩展性和组合框架。它包括程序集和类型发现，类型依赖性解析，依赖注入以及一些不错的程序集下载功能。Prism支持利用MEF功能，以及以下内容： 通过XAML和代码属性进行模块注册 通过配置文件和目录扫描进行模块注册 加载模块时的状态跟踪 使用MEF时模块的自定义声明性元数据 Unity和MEF依赖注入容器都可以与Prism无缝协作。 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:3","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"关键决定\r您要做的第一个决定是您是否要开发模块化解决方案。如上一节所述，构建模块化应用程序有许多好处，但是您需要花费时间和精力来获得这些好处。如果您决定开发模块化解决方案，还有几个需要考虑的事项： 确定您将使用的框架。您可以创建自己的模块化框架，使用Prism，MEF或其他框架。 确定如何组织解决方案。通过定义每个模块的边界来处理模块化体系结构，包括哪些组件是每个模块的一部分。您可以决定使用模块化来简化开发，以及控制应用程序的部署方式或是否支持插件或可扩展体系结构。 确定如何对模块进行分区。可以根据需求对模块进行不同的分区，例如，按功能区域，提供程序模块，开发团队和部署要求进行分区。 确定应用程序将为所有模块提供的核心服务。例如，核心服务可以是错误报告服务或身份验证和授权服务。 如果您使用的是Prism，请确定在模块目录中注册模块时使用的方法。对于WPF，您可以在代码，XAML，配置文件中注册模块，或在磁盘上的本地目录中发现模块。 确定您的模块通信和依赖策略。模块需要相互通信，您需要处理模块之间的依赖关系。 确定您的依赖注入容器。通常，模块化系统需要依赖注入，控制反转或服务定位器，以允许松散耦合和动态加载和创建模块。Prism允许在使用Unity，MEF或其他容器之间进行选择，并为Unity或基于MEF的应用程序提供库。 最小化应用程序启动时间。考虑模块的按需和后台下载，以最大限度地减少应用程序启动时间。 确定部署要求。您需要考虑如何部署应用程序。 下一节提供了有关这些决策的详细信息。 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:4","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"将您的应用程序划分为模块\r当您以模块化方式开发应用程序时，可以将应用程序组织到单独的客户端模块中，这些模块可以单独开发，测试和部署。每个模块都将封装应用程序的一部分整体功能。您必须做出的首要设计决策之一是决定如何将应用程序的功能划分为离散模块。 模块应该封装一组相关的问题，并具有一组独特的职责。模块可以表示应用程序的垂直切片或水平服务层。大型应用程序可能有两种类型的模块。 围绕垂直切片组织模块的应用程序 围绕水平层组织模块的应用程序 较大的应用程序可能具有使用垂直切片和水平层组织的模块。模块的一些示例包括以下内容： 包含特定应用程序功能的模块，例如Stock Trader参考实现中的新闻模块（Stock Trader RI） 包含特定子系统或功能的模块，用于一组相关用例，例如采购，发票或总帐 包含基础结构服务的模块，例如日志记录，缓存和授权服务，或Web服务 除了其他内部系统之外，包含调用业务线（LOB）系统（如Siebel CRM和SAP）的服务的模块 模块应该对其他模块具有最小的依赖关系。当模块依赖于另一个模块时，它应该通过使用共享库中定义的接口而不是具体类型来松散耦合，或者通过使用EventAggregator通过EventAggregator事件类型与其他模块进行通信。 模块化的目标是以一种即使在添加和删除功能和技术时仍保持灵活性，可维护性和稳定性的方式对应用程序进行分区。实现此目的的最佳方法是设计应用程序，使模块尽可能独立，具有良好定义的接口，并尽可能隔离。 确定项目与模块的比率\r有几种方法可以创建和打包模块。建议的和最常见的方法是为每个模块创建一个组件。这有助于保持逻辑模块分离并促进适当的封装。它还使得更容易将组件作为模块边界以及如何部署模块的包装进行讨论。但是，没有什么可以阻止单个程序集包含多个模块，在某些情况下，这可能是首选，以最大限度地减少解决方案中的项目数量。对于大型应用程序，拥有10-50个模块并不罕见。将每个模块分离到自己的项目中会增加解决方案的复杂性，并会降低Visual Studio的性能。 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:5","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"使用依赖注入来实现松散耦合\r模块可以依赖于主机应用程序或其他模块提供的组件和服务。Prism支持在模块之间注册依赖关系的能力，以便以正确的顺序加载和初始化它们。Prism还支持在将模块加载到应用程序时初始化模块。在模块初始化期间，模块可以检索对其所需的附加组件和服务的引用，和/或注册它包含的任何组件和服务，以使其可供其他模块使用。 模块应使用独立机制来获取外部接口的实例，而不是直接实例化具体类型，例如通过使用依赖注入容器或工厂服务。诸如Unity或MEF之类的依赖注入容器允许类型通过依赖注入自动获取所需的接口和类型的实例。Prism与Unity和MEF集成，允许模块轻松使用依赖注入。 下图显示了加载模块时需要获取或注册组件和服务引用的典型操作顺序。 在此示例中，OrdersModule程序集定义了OrdersRepository类（以及实现顺序功能的其他视图和类）。所述CustomerModule组件限定CustomersViewModel类依赖于OrdersRepository，通常基于由服务暴露的接口上。应用程序启动和引导过程包含以下步骤： 引导程序启动模块初始化过程，模块加载程序加载并初始化OrdersModule。 在OrdersModule的初始化中，它将OrdersRepository注册到容器中。 然后，模块加载器加载CustomersModule。模块加载的顺序可以由模块元数据中的依赖项指定。 该CustomersModule构建的一个实例CustomerViewModel通过容器以解决该问题。该CustomerViewModel对一个依赖OrdersRepository（通常基于它的接口上），并指示它通过构造或财产注射。容器根据OrdersModule注册的类型在视图模型的构造中注入该依赖项。最终结果是从CustomerViewModel到OrderRepository的接口引用，而没有这些类之间的紧密耦合。 注意：用于公开OrderRespository（IOrderRepository）的接口可以驻留在单独的“共享服务”程序集或“订单服务”程序集中*，该程序集仅包含公开这些服务所需的服务接口和类型。这样，CustomersModule和OrdersModule之间就没有硬依赖关系。* 请注意，两个模块都依赖于依赖注入容器。在模块构建器中的模块构造期间注入该依赖性。 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:6","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"核心情景\r本节介绍在应用程序中使用模块时将遇到的常见方案。这些方案包括定义模块，注册和发现模块，加载模块，初始化模块，指定模块依赖关系，按需加载模块，在后台下载远程模块以及检测模块何时已加载。您可以在代码，XAML或应用程序配置文件中注册和发现模块，也可以通过扫描本地目录来注册和发现模块。 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:7","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"定义模块\r模块是功能和资源的逻辑集合，以可以单独开发，测试，部署和集成到应用程序中的方式打包。每个模块都有一个中心类，负责初始化模块并将其功能集成到应用程序中。该类实现了IModule接口，如下所示。 public class MyModule : IModule { public void Initialize() { // Initialize module } } 实现Initialize方法的方式取决于应用程序的要求。模块目录中定义了模块类类型，初始化模式和任何模块依赖性。对于目录中的每个模块，模块加载器创建模块类的实例，然后调用Initialize方法。模块按模块目录中指定的顺序处理。运行时初始化顺序基于模块下载，可用和满足依赖性的时间。 根据应用程序使用的模块目录的类型，可以通过模块类本身的声明性属性或模块目录文件中的模块依赖性来设置模块依赖性。以下部分提供了更多详细信息。 创建模块目录\rprotected override IModuleCatalog CreateModuleCatalog() { return new AggregateModuleCatalog() } 注册和发现模块\r应用程序可以加载的模块在模块目录中定义。Prism Module Loader使用模块目录来确定哪些模块可以加载到应用程序中，何时加载它们以及它们的加载顺序。 模块目录由实现IModuleCatalog接口的类表示。模块目录类由应用程序引导程序类在应用程序初始化期间创建。Prism提供了不同的模块目录实现供您选择。您还可以通过调用AddModule方法或从ModuleCatalog派生来创建具有自定义行为的模块目录，从另一个数据源填充模块目录。 **注意：**通常，Prism中的模块使用依赖注入容器和公共服务定位器来检索模块初始化所需的类型实例。Unity和MEF容器都由Prism支持。虽然注册，发现，下载和初始化模块的整个过程是相同的，但细节可以根据是使用Unity还是MEF而有所不同。本主题将解释方法之间特定于容器的差异。 在代码中注册模块\r最基本的模块目录由ModuleCatalog类提供。您可以使用此模块目录通过指定模块类类型以编程方式注册模块。您还可以以编程方式指定模块名称和初始化模式。要直接使用ModuleCatalog类注册模块，请在应用程序的Bootstrapper类中调用AddModule方法。以下代码中显示了一个示例。 protected override void ConfigureModuleCatalog() { Type moduleCType = typeof(ModuleC); ModuleCatalog.AddModule( new ModuleInfo() { ModuleName = moduleCType.Name, ModuleType = moduleCType.AssemblyQualifiedName, }); } **注意：**如果您的应用程序直接引用模块类型，您可以按类型添加它，如上所示; 否则，您需要提供完全限定的类型名称和程序集的位置。 要查看在代码中定义模块目录的另一个示例，请参阅Stock Trader参考实现（Stock Trader RI）中的StockTraderRIBootstrapper.cs。 注：该引导程序基类提供了CreateModuleCatalog方法来帮助创建的ModuleCatalog。默认情况下，此方法创建ModuleCatalog实例，但可以在派生类中重写此方法，以便创建不同类型的模块目录。 使用XAML文件注册模块\r您可以通过在XAML文件中指定模块目录来以声明方式定义模块目录。XAML文件指定要创建的模块目录类类型以及要添加到哪个模块。通常，.xaml文件作为资源添加到shell项目中。模块目录由引导程序创建，并调用CreateFromXaml方法。从技术角度来看，这种方法非常类似于在代码中定义ModuleCatalog，因为XAML文件只是定义了要实例化的对象的层次结构。 以下代码示例显示了指定模块目录的XAML文件。 \u003c--! ModulesCatalog.xaml --\u003e \u003cModularity:ModuleCatalog xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:sys=\"clr-namespace:System;assembly=mscorlib\" xmlns:Modularity=\"clr-namespace:Microsoft.Practices.Prism.Modularity;assembly=Microsoft.Practices.Prism\"\u003e \u003cModularity:ModuleInfoGroup Ref=\"file://DirectoryModules/ModularityWithMef.Desktop.ModuleB.dll\" InitializationMode=\"WhenAvailable\"\u003e \u003cModularity:ModuleInfo ModuleName=\"ModuleB\" ModuleType=\"ModularityWithMef.Desktop.ModuleB, ModularityWithMef.Desktop.ModuleB, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\" /\u003e \u003c/Modularity:ModuleInfoGroup\u003e \u003cModularity:ModuleInfoGroup InitializationMode=\"OnDemand\"\u003e \u003cModularity:ModuleInfo Ref=\"file://ModularityWithMef.Desktop.ModuleE.dll\" ModuleName=\"ModuleE\" ModuleType=\"ModularityWithMef.Desktop.ModuleE, ModularityWithMef.Desktop.ModuleE, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\" /\u003e \u003cModularity:ModuleInfo Ref=\"file://ModularityWithMef.Desktop.ModuleF.dll\" ModuleName=\"ModuleF\" ModuleType=\"ModularityWithMef.Desktop.ModuleF, ModularityWithMef.Desktop.ModuleF, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\"\u003e \u003cModularity:ModuleInfo.DependsOn\u003e \u003csys:String\u003eModuleE\u003c/sys:String\u003e \u003c/Modularity:ModuleInfo.DependsOn\u003e \u003c/Modularity:ModuleInfo\u003e \u003c/Modularity:ModuleInfoGroup\u003e \u003c!-- Module info without a group --\u003e \u003cModularity:ModuleInfo Ref=\"file://DirectoryModules/ModularityWithMef.Desktop.ModuleD.dll\" ModuleName=\"ModuleD\" ModuleType=\"ModularityWithMef.Desktop.ModuleD, ModularityWithMef.Desktop.ModuleD, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\" /\u003e \u003c/Modularity:ModuleCatalog\u003e 注意： ModuleInfoGroups提供了一种方便的方法来对同一程序集中的模块进行分组，以相同的方式进行初始化，或者只对同一组中的模块具有依赖性。模块之间的依赖关系可以在同一ModuleInfoGroup中的模块中定义; 但是，您无法在不同的ModuleInfoGroups中定义模块之间的依赖关系。将模块放在模块组中是可选的。为组设置的属性将应用于其包含的所有模块。请注意，模块也可以在不在组内的情况下进行注册。 在应用程序的Bootstrapper类中，您需要指定XAML文件是ModuleCatalog的源，如以下代码所示。 protected override IModuleCatalog CreateModuleCatalog() { return ModuleCatalog.CreateFromXaml(new Uri(\"/MyProject;component/ModulesCatalog.xaml\", UriKind.Relative)); } 使用配置文件注册模块\r在WPF中，可以在App.config文件中指定模块信息。此方法的优点是此文件未编译到应用程序中。这使得在运行时添加或删除模块非常容易，无需重新编译应用程序。 以下代码示例显示了指定模块目录的配置文件。如果要自动加载模块，请设置startupLoaded =“true”","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:8","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"加载模块\r填充ModuleCatalog后，可以加载和初始化模块。模块加载意味着模块组件从磁盘传输到内存。该ModuleManager会负责协调加载和初始化过程。 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:9","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"初始化模块\r模块加载后，它们被初始化。这意味着创建了模块类的实例并调用了其Initialize方法。初始化是将模块与应用程序集成的地方。考虑以下模块初始化的可能性： 使用应用程序注册模块的视图。如果您的模块使用视图发现或视图注入参与用户界面（UI）组合，则您的模块将需要将其视图或视图模型与相应的区域名称相关联。这允许视图在应用程序中的菜单，工具栏或其他可视区域上动态显示。 订阅应用程序级别的事件或服务。通常，应用程序会公开您的模块感兴趣的特定于应用程序的服务和/或事件。使用Initialize方法将模块的功能添加到那些应用程序级别的事件和服务。 例如，应用程序可能会在关闭时引发事件，并且您的模块想要对该事件做出反应。您的模块也可能必须向应用程序级服务提供一些数据。例如，如果您已创建MenuService（它负责添加和删除菜单项），则可以在模块的Initialize方法中添加正确的菜单项。 注意：默认情况下，模块实例生存期是短暂的。在加载过程中调用Initialize方法后，将释放对模块实例的引用。如果您没有为模块实例建立强引用链，则会进行垃圾回收。如果您订阅包含对模块的弱引用的事件，则此行为可能会导致调试有问题，因为您的模块在垃圾收集器运行时“消失”。 使用依赖项注入容器注册类型。如果使用依赖注入模式（如Unity或MEF），则模块可以为应用程序或其他模块注册要使用的类型。它还可能要求容器解析所需类型的实例。 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:10","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"指定模块依赖项\r模块可能依赖于其他模块。如果模块A依赖于模块B，则必须在模块A之前初始化模块B. ModuleManager会跟踪这些依赖关系并相应地初始化模块。根据您定义模块目录的方式，您可以在代码，配置或XAML中定义模块依赖性。 在代码中指定依赖项\r对于在代码中注册模块或按目录发现模块的WPF应用程序，Prism提供了在创建模块时使用的声明性属性，如以下代码示例所示。 // (when using Unity) [Module(ModuleName = \"ModuleA\")\\] [ModuleDependency(\"ModuleD\")\\] public class ModuleA: IModule { ... } 在XAML中指定依赖项\r以下XAML显示了模块F依赖于模块E的位置。 \u003c-- ModulesCatalog.xaml --\u003e \u003cModularity:ModuleInfo Ref=\"file://ModularityWithMef.Desktop.ModuleE.dll\" moduleName=\"ModuleE\" moduleType=\"ModularityWithMef.Desktop.ModuleE, ModularityWithMef.Desktop.ModuleE, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\"\u003e \u003cModularity:ModuleInfo Ref=\"file://ModularityWithMef.Desktop.ModuleF.dll\" moduleName=\"ModuleF\" moduleType=\"ModularityWithMef.Desktop.ModuleF, ModularityWithMef.Desktop.ModuleF, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\"\u003e \u003cModularity:ModuleInfo.DependsOn\u003e \u003csys:String\u003eModuleE\u003c/sys:String\u003e \u003c/Modularity:ModuleInfo.DependsOn\u003e \u003c/Modularity:ModuleInfo\u003e . . . 在配置中指定依赖项\r以下示例App.config文件显示了模块F依赖于模块E的位置。 \u003c!-- App.config --\u003e \u003cmodules\u003e \u003cmodule assemblyFile=\"ModularityWithUnity.Desktop.ModuleE.dll\" moduleType=\"ModularityWithUnity.Desktop.ModuleE, ModularityWithUnity.Desktop.ModuleE, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\" moduleName=\"ModuleE\" startupLoaded=\"false\" /\u003e \u003cmodule assemblyFile=\"ModularityWithUnity.Desktop.ModuleF.dll\" moduleType=\"ModularityWithUnity.Desktop.ModuleF, ModularityWithUnity.Desktop.ModuleF, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\" moduleName=\"ModuleF\" startupLoaded=\"false\"\u003e \u003cdependencies\u003e \u003cdependency moduleName=\"ModuleE\" /\u003e \u003c/dependencies\u003e \u003c/module\u003e \u003c/modules\u003e 按需加载模块\r要按需加载模块，您需要指定将它们加载到模块目录中，并将InitializationMode设置为OnDemand。执行此操作后，您需要在应用程序中编写请求加载模块的代码。 在代码中指定按需加载\r使用属性将模块指定为按需，如以下代码示例所示。 // Boostrapper.cs protected override void ConfigureModuleCatalog() { . . . Type moduleCType = typeof(ModuleC); this.ModuleCatalog.AddModule(new ModuleInfo() { ModuleName = moduleCType.Name, ModuleType = moduleCType.AssemblyQualifiedName, InitializationMode = InitializationMode.OnDemand }); . . . } 在XAML中指定按需加载\r在XAML中定义模块目录时，可以指定InitializationMode.OnDemand，如以下代码示例所示。 \u003c!-- ModulesCatalog.xaml --\u003e ... \u003cmodule assemblyFile=\"ModularityWithUnity.Desktop.ModuleE.dll\" moduleType=\"ModularityWithUnity.Desktop.ModuleE, ModularityWithUnity.Desktop.ModuleE, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\" moduleName=\"ModuleE\" startupLoaded=\"false\" /\u003e ... 在配置中指定按需加载\r在App.config文件中定义模块目录时，可以指定InitializationMode.OnDemand，如以下代码示例所示。 \u003c!-- App.config --\u003e \u003cmodule assemblyFile=\"ModularityWithUnity.Desktop.ModuleC.dll\" moduleType=\"ModularityWithUnity.Desktop.ModuleC, ModularityWithUnity.Desktop.ModuleC, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\" moduleName=\"ModuleC\" startupLoaded=\"false\" /\u003e 请求按需加载模块\r在按需指定模块后，应用程序可以请求加载模块。想要启动加载的代码需要获取对引导程序向容器注册的IModuleManager服务的引用。 private void OnLoadModuleCClick(object sender, RoutedEventArgs e) { moduleManager.LoadModule(\"ModuleC\"); } ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:11","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"检测模块何时加载\r所述ModuleManager会服务提供了一个用于事件的应用程序的模块负载时来跟踪或无法加载。您可以通过依赖注入IModuleManager接口来获取对此服务的引用。 this.moduleManager.LoadModuleCompleted += this.ModuleManager_LoadModuleCompleted; void ModuleManager_LoadModuleCompleted(object sender, LoadModuleCompletedEventArgs e) { ... } 为了使应用程序和模块保持松散耦合，应用程序应避免使用此事件将模块与应用程序集成。相反，模块的Initialize方法应该处理与应用程序的集成。 该LoadModuleCompletedEventArgs包含IsErrorHandled财产。如果模块无法加载并且应用程序想要阻止ModuleManager记录错误并抛出异常，则可以将此属性设置为true。 ***注意：*加载并初始化模块后，无法卸载模块组件。Prism库不会保存模块实例引用，因此初始化完成后可能会对模块类实例进行垃圾回收。 ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:12","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"MEF中的模块\r如果您选择使用MEF作为依赖注入容器，本节仅突出显示差异。 注意：使用MEF时，MefBootstrapper使用MefModuleManager。它扩展了ModuleManager并实现了IPartImportsSatisfiedNotification接口，以确保在MEF导入新类型时更新ModuleCatalog*。* 使用MEF在代码中注册模块\r使用MEF时，可以将ModuleExport属性应用于模块类，以使MEF自动发现类型。以下是一个例子。 [ModuleExport(typeof(ModuleB), InitializationMode = InitializationMode.OnDemand)] public class ModuleB : IModule { ... } 您还可以使用MEF来发现和加载模块，使用AssemblyCatalog类（可用于发现程序集中的所有导出的模块类）和AggregateCatalog类（允许将多个目录组合到一个逻辑目录中）。默认情况下，Prism MefBootstrapper类创建一个AggregateCatalog实例。然后，您可以覆盖ConfigureAggregateCatalog方法以注册程序集，如以下代码示例所示。 protected override void ConfigureAggregateCatalog() { base.ConfigureAggregateCatalog(); //Module A is referenced in in the project and directly in code. this.AggregateCatalog.Catalogs.Add(new AssemblyCatalog(typeof(ModuleA).Assembly)); this.AggregateCatalog.Catalogs.Add(new AssemblyCatalog(typeof(ModuleC).Assembly)); . . . } Prism MefModuleManager实现使MEF AggregateCatalog和Prism ModuleCatalog保持同步，从而允许Prism发现通过ModuleCatalog或AggregateCatalog添加的模块。 注意： MEF 广泛使用Lazy 来防止导出和导入类型的实例化，直到使用Value*属性。* 使用MEF在目录中发现模块\rMEF提供了一个DirectoryCatalog，可用于检查包含模块（以及其他MEF导出类型）的程序集的目录。在这种情况下，您将覆盖ConfigureAggregateCatalog方法以注册该目录。此方法仅适用于WPF。 要使用此方法，首先需要使用ModuleExport属性将模块名称和依赖项应用于模块，如以下代码示例所示。这允许MEF导入模块并允许Prism 更新ModuleCatalog。 protected override void ConfigureAggregateCatalog() { base.ConfigureAggregateCatalog(); . . . DirectoryCatalog catalog = new DirectoryCatalog(\"DirectoryModules\"); this.AggregateCatalog.Catalogs.Add(catalog); } 使用MEF在代码中指定依赖关系\r对于使用MEF的WPF应用程序，请使用ModuleExport属性，如下所示。 // (when using MEF) [ModuleExport(typeof(ModuleA), DependsOnModuleNames = new string[] { \"ModuleD\" })] public class ModuleA : IModule { ... } 因为MEF允许您在运行时发现模块，所以您还可以在运行时发现模块之间的新依赖关系。虽然您可以在ModuleCatalog旁边使用MEF ，但重要的是要记住ModuleCatalog在从XAML或配置加载时（在加载任何模块之前）验证依赖关系链。如果ModuleCatalog中列出了一个模块，然后使用MEF加载，则将使用ModuleCatalog依赖项，并忽略DependsOnModuleNames属性。 使用MEF指定按需加载\r如果使用MEF和ModuleExport属性来指定模块和模块依赖关系，则可以使用InitializationMode属性指定应按需加载模块，如此处所示。 [ModuleExport(typeof(ModuleC), InitializationMode = InitializationMode.OnDemand)] public class ModuleC : IModule { } ","date":"2019-06-29","objectID":"/2019/06/prism8-modular/:0:13","tags":["Prism","Modular"],"title":"Prism Modular","uri":"/2019/06/prism8-modular/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 Managing Dependencies Between Components Using the Prism Library for WPF 基于Prism库的应用程序是复合应用程序，可能包含许多松散耦合的类型和服务。他们需要进行交互以提供内容并根据用户操作接收通知。因为它们是松散耦合的，所以它们需要一种相互交互和通信的方式来提供所需的业务功能。为了将这些不同的部分组合在一起，基于Prism库的应用依赖于依赖注入容器。 依赖注入容器通过提供实例化类实例的工具并根据容器的配置管理其生命周期来减少对象之间的依赖关系。在对象创建期间，容器会将对象所需的所有依赖项注入其中。如果尚未创建这些依赖项，则容器首先创建并解析它们的依赖项。在某些情况下，容器本身被解析为依赖项。例如，当使用Unity应用程序块（Unity）作为容器时，模块会注入容器，因此可以使用该容器注册其视图和服务。 使用容器有几个好处： 容器不需要组件来定位其依赖项或管理它们的生命周期。 容器允许交换已实现的依赖项而不影响组件。 容器通过允许模拟依赖项来促进可测试性。 容器通过允许将新组件轻松添加到系统中来提高可维护性。 在基于Prism库的应用程序的上下文中，容器具有特定的优点： 容器在加载时将模块依赖项注入模块。 容器用于注册和解析视图模型和视图。 容器可以创建视图模型并注入视图。 容器注入组合服务，例如区域管理器和事件聚合器。 容器用于注册特定于模块的服务，这些服务是具有模块特定功能的服务。 注意： Prism指南中的某些示例依赖Unity应用程序块（Unity）作为容器。其他代码示例（例如Modularity QuickStarts）使用Managed Extensibility Framework（MEF）。Prism库本身不是特定于容器的，您可以将其服务和模式与其他容器一起使用，例如Castle Windsor，StructureMap和Spring.NET。 ","date":"2019-06-28","objectID":"/2019/06/prism7-unitycontainer/:0:0","tags":["Prism","UnityContainer"],"title":"Prism UnityContainer","uri":"/2019/06/prism7-unitycontainer/"},{"categories":"Prism","content":"关键决策：选择依赖注入容器\rPrism Library为依赖注入容器提供了两个选项：Unity或MEF。棱镜是可扩展的，从而允许使用其他容器而不需要一点工作。Unity和MEF都为依赖注入提供了相同的基本功能，即使它们的工作方式非常不同。两个容器提供的一些功能包括： 它们都使用容器注册类型。 他们都用容器注册实例。 它们都强制创建已注册类型的实例。 它们都将注册类型的实例注入到构造函数中。 它们都将已注册类型的实例注入属性。 它们都具有用于标记需要管理的类型和依赖项的声明性属性。 它们都解决了对象图中的依赖关系。 Unity提供了MEF不具备的几种功能： 它解决了没有注册的具体类型。 它解决了开放的泛型。 它使用拦截来捕获对象的调用并向目标对象添加其他功能。 MEF提供了Unity不具备的几种功能： 它发现目录中的程序集。 它使用XAP文件下载和程序集发现。 它会在发现新类型时重新组合属性和集合。 它会自动导出派生类型。 它与.NET Framework一起部署。 容器具有不同的功能和不同的工作方式，但Prism库将与容器一起使用并提供类似的功能。在考虑使用哪个容器时，请记住前面的功能并确定哪种容量更适合您的方案。 ","date":"2019-06-28","objectID":"/2019/06/prism7-unitycontainer/:0:1","tags":["Prism","UnityContainer"],"title":"Prism UnityContainer","uri":"/2019/06/prism7-unitycontainer/"},{"categories":"Prism","content":"使用容器的注意事项\r在使用容器之前，您应该考虑以下事项： 考虑使用容器注册和解析组件是否合适： 考虑在您的方案中是否可以接受向容器注册和从中解析实例的性能影响。例如，如果需要创建10,000个多边形以在渲染方法的局部范围内绘制曲面，则通过容器解析所有这些多边形实例的成本可能会产生显着的性能成本，因为容器使用反射来创建每个实体。 如果存在许多或深度依赖性，则创建成本会显着增加。 如果组件没有任何依赖关系或者不是其他类型的依赖关系，那么将它放在容器中可能没有意义。 如果组件具有一组与该类型不可分割的依赖关系并且永远不会更改，则将其放入容器中可能没有意义。 考虑组件的生命周期是否应该注册为单例或实例： 如果组件是充当单个资源（例如日志记录服务）的资源管理器的全局服务，则可能需要将其注册为单例。 如果组件为多个使用者提供共享状态，您可能希望将其注册为单例。 如果正在注入的对象需要在每次依赖对象需要时注入一个新实例，请将其注册为非单例。例如，每个视图可能需要一个视图模型的新实例。 考虑是否要通过代码或配置配置容器： 如果要集中管理所有不同的服务，请通过配置配置容器。 如果要有条件地注册特定服务，请通过代码配置容器。 如果您有模块级服务，请考虑通过代码配置容器，以便仅在加载模块时注册这些服务。 **注意：**某些容器（如MEF）无法通过配置文件进行配置，必须通过代码进行配置。 ","date":"2019-06-28","objectID":"/2019/06/prism7-unitycontainer/:0:2","tags":["Prism","UnityContainer"],"title":"Prism UnityContainer","uri":"/2019/06/prism7-unitycontainer/"},{"categories":"Prism","content":"核心情景\r容器用于两个主要目的，即注册和解析。 注册\r在将依赖项注入对象之前，需要向容器注册依赖项的类型。注册类型通常涉及向容器传递接口和实现该接口的具体类型。注册类型和对象主要有两种方法：通过代码或通过配置。具体方式因容器而异。 通常，有两种方法可以通过代码在容器中注册类型和对象： 您可以使用容器注册类型或映射。在适当的时候，容器将构建您指定的类型的实例。 您可以将容器中的现有对象实例注册为单例。容器将返回对现有对象的引用。 使用Unity容器注册类型\r在初始化期间，类型可以注册其他类型，例如视图和服务。注册允许通过容器提供其依赖项，并允许从其他类型访问它们。要做到这一点，类型将需要将容器注入模块构造函数。以下代码显示了命令QuickStart中的OrderModule类型如何注册类型。 // OrderModule.cs public class OrderModule : IModule { public void Initialize() { this.container.RegisterType\u003cIOrdersRepository, OrdersRepository\u003e(new ContainerControlledLifetimeManager()); ... } ... } 根据您使用的容器，也可以通过配置在代码外部执行注册。有关此示例，请参阅。 **注意：**与配置相比，在代码中注册的优点是只有在模块加载时才会进行注册。 使用MEF注册类型\rMEF使用基于属性的系统来向容器注册类型。因此，向容器添加类型注册很简单：它需要在类型中添加**[Export]**属性，如下面的代码示例所示。 [Export(typeof(ILoggerFacade))] public class CallbackLogger: ILoggerFacade { } 使用MEF时的另一个选择是创建类的实例并使用容器注册该特定实例。带有MEF QuickStart的Modularity中的QuickStartBootstrapper在ConfigureContainer方法中显示了一个示例，如下所示。 protected override void ConfigureContainer() { base.ConfigureContainer(); // Because we created the CallbackLogger and it needs to // be used immediately, we compose it to satisfy any imports it has. this.Container.ComposeExportedValue\u003cCallbackLogger\u003e(this.callbackLogger); } **注意：**使用MEF作为容器时，建议您使用属性来注册类型。 ","date":"2019-06-28","objectID":"/2019/06/prism7-unitycontainer/:0:3","tags":["Prism","UnityContainer"],"title":"Prism UnityContainer","uri":"/2019/06/prism7-unitycontainer/"},{"categories":"Prism","content":"Resolving\r注册类型后，可以将其解析或注入为依赖项。在解析类型并且容器需要创建新实例时，它会将依赖项注入这些实例。 通常，在解析类型时，会发生以下三种情况之一： 如果尚未注册该类型，则容器会引发异常。 **注意：**某些容器（包括Unity）允许您解析尚未注册的具体类型。 如果类型已注册为单例，则容器将返回单例实例。如果这是第一次调用该类型，则容器会创建它并保留它以供将来调用。 如果类型尚未注册为单例，则容器将返回新实例。 **注意：**默认情况下，使用MEF注册的类型是单例，容器包含对象的引用。在Unity中，默认情况下会返回新的对象实例，并且容器不会维护对该对象的引用。 ","date":"2019-06-28","objectID":"/2019/06/prism7-unitycontainer/:0:4","tags":["Prism","UnityContainer"],"title":"Prism UnityContainer","uri":"/2019/06/prism7-unitycontainer/"},{"categories":"Prism","content":"使用Unity解析实例\r命令快速入门中的以下代码示例显示了从容器中解析OrdersEditorView和OrdersToolBar视图的位置，以将它们与相应的区域相关联。 // OrderModule.cs public class OrderModule : IModule { public void Initialize() { this.container.RegisterType\u003cIOrdersRepository, OrdersRepository\u003e(new ContainerControlledLifetimeManager()); // Show the Orders Editor view in the shell's main region. this.regionManager.RegisterViewWithRegion(\"MainRegion\", () =\u003e this.container.Resolve\u003cOrdersEditorView\u003e()); // Show the Orders Toolbar view in the shell's toolbar region. this.regionManager.RegisterViewWithRegion(\"GlobalCommandsRegion\", () =\u003e this.container.Resolve\u003cOrdersToolBar\u003e()); } ... } 该OrdersEditorViewModel构造包含以下依赖（订单仓库和订单命令代理），当其解决注入。 // OrdersEditorViewModel.cs public OrdersEditorViewModel(IOrdersRepository ordersRepository, OrdersCommandProxy commandProxy) { this.ordersRepository = ordersRepository; this.commandProxy = commandProxy; // Create dummy order data. this.PopulateOrders(); // Initialize a CollectionView for the underlying Orders collection. this.Orders = new ListCollectionView( _orders ); // Track the current selection. this.Orders.CurrentChanged += SelectedOrderChanged; this.Orders.MoveCurrentTo(null); } 除了前面代码中显示的构造函数注入之外，Unity还允许注入属性。应用**[Dependency]**属性的任何属性将在解析对象时自动解析并注入。 ","date":"2019-06-28","objectID":"/2019/06/prism7-unitycontainer/:0:5","tags":["Prism","UnityContainer"],"title":"Prism UnityContainer","uri":"/2019/06/prism7-unitycontainer/"},{"categories":"Prism","content":"使用MEF解析实例\r以下代码示例显示了使用MEF QuickStart的Modularity中的Bootstrapper如何获取shell的实例。代码可以请求接口的实例，而不是请求具体类型。 protected override DependencyObject CreateShell() { return this.Container.GetExportedValue\u003cShell\u003e(); } 在MEF解析的任何类中，您也可以使用构造函数注入，如下面的模块化与MEF QuickStart中的ModuleA中的代码示例所示，其中注入了ILoggerFacade和IModuleTracker。 [ImportingConstructor] public ModuleA(ILoggerFacade logger, IModuleTracker moduleTracker) { if (logger == null) { throw new ArgumentNullException(\"logger\"); } if (moduleTracker == null) { throw new ArgumentNullException(\"moduleTracker\"); } this.logger = logger; this.moduleTracker = moduleTracker; this.moduleTracker.RecordModuleConstructed(WellKnownModuleNames.ModuleA); } 另一种选择是使用属性注入，如Modularity with MEF QuickStart 中的ModuleTracker类所示，其中注入了ILoggerFacade的实例。 [Export(typeof(IModuleTracker))] public class ModuleTracker : IModuleTracker { [Import] private ILoggerFacade Logger; } ","date":"2019-06-28","objectID":"/2019/06/prism7-unitycontainer/:0:6","tags":["Prism","UnityContainer"],"title":"Prism UnityContainer","uri":"/2019/06/prism7-unitycontainer/"},{"categories":"Prism","content":"在Prism中使用依赖注入容器和服务\r依赖注入容器（通常称为“容器”）用于满足组件之间的依赖关系; 满足这些依赖性通常涉及注册和解决。Prism Library提供对Unity容器和MEF的支持，但它不是特定于容器的。因为库通过IServiceLocator接口访问容器，所以可以替换容器。为此，您的容器必须实现IServiceLocator接口。通常，如果要更换容器，则还需要提供自己的容器特定引导程序。该IServiceLocator接口在Common Service Locator Library中定义。这是一项开源工作，旨在提供IoC（控制反转）容器的抽象，例如依赖注入容器和服务定位器。使用此库的目的是利用IoC和服务位置，而不必与特定实现相关联。 Prism库提供UnityServiceLocatorAdapter和MefServiceLocatorAdapter。两个适配器都通过扩展ServiceLocatorImplBase类型来实现ISeviceLocator接口。下图显示了类层次结构。 虽然Prism Library不引用或依赖于特定容器，但应用程序通常依赖于特定容器。这意味着特定应用程序引用容器是合理的，但Prism Library不直接引用容器。例如，Stock Trader RI和Prism附带的几个QuickStart依赖Unity作为容器。其他样品和快速入门依赖于MEF。 ","date":"2019-06-28","objectID":"/2019/06/prism7-unitycontainer/:0:7","tags":["Prism","UnityContainer"],"title":"Prism UnityContainer","uri":"/2019/06/prism7-unitycontainer/"},{"categories":"Prism","content":"IServiceLocator\r以下代码显示了IServiceLocator接口。 public interface IServiceLocator : IServiceProvider { object GetInstance(Type serviceType); object GetInstance(Type serviceType, string key); IEnumerable\u003cobject\u003e GetAllInstances(Type serviceType); TService GetInstance\u003cTService\u003e(); TService GetInstance\u003cTService\u003e(string key); IEnumerable\u003cTService\u003e GetAllInstances\u003cTService\u003e(); } 服务定位器在Prism库中扩展，扩展方法如下面的代码所示。您可以看到IServiceLocator仅用于解析，这意味着它用于获取实例; 它不用于注册。 // ServiceLocatorExtensions public static class ServiceLocatorExtensions { public static object TryResolve(this IServiceLocator locator, Type type) { try { return locator.GetInstance(type); } catch (ActivationException) { return null; } } public static T TryResolve\u003cT\u003e(this IServiceLocator locator) where T: class { return locator.TryResolve(typeof(T)) as T; } } Unity容器不支持的TryResolve扩展方法 - 如果已注册，则返回要解析的类型的实例; 否则，它返回null。 所述ModuleInitializer使用IServiceLocator为加载模块期间解析模块，作为显示在下面的代码示例。 // ModuleInitializer.cs - Initialize() IModule moduleInstance = null; try { moduleInstance = this.CreateModule(moduleInfo); moduleInstance.Initialize(); } ... // ModuleInitializer.cs - CreateModule() protected virtual IModule CreateModule(string typeName) { Type moduleType = Type.GetType(typeName); if (moduleType == null) { throw new ModuleInitializeException(string.Format(CultureInfo.CurrentCulture, Properties.Resources.FailedToGetType, typeName)); } return (IModule)this.serviceLocator.GetInstance(moduleType); } ","date":"2019-06-28","objectID":"/2019/06/prism7-unitycontainer/:0:8","tags":["Prism","UnityContainer"],"title":"Prism UnityContainer","uri":"/2019/06/prism7-unitycontainer/"},{"categories":"Prism","content":"使用IServiceLocator的注意事项\rIServiceLocator并不是通用容器。容器具有不同的使用语义，这通常决定了为什么选择容器。考虑到这一点，Stock Trader RI直接使用依赖注入容器而不是使用IServiceLocator。这是您的应用程序开发的推荐方法。 在以下情况下，您可能适合使用IServiceLocator： 您是一家独立软件供应商（ISV），负责设计需要支持多个容器的第三方服务。 您正在设计一个服务，以便在使用多个容器的组织中使用。 ","date":"2019-06-28","objectID":"/2019/06/prism7-unitycontainer/:0:9","tags":["Prism","UnityContainer"],"title":"Prism UnityContainer","uri":"/2019/06/prism7-unitycontainer/"},{"categories":"Prism","content":"使用Prism\r注意：该版本为Prism6,最新版已有较大改动。 使用Prism Library开发复合应用程序时所需的常见活动。 此示例，描述了创建由定义单个视图的单个模块组成的基本Prism应用程序所需的步骤。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:1:0","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"定义Shell\r应用程序shell提供应用程序的基本布局。此布局使用模块可用于放置视图的区域定义。Views和shells可以使用区域来定义可添加内容的可发现区域，如下图所示。Shells通常设置整个应用程序的外观，并包含整个应用程序中使用的样式。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:1:1","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"创建Bootstrapper\r引导程序是连接应用程序与Prism Library服务和Unity或MEF容器的粘合剂。每个应用程序都会创建一个特定于应用程序的引导程序，它通常从UnityBootstrapper或MefBootstrapper继承，如下图所示。您需要确定要用于填充模块目录的方法。最低限度，每个应用程序将提供模块目录和shell。 默认情况下，引导程序使用.NET Framework Trace类记录事件。大多数应用程序都希望提供自己的日志记录服务，例如Enterprise Library日志记录。应用程序可以在其引导程序中提供其日志记录服务。 默认情况下，UnityBootstrapper和MefBootstrapper启用Prism Library服务。可以在特定于应用程序的引导程序中禁用或替换它们。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:1:2","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"创建Module\r该模块包含特定于应用程序功能的视图和服务。通常，这些包含在单独的程序集中，由不同的团队开发。模块由实现IModule接口的类表示。这些模块在初始化期间注册其视图和服务，并可能向shell添加一个或多个视图。根据您的模块发现方法，您可能需要将属性应用于模块类或定义模块之间的依赖关系。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:1:3","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"将Module View添加到Shell\r模块利用shell的区域来放置内容。在初始化期间，模块使用RegionManager定位shell中的区域，并向这些区域添加一个或多个视图，或者注册要在这些区域内创建的一个或多个视图类型。该RegionManager是负责跟踪区域的整个应用程序，是从引导程序初始化的核心服务。 文档中的其余主题提供了有关Prism关键概念的详细信息。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:1:4","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"使用Prism库为WPF初始化应用程序\r本主题介绍了为WPF应用程序启动和运行Prism所需要做的事情。Prism应用程序需要在应用程序启动过程中进行注册和配置 - 这称为Bootstrapper应用程序。Prism Bootstrapper过程包括创建和配置模块目录，创建依赖注入容器（如Unity），为UI组合配置默认区域适配器，创建和初始化shell视图以及初始化模块。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:2:0","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"Bootstrapper\r引导程序是一个类，负责初始化使用Prism库构建的应用程序。通过使用引导程序，您可以更好地控制Prism库组件如何连接到您的应用程序。 Prism库包含一个默认的抽象Bootstrapper基类，可以专门用于任何容器。Bootstrapper类中的许多方法都是虚方法。您可以在自己的自定义引导程序实现中适当地覆盖这些方法。 Prism库提供了一些派生自Bootstrapper的附加基类，这些基类具有适用于大多数应用程序的默认实现。应用程序引导程序实现的唯一阶段是创建和初始化shell。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:2:1","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"Dependency Injection\r使用Prism Library构建的应用程序依赖于容器提供的依赖注入。该库提供了与Unity应用程序块（Unity）或托管扩展性框架（MEF）一起使用的程序集，它允许您使用其他依赖项注入容器。引导过程的一部分是配置此容器并使用容器注册类型。 Prism库包括UnityBootstrapper和MefBootstrapper类，它们实现了在应用程序中使用Unity或MEF作为依赖注入容器所需的大部分功能。除了上图中显示的阶段之外，每个引导程序还添加了一些特定于其容器的步骤。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:2:2","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"Creating the Shell\r在传统的Windows Presentation Foundation（WPF）应用程序中，启动主窗口的App.xaml文件中指定了启动统一资源标识符（URI）。 在使用Prism Library创建的应用程序中，引导程序负责创建shell或主窗口。这是因为shell依赖于需要在显示shell之前注册的服务（例如Region Manager）。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:2:3","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"关键决定\r在您决定在应用程序中使用Prism库之后，还需要做出一些额外的决定： 您需要决定是否使用MEF，Unity或其他容器作为依赖注入容器。这将确定您应该使用哪个提供的引导程序类，以及是否需要为另一个容器创建引导程序。 您应该考虑应用程序中所需的特定于应用程序的服务。这些将需要在容器中注册。 确定内置日志记录服务是否足以满足您的需求，或者是否需要创建其他日志记录服务。 确定应用程序如何发现模块：通过显式代码声明，通过目录扫描，配置或XAML发现的模块上的代码属性。 本主题的其余部分提供了更多详细信息。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:2:4","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"Core Scenarios\r创建启动序列是构建Prism应用程序的重要部分。本节介绍如何创建引导程序并对其进行自定义以创建shell，配置依赖项注入容器，注册应用程序级服务以及如何加载和初始化模块。 ","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:2:5","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"创建Bootstrapper\r如果您选择使用Unity或MEF作为依赖注入容器，则可以轻松地为您的应用程序创建一个简单的引导程序。您需要创建一个派生自MefBootstrapper或UnityBootstrapper的新类。然后，实现CreateShell方法。（可选）您可以覆盖InitializeShell方法以进行特定于shell的初始化。 实现CreateShell方法\r该CreateShell方法允许开发者指定一个棱镜应用顶层窗口。shell通常是MainWindow或MainPage。通过返回应用程序的shell类的实例来实现此方法。在Prism应用程序中，您可以创建shell对象，或者根据应用程序的要求从容器中解析它。 以下代码示例中显示了使用ServiceLocator解析shell对象的示例。 protected override DependencyObject CreateShell() { return ServiceLocator.Current.GetInstance\u003cShell\u003e(); } 注意：您经常会看到ServiceLocator用于解析类型的实例而不是特定的依赖注入容器。该服务定位是通过调用容器实现的，所以它使容器无关代码一个不错的选择。您也可以直接引用和使用容器而不是ServiceLocator。 实现InitializeShell方法\r创建shell后，可能需要运行初始化步骤以确保准备好显示shell。对于WPF应用程序，您将创建shell应用程序对象并将其设置为应用程序的主窗口，如此处所示（来自WPF的Modularity QuickStarts）。 protected override void InitializeShell() { Application.Current.MainWindow = Shell; Application.Current.MainWindow.Show(); } InitializeShell的基本实现什么都不做。不调用基类实现是安全的。 创建和配置模块目录\rCreating and Configuring the Module Catalog 如果要构建模块应用程序，则需要创建和配置模块目录。Prism使用具体的IModuleCatalog实例来跟踪应用程序可用的模块，可能需要下载的模块以及模块所在的位置。 该引导程序提供了一个受保护的ModuleCatalog属性来引用目录以及一个基实现虚拟的CreateModuleCatalog方法。基础实现返回一个新的ModuleCatalog ; 但是，可以重写此方法以提供不同的IModuleCatalog实例，如下面的代码来自模块化中的QuickStartBootstrapper和MEF for WPF QuickStart。 protected override IModuleCatalog CreateModuleCatalog() { // When using MEF, the existing Prism ModuleCatalog is still // the place to configure modules via configuration files. return new ConfigurationModuleCatalog() } 在UnityBootstrapper和MefBootstrapper类中，Run方法调用CreateModuleCatalog方法，然后使用返回的值设置类的ModuleCatalog属性。如果重写此方法，则无需调用基类的实现，因为您将替换提供的功能。有关模块化的更多信息，请参阅“模块化应用程序开发”。 创建和配置容器\rCreating and Configuring the Container 容器在使用Prism Library创建的应用程序中起着关键作用。Prism Library和构建在它上面的应用程序都依赖于一个容器来注入所需的依赖项和服务。在容器配置阶段，注册了几个核心服务。除了这些核心服务之外，您还可以使用特定于应用程序的服务，这些服务提供与组合相关的其他功能。 核心服务\r下表列出了Prism库中的核心非应用程序特定服务。 服务界面 描述 IModuleManager 定义将检索和初始化应用程序模块的服务的接口。 IModuleCatalog 包含有关应用程序中模块的元数据。Prism Library提供了几种不同的目录。 IModuleInitializer 初始化模块。 IRegionManager 注册和检索区域，这些区域是布局的可视容器。 IEventAggregator 在发布者和订阅者之间松散耦合的事件集合。 ILoggerFacade 日志记录机制的包装器，因此您可以选择自己的日志记录机制。Stock Trader参考实施（Stock Trader RI）通过EnterpriseLibraryLoggerAdapter类使用Enterprise Library Logging Application Block 作为如何使用您自己的记录器的示例。使用CreateLogger方法返回的值，通过引导程序的Run方法向容器注册日志记录服务。向容器注册另一个记录器将不起作用; 而是覆盖引导程序上的CreateLogger方法。 IServiceLocator 允许Prism库访问容器。如果要自定义或扩展库，这可能很有用。 Prism，UnityBootstrapper和MefBootstrapper中有两个Bootstrapper派生类。创建和配置不同的容器涉及以不同方式实现的类似概念。 在UnityBootstrapper中创建和配置容器\rCreating and Configuring the Container in the UnityBootstrapper 该UnityBootstrapper类的CreateContainer方法简单地创建并返回的新实例UnityContainer。在大多数情况下，您无需更改此功能; 但是，该方法是虚拟的，从而允许这种灵活性。 创建容器后，可能需要为您的应用程序配置容器。UnityBootstrapper中的ConfigureContainer实现默认注册了许多核心Prism服务，如下所示。 注意：此示例是模块在其Initialize方法中注册模块级服务的情况。 // UnityBootstrapper.cs protected virtual void ConfigureContainer() { ... if (useDefaultConfiguration) { RegisterTypeIfMissing(typeof(IServiceLocator), typeof(UnityServiceLocatorAdapter), true); RegisterTypeIfMissing(typeof(IModuleInitializer), typeof(ModuleInitializer), true); RegisterTypeIfMissing(typeof(IModuleManager), typeof(ModuleManager), true); RegisterTypeIfMissing(typeof(RegionAdapterMappings), typeof(RegionAdapterMappings), true) RegisterTypeIfMissing(typeof(IRegionManager), typeof(RegionManager), true); RegisterTypeIfMissing(typeof(IEventAggregator), typeof(EventAggregator), true); RegisterTypeIfMissing(typeof(IRegionViewRegistry), typeof(RegionViewRegistry), true); RegisterTypeIfMissing(typeof(IRegionBehaviorFactory), typeof(RegionBehaviorFactory), true); RegisterTypeIfMissing(typeof(IRegionNavigationJournalEntry), typeof(RegionNavigationJournalEntry), false); RegisterTypeIfMissing(typeof(IRegionNavigationJournal), typeof(RegionNavigationJournal), false); RegisterTypeIfMissing(typeof(IRegionNavigationService), typeof(RegionNavigationService), false); RegisterTypeIfMissing(typeof(IRegionNavigationContentLoader), typeof(UnityRegionNavigationContentLoader), true); } } 引导程序的RegisterTypeIfMissing方法确定服务是否已经注册 - 它不会注册两次。这允许您通过配置覆盖默认注册。您也可以默认关闭注册任何服务; 为此，请使用重载的Bootstrapper.R","date":"2019-06-27","objectID":"/2019/06/prism6-usingprism/:2:6","tags":["Prism","使用Prism"],"title":"Prism 使用Prism","uri":"/2019/06/prism6-usingprism/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 ViewModelLocator用于绑定视图的DataContext，以使用标准命名约定的一个ViewModel的实例。 Prism ViewModelLocator有一个AutoWireViewModel附加属性，当设置为true调用类中的AutoWireViewModelChanged方法ViewModelLocationProvider来解析视图的ViewModel时，然后将视图的数据上下文设置为该ViewModel的实例。 将AutoWireViewModel附加属性添加到每个视图： \u003cWindow x:Class=\"Demo.Views.MainWindow\" ... xmlns:prism=\"http://prismlibrary.com/\" prism:ViewModelLocator.AutoWireViewModel=\"True\"\u003e 要查找ViewModel，ViewModelLocationProvider首先尝试从ViewModelLocationProvider.Register方法注册的任何映射中解析ViewModel （请参阅自定义ViewModel注册）。如果使用此方法无法解析ViewModel，则会ViewModelLocationProvider回退到基于约定的方法来解析正确的ViewModel类型。 该惯例假定： ViewModel与视图类型位于同一个程序集中 ViewModel位于.ViewModels子命名空间中 视图位于.Views子命名空间中 ViewModel名称与视图名称对应，以“ViewModel”结尾。 注意 本ViewModelLocationProvider可以在发现Prism.Mvvm命名空间中的Prism.Core NuGet包。本ViewModelLocator可以在发现Prism.Mvvm命名空间中的Prism.WPF NuGet包。 注意 ViewModelLocator是必需的，并且在使用Xamarin.Forms进行开发时会自动应用于每个View，因为它负责向INavigationServiceViewModel 提供正确的实例。在开发Xamarin.Forms应用程序时，ViewModelLocator只能选择退出。 ","date":"2019-06-26","objectID":"/2019/06/prism5-viewmodellocator/:0:0","tags":["Prism","ViewModelLocator"],"title":"Prism ViewModel Locator","uri":"/2019/06/prism5-viewmodellocator/"},{"categories":"Prism","content":"更改命名约定\r如果您的应用程序不遵循ViewModelLocator默认命名约定，则可以更改约定以满足应用程序的要求。本ViewModelLocationProvider类提供了一个称为静态方法SetDefaultViewTypeToViewModelTypeResolver，可以用来提供自己的约定关联视图查看模型。 要更改ViewModelLocator命名约定，请覆盖类中的ConfigureViewModelLocator方法App.xaml.cs。然后在ViewModelLocationProvider.SetDefaultViewTypeToViewModelTypeResolver方法中提供自定义命名约定逻辑。 protected override void ConfigureViewModelLocator() { base.ConfigureViewModelLocator(); ViewModelLocationProvider.SetDefaultViewTypeToViewModelTypeResolver((viewType) =\u003e { var viewName = viewType.FullName.Replace(\".ViewModels.\", \".CustomNamespace.\");//看视频就明白了 var viewAssemblyName = viewType.GetTypeInfo().Assembly.FullName; var viewModelName = $\"{viewName}ViewModel, {viewAssemblyName}\"; return Type.GetType(viewModelName); }); } ","date":"2019-06-26","objectID":"/2019/06/prism5-viewmodellocator/:0:1","tags":["Prism","ViewModelLocator"],"title":"Prism ViewModel Locator","uri":"/2019/06/prism5-viewmodellocator/"},{"categories":"Prism","content":"自定义ViewModel注册\r可能存在您的应用程序遵循ViewModelLocator默认命名约定的情况，但您有许多不符合约定的ViewModel。您可以ViewModelLocator使用该ViewModelLocationProvider.Register方法直接将ViewModel的映射注册到特定视图，而不是尝试自定义命名约定逻辑以有条件地满足所有命名要求。 以下示例显示了在名为MainWindow的ViewModel和ViewModel 之间创建映射的各种方法CustomViewModel。 类型/类型 ViewModelLocationProvider.Register(typeof(MainWindow).ToString(), typeof(CustomViewModel)); 类型/工厂 ViewModelLocationProvider.Register(typeof(MainWindow).ToString(), () =\u003e Container.Resolve\u003cCustomViewModel\u003e()); 通用工厂 ViewModelLocationProvider.Register\u003cMainWindow\u003e(() =\u003e Container.Resolve\u003cCustomViewModel\u003e()); 通用类型 ViewModelLocationProvider.Register\u003cMainWindow, CustomViewModel\u003e(); 注意\r直接注册ViewModel ViewModelLocator比依赖默认命名约定更快。这是因为命名约定需要使用反射，而自定义映射直接提供类型ViewModelLocator。 重要\r该viewTypeName参数必须是视图的Type（Type.ToString()）的完全限定名称。否则映射将失败。 ","date":"2019-06-26","objectID":"/2019/06/prism5-viewmodellocator/:0:2","tags":["Prism","ViewModelLocator"],"title":"Prism ViewModel Locator","uri":"/2019/06/prism5-viewmodellocator/"},{"categories":"Prism","content":"控制ViewModel的解析方式\r默认情况下，ViewModelLocator将使用您选择的DI容器来创建Prism应用程序以解析ViewModels。但是，如果您需要自定义ViewModel的解析方式或完全更改解析器，则可以使用该ViewModelLocationProvider.SetDefaultViewModelFactory方法实现此目的。 此示例显示如何更改用于解析ViewModel实例的容器。 protected override void ConfigureViewModelLocator() { base.ConfigureViewModelLocator(); ViewModelLocationProvider.SetDefaultViewModelFactory(viewModelType) =\u003e { return MyAwesomeNewContainer.Resolve(viewModelType); }); } 这是一个示例，说明如何检查为其创建ViewModel的视图类型，以及执行逻辑来控制ViewModel的创建方式。 protected override void ConfigureViewModelLocator() { base.ConfigureViewModelLocator(); ViewModelLocationProvider.SetDefaultViewModelFactory((view, viewModelType) =\u003e { switch (view) { case Window window: //your logic break; case UserControl userControl: //your logic break; } return MyAwesomeNewContainer.Resolve(someNewType); }); } ","date":"2019-06-26","objectID":"/2019/06/prism5-viewmodellocator/:0:3","tags":["Prism","ViewModelLocator"],"title":"Prism ViewModel Locator","uri":"/2019/06/prism5-viewmodellocator/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 Prism库提供了一种事件机制，可以在应用程序中松散耦合的组件之间进行通信。该机制基于事件聚合器服务，允许发布者和订阅者通过事件进行通信，但仍然没有彼此直接引用。 在EventAggregator提供多种发布/订阅功能。这意味着可以有多个发布者引发相同的事件，并且可以有多个订阅者收听同一事件。考虑使用EventAggregator跨模块发布事件以及在业务逻辑代码（如控制器和演示者）之间发送消息时。 使用Prism Library创建的事件是键入的事件。这意味着您可以在运行应用程序之前利用编译时类型检查来检测错误。在Prism Library中，EventAggregator允许订阅者或发布者定位特定的EventBase。事件聚合器还允许多个发布者和多个订阅者，如下图所示。 ","date":"2019-06-25","objectID":"/2019/06/prism4-eventaggregator/:0:0","tags":["Prism","EventAggregator"],"title":"Prism Event Aggregator","uri":"/2019/06/prism4-eventaggregator/"},{"categories":"Prism","content":"IEventAggregator\rEventAggregator类被提供作为在容器中的服务，并且可以通过检索IEventAggregator界面。事件聚合器负责定位或构建事件以及保留系统中事件的集合。 public interface IEventAggregator { TEventType GetEvent\u003cTEventType\u003e() where TEventType : EventBase; } 如果EventAggregator事件尚未构造，则在第一次访问时构造事件。这使发布者或订阅者无需确定事件是否可用。 ","date":"2019-06-25","objectID":"/2019/06/prism4-eventaggregator/:0:1","tags":["Prism","EventAggregator"],"title":"Prism Event Aggregator","uri":"/2019/06/prism4-eventaggregator/"},{"categories":"Prism","content":"PubSubEvent\r连接发布者和订阅者的真正工作是由PubSubEvent班级完成的。EventBase是Prism Library中包含的类的唯一实现。此类维护订户列表并处理订阅者的事件调度。 PubSubEvent类是一个通用类，需要将其定义为一般类型的有效载荷类型。这有助于在编译时强制发布者和订阅者提供成功事件连接的正确方法。以下代码显示了PubSubEvent类的部分定义。 ","date":"2019-06-25","objectID":"/2019/06/prism4-eventaggregator/:0:2","tags":["Prism","EventAggregator"],"title":"Prism Event Aggregator","uri":"/2019/06/prism4-eventaggregator/"},{"categories":"Prism","content":"创建一个事件\rPubSubEvent\u003cTPayload\u003e意图是为应用程序或模块的特定事件的基类。TPayLoad是事件的有效负载的类型。有效负载是在事件发布时将传递给订阅者的参数。 例如，以下代码显示了TickerSymbolSelectedEvent。有效负载是包含公司符号的字符串。请注意此类的实现是如何为空。 public class TickerSymbolSelectedEvent : PubSubEvent\u003cstring\u003e{} 注意\r在复合应用程序中，事件经常在多个模块之间共享，因此它们在公共位置定义。通常的做法是在共享程序集中定义这些事件，例如“核心”或“基础结构”项目。 ","date":"2019-06-25","objectID":"/2019/06/prism4-eventaggregator/:0:3","tags":["Prism","EventAggregator"],"title":"Prism Event Aggregator","uri":"/2019/06/prism4-eventaggregator/"},{"categories":"Prism","content":"发布事件\r发布者通过从EventAggregator调用Publish方法中检索事件来引发事件。要访问EventAggregator，可以通过向IEventAggregator类构造函数添加类型参数来使用依赖项注入。 public class MainPageViewModel { IEventAggregator _eventAggregator; public MainPageViewModel(IEventAggregator ea) { _eventAggregator = ea; } } 以下代码演示了如何发布TickerSymbolSelectedEvent。 _eventAggregator.GetEvent\u003cTickerSymbolSelectedEvent\u003e().Publish(\"STOCK0\"); ","date":"2019-06-25","objectID":"/2019/06/prism4-eventaggregator/:0:4","tags":["Prism","EventAggregator"],"title":"Prism Event Aggregator","uri":"/2019/06/prism4-eventaggregator/"},{"categories":"Prism","content":"订阅事件\r订阅者可以使用类中Subscribe可用的方法重载之一来参与事件PubSubEvent。 public class MainPageViewModel { public MainPageViewModel(IEventAggregator ea) { ea.GetEvent\u003cTickerSymbolSelectedEvent\u003e().Subscribe(ShowNews); } void ShowNews(string companySymbol) { //implement logic } } 有几种订阅方式PubSubEvents。使用以下标准来帮助确定最适合您需求的选项： 如果您需要能够在收到事件时更新UI元素，请订阅以在UI线程上接收事件。 如果您需要过滤事件，请在订阅时提供过滤器委托。 如果您对事件有性能问题，请考虑在订阅时使用强引用的委托，然后手动取消订阅PubSubEvent。 如果以上都不适用，请使用默认订阅。 以下部分描述了这些选项。 在UI线程订阅\r订阅者通常需要更新UI元素以响应事件。在WPF中，只有UI线程可以更新UI元素。 默认情况下，订阅者在发布者的线程上接收事件。如果发布者从UI线程发送事件，则订阅者可以更新UI。但是，如果发布者的线程是后台线程，则订阅者可能无法直接更新UI元素。在这种情况下，订户需要使用Dispatcher类在UI线程上安排更新。 该PubSubEvent具有棱镜图书馆可以通过允许用户自动接收UI线程上的事件协助。订阅者在订阅期间指示此信息，如以下代码示例所示。 public class MainPageViewModel { public MainPageViewModel(IEventAggregator ea) { ea.GetEvent\u003cTickerSymbolSelectedEvent\u003e().Subscribe(ShowNews, ThreadOption.UIThread); } void ShowNews(string companySymbol) { //implement logic } } 以下选项适用于ThreadOption： PublisherThread：使用此设置在发布商的主题上接收活动。这是默认设置。 BackgroundThread：使用此设置在.NET Framework线程池线程上异步接收事件。 UIThread：使用此设置在UI线程上接收事件。 注意 为了PubSubEvent在UI线程上发布给订阅者，EventAggregator最初必须在UI线程上构建。 订阅过滤\r订阅者可能不需要处理已发布事件的每个实例。在这些情况下，订户可以使用过滤器参数。filter参数是类型的，System.Predicate\u003cTPayLoad\u003e并且是在发布事件时执行的委托，以确定已发布事件的有效负载是否与调用订阅者回调所需的一组条件匹配。如果有效负载不满足指定的条件，则不执行订户回调。 通常，此过滤器作为lambda表达式提供，如以下代码示例所示。 public class MainPageViewModel { public MainPageViewModel(IEventAggregator ea) { TickerSymbolSelectedEvent tickerEvent = ea.GetEvent\u003cTickerSymbolSelectedEvent\u003e(); tickerEvent.Subscribe(ShowNews, ThreadOption.UIThread, false, companySymbol =\u003e companySymbol == \"STOCK0\"); } void ShowNews(string companySymbol) { //implement logic } } 注意\r该Subscribe方法返回一个类型的订阅令牌Prism.Events.SubscriptionToken，可用于稍后删除对该事件的订阅。当您使用匿名委托或lambda表达式作为回调委托时，或者使用不同的过滤器订阅相同的事件处理程序时，此标记特别有用。 注意\r建议不要在回调委托中修改有效负载对象，因为多个线程可能同时访问有效负载对象。您可以使有效负载不可变，以避免并发错误。 使用强引用订阅\r如果您在短时间内提出多个事件并注意到它们的性能问题，则可能需要使用强委托引用进行订阅。如果您这样做，则需要在处置订户时手动取消订阅该事件。 默认情况下，PubSubEvent维护对订阅者处理程序的弱委托引用并对订阅进行过滤。这意味着PubSubEvent保留的引用不会阻止订户的垃圾收集。使用弱委托引用可以使订户免于取消订阅并允许正确的垃圾收集。 但是，维护此弱委托引用比相应的强引用要慢。对于大多数应用程序，此性能不会很明显，但如果您的应用程序在短时间内发布大量事件，则可能需要对PubSubEvent使用强引用。如果您确实使用了强委托引用，则订阅者应该取消订阅，以便在不再使用订阅对象时启用正确的垃圾回收。 要使用强引用进行订阅，请使用方法keepSubscriberReferenceAlive上的参数Subscribe，如以下代码示例所示。 public class MainPageViewModel { public MainPageViewModel(IEventAggregator ea) { bool keepSubscriberReferenceAlive = true; TickerSymbolSelectedEvent tickerEvent = ea.GetEvent\u003cTickerSymbolSelectedEvent\u003e(); tickerEvent.Subscribe(ShowNews, ThreadOption.UIThread, keepSubscriberReferenceAlive, companySymbol =\u003e companySymbol == \"STOCK0\"); } void ShowNews(string companySymbol) { //implement logic } } keepSubscriberReferenceAlive参数的类型的bool： 设置为时true，事件实例保留对订户实例的强引用，从而不允许它收集垃圾。有关如何取消订阅的信息，请参阅本主题后面的“取消订阅事件”一节。 当设置为false（省略此参数时的默认值）时，事件维护对订户实例的弱引用，从而允许垃圾收集器在没有其他引用时配置订阅者实例。收集订户实例后，将自动取消订阅该事件。 ","date":"2019-06-25","objectID":"/2019/06/prism4-eventaggregator/:0:5","tags":["Prism","EventAggregator"],"title":"Prism Event Aggregator","uri":"/2019/06/prism4-eventaggregator/"},{"categories":"Prism","content":"取消事件订阅\r如果您的订户不再想要接收活动，您可以使用订阅者的处理程序取消订阅，也可以使用订阅令牌取消订阅。 以下代码示例演示如何直接取消订阅处理程序。 public class MainPageViewModel { TickerSymbolSelectedEvent _event; public MainPageViewModel(IEventAggregator ea) { _event = ea.GetEvent\u003cTickerSymbolSelectedEvent\u003e(); _event.Subscribe(ShowNews); } void Unsubscribe() { _event.Unsubscribe(ShowNews); } void ShowNews(string companySymbol) { //implement logic } } 以下代码示例演示如何取消订阅订阅令牌。令牌作为方法的返回值提供Subscribe。 public class MainPageViewModel { TickerSymbolSelectedEvent _event; SubscriptionToken _token; public MainPageViewModel(IEventAggregator ea) { _event = ea.GetEvent\u003cTickerSymbolSelectedEvent\u003e(); _token = _event.Subscribe(ShowNews); } void Unsubscribe() { _event.Unsubscribe(_token); } void ShowNews(string companySymbol) { //implement logic } } ","date":"2019-06-25","objectID":"/2019/06/prism4-eventaggregator/:0:6","tags":["Prism","EventAggregator"],"title":"Prism Event Aggregator","uri":"/2019/06/prism4-eventaggregator/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 在许多情况下，视图模型定义的命令将绑定到关联视图中的控件，以便用户可以直接从视图中调用该命令。但是，在某些情况下，您可能希望能够从应用程序UI的父视图中的控件调用一个或多个视图模型上的命令。 例如，如果您的应用程序允许用户同时编辑多个项目，您可能希望允许用户使用应用程序工具栏或功能区中的按钮所代表的单个命令来保存所有项目。在这种情况下，Save All命令将调用每个项目的视图模型实例实现的每个Save命令，如下图所示。 Prism通过CompositeCommand课程支持这种情况。 CompositeCommand类表示从多个子指令构成的指令。调用复合命令时，将依次调用其每个子命令。在需要在UI中将一组命令表示为单个命令或者要调用多个命令来实现逻辑命令的情况下，它非常有用。 本CompositeCommand类维护子类命令列表 （DelegateCommand实例）。CompositeCommand类的Execute方法依次调用每个子类的Execute命令方法。CanExecute方法类似地调用每个子命令的CanExecute方法，但是如果无法执行任何子命令，则该CanExecute方法将返回false。换句话说，默认情况下，CompositeCommand只有在可以执行所有子命令时才能执行。 ","date":"2019-06-24","objectID":"/2019/06/prism3-compositecommands/:0:0","tags":["Prism","compositecommands"],"title":"Prism Composite Commands","uri":"/2019/06/prism3-compositecommands/"},{"categories":"Prism","content":"创建Composite Commands\r要创建复合命令，请实例化一个CompositeCommand实例，然后将其公开为ICommand或ComponsiteCommand属性。 public class ApplicationCommands { private CompositeCommand _saveCommand = new CompositeCommand(); public CompositeCommand SaveCommand { get { return _saveCommand; } } } ","date":"2019-06-24","objectID":"/2019/06/prism3-compositecommands/:0:1","tags":["Prism","compositecommands"],"title":"Prism Composite Commands","uri":"/2019/06/prism3-compositecommands/"},{"categories":"Prism","content":"使得Composite Commands全局可用\r通常，CompositeCommands在整个应用程序中共享，需要全局可用。当您CompositeCommand在整个应用程序中使用同一个CompositeCommand实例注册子命令时，这一点很重要。这需要在应用程序中将CompositeCommand作为单例取消。这可以通过使用依赖注入（DI）或将CompositeCommand定义为静态类来完成。 使用依赖注入\r定义CompositeCommands的第一步是创建一个接口。 public interface IApplicationCommands { CompositeCommand SaveCommand { get; } } 接下来，创建一个实现该接口的类。 public class ApplicationCommands : IApplicationCommands { private CompositeCommand _saveCommand = new CompositeCommand(); public CompositeCommand SaveCommand { get { return _saveCommand; } } } 定义ApplicationCommands类后，必须将其注册为容器的单例。 public partial class App : PrismApplication { protected override void RegisterTypes(IContainerRegistry containerRegistry) { containerRegistry.RegisterSingleton\u003cIApplicationCommands, ApplicationCommands\u003e(); } } 接下来，请求IApplicationCommandsViewModel构造函数中的接口。一旦有了ApplicationCommands该类的实例，现在可以使用适当的CompositeCommand注册DelegateCommands。 public DelegateCommand UpdateCommand { get; private set; } public TabViewModel(IApplicationCommands applicationCommands) { UpdateCommand = new DelegateCommand(Update); applicationCommands.SaveCommand.RegisterCommand(UpdateCommand); } 使用静态类\r创建一个代表CompositeCommands的静态类 public static class ApplicationCommands { public static CompositeCommand SaveCommand = new CompositeCommand(); } 在ViewModel中，将子命令与静态ApplicationCommands类关联。 public DelegateCommand UpdateCommand { get; private set; } public TabViewModel() { UpdateCommand = new DelegateCommand(Update); ApplicationCommands.SaveCommand.RegisterCommand(UpdateCommand); } 注意 为了提高代码的可维护性和可测试性，建议您使用可靠性注入方法。 ","date":"2019-06-24","objectID":"/2019/06/prism3-compositecommands/:0:2","tags":["Prism","compositecommands"],"title":"Prism Composite Commands","uri":"/2019/06/prism3-compositecommands/"},{"categories":"Prism","content":"绑定全局可用命令\r一旦创建了CompositeCommands，就必须将它们绑定到UI元素以调用命令。 使用依赖注入 (Dependency Injection)\r使用DI时，必须将IApplicationCommands暴露给View。在视图的ViewModel中，请IApplicationCommands在构造函数中请求并IApplicationCommands为该实例设置type属性。 public class MainWindowViewModel : BindableBase { private IApplicationCommands _applicationCommands; public IApplicationCommands ApplicationCommands { get { return _applicationCommands; } set { SetProperty(ref _applicationCommands, value); } } public MainWindowViewModel(IApplicationCommands applicationCommands) { ApplicationCommands = applicationCommands; } } 在视图中，将按钮绑定到ApplicationCommands.SaveCommand属性。这SaveCommand是在ApplicationCommands类上定义的属性。 \u003cButton Content=\"Save\" Command=\"{Binding ApplicationCommands.SaveCommand}\"/\u003e 使用静态类\r如果您使用的是静态类方法，则以下代码示例演示如何将按钮绑定到WPF中的静态ApplicationCommands类。 \u003cButton Content=\"Save\" Command=\"{x:Static local:ApplicationCommands.SaveCommand}\" /\u003e ","date":"2019-06-24","objectID":"/2019/06/prism3-compositecommands/:0:3","tags":["Prism","compositecommands"],"title":"Prism Composite Commands","uri":"/2019/06/prism3-compositecommands/"},{"categories":"Prism","content":"取消注册命令\r如前面的示例所示，使用该CompositeCommand.RegisterCommand方法注册子命令。但是，当您不再希望响应CompositeCommand或者您要销毁View / ViewModel以进行垃圾回收时，您应该使用该CompositeCommand.UnregisterCommand方法取消注册子命令。 public void Destroy() { _applicationCommands.UnregisterCommand(UpdateCommand); } 重要\r您必须从CompositeCommand不再需要View / ViewModel（为GC准备好）时取消注册您的命令。否则你会引入内存泄漏。 ","date":"2019-06-24","objectID":"/2019/06/prism3-compositecommands/:0:4","tags":["Prism","compositecommands"],"title":"Prism Composite Commands","uri":"/2019/06/prism3-compositecommands/"},{"categories":"Prism","content":"在活动视图上执行命令\r父视图级别的复合命令通常用于协调如何调用子视图级别的命令。在某些情况下，您将需要执行所有显示视图的命令，如前面所述的Save All命令示例中所示。在其他情况下，您将希望仅在活动视图上执行该命令。在这种情况下，复合命令将仅对被视为活动的视图执行子命令; 它不会在非活动的视图上执行子命令。例如，您可能希望在应用程序的工具栏上实现缩放命令，该命令仅导致当前活动项目被缩放，如下图所示。 为了支持这种情况，Prism提供了IActiveAware界面。该IActiveAware接口定义了一个IsActive返回属性true时实施者是活动的，并且IsActiveChanged当活动状态改变时引发事件。 您可以IActiveAware在视图或ViewModel上实现该接口。它主要用于跟踪视图的活动状态。视图是否处于活动状态由特定控件内的视图决定。例如，对于Tab控件，有一个适配器将当前选定选项卡中的视图设置为活动状态。 本DelegateCommand类还实现了IActiveAware接口。CompositeCommand可被配置成评估子类DelegateCommands的活动状态（除了CanExecute通过指定状态）true为monitorCommandActivity在构造参数。当此参数设置为时true，CompositeCommand类在确定方法的返回值以及在CanExecute方法中执行子命令时将考虑每个子DelegateCommand的活动状态Execute。 public class ApplicationCommands : IApplicationCommands { private CompositeCommand _saveCommand = new CompositeCommand(true); public CompositeCommand SaveCommand { get { return _saveCommand; } } } 当monitorCommandActivity参数为时true，CompositeCommand该类表现出以下行为： CanExecute：true仅在可以执行所有活动命令时返回。根本不会考虑不活动的子命令。 Execute：执行所有活动命令。根本不会考虑不活动的子命令。 通过IActiveAware在ViewModel上实现界面，当您的视图变为活动或非活动时，您将收到通知。当视图的活动状态更改时，您可以更新子命令的活动状态。然后，当用户调用复合命令时，将调用活动子视图上的命令。 public class TabViewModel : BindableBase, IActiveAware { private bool _isActive; public bool IsActive { get { return _isActive; } set { _isActive = value; OnIsActiveChanged(); } } public event EventHandler IsActiveChanged; public DelegateCommand UpdateCommand { get; private set; } public TabViewModel(IApplicationCommands applicationCommands) { UpdateCommand = new DelegateCommand(Update); applicationCommands.SaveCommand.RegisterCommand(UpdateCommand); } private void Update() { //implement logic } private void OnIsActiveChanged() { UpdateCommand.IsActive = IsActive; //set the command as active IsActiveChanged?.Invoke(this, new EventArgs()); //invoke the event for al listeners } } ","date":"2019-06-24","objectID":"/2019/06/prism3-compositecommands/:0:5","tags":["Prism","compositecommands"],"title":"Prism Composite Commands","uri":"/2019/06/prism3-compositecommands/"},{"categories":"Prism","content":"注意：该版本为Prism6,最新版已有较大改动。 除了提供对要在视图中显示或编辑的数据的访问之外，ViewModel还可能定义可由用户执行的一个或多个动作或操作。用户可以通过UI执行的动作或操作通常被定义为命令。命令提供了一种方便的方法来表示可以轻松绑定到UI中的控件的操作或操作。它们封装了实现操作或操作的实际代码，并有助于使其与视图中的实际可视化表示分离。 当用户与视图交互时，用户可以以多种不同的方式直观地表示和调用命令。在大多数情况下，它们是通过鼠标单击调用的，但也可以通过快捷键按下，触摸手势或任何其他输入事件来调用它们。视图中的控件是绑定到ViewModel命令的数据，以便用户可以使用控件定义的任何输入事件或手势来调用它们。视图中的UI控件与命令之间的交互可以是双向的。在这种情况下，可以在用户与UI交互时调用该命令，并且可以在启用或禁用基础命令时自动启用或禁用UI。 ViewModel可以将命令实现为命令对象（实现ICommand接口的对象）。可以以声明方式定义视图与命令的交互，而无需在视图的代码隐藏文件中使用复杂的事件处理代码。例如，某些控件固有地支持命令并提供Command可以是绑定到ICommandViewModel提供的对象的数据的属性。在其他情况下，命令行为可用于将控件与ViewModel提供的命令方法或命令对象相关联。 实现ICommand界面很简单。Prism提供了DelegateCommand这个界面的实现，您可以在应用程序中轻松使用它。 ","date":"2019-06-23","objectID":"/2019/06/prism2-commanding/:0:0","tags":["Prism","Commanding"],"title":"Prism Commanding","uri":"/2019/06/prism2-commanding/"},{"categories":"Prism","content":"DelegateCommand\rPrism DelegateCommand类封装了两个委托，每个委托引用在ViewModel类中实现的方法。它通过调用这些委托来实现ICommand接口Execute和CanExecute方法。您可以在DelegateCommand类构造函数中指定ViewModel方法的委托。例如，以下代码示例显示如何DelegateCommand通过指定OnSubmit和CanSubmit ViewModel方法的委托来构造表示Submit命令的实例。然后，该命令通过只读属性公开给视图，该属性返回对该参数的引用DelegateCommand。 public class ArticleViewModel { public DelegateCommand SubmitCommand { get; private set; } public ArticleViewModel() { SubmitCommand = new DelegateCommand\u003cobject\u003e(Submit, CanSubmit); } void Submit(object parameter) { //implement logic } bool CanSubmit(object parameter) { return true; } } 在DelegateCommand对象上调用Execute方法时，它只是通过您在构造函数中指定的委托将调用转发到ViewModel类中的方法。同样，CanExecute调用该方法时，将调用ViewModel类中的相应方法。CanExecute构造函数中方法的委托是可选的。如果没有指定一个委托，DelegateCommand将始终返回true了CanExecute。 该DelegateCommand班是一个泛型类型。type参数指定传递给Execute和CanExecute方法的命令参数的类型。在前面的示例中，command参数是type object。非通用的版本DelegateCommand类也通过棱镜用于提供当没有所需的命令参数，并且被定义为如下： public class ArticleViewModel { public DelegateCommand SubmitCommand { get; private set; } public ArticleViewModel() { SubmitCommand = new DelegateCommand(Submit, CanSubmit); } void Submit() { //implement logic } bool CanSubmit() { return true; } } 所述DelegateCommand故意阻止使用值类型（int，双，布尔等）。因为ICommand需要一个object具有值类型T将导致当意外行为CanExecute(null)XAML初始化命令绑定期间被调用。使用default(T)被认为是被拒绝作为解决方案，因为实现者无法区分有效值和默认值。如果要将值类型用作参数，则必须使用DelegateCommand\u003cNullable\u003cint\u003e\u003e或使用简写?语法（DelegateCommand\u003cint?\u003e）使其可为空。 ","date":"2019-06-23","objectID":"/2019/06/prism2-commanding/:0:1","tags":["Prism","Commanding"],"title":"Prism Commanding","uri":"/2019/06/prism2-commanding/"},{"categories":"Prism","content":"从View调用DelegateCommands\r有许多方法可以将视图中的控件与ViewModel提供的命令对象相关联。某些WPF，Xamarin.Forms和UWP控件可以通过Command属性轻松地绑定到命令对象。 \u003cButton Command=\"{Binding SubmitCommand}\" CommandParameter=\"OrderId\"/\u003e 也可以使用CommandParameter属性选择性地定义命令参数。期望参数的类型在DelegateCommand\u003cT\u003e泛型声明中指定。当用户与该控件交互时，控件将自动调用目标命令，并且命令参数（如果提供）将作为参数传递给命令的Execute方法。在前面的示例中，按钮将SubmitCommand在单击时自动调用。此外，如果CanExecute指定了委托，则CanExecute返回时将自动禁用该按钮，如果返回false则将启用该按钮true。 ","date":"2019-06-23","objectID":"/2019/06/prism2-commanding/:0:2","tags":["Prism","Commanding"],"title":"Prism Commanding","uri":"/2019/06/prism2-commanding/"},{"categories":"Prism","content":"Raising Change Notifications\rViewModel通常需要指示命令CanExecute状态的更改，以便UI中绑定到该命令的任何控件都将更新其启用状态以反映绑定命令的可用性。在DelegateCommand提供了几种这些通知发送到用户界面。 RaiseCanExecuteChanged\rRaiseCanExecuteChanged每当需要手动更新绑定的UI元素的状态时，请使用该方法。例如，当IsEnabled属性值更改时，我们调用RaiseCanExecuteChanged属性的setter来通知UI状态更改。 private bool _isEnabled; public bool IsEnabled { get { return _isEnabled; } set { SetProperty(ref _isEnabled, value); SubmitCommand.RaiseCanExecuteChanged(); } } ObservesProperty\r如果命令应在属性值更改时发送通知，则可以使用该ObservesProperty方法。使用该ObservesProperty方法时，只要提供的属性的值发生更改，DelegateCommand将自动调用RaiseCanExecuteChanged以通知UI状态更改。 public class ArticleViewModel : BindableBase { private bool _isEnabled; public bool IsEnabled { get { return _isEnabled; } set { SetProperty(ref _isEnabled, value); } } public DelegateCommand SubmitCommand { get; private set; } public ArticleViewModel() { SubmitCommand = new DelegateCommand(Submit, CanSubmit).ObservesProperty(() =\u003e IsEnabled); } void Submit() { //implement logic } bool CanSubmit() { return IsEnabled; } } 注意 使用该ObservesProperty方法时，您可以链接注册多个属性以供观察。示例：ObservesProperty(() =\u003e IsEnabled).ObservesProperty(() =\u003e CanSave)。 ObservesCanExecute\r如果您CanExecute是简单Boolean属性的结果，则可以省去声明CanExecute委托，并使用该ObservesCanExecute方法。ObservesCanExecute当注册的属性值发生变化时，它不仅会向UI发送通知，而且还会使用与实际CanExecute委托相同的属性。 public class ArticleViewModel : BindableBase { private bool _isEnabled; public bool IsEnabled { get { return _isEnabled; } set { SetProperty(ref _isEnabled, value); } } public DelegateCommand SubmitCommand { get; private set; } public ArticleViewModel() { SubmitCommand = new DelegateCommand(Submit, CanSubmit).ObservesCanExecute(() =\u003e IsEnabled); } void Submit() { //implement logic } } 警告\r不要尝试链式注册ObservesCanExecute方法。CanExcute代表只能观察到一个属性。 ","date":"2019-06-23","objectID":"/2019/06/prism2-commanding/:0:3","tags":["Prism","Commanding"],"title":"Prism Commanding","uri":"/2019/06/prism2-commanding/"},{"categories":"Prism","content":"基于Task-Based的DelegateCommand\rasync/await调用Execute委托内部的异步方法是一个非常常见的要求。每个人的第一直觉是他们需要一个AsyncCommand，但这种假设是错误的。ICommand本质上是同步的，并且代表Execute和CanExecute代表应被视为事件。这意味着这async void是一个非常有效的语法用于命令。使用异步方法有两种方法DelegateCommand。 方法一 public class ArticleViewModel { public DelegateCommand SubmitCommand { get; private set; } public ArticleViewModel() { SubmitCommand = new DelegateCommand(Submit); } async void Submit() { await SomeAsyncMethod(); } } 方法二 public class ArticleViewModel { public DelegateCommand SubmitCommand { get; private set; } public ArticleViewModel() { SubmitCommand = new DelegateCommand(async ()=\u003e await Submit()); } Task Submit() { return SomeAsyncMethod(); } } ","date":"2019-06-23","objectID":"/2019/06/prism2-commanding/:0:4","tags":["Prism","Commanding"],"title":"Prism Commanding","uri":"/2019/06/prism2-commanding/"},{"categories":"Prism","content":"简介\r注意：该版本为Prism6,最新版已有较大改动。 Prism需要.Framework4.5，包含MVVM（Model-View-ViewModel）模式，Navigation，和MEF（Managed Extensibility Framework） ","date":"2019-06-22","objectID":"/2019/06/prism1-introduce/:1:0","tags":["Prism"],"title":"Prism 简介","uri":"/2019/06/prism1-introduce/"},{"categories":"Prism","content":"前期准备\r学习Prism需要一些WPF的概念，需要了解和熟悉 XAML(Extensible Application Markup Language)。在WPF应用程序中以声明方式定义和初始化用户界面的语言。 数据绑定(Binding)。这就是UI元素如何连接到WPF中的组件和数据。 资源(Resources)。这些是在WPF中创建和管理样式，数据模板和控件模板的方式。 命令(Commands)。这些是用户手势和输入连接到控件的方式。 用户控件(User Controls)。这些是提供自定义行为或自定义外观的组件。 依赖属性(Dependency properties)。这些是公共语言运行时（CLR）属性系统的扩展，用于启用属性设置和监视，以支持数据绑定，路由命令和事件。 行为(Behaviors)。行为是封装交互功能的对象，可以轻松应用于用户界面中的控件。 ","date":"2019-06-22","objectID":"/2019/06/prism1-introduce/:2:0","tags":["Prism"],"title":"Prism 简介","uri":"/2019/06/prism1-introduce/"},{"categories":"Prism","content":"关键概念\rPrism提供了您可能不熟悉的功能和设计模式，特别是如果您是设计模式和复合应用程序开发的新手。本节简要概述了Prism背后的主要概念，并定义了您将在整个文档和代码中使用的一些术语。 模块（Modules）。模块是可以独立开发，测试和（可选）部署的功能包。在许多情况下，模块由不同的团队开发和维护。典型的Prism应用程序由多个模块构建。模块可用于表示特定的业务相关功能（例如，配置文件管理），并封装实现该功能所需的所有视图，服务和数据模型。模块还可用于封装可在多个应用程序中重用的常见应用程序基础结构或服务（例如，日志记录和异常管理服务）。 模块目录（Module Catalog）。在复合应用程序中，必须由主机应用程序在运行时发现和加载模块。在Prism中，模块目录用于指定要加载哪些模块，何时加载以及按什么顺序加载。模块目录由ModuleManager和ModuleLoader组件使用，如果模块是远程的，则负责下载模块，将模块的程序集加载到应用程序域中，以及初始化模块。Prism允许以不同方式指定模块目录，包括以编程方式使用代码，以声明方式使用XAML或使用配置文件。如果需要，您还可以实现自定义模块目录。 壳（Shell）。shell是加载模块的宿主应用程序。shell定义了应用程序的整体布局和结构，但它通常不知道它将托管的确切模块。它通常实现常见的应用程序服务和基础结构，但大多数应用程序的功能和内容都是在模块中实现的。shell还提供顶级窗口或可视元素，然后将托管由加载的模块提供的不同UI组件。 视图（Views）。视图是UI控件，用于封装应用程序的特定功能或功能区域的UI。视图与MVVM模式结合使用，MVVM模式用于在UI与应用程序的表示逻辑和数据之间提供关注点的清晰分离。视图用于封装UI并定义用户交互行为，从而允许独立于底层应用程序功能更新或替换视图。视图使用数据绑定与视图模型类交互。 视图模型（View models）。视图模型是封装应用程序的表示逻辑和状态的类。它们是MVVM模式的一部分。View模型封装了应用程序的大部分功能。视图模型定义属性，命令和事件，视图中的控件可以对其进行数据绑定。 模型（Models）。模型类封装了应用程序数据和业务逻辑。它们用作MVVM模式的一部分。模型封装了数据以及任何相关的验证和业务规则，以确保数据的一致性和完整性。 命令（Commands）。命令用于封装应用程序功能，允许独立于应用程序的UI定义和测试它们。它们可以在视图模型中定义为命令对象或命令方法。Prism提供DelegateCommand类和CompositeCommand类。后者用于表示一起调用的命令集合。 地区（Regions）。区域是在应用程序的UI（在shell或视图中）中定义的逻辑占位符，其中显示视图。区域允许更新应用程序UI的布局，而无需更改应用程序逻辑。许多常用控件可用作区域，允许视图自动显示在控件中，例如ContentControl，ItemsControl，ListBox或TabControl。可以以编程方式或自动方式在区域内显示视图。Prism还为实施区域导航提供支持。区域可以通过RegionManager组件由其他组件定位，该组件使用RegionAdapter和RegionBehavior组件，以协调特定区域内的视图显示。 导航（Navigation）。导航定义为应用程序通过其与应用程序或内部应用程序状态更改进行交互而更改其UI的过程。Prism支持两种导航样式：基于状态的导航，其中现有视图的状态被更新以实现简单的导航场景;以及视图切换导航，其中创建新视图并在应用程序的UI内替换旧视图。视图切换导航使用基于统一资源标识符（URI）的导航机制与Prism区域相结合，以允许实现灵活的导航方案。 事件聚合（EventAggregator）。复合应用程序中的组件通常需要以松散耦合的方式与应用程序中的其他组件和服务进行通信。为了支持这一点，Prism提供了EventAggregator组件，它实现了pub-sub事件机制，从而允许组件发布事件和其他组件来订阅这些事件，而不需要引用另一个事件。所述EventAggregator经常被用来允许在不同的模块中定义的部件彼此通信。 依赖注入容器（Dependency injection container）。整个Prism使用依赖注入（DI）模式来允许管理组件之间的依赖关系。依赖注入允许在运行时实现组件依赖性，并且它支持可扩展性和可测试性。Prism旨在与Unity或MEF一起使用，或通过ServiceLocator与任何其他依赖注入容器一起使用。 服务（Services）。服务是封装非UI相关功能的组件，例如日志记录，异常管理和数据访问。服务可以由应用程序定义，也可以在模块内定义。服务通常在依赖注入容器中注册，以便它们可以根据需要定位或构造，并由依赖于它们的其他组件使用。 控制器（Controllers）。控制器是用于协调要在应用程序UI中的区域中显示的视图的构造和初始化的类。控制器封装了表示要显示哪些视图的表示逻辑。控制器将使用Prism的视图切换导航机制，该机制提供可扩展的基于URI的导航机制，以协调区域内视图的构造和放置。Application Controller模式定义了映射到此职责的抽象。 引导程序（Bootstrapper）。该引导程序组件应用程序使用来初始化各个棱镜组件和服务。它用于初始化依赖注入容器，以便向其注册任何应用程序级组件和服务。它还用于配置和初始化模块目录以及shell的视图和视图模型或演示者。 Prism的设计使您可以单独使用任何前述功能和设计模式，也可以根据您的要求和应用场景一起使用。您可以以任意组合使用MVVM模式，模块化，区域，命令或事件，而无需采用所有这些模式。当然，如果您想充分利用分离关注点和松散耦合提供的好处，您通常会将Prism的许多功能和设计模式相互结合使用。下图显示了典型的Prism应用程序体系结构，并展示了Prism的所有各种功能如何在多模块复合应用程序中协同工作。 使用Prism库的典型复合应用程序架构 大多数Prism应用程序由一个shell应用程序组成，该应用程序定义用于显示顶级视图的区域和可由加载的模块访问的共享服务。shell定义了一个合适的Module catalog，以指定在启动时加载哪些模块（如果适用）。还定义了依赖注入容器，其允许在运行时实现组件依赖性。应用程序启动时，Bootstrapper在容器中注册共享服务和组件。 各个模块封装了整个应用程序功能的一部分，并使用分离的表示模式（如MVVM）定义视图，视图模型，模型和服务组件。加载模块时，模块中定义的视图将显示在shell定义的区域内。初始化完成后，用户然后使用基于状态或视图切换的导航在应用程序内导航，以协调应用程序区域内的新视图的可视更新或显示。 ","date":"2019-06-22","objectID":"/2019/06/prism1-introduce/:3:0","tags":["Prism"],"title":"Prism 简介","uri":"/2019/06/prism1-introduce/"},{"categories":"随笔","content":"学习最终还是听说读写的能力，不管知识点的多少，最好的学习方法还是将知识点梳理出脉络和结构进行定向输出的过程。这其中有很多的细节 学习的目的\r","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:0:0","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"人的学习\r","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:1:0","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"为何学习\r找出规律 压缩信息 ","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:1:1","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"如何学习\r明确任务 通过例子 ","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:1:2","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"学习误区\r错误的输入输出 错误的知识类型 把知识当信息 ","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:1:3","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"如何应用\r分而治之 二阶知识 ","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:1:4","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"机器的学习\r","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:2:0","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"为何建模\r识别模式 压缩数据 ","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:2:1","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"如何建模\r明确任务 样本训练 ","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:2:2","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"建模误区\r错误的输入输出 错误的学习算法 浅层学习 深度学习 错误迁移模式 ","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:2:3","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"如何应用\r分而治之 先验知识 思维导图的目的\r","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:2:4","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"思维导图\r常见学习的误区 阅读知识描述 理解文字意思 不断重复描述 思维导图的使用 先写出一个关键词 不断问自己它是什么 想出很多的例子，强迫自己用一个关键词来描述很多的例子 分析所有例子的共同输入和输出，找出规律 需要学习的是规律，而不是具体情况 通过共同的规律来预测未见过的情况 ","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:3:0","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"思维导图设计\r明确输入输出任务 将信息压缩成知识 例子重塑大脑连接 二阶知识拆分只是 如何画思维导图\r","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:4:0","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"使用步骤\r搜集例子 头脑风暴 上网调查 自我提问 一阶知识 分类 它是什么 为什么是 回归 它的目的 如何达成 二阶知识 组合关系 它有什么 执行步骤 先后顺序 ","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:5:0","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"使用技巧\r工具使用 外框 视角、注意力 联系 跨层知识关系 笔记 知识描述 概要 显示描述 知识命名 定语名词 动词宾语 使用误区 记录所有信息 知识间不独立 记忆他人导图 从不验证更新 画无规律信息 怎样喜欢学习\r保持好奇心 Stay Hungry,Stay Foolish! ","date":"2019-05-27","objectID":"/2019/05/essay2-mindmapping/:6:0","tags":["思维导图"],"title":"随笔 思维导图","uri":"/2019/05/essay2-mindmapping/"},{"categories":"随笔","content":"计划\r","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:0:0","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"长期计划\r要把计划列成一个详细的清单，而且要注明时间和完成期限 只是一个计划告诉你方向 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:1:0","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"短期计划\r细计划 把一个三年的学习计划，按照某种规律（逻辑、类型、阶段等等）分成三份，安排到每一年， 每年的学习内容细化，安排到每一个月。因为一个月有三十天，所以可以把一个月分为三个周期：第一个十天，第二个十天，第三个十天，十天就是一个周期。确定这个周期学习什么，下个周期学习什么，以此类推。 画一张每日工作表，自己每天晚上计划一下第二天的学习内容。 将整个计划分成若干阶段，每个阶段20小时阶段（2+2+2+2+2+5+5，每周20小时，工作日2小时，周末5小时），每周20小时，每天学习完进行练习，每周学习完进行测试。 计划调整 有时计划会低估或则高估自己的学习能力，根据每天的学习内容即时调整 执行\r快速浏览： 看目录：知道每一章重点在哪一节，用来解决什么问题 看课后习题，圈出术语和知识点 详细阅读： 根据重点和术语有重点的看书中概念，案例，图表 做题： 做课后习题 回顾： 看着目录知道这一章讲哪些内容，有哪些专业术语和知识点 测试： 学完课程后去网上找试卷进行测试 总结： 读一本书要写读书笔记，学知识要写总结 目的是把书中的知识和自己的理解结合起来形成自己的想法和思路，将自己的笔记标注时间，以后可以复习 定向输出： 找一个平台定向输出自己的所学。在写作的过程中，需要不断回忆自己学到的知识，并且利用自己的语言将它表达出来。还要思考文章的结构，怎么才能循序渐进地把一个复杂的道理讲得明白，讲得令人心服口服，讲得让人无懈可击。如果有某些细节自己不知道、不清楚，为了避免文中出现疏漏，你就会去查阅资料或者翻阅书籍，这就完成了一个巩固与复习的过程。 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:2:0","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"学习障碍\r","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:0","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"仪式感\r人藉由这种仪式带来的仪式感，来给自己一种强烈的自我暗示———这种自我暗示能够使自我变革，把自己的专注力、反应能力、运动能力迅速提升； 睡觉前，想一想今天学了哪些内容，第二天要学习哪些内容； 醒来，想一下今天又哪些任务； ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:1","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"预热\r提前半小时到达学习地点，准备好学习所需的物品； 翻看今天要学习的内容，浏览重要的概念和例题； 最后一分钟什么也不做，静心； ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:2","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"放松\r身体能量:每隔50分钟吃点东西喝点水 情绪能量:听音乐，做运动 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:3","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"厌倦感\r在高效学习的晚上，还有一部分愉悦的学习热情的时候中断学习，这样第二天可以更快进入学习状态 在讨厌某件事情的时候立马做，在开心的余热中立刻结束。 运动趋向运动，静止趋向静止 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:4","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"能量爆发期\r规划自己一天当中哪几个阶段学习热情比较高，效率高，为这几个阶段做提前准备，为了下午的学习，中午先休息一会，在工作之余听听音乐 在疲劳来临之前休息放松是最好的缓解疲劳的方法 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:5","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"计划被中断\r当天的某个计划被中断，没什么大不了，继续计划就可以 60分的完成也好过不完成。不要放弃 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:6","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"奖惩机制\r每天锻炼，没做好每天多做 看视频，没做好每天不看视频来锻炼 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:7","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"自我经营\r人与人最大的差别，不是他们的社会地位和收入水平，而是他们在业余时间学什么、做什么。 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:8","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"随笔","content":"当机立断\r无论学什么，一定要当机立断，今天写计划，今天就执行，别等别拖别准备。 总结\r自学的本质就是管理自己，经营自己，掌控自己，驾驭自己，最后得到时间上的盈利——时间价值最大化。 人，终究是要学会使用自己，而不是放纵自己。 参考文献\rhttps://www.zhihu.com/question/21107510 https://www.zhihu.com/question/36766890/answer/70795756 ","date":"2019-04-04","objectID":"/2019/04/essay1-selflearn/:3:9","tags":["自学"],"title":"随笔 如何学习","uri":"/2019/04/essay1-selflearn/"},{"categories":"Web","content":"DOM(document object medol)文档对象模型。 DOM就是HTML页面的模型，将每个标签都做为一个对象，JavaScript通过调用DOM中的属性、方法就可以对网页中的文本框、层等元素进行编程控制。比如通过操作文本框的DOM对象，就可以读取文本框中的值、设置文本框中的值。 JavaScript→Dom就是C#→.Net Framwork。没有.net，C#只能for、while，连WriteLine、MessageBox都不行。Dom就是一些让JavaScript能操作HTML页面控件的类、函数。 DOM也像WinForm一样，通过事件、属性、方法进行编程。 CSS+JavaScript+DOM=DHTML 学习阶段只考虑IE。用IE Collection安装IE所有版本，学习使用IE6（要调试必须使用本机安装的版本）。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:0:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"事件\r事件：\u003cbody onmousedown=\"alert('哈哈')\"\u003e当点击鼠标的时候执行onmousedown中的代码。有时间事件响应的代码太多，就放到单独的函数中： \u003cscript type=\"text/javascript\"\u003e function bodymousedown() { alert(\"网页被点坏了，赔吧！\"); alert(\"逗你玩的！\"); } \u003c/script\u003e \u003cbody onmousedown=\"bodymousedown()\"\u003e bodymousedown后的括号不能丢（ onmousedown=“bodymousedown” ），因为表示onmousedown事件发生时调用bodymousedown函数，而不是onmousedown事件的响应函数是bodymousedown。 \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function setTxt() { t1.value = \"1234\"; } \u003c/script\u003e \u003c/head\u003e \u003cbody onload=\"setTxt();\" onunload=\"alert('欢迎下次光临！')\" onbeforeunload=\"window.event.returnValue='确定关闭？'\"\u003e \u003cinput id=\"t1\" type=\"text\" value=\"\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:1:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"动态设置事件\r可以在代码中动态设置事件响应函数，就像.Net中btn.Click+=一样 function f1() { alert(\"1\"); } function f2(){ alert(\"2\"); } \u003cinput type=\"button\" onclick=\"document.ondblclick=f1\" value=\"关联事件1\" /\u003e//注意f1不要加括号。如果加上括号就变成了执行f1函数，并且将函数的返回值复制给document.ondblclick \u003cinput type=\"button\" onclick=\"document.ondblclick=f2\" value=\"关联事件2\" /\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function load() { alert('地球日'); alert('2012不远了'); } function f1() { alert(\"f1\"); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"按钮\" onclick=\"document.onclick=f1\" /\u003e \u003cinput type=\"button\" value=\"关闭\" onclick=\"window.close()\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:2:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"window对象\rwindow对象代表当前浏览器窗口，使用window对象的属性、方法的时候可以省略window，比如window.alert(‘a’)可以省略成alert(‘aa’)。 alert方法，弹出消息对话框 confirm方法，显示“确定”、“取消”对话框，如果按了【确定】按钮，就返回true，否则就false if (confirm(\"是否继续？\")) { alert(\"确定\"); } else { alert(\"取消\"); } + 重新导航到指定的地址：navigate(\"http://www.rupeng.com\");\r+ setInterval每隔一段时间执行指定的代码，第一个参数为代码的字符串，第二个参数为间隔时间（单位毫秒），返回值为定时器的标识\r`setInterval(\"alert('hello')\", 5000);`\r+ clearInterval取消setInterval的定时执行，相当于Timer中的Enabled=False。因为setInterval可以设定多个定时，所以clearInterval要指定清除那个定时器的标识，即setInterval的返回值。\rvar intervalId = setInterval(\"alert('hello')\", 5000);\rclearInterval(intervalId); + setTimeout也是定时执行，但是不像setInterval那样是重复的定时执行，只执行一次，clearTimeout也是清除定时。很好区分：Interval：间隔；timeout：超时。 var timeoutId = setTimeout(\"alert('hello')\", 2000); + showModalDialog弹出模态对话框，注意showModalDialog必须在onClick等用户手动触发的事件中才会执行，否则可能会被最新版本的浏览器当成广告弹窗而拦截。\r+ 第一个参数为弹出模态窗口的页面地址。\r+ 在弹出的页面中调用window.close()（不能省略window.close()中的window.）关闭窗口，只有在对话框中调用window.close()才会自动关闭窗口，否则浏览器会提示用户进行确认。\r+ 除了有特有的属性之外，当然还有通用的HTML元素的事件：onclick（单击）、ondblclick（双击）、onkeydown（按键按下）、onkeypress（点击按键）、onkeyup（按键释放）、onmousedown（鼠标按下）、onmousemove（鼠标移动）、onmouseout（鼠标离开元素范围）、onmouseover（鼠标移动到元素范围）、onmouseup（鼠标按键释放）等。\r\u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e1234567890\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e var tid; function setTimeoutDemo() { tid = setTimeout(\"alert('下课了')\", 3000); } function clearTimeoutDemo() { //判断tid是否初始化 if (tid) { clearTimeout(tid); } } var dir = \"left\"; function scroll() { var title = window.document.title; if (dir == \"left\") { var first = title.charAt(0); var last = title.substring(1, title.length); //start 从0数 end从1数 } else if (dir == \"right\") { var last = title.charAt(title.length - 1); var first = title.substring(0, title.length - 1); } window.document.title = last + first; } setInterval(\"scroll()\", 500); function setDir(str) { dir = str; } function scrollRight() { var title = window.document.title; var last = title.charAt(title.length - 1); var first = title.substring(0, title.length - 1); title = last + first; window.document.title = title; } window.showModalDialog(\"1-.htm\"); function showDialog() { window.showModalDialog(\"1-.htm\"); } function show() { window.showModelessDialog(\"1-.htm\"); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"启动\" onclick=\"setTimeoutDemo();\" /\u003e \u003cinput type=\"button\" value=\"取消\" onclick=\"clearTimeoutDemo();\" /\u003e \u003cinput type=\"button\" value=\"向左\" onclick=\"setDir('left')\" /\u003e \u003cinput type=\"button\" value=\"向右\" onclick=\"setDir('right')\" /\u003e \u003cbr /\u003e \u003cinput type=\"button\" value=\"模式窗口\" onclick=\"showDialog()\" /\u003e \u003cinput type=\"button\" value=\"非模式窗口\" onclick=\"show()\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e var times = 10; function count() { var btn = document.getElementById(\"btn\"); if (times \u003e 0) { btn.value = \"同意(倒计时\" + times + \")\"; times--; } else { btn.value = \"同意\"; btn.disabled = false; clearInterval(tid); } } var tid = setInterval(\"count()\", 1000); \u003c/script\u003e \u003c/head\u003e \u003cbody onload=\"count()\"\u003e 注册协议 \u003cbr /\u003e \u003cinput id=\"btn\" type=\"button\" value=\"同意\" disabled=\"disabled\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:3:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"window对象属性\rwindow.location.href='http://www.itcast.cn'，重新导向新的地址，和navigate方法效果一样。window.location.reload() 刷新页面 window.event是非常重要的属性，用来获得发生事件时的信息，事件不局限于window对象的事件，所有元素的事件都可以通过event属性取到相关信息。类似于winForm中的e(EventArg). altKey属性，bool类型，表示发生事件时alt键是否被按下，类似的还有ctrlKey、shiftKey属性，例子 \u003cinput type=\"button\" value=\"点击\" onclick=\"if(event.altKey){alert('Alt点击')}else{alert('普通点击')}\" /\u003e ； clientX、clientY 发生事件时鼠标在客户区的坐标；screenX、screenY 发生事件时鼠标在屏幕上的坐标；offsetX、offsetY 发生事件时鼠标相对于事件源（比如点击按钮时触发onclick）的坐标。 returnValue属性，如果将returnValue设置为false，就会取消默认事件的处理。在超链接的onclick里面禁止访问href的页面。在表单校验的时候禁止提交表单到服务器，防止错误数据提交给服务器、防止页面刷新。 srcElement，获得事件源对象。几个事件共享一个事件响应函数用。 keyCode，发生事件时的按键值。 button，发生事件时鼠标按键，1为左键，2为右键，3为左右键同时按。\u003cbody onmousedown=\"if(event.button==2){alert('禁止复制');}\"\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:4:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"（*）screen对象，屏幕的信息\ralert(\"分辨率：\" + screen.width + \"*\" + screen.height); if (screen.width \u003c 1024 || screen.height \u003c 768){ alert(\"分辨率太低！\"); } ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:5:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"clipboardData对象\r对粘贴板的操作。clearData(“Text”)清空粘贴板；getData(“Text”)读取粘贴板的值，返回值为粘贴板中的内容；setData(“Text”,val)，设置粘贴板中的值。 案例：复制地址给友好。见备注。 当复制的时候body的oncopy方法被触发，直接return false就是禁止复制。\u003cbody oncopy=“alert(‘禁止复制！’);return false;” 很多元素也有oncopy、onpaste事件： 案例：禁止粘贴帐号。见备注。 在网站中复制文章的时候，为了防止那些拷贝党不添加文章来源，自动在复制的内容后添加版权声明。 function modifyClipboard() { clipboardData.setData('Text', clipboardData.getData('Text') + '本文来自传智播客技术专区，转载请注明来源。' + location.href); } + `oncopy=\"setTimeout('modifyClipboard()',100)\"`。用户复制动作发生0.1秒以后再去改粘贴板中的内容。100ms只是一个经常取值，写1000、10、50、200……都行。不能直接在oncopy里修改粘贴板。\r+ 不能直接在oncopy中执行对粘贴板的操作，因此设定定时器，0.1秒以后执行，这样就不再oncopy的执行调用栈上了。\rhistory操作历史记录 window.history.back()后退；window.history.forward()前进。也可以用window.history.go(-1)、window.history.go(1)前进 \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function getXY() { document.title = window.event.clientX + \" \" + window.event.clientY; } function turnInto(right) { if (right) { alert(\"欢迎进入\"); } else { alert(\"非法入侵\"); window.event.returnValue = false; alert(\"123123\"); } } function btnClick() { return false; alert(\"abc\"); } function txtKeyDown() { var txt = window.event.srcElement; if (txt.id == \"txtNums\") { if (window.event.keyCode \u003e= 48 \u0026\u0026 window.event.keyCode \u003c= 57) { } else { return false; } } else if (txt.id = \"txt\") { } } \u003c/script\u003e \u003c/head\u003e \u003cbody onmousemove=\"getXY()\" onmousedown=\"if(window.event.button==2){alert('禁止复制')}\"\u003e \u003cinput type=\"button\" value=\"url\" onclick=\"alert(window.location.href);\" /\u003e \u003cinput type=\"button\" value=\"转向\" onclick=\"window.location.href='2-window对象.htm'\" /\u003e \u003cinput type=\"button\" value=\"reload\" onclick=\"window.location.reload()\" /\u003e \u003cinput type=\"button\" value=\"ctrlKey\" onclick=\"if(window.event.ctrlKey){alert('按下ctrl')}else{alert('没有按下')}\" /\u003e \u003cbr /\u003e \u003ca href=\"1-.htm\" onclick=\"turnInto(0)\"\u003e超链接\u003c/a\u003e \u003cinput type=\"button\" value=\"returnValue\" onclick=\"btnClick();\" /\u003e \u003cform action=\"http://www.baidu.com\"\u003e \u003cinput type=\"submit\" onclick=\"alert('请输入用户名密码');window.event.returnValue=false\"/\u003e \u003c/form\u003e \u003cinput id=\"txtNums\" type=\"text\" value=\"\" onkeydown=\"return txtKeyDown()\" /\u003e \u003cinput id=\"txt\" type=\"text\" value=\"\" onkeydown=\"txtKeyDown()\" /\u003e \u003cinput type=\"button\" value=\"screen\" onclick=\"alert(window.screen.width + ' ' + window.screen.height)\" /\u003e \u003chr /\u003e 手机号：\u003cinput type=\"text\" value=\"\" oncopy=\"alert('禁止复制');return false\" /\u003e\u003cbr /\u003e 重复手机号：\u003cinput type=\"text\" value=\"\" onpaste=\"alert('请输入');return false\" /\u003e \u003chr /\u003e \u003cinput id=\"tabc\" type=\"text\" value=\"213123123\" /\u003e\u003cinput type=\"button\" value=\"copy\" onclick=\"window.clipboardData.setData('text',tabc.value);alert('复制成功');\" /\u003e\u003cbr /\u003e \u003cinput id=\"t123\" type=\"text\" value=\"\" /\u003e\u003cinput type=\"button\" value=\"paste\" onclick=\"t123.value=clipboardData.getData('text')\" /\u003e\u003cbr /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function setClip() { var text = window.clipboardData.getData(\"text\"); text = text + \"转载请注明：\" + window.location.href; window.clipboardData.setData(\"text\",text); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003ctextarea id=\"t1\" oncopy=\"setTimeout('setClip()',50)\"\u003e asdfasdfasdf asdfasdfasdf \u003c/textarea\u003e \u003ca href=\"6-history.htm\"\u003e链接\u003c/a\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"后退\" onclick=\"window.history.back()\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:6:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"document属性。\r是最复杂的属性之一。后面讲解详细使用。 document是window对象的一个属性，因为使用window对象成员的时候可以省略window.，所以一般直接写document document的方法： write：向文档中写入内容。writeln，和write差不多，只不过最后添加一个回车 \u003cinput type=\"button\" value=\"点击\" onclick=\"document.write('\u003cfont color=red\u003e你好\u003c/font\u003e')\" /\u003e + 在onclick等事件中写的代码会冲掉页面中的内容，只有在页面加载过程中write才会与原有内容融合在一起\r\u003cscript type=\"text/javascript\"\u003e document.write('\u003cfont color=red\u003e你好\u003c/font\u003e'); \u003c/script\u003e + write经常在广告代码、整合资源代码中被使用。见备注\r内容联盟、广告代码、cnzz，不需要被主页面的站长去维护内容，只要被嵌入的js内容提供商修改内容，显示的内容就变了。 getElementById方法（非常常用），根据元素的Id获得对象，网页中id不能重复。也可以直接通过元素的id来引用元素，但是有有效范围、form1.textbox1之类的问题，因此不建议直接通过id操作元素，而是通过getElementById （*）getElementsByName，根据元素的name获得对象，由于页面中元素的name可以重复，比如多个RadioButton的name一样，因此getElementsByName返回值是对象数组。 （*）getElementsByTagName，获得指定标签名称的元素数组，比如getElementsByTagName(“p”)可以获得所有的标签。 案例：实现checkbox的全选，反选 案例：点击一个按钮，被点击的按钮显示“呜呜”，其他按钮显示“哈哈”。 案例：十秒钟后协议文本框下的注册按钮才能点击，时钟倒数。(btn.disabled = true ) \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function writeDemo() { document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); } document.writeln(\"123\u003cbr/\u003e\"); document.writeln(\"123\u003cbr/\u003e\"); document.writeln(\"\u003ca href='123.htm'\u003e123\u003c/a\u003e\"); document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); document.write(\"\u003ca href='http://www.baidu.com'\u003e百度\u003c/a\u003e\"); document.write(\"\u003cul\u003e\u003cli\u003e开始\u003c/li\u003e\u003cli\u003e运行\u003c/li\u003e\u003cli\u003e结束\u003c/li\u003e\u003c/ul\u003e\"); //document.write(\"\u003cscript type='text/javascript'\u003ealert('hello world');\u003c\\/script\u003e\"); \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv\u003eabc \u003cscript type=\"text/javascript\"\u003e document.writeln(\"123\u003cbr/\u003e\"); document.writeln(\"123\u003cbr/\u003e\"); \u003c/script\u003eabc \u003c/div\u003e \u003cdiv\u003e sdfsd \u003c/div\u003e \u003cinput type=\"button\" value=\"按钮\" onclick=\"writeDemo()\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function setText() { var txt = document.getElementById(\"t1\"); txt.value = \"123\"; //t1.value = \"123\"; } function setText2() { var txt = document.getElementById(\"t2\"); txt.value = \"abc\"; //form1.t2.value = \"abc\"; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput id=\"t1\" type=\"text\" value=\"\" /\u003e \u003cform id=\"form1\"\u003e \u003cinput id=\"t2\" type=\"text\" value=\"\" /\u003e \u003c/form\u003e \u003cinput type=\"button\" value=\"按钮\" onclick=\"setText()\" /\u003e \u003cinput type=\"button\" value=\"按钮2\" onclick=\"setText2()\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function btnClick() { var chks = document.getElementsByName(\"hobby\"); //错误 // for (var c in chks) { // alert(c); // } for (var i = 0; i \u003c chks.length; i++) { //alert(chks[i].value); chks[i].checked = \"checked\"; } } function checkAll() { var chkAll = document.getElementById(\"chkAll\"); var chks = document.getElementsByName(\"hobby\"); for (var i = 0; i \u003c chks.length; i++) { chks[i].checked = chkAll.checked; } } function reverseCheck() { var chks = document.getElementsByName(\"hobby\"); for (var i = 0; i \u003c chks.length; i++) { chks[i].checked = !chks[i].checked; } } function checkSingle() { var b = true; //假设全被选中 var chkAll = document.getElementById(\"chkAll\"); var chks = document.getElementsByName(\"hobby\"); for (var i = 0; i \u003c chks.length; i++) { //查找所有子的checkbox，判断是否被选中 //如果有一个checkbox没有被选中，则退出循环，最终全选的checkbox为false if (!chks[i].checked) { b = false; break; } } chkAll.checked = b; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"checkbox\" value=\"cf\" onclick=\"checkSingle()\" name=\"hobby\"/\u003e吃饭\u003cbr /\u003e \u003cinput type=\"checkbox\" value=\"sj\" onclick=\"checkSingle()\" name=\"hobby\"/\u003e睡觉\u003cbr /\u003e \u003cinput type=\"checkbox\" value=\"ddd\" onclick=\"checkSingle()\" name=\"hobby\"/\u003e打豆豆\u003cbr /\u003e \u003cbr /\u003e\u003cbr /\u003e \u003cinput id=\"chkAll\" type=\"checkbox\" onclick=\"checkAll()\"/\u003e全选 \u003cinput type=\"button\" value=\"反选\" onclick=\"reverseCheck()\" /\u003e \u003cinput type=\"button\" value=\"全选\" onclick=\"btnClick()\" /\u003e \u003cbr /\u003e \u003cinput type=\"checkbox\" value=\"ctl\" /\u003e春天里\u003cbr /\u003e \u003cinput type=\"checkbox\" value=\"xtl\" /\u003e夏天里\u003cbr /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"htt","date":"2019-04-04","objectID":"/2019/04/web4-dom/:6:1","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"dom动态创建\rdocument.write只能在页面加载过程中才能动态创建。 可以调用document的createElement方法来创建具有指定标签的DOM对象，然后通过调用某个元素的appendChild方法将新创建元素添加到相应的元素下 function showit() { var divMain = document.getElementById(\"divMain\"); var btn = document.createElement(\"input\"); btn.type = \"button\"; btn.value = \"我是动态的！\"; divMain.appendChild(btn); } \u003cdiv id=\"divMain\"\u003e\u003c/div\u003e \u003cinput type=\"button\" value=\"ok\" onclick=\"showit()\" /\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function createBtn() { var btn = document.createElement(\"input\"); btn.type = \"button\"; btn.value = \"新按钮\"; btn.onclick = function() { alert(\"我是新来的\"); } var d = document.getElementById(\"d1\"); d.appendChild(btn); } function createLink() { var link = document.createElement(\"a\"); link.href = \"http://www.baidu.com\"; link.innerText = \"百度\"; link.target = \"_blank\"; var d = document.getElementById(\"d1\"); d.appendChild(link); } function btnClick(){ alert(\"我是新来的\"); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"创建按钮\" onclick=\"createBtn()\" /\u003e \u003cinput type=\"button\" value=\"创建超链接\" onclick=\"createLink()\" /\u003e \u003cdiv id=\"d1\"\u003eabc\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e Value 获取表单元素 几乎所有DOM元素都有innerText、innerHTML属性（注意大小写），分别是元素标签内内容的文本表示形式和HTML源代码，这两个属性是可读可写的。 \u003ca href=\"http://www.itcast.cn\" id=\"link1\"\u003e传\u003cfont color=\"Red\"\u003e智\u003c/font\u003e播客\u003c/a\u003e \u003cinput type=\"button\" value=\"inner*\" onclick=\"alert(document.getElementById('link1').innerText);alert(document.getElementById('link1').innerHTML);\" /\u003e 用innerHTML也可以替代createElement，属于简单、粗放型、后果自负的创建 function createlink() { var divMain = document.getElementById(\"divMain\"); divMain.innerHTML = \"\u003ca href='http://www.rupeng.com'\u003e如鹏网\u003c/a\u003e\"; } \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function getLinkText() { var link = document.getElementById(\"link1\"); alert(link.innerText); alert(link.innerHTML); } function setDiv() { var div = document.getElementById(\"d1\"); //div.innerText = \"\u003cfont color='red'\u003e123123\u003c/font\u003e\"; //div.innerHTML = \"\u003cfont color='red'\u003e123123\u003c/font\u003e\"; //div.innerHTML = \"\u003cul\u003e\u003cli\u003e春天里\u003c/li\u003e\u003cli\u003e怒放\u003c/li\u003e\u003c/ul\u003e\"; //div.innerHTML = \"\u003cinput type='text' value='1234' /\u003e\"; //div.innerText = div.innerText + \"123123\"; //Node节点 Element元素的区别 //html文档里所有的内容都是节点 标签 属性 文本 //元素 一个完整的标签 //var txtNode = document.createTextNode(\"123123\"); // div.appendChild(txtNode); div.innerHTML = \"\u003cscript type='text/javascript'\u003efunction test(){alert('hello');}\u003c\\/script\u003e\"; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003ca id=\"link1\" href=\"http://www.itcast.cn\"\u003e传智\u003cfont color=\"red\"\u003e播客\u003c/font\u003e\u003c/a\u003e \u003cinput type=\"button\" value=\"按钮\" onclick=\"getLinkText()\" /\u003e \u003cdiv id=\"d1\"\u003eabcd\u003c/div\u003e \u003cinput type=\"button\" value=\"set div\" onclick=\"setDiv() \" /\u003e \u003cinput type=\"button\" value=\"test\" onclick=\"test()\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function createTable() { var div = document.getElementById(\"d1\"); var dic = { \"baidu\": \"http://www.baidu.com\", \"传智播客\": \"http://www.itcast.cn\", \"cnbeta\": \"http://www.cnbeta.com\" }; var table = document.createElement(\"table\"); table.border = 1; for (var key in dic) { var tr = document.createElement(\"tr\"); var td0 = document.createElement(\"td\"); td0.innerText = key; //把td0加到tr中 tr.appendChild(td0); var td1 = document.createElement(\"td\"); td1.innerHTML = \"\u003ca href='\" + dic[key] + \"'\u003e\" + dic[key] + \"\u003c/a\u003e\"; tr.appendChild(td1); //把tr添加到table中 table.appendChild(tr); } //把table添加到div中 div.appendChild(table); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"d1\"\u003e\u003c/div\u003e \u003cinput type=\"button\" value=\"load。。。\" onclick=\"createTable()\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:7:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"浏览器兼容性的例子\rie6，ie7对table.appendChild(“tr”)的支持和IE8不一样，用insertRow、insertCell来代替或者为表格添加tbody，然后向tbody中添加tr。FF不支持InnerText。 所以动态加载网站列表的程序修改为： var tr = tableLinks.insertRow(-1);//FF必须加-1这个参数 var td1 = tr.insertCell(-1); td1.innerText = key; var td2 = tr.insertCell(-1); td2.innerHTML = \"\u003ca href='\" + value + \"'\u003e\" + value + \"\u003c/a\u003e\"; 或者： \u003ctable id=\"tableLinks\"\u003e \u003ctbody\u003e\u003c/tbody\u003e \u003c/table\u003e，然后tableLinks. tBodies[0].appendChild(tr); \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function add() { var name = document.getElementById(\"txtName\").value; var content = document.getElementById(\"txtContent\").value; var tr = document.createElement(\"tr\"); var td0 = document.createElement(\"td\"); td0.innerText = name; tr.appendChild(td0); var td1 = document.createElement(\"td\"); td1.innerText = content; tr.appendChild(td1); var table = document.getElementById(\"re\"); table.appendChild(tr); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003e 最新新闻 \u003c/p\u003e \u003ctable id=\"re\"\u003e\u003c/table\u003e \u003chr /\u003e 评论： \u003cinput id=\"txtName\" type=\"text\" value=\"\" /\u003e\u003cbr /\u003e \u003ctextarea id=\"txtContent\" cols=\"50\" rows=\"10\"\u003e\u003c/textarea\u003e \u003cbr /\u003e \u003cinput type=\"button\" value=\"评论\" onclick=\"add()\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function add() { var name = document.getElementById(\"txtName\").value; var content = document.getElementById(\"txtContent\").value; var table = document.getElementById(\"re\"); var tr = table.insertRow(-1); var td = tr.insertCell(-1); td.innerHTML = name; var td1 = tr.insertCell(-1); td1.innerHTML = content; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003e 最新新闻 \u003c/p\u003e \u003ctable id=\"re\"\u003e\u003c/table\u003e \u003chr /\u003e 评论： \u003cinput id=\"txtName\" type=\"text\" value=\"\" /\u003e\u003cbr /\u003e \u003ctextarea id=\"txtContent\" cols=\"50\" rows=\"10\"\u003e\u003c/textarea\u003e \u003cbr /\u003e \u003cinput type=\"button\" value=\"评论\" onclick=\"add()\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:8:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"事件冒泡\r事件冒泡：如果元素A嵌套在元素B中，那么A被点击不仅A的onclick事件会被触发，B的onclick也会被触发。触发的顺序是“由内而外” 。验证：在页面上添加一个table、table里有tr、tr里有td，td里放一个p，在p、td、tr、table中添加onclick事件响应，见备注。 \u003ctable onclick=\"alert('table onclick');\"\u003e \u003ctr onclick=\"alert('tr onclick');\"\u003e \u003ctd onclick=\"alert('td onclick');\"\u003e\u003cp onclick=\"alert('p onclick');\"\u003eaaaa\u003c/p\u003e\u003c/td\u003e \u003ctd\u003ebbb\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function btn3() { alert(event.srcElement.value); } //事件响应函数的调用函数 function btn4() { alert(this.value); } function initBtn5() { var btn = document.getElementById(\"btn5\"); //事件响应函数 btn.onclick = btn4; } \u003c/script\u003e \u003c/head\u003e \u003cbody onload=\"initBtn5()\"\u003e \u003ctable onclick=\"alert('table')\"\u003e \u003ctr onclick=\"alert('tr')\"\u003e \u003ctd onclick=\"alert('td')\"\u003e \u003cdiv onclick=\"alert('div')\"\u003easd\u003c/div\u003e\u003c/td\u003e \u003ctd\u003e2\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003cinput type=\"button\" value=\"click1\" onclick=\"alert(event.srcElement.value)\" /\u003e\u003cbr /\u003e \u003c!-- 事件响应函数--\u003e \u003cinput type=\"button\" value=\"click2\" onclick=\"alert(this.value)\" /\u003e \u003cinput type=\"button\" value=\"click3\" onclick=\"btn3()\" /\u003e \u003cinput type=\"button\" value=\"click4\" onclick=\"btn4()\" /\u003e \u003cinput id=\"btn5\" type=\"button\" value=\"click5\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:8:1","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"this\r事件中的this。 除了可以使用event.srcElement在事件响应函数中 this表示发生事件的控件。 只有在事件响应函数才能使用this获得发生事件的控件，在事件响应函数调用的函数中不能使用，如果要使用则要将this传递给函数或者使用event.srcElement。 (*)this和event.srcElement的语义是不一样的，this就是表示当前监听事件的这个对象，event.srcElement是引发事件的对象：事件冒泡。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:9:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"修改样式\r易错：修改元素的样式不是设置class属性，而是className属性。案例：网页开关灯的效果。 修改元素的样式不能this.style=\"background-color:Red\"。 易错：单独修改样式的属性使用“style.属性名”。注意在css中属性名在JavaScript中操作的时候属性名可能不一样，主要集中在那些属性名中含有-的属性，因为JavaScript中-是不能做属性、类名的。所以CSS中背景颜色是background-color，而JavaScript则是style.backgroundColor；元素样式名是class，在JavaScript中是className属性；font-size→style.fontSize；margin-top→style.marginTop 单独修改控件的样式\u003cinput type=\"button\" value=\"AAA\" onclick=\"this.style.color='red'\" /\u003e。技巧，没有文档的情况下的值属性名，随便给一个元素设定id，然后在js中就能id.style.出来能用的属性。 \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e .light{ background-color:White; } .dark { background-color:Black; } \u003c/style\u003e \u003cscript type=\"text/javascript\"\u003e function open1() { document.body.className = \"light\"; } function close1() { document.body.className = \"dark\"; } function change() { var txt = document.getElementById(\"txt1\"); //错误 不能这样用。可以把style看成一个只读属性 //txt.style = \"background-color:Green\"; txt.style.backgroundColor = \"Green\"; txt.style.color = \"red\"; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" value=\"开灯\" onclick=\"open1()\" /\u003e \u003cinput type=\"button\" value=\"关灯\" onclick=\"close1()\" /\u003e \u003cinput id=\"txt1\" type=\"text\" value=\"123\" /\u003e \u003cinput type=\"button\" value=\"click\" onclick=\" change() \" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function initTxt() { var txts = document.getElementsByTagName(\"input\"); for (var i = 0; i \u003c txts.length; i++) { if (txts[i].type == \"text\") { //事件响应函数 txts[i].onblur = iBlur; } } } function iBlur() { if (this.value.length \u003c= 0) { this.style.backgroundColor = \"red\"; } else { this.style.backgroundColor = \"white\"; } } function iFocus(txt) { txt.value = \"\"; } \u003c/script\u003e \u003c/head\u003e \u003cbody onload=\"initTxt()\"\u003e \u003cinput type=\"text\" value=\"\"/\u003e \u003cinput type=\"text\" value=\"\" /\u003e \u003cinput type=\"text\" value=\"\" /\u003e \u003cinput type=\"button\" value=\"click\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function iBlur(txt) { var t2 = document.getElementById(\"t2\"); t2.style.backgroundColor = txt.style.backgroundColor; t2.style.color = txt.style.color; t2.style.width = txt.style.width; t2.value = txt.value; } function iFocus(txt) { var t1 = document.getElementById(\"t1\"); txt.style.backgroundColor = t1.style.backgroundColor; txt.style.color = t1.style.color; txt.style.width = t1.style.width; txt.value = t1.value; } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput id=\"t1\" type=\"text\" value=\"\" style=\"background-color:Green; color:Red; width:300px\" /\u003e \u003cinput type=\"text\" onfocus=\"iFocus(this)\" /\u003e \u003c/body\u003e \u003c/html\u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function init() { var table = document.getElementById(\"rating\"); var tds = table.getElementsByTagName(\"td\"); for (var i = 0; i \u003c tds.length; i++) { //事件响应函数 tds[i].onmouseover = change; tds[i].onclick = stop; tds[i].style.cursor = \"pointer\"; } } //记录是否点鼠标，默认没点 var isClick = false; function stop() { isClick = true; } function indexOf(arr,element){ var j = -1; for(var i=0;i\u003carr.length;i++){ if(arr[i] == element) { j = i; break; } } return j; } function change() { //当没点鼠标的时候去执行 if (!isClick) { var table = document.getElementById(\"rating\"); var tds = table.getElementsByTagName(\"td\"); var n = indexOf(tds, this); for (var i = 0; i \u003c= n; i++) { //tds[i].style.backgroundColor = \"red\"; tds[i].innerText = \"★\"; } for (var i = n + 1; i \u003c tds.length; i++) { //tds[i].style.backgroundColor = \"white\"; tds[i].innerText = \"☆\"; } } } \u003c/script\u003e \u003c/head\u003e \u003cbody onload=\"init()\"\u003e \u003ctable id=\"rating\"\u003e \u003ctr\u003e \u003ctd\u003e☆\u003c/td\u003e\u003ctd\u003e☆\u003c/td\u003e\u003ctd\u003e☆\u003c/td\u003e\u003ctd\u003e☆\u003c/td\u003e\u003ctd\u003e☆\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c/body\u003e \u003c/html\u003e \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function init() { var d1 = document.getElementById(\"d1\"); var links = d1.getElementsByTagName(\"a\"); for (var i = 0; i \u003c links.length; i++) { links[i].onclick = linkClick; } } function linkClick() { var d1 = document.getElementById(\"d1\"); var links = d1.getElementsByTagName(\"a\")","date":"2019-04-04","objectID":"/2019/04/web4-dom/:10:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"控制层显示\r修改style.display，例子：切换层的显示 function togglediv() { var div1 = document.getElementById('div1'); if (div1.style.display == '') { div1.style.display = 'none';//不显示 } else { div1.style.display = '';//显示 } } 案例：注册页面，点击“高级”CheckBox，则显示高级选项，否则隐藏 案例：鼠标放到一个超链接的时候，在鼠标的位置显示一个黄色背景，带图片的悬浮提示，鼠标离开就消失。提示：鼠标进入控件的事件是onmouseover，离开的事件是onmouseout。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:11:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"Body事件的范围\rIE中如果在body上添加onclick、onmousemove等事件响应，那么如果页面没有满，则 “body 中最后一个元素以下（横向不限制）” 的部分是无法响应事件的，必须使用代码在document上监听那些事件，比如document.onmousemove = MovePic FF中也差不多。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:12:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"元素的位置、大小单位\r通过dom读取元素的top、left、width、height等取到的值不是数字，而是“10px”这样的字符串；为这些属性设值的时候IE可以是80、90这样的数字，FF必须是“80px”、“90%”等这样的字符串形式，为了兼容统一用字符串形式。 易错：不要写成div1.style.width=80px，而是div1.style.width=‘80px’ 如果要修改元素的大小（宽度加10），则首先要取出元素的宽度，然后用parseInt将宽度转换为数字（parseInt可以将\"20px\"这样数字开头的包含其他内容的字符串解析为20，）；然后加上一个值，再加上px赋值回去。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:13:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"层的操作\r元素的position 样式值：static（无定位，显示在默认位置）、absolute（绝对定位）、fixed（相对于窗口的固定定位，位置不会随着浏览器的滚动而变化，IE6不支持）、relative（相对元素默认位置的定位）。如果要通过代码修改元素的坐标则一般使用absolute，然后修改元素的top（上边缘距离）、left（左边缘距离）两个样式值。left、top都是指的层的左上角的坐标 案例：跟着鼠标飞的图片。提示：鼠标移动的事件是onmousemove（一边移动事件一边触发，而不是移动开始或者移动完成才触发），通过window.event的clientX、clientY属性获得鼠标的位置。 案例：放三个超链接，鼠标放上时候动态生成一个层，层显示在鼠标的位置，鼠标离开的时候移除该层removeChild 案例：点击按钮层动态变大。提示：英文字母连续单词不会在中间自动换行的陷阱 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:14:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"易错\r易错：不要写成div1.style.width=80px，而是div1.style.width=‘80px’ 修改元素的样式不能this.style=“background-color:Red”，哪怕可以的话也是把以前所有样式都冲掉了。单独修改控件的样式this.style. background=‘red’，只修改要修改的样式。技巧，没有文档的情况下的值属性名，随便给一个元素设定id，然后在js中就能id.style.出来能用的属性。 createElement的两种用法，注意innerText的问题 var input = document.createElement(\"\")快速创建元素，并且赋值，但是注意设置的inner部分不会被设置var link = document.createElement(\"百度\") label.setAttribute(“for”, “username”); //设定一些Dom元素属性名特殊的属性,label.for = “username\"会有问题。label.setAttribute(“xuehao”,“33333”) ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:15:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"form对象\rdocument.getElementById(‘btn1’).click() form对象是表单的Dom对象。 方法：submit()提交表单，但是不会触发onsubmit事件。 实现autopost，也就是焦点离开控件以后页面立即提交，而不是只有提交submit按钮以后才提交，当光标离开的时候触发onblur事件，在onblur中调用form的submit方法。代码见备注。 在点击submit后form的onsubmit事件被触发，在onsubmit中可以进行数据校验，数据数据有问题，返回false即可取消提交 \u003cform name=\"form1\" action=\"a.aspx\" method=\"get\" onsubmit=\"if(document.getElementById('txtname').value.length\u003c=0){alert('姓名必填');return false;}\"\u003e 自动提交 \u003cform name=\"form1\" action=\"a.aspx\" method=\"get\"\u003e \u003cinput type=\"text\" onblur=\"form1.submit()\" /\u003e \u003cinput type=\"text\" /\u003e \u003c/form\u003e ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:16:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"不同浏览器差异\r面试题：说说开发项目的时候不同浏览器的不同点，你是怎么解决的？Button,appendChild,insertCell,px 不同浏览器中对DOM支持的方法不一样 获取网页中那个元素触发了事件：在IE里使用srcElement ；在FireFox里使用target 使用Dom获取和更改网页标签元素内文本：在IE里使用innerText ；在FireFox里使用textContent 动态为网页或元素绑定事件：在IE中绑定事件的方法是attachEvent ；在FireFox中绑定事件的方法是addEventListener 更多http://www.360doc.com/content/09/0319/12/16915_2855107.shtml。 不同浏览器中对CSS的支持不一样，所以出现在IE中显示正常的网页，在FF下全部乱掉了。哀悼网页使用的CSS只有IE支持，FF都不支持。 JQuery之类的框架进行了封装，将不同浏览器的差异帮开发人员处理了，开发人员只要调用JQuery的方法，JQuery会帮助在不同浏览器中进行翻译。用JQuery就可以解决不同浏览器上Dom的不同。对于CSS的不同是美工的事，IETester、FF、Chrome。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:17:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"弹出对话框处理\r复习，使用window.showModalDialog(‘dialog.htm’)弹出模态对话框 给对话框传递参数，使用showModalDialog的第二个参数传递参数，在对话框中用window.dialogArguments获得传递的参数值；对话框中给window.parent.returnValue设定返回值，这样在父窗口中就可以通过showModalDialog返回值读取设置的返回值了。例子：弹出对话框询问用户姓名，向用户问好；弹出含有“是”、“否”、“取消”三个按钮的模态窗口，点击按钮的时候窗口关闭，然后主窗口显示用户点击的按钮。 传递多个参数，将参数包装到数组中，然后仍然是通过第二个参数传递，返回多个返回值也可以返回数组：var arr = new Array();arr[0]=30;arr[1]=“tom”; 练习（面试题），弹出一个含有确定、取消、重试三个按钮的对话框，并且得知用户的选择。 给对话框传递参数，使用showModalDialog的第二个参数传递参数，在对话框中用window.dialogArguments获得传递的参数值；对话框中给window.parent.returnValue设定返回值，这样在父窗口中就可以通过showModalDialog返回值读取设置的返回值了： dialog.htm： function getData() { return document.getElementById('mytext1').value; } \u003cbody onLoad=\"javascript:document.getElementById('mytext1').value=window.dialogArguments;\"\u003e \u003cinput type=\"text\" id=\"mytext1\"/\u003e \u003cinput type=\"button\" value=\"确定\" onclick=\"javascript:window.parent.returnValue=getData();window.close();\"\u003e \u003c/body\u003e 主页面： var result=window.showModalDialog('dialog2.htm',777); alert(result); 传递多个参数，将参数包装到数组中即可：var arr = new Array();arr[0]=30;arr[1]=“tom”; ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:18:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"JS正则表达式\rJavaScript中创建正则表达式类的方法： var regex = new RegExp(”\\d{5}\") 或者 var regex = /\\d{5}/ /表达式/是JavaScript中专门为简化正则表达式编写而提供的语法，写在//中的正则表达式就不用管转义符了。 RegExp对象的方法： （1）test(str)判断字符串str是否匹配正则表达式，相当于IsMatch var regex = /.+@.+/; alert(regex.test(\"a@b.com\")); alert(regex.test(\"ab.com\")); （2）exec(str)进行搜索匹配，返回值为匹配结果，没找到返回null() （3）compile编译表达式，提高运行速度。 () ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:19:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"string 的正则表达\rReplace match String对象中提供了一些与正则表达式相关的方法，相当于对于RegExp类的包装，简化调用： match(regexp)，相当于调用exec var s = \"aaa@163.com\"; var regex = /(.+)@(.+)/; var match = s.match(regex); alert(RegExp.$1 + \"，服务器：\" + RegExp.$2); 练习：光标离开Email地址框的时候用正则表达式校验是否是合法的Email地址，如果不是的话Email地址框变红，并且注册按钮禁用，否则Email地址框颜色为白色，启用注册按钮。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:20:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"HTML JS压缩\rHTML、JavaScript的压缩和混淆。去掉空格、缩短变量名，让js、html尺寸更小，提高下载速度。 HTML、JS压缩、混淆有动态和静态两种方案。HTML压缩器，比如HTML Compress，JavaScript压缩工具：Google Closure Compiler、YUI Compressor 等。 很多js库都提供了.min.js、compress.js的压缩版本。 ","date":"2019-04-04","objectID":"/2019/04/web4-dom/:21:0","tags":["Web","DOM"],"title":"自学 DOM","uri":"/2019/04/web4-dom/"},{"categories":"Web","content":"什么是JAVASCRIPT\rHTML只是描述网页长相的标记语言，没有计算、判断能力，如果所有计算、判断（比如判断文本框是否为空、判断两次密码是否输入一致）都放到服务器端执行的话网页的话页面会非常慢、用起来也很难用，对服务器的压力也很大，因此要求能在浏览器中执行一些简单的运算、判断。JavaScript就是一种在浏览器端执行的语言。HTML内容，css衣服，修饰，js控制 JavaScript的Java没直接的关系，唯一的关系就是JavaScript原名LiveScript，后来吸收了Java的一些特性，升级为JavaScript。JavaScript有时被简称为JS。 JavaScript是解释型语言，无需编译就可以随时运行，这样哪怕语法有错误，没有语法错误的部分还是能正确运行。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:1:0","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"JAVASCRIPT开发环境\rVS中JavaScript、JQuery的自动完成功能：在VS2010中直接有，VS2008需要安装VisualStudio 2008SP1（http://www.microsoft.com/downloads/details.aspx?displaylang=zh-cn\u0026familyid=27673c47-b3b5-4c67-bd99-84e525b5ce61）和VS90SP1-KB958502-x86（http://code.msdn.microsoft.com/KB958502/Release/ProjectReleases.aspx?ReleaseId=1736）补丁会更强更好用。如果实在“.” 不出来也没关系，不影响运行。注意：先安装2008SP1，再安装VS90SP1-KB958502-x86。 JS是非常灵活的动态语言，不像C#等静态语言那样严谨，开发工具中的JS完成功能只是一个辅助、建议，“.”出来的成员调用可能不能用，“.”不出来的成员也许也能调用，因此不要因为“点儿不出来”而担心代码有问题。 VS2008的HTML编辑器中触发JavaScript自动完成：Ctrl+J。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:2:0","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"入门\r\u003cscript type=\"text/javascript\"\u003e alert(new Date().toLocaleDateString()); \u003c/script\u003e \u003cscript language=\"....\u003e已经不推荐使用。 JavaScript代码放到\u003cscript\u003e标签中，script可以放到\u003chead\u003e、\u003cbody\u003e等任意位置，而且可以有不止一个\u003cscript\u003e标签。alert函数是弹出消息窗口，new Date()是创建一个Date类的对象，默认值就是当前时间。 JS是大小写敏感的。 放到\u003chead\u003e中的\u003cscript\u003e在body加载之前就已经运行了。写在body中的\u003cscript\u003e是随着页面的加载而一个个执行的。 除了可以在页面中声明JavaScript以外，还可以将JavaScript写到单独的js文件中，然后在页面中引入：\u003cscript src=\"test.js\" type=\"text/javascript\"\u003e\u003c/script\u003e。声明到单独的js文件的好处是多页面也可以共享、减小网络流量。js文件的CDN(*)内容分发布网络(CDN),将别的服务器上的库 注意：不要写成\u003cscript src=\"test.js\" type=\"text/javascript\"/\u003e否则会有问题，这是一个比较特殊的地方。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:0","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"事件\r在超链接的点击里执行JavaScript：\u003ca href=\"javascript:alert(88)\"\u003e发发\u003c/a\u003e JavaScript中也有事件的概念，当按钮被点击的时候也可以执行JavaScript： \u003cinput type=\"button\" onclick=\"alert(99)\" value=\"久久\"/\u003e 只有超链接的href中的JavaScript中才需要加““javascript:”，因为它不是事件，而是把““javascript:”看成像“http:”、“ftp:”、“thunder://”、“ed2k://”、“mailto:”一样的网络协议，交由js解析引擎处理。只有href中这是这是一个特例。 \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e var sum = 0; for(int i = 0;i\u003c=100;i++){ sum += i; } alert(sum); function test() { var sum = 0; for(int i = 0;i\u003c=100;i++){ sum += i; } alert(sum); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003ca href=\"javascript:test()\"\u003eClick me\u003c/a\u003e \u003ca href=\"win.htm\" onclick=\"alert('123')\"\u003eClick me\u003c/a\u003e \u003cinput type=\"button\" value=\"按钮\" ondblclick=\"test()\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:1","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"变量\rJavaScript中即可以使用双引号声明字符串，也可以使用单引号声明字符串。主要是为了方便和html集成，避免转义符的麻烦。只有一种类型var JavaScript中有null、undefined两种，null表示变量的值为空，undefined则表示变量还没有指向任何的对象，未初始化。两者的区别参考资料。 JavaScript是弱类型，声明变量的时候无法：int i=0；只能通过var i=0;声明变量，和C#中的var不一样，不是C#中那样的类型推断。 JavaScript中也可以不用var声明变量，直接用，这样的变量是“全局变量”，因此除非确实想用全局变量，否则使用的时候最好加上var。 JS是动态类型的，因此var i=0;i=“abc”;是合法的。并且可以把方法放到var中， \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e var x = \"abc\"; if (!null) { alert(\"null\"); } if (!undefined) { alert(\"undefined\"); } if (x == null) { alert(\"null\"); } if (typeof(x) == \"undefined\") { alert(\"undefined\"); } if (!x) { alert(\"未初始化 0\"); } if (x) { alert(x); } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:2","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"除错和调试\r如果JavaScript中的代码有语法错误，浏览器会弹出报错信息，查看报错信息就能帮助排查错误。 JavaScript的调试，使用VS可以很方便的进行JavaScript的调试，调试时需要注意几点： IE6的调试选项要打开，Internet选项→高级，去掉“禁用脚本调试”前的勾选。 以调试方式运行网页。 设置断点、监视变量等操作和C#一样。 案例：用循环语句的方法计算1到100之间整数的和 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:3","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"判断变量初始化\rJavaScript中判断变量、参数是否初始化 的三种方法： var x; if (x == null) { alert(\"null\"); } if (typeof (x) == \"undefined\") { alert('undefined'); } if (!x) {alert('不x');} if(x){}//变量被初始化了或者变量不为空或者变量不为0. 推荐用最后一种方法。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:4","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"函数声明\rJavaScript中声明函数的方式： function add(i1, i2) { return i1 + i2; } int add(int i1,int i2)//C#写法 不需要声明返回值类型、参数类型。函数定义以function开头。 var r = add(1, 2); alert(r); r = add(\"你好\", \"tom\"); alert(r); JavaScript中不像C#中那样要求所有路径都有返回值，没有返回值就是undefined。 易错：自定义函数名不要和js内置、dom内置方法重名，比如selectall、focus等函数名不要用。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:5","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"匿名函数\rvar f1 = function(i1, i2) { return i1 + i2; } alert(f1(1,2)); 类似于C#中的匿名函数。 这种匿名函数的用法在JQuery中的非常多 alert(function(i1, i2) { return i1 + i2; }(10,10));//直接声明一个匿名函数，立即使用。用匿名函数省得定义一个用一次就不用的函数，而且免了命名冲突的问题，js中没有命名空间的概念，因此很容易函数名字冲突。通过例子发现一旦命名冲突以最后声明的为准 必须\u003cscript src=\"my1.js\" type=\"text/javascript\"\u003e\u003c/script\u003e不能：\u003cscript src=\"my1.js\" type=\"text/javascript\"/\u003e ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:6","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"面向对象基础\rJavaScript中没有类的语法，是用函数闭包（closure）模拟出来的，下面讲解的时候还是用C#中的类、构造函数的概念，JavaScript中String、Date等“类”都被叫做“对象”，挺怪，方便初学者理解，不严谨。JavaScript中声明类（类不是类，是对象）： function Person(name,age) { this.name = name; this.age =age; this.sayHello=function(){ alert(\"你好，我是\"+this.name+\"，我\"+this.age+\"岁了\"); } } var p1 = new Person(\"tom\",20); p1.sayHello(); 必须要声明类名，function Person(name,age)可以看做是声明构造函数，Name、Age这些属性也是使用者动态添加了。var p1 = new Person(“tom”, 30);//不要丢了new，否则就变成调用函数了，p1为undefined。new 相当于创建了函数的一个实例 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:7","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"string 对象\rlength属性； charAt方法；取第几个字符 indexOf lastIndexOf Substr(start,length)、substring(start,end) split match、replace(只会替换一个，替换多个要用正则表达式)、search方法，正则表达式相关 var str = \"我爱北京天安门,北京天安门爱我\"; var reg = /我/g; alert(str.replace(\"我\", \"你\")); //replace()当第一个参数是字符串，只替换源字符串中的第一个匹配到的字符 如果是reg，就可以全部替换成功alert(str.replace(reg, \"你\")); 是正则表达式，是一个object ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:8","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"ARRAY对象\rJavaScript中的Array对象就是数组，首先是一个动态数组，而且是一个像C#中数组、ArrayList、Hashtable等的超强综合体。 var names = new Array(); names[0] = \"tom\"; names[1] = \"jerry\"; names[2] = \"lily\"; for (var i = 0; i \u003c names.length; i++) { alert(names[i]); } 无需预先制定大小，动态。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:9","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"dictionary\rJS中的Array是一个宝贝，不仅是一个数组，还是一个Dictionary，还是一个Stack。 var pinyins = new Array(); pinyins[\"人\"] = \"ren\"; pinyins[\"口\"] = \"kou\"; pinyins[\"手\"] = \"shou\"; alert(pinyins[\"人\"]); alert(pinyins.人); 像Hashtable、Dictionary那样用，而且像它们一样效率高。 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:10","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"array简化\rArray还可以有简化的创建方式 var arr = [3, 5, 6, 8, 9]; 普通数组初始化 这种数组可以看做是pinyins[“人”] = “ren”;的特例，也就是key为0、1、2…… 字典风格的简化创建方式： var arr = {\"tom\":30,\"jim\":20}; ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:11","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"数组，for其他\r对于数组风格的Array来说，可以使用join方法拼接为字符串 var arr = [\"tom\",\"jim\",\"lily\"];\ralert(arr.join(\",\"));//JS中join是array的方法，不像.Net中是string的方法 for循环可以像C#中的foreach一样用 for循环还可以获得一个对象所有的成员，类似于.Net中的反射 for (var e in document) { alert(e); } 有了它没有文档也可以进行开发。 var p1 = new Object();//创建一个Object对象，动态增加属性、方法s p1.Name = \"tom\"; p1.Age = 30; p1.SayHello = function() { alert(\"hello\"); }; p1.SayHello(); for(var e in p1) {//对象的成员都是对象的key alert(e); } ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:12","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"Web","content":"扩展方法\r通过类对象的prototype设置扩展方法，下面为String对象增加quote（两边加字符）方法 String.prototype.quote = function(quotestr) { if (!quotestr) { quotestr = \"\\\"\"; } return quotestr + this + quotestr; }; alert(\"abc\".quote());alert(\"abc\".quote(\"|\")); 扩展方法的声明要在使用扩展方法之前执行。JS的函数没有专门的函数默认值的语法，但是可以不给参数传值，不传值的参数值就是undefined，自己做判断来给默认值。 一门新的语言学：数据类型，程序接口，类库 ","date":"2019-03-16","objectID":"/2019/03/web3-javascript/:3:13","tags":["Web","javascript"],"title":"自学 javascript","uri":"/2019/03/web3-javascript/"},{"categories":"DotNet基础","content":"在windows form开发过程中还是有很多坑需要注意，包括一些重要代码记不得，在这个文件中进行汇总更新。 ","date":"2018-12-05","objectID":"/2018/12/dotnetbase5-winform/:0:0","tags":["DotNet基础","winform"],"title":"DotNet基础 winform","uri":"/2018/12/dotnetbase5-winform/"},{"categories":"DotNet基础","content":"命名规则\rM结尾表示model A结尾表示消息 Object表示 ,底层接口 Presenter表示，逻辑类 Transaction表示，具体逻辑 View表示界面接口 Helper：表示静态函数 Statements：表示字符串 E表示enum ~BTN按钮 私有变量m_ 获得Get 建立Build 生成Generate listbox 为 LB ","date":"2018-12-05","objectID":"/2018/12/dotnetbase5-winform/:1:0","tags":["DotNet基础","winform"],"title":"DotNet基础 winform","uri":"/2018/12/dotnetbase5-winform/"},{"categories":"DotNet基础","content":"一个项目体验\rusing System; using System.Windows.Forms; namespace AerationSystem { static class Program { /// \u003csummary\u003e /// 应用程序的主入口点。 /// \u003c/summary\u003e [STAThread] static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); GetAllFrom getform = new GetAllFrom(); getform.MakeLoginForm(); getform.login.ShowDialog(); if(getform.login.DialogResult==DialogResult.OK) { getform.MakeAllForm(); Application.Run(getform.currentMain); //Application.Run(new Form1()); } } } } 读取xml标签类 public class XMLHelper { /// \u003csummary\u003e /// 读取多行同一标签属性 /// \u003c/summary\u003e /// \u003cparam name=\"filename\"\u003e地址\u003c/param\u003e /// \u003cparam name=\"nodeflag\"\u003e标签\u003c/param\u003e /// \u003cparam name=\"strflag\"\u003e属性\u003c/param\u003e /// \u003creturns\u003e多行同一标签属性\u003c/returns\u003e public static string[] ReadMultipleTagOneAttribute(string filename,string nodeflag, string strflag) { try { XmlDocument xl = new XmlDocument(); xl.Load(filename); XmlNodeList xnl = xl.GetElementsByTagName(\"appSettings\")[0].ChildNodes; List\u003cstring\u003e vs = new List\u003cstring\u003e(); foreach (XmlNode cn in xnl) { if (cn.Name.Equals(nodeflag)) { vs.Add(cn.Attributes.GetNamedItem(strflag).Value); } } return vs.ToArray(); } catch (Exception ex) { Console.WriteLine(ex.StackTrace + ex.Message); } return null; } /// \u003csummary\u003e /// 读取同一标签多个属性,如果有多个同标签则返回null /// \u003c/summary\u003e /// \u003cparam name=\"filename\"\u003e地址\u003c/param\u003e /// \u003cparam name=\"nodeflag\"\u003e标签\u003c/param\u003e /// \u003cparam name=\"strflag\"\u003e多个属性\u003c/param\u003e /// \u003creturns\u003e多个属性值\u003c/returns\u003e public static string[] ReadMultipleAttributeOneTag(string filename, string nodeflag, string[] strflag) { try { XmlDocument xl = new XmlDocument(); xl.Load(filename); XmlNodeList xnl = xl.GetElementsByTagName(\"appSettings\")[0].ChildNodes; List\u003cstring\u003e vs = new List\u003cstring\u003e(); int tagcount = 0; foreach (XmlNode cn in xnl) { if (cn.Name.Equals(nodeflag)) { foreach (string s in strflag) { vs.Add(cn.Attributes.GetNamedItem(s).Value); } tagcount++; } } if (tagcount \u003e 1) { throw new Exception(\"出现多个相同标签\"); } return vs.ToArray(); } catch (Exception ex) { Console.WriteLine(ex.StackTrace + ex.Message); } return null; } } SQLHelper类 public class SQLDatabaseHelper { /// \u003csummary\u003e /// 返回多个表 /// \u003c/summary\u003e /// \u003cparam name=\"dbname\"\u003e数据库URL\u003c/param\u003e /// \u003cparam name=\"sqlstr\"\u003e执行语句\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static DataSet QueryDs(String dbname, String sqlstr) { OleDbConnection Connection = new OleDbConnection(dbname); try { Connection.Open(); OleDbDataAdapter oleDbAdapter = new OleDbDataAdapter(sqlstr, Connection); DataSet ds = new DataSet(); oleDbAdapter.Fill(ds); return ds; } catch (Exception ex) { Console.WriteLine(\"打开数据库连接异常:\" + ex.Message + \"\\r\\n\"); } finally { Connection.Close(); } return null; } /// \u003csummary\u003e /// 执行语句返会受影响函数 /// \u003c/summary\u003e /// \u003cparam name=\"dbname\"\u003e数据库URL\u003c/param\u003e /// \u003cparam name=\"sqlstr\"\u003e执行语句\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static int Execute(String dbname, String sqlstr) { OleDbConnection Connection = new OleDbConnection(dbname); try { Connection.Open(); OleDbCommand oleDbCommand = new OleDbCommand(sqlstr, Connection); return oleDbCommand.ExecuteNonQuery(); } catch (Exception ex) { Console.WriteLine(ex.Message); } finally { Connection.Close(); } return 0; } /// \u003csummary\u003e /// 执行多条语句 /// \u003c/summary\u003e /// \u003cparam name=\"dbname\"\u003e数据库url\u003c/param\u003e /// \u003cparam name=\"sqlstrs\"\u003e受影响的行数\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public static int ExecuteAll(string dbname, string[] sqlstrs) { int count = 0; foreach (string s in sqlstrs) { count = count + Execute(dbname, s); } return count; } /// \u003csummary\u003e /// 返回表 /// \u003c/summary\u003e /// \u003cparam name=\"dbname\"\u003e数据库URL\u003c/param\u003e /// \u003cparam name=\"sqlstr\"\u003e执行语句\u003c/param\u003e /// \u003creturns\u003e受影响行数\u003c/returns\u003e public static DataTable QueryDt(String dbname, String sqlstr) { OleDbConnection Connection = new OleDbConnection(dbname); try { Connection.Open(); OleDbDataAdapter oleDbAdapter = new OleDbDataAdapter(sqlstr, Connection); OleDbCommandBuilder oleDbBuilder = new OleDbCommandBuilder(oleDbAdapter); DataSet ds = new DataSet(); oleDbAdapter.Fill(ds); return ds.Tables[0]; } catch (Exception ex) { Console.Writ","date":"2018-12-05","objectID":"/2018/12/dotnetbase5-winform/:2:0","tags":["DotNet基础","winform"],"title":"DotNet基础 winform","uri":"/2018/12/dotnetbase5-winform/"},{"categories":"DotNet基础","content":"自定义控件\rScreen.PrimaryScreen.WorkingArea.Width;获取桌面宽度，hight高度 this.size程序宽度 base.Invalidate(this.MenuRect)重绘矩形区域 this.FormBorderStyle = FormBorderStyle.None;无边框 this.SetStyle( ControlStyles.AllPaintingInWmPaint | ControlStyles.OptimizedDoubleBuffer | ControlStyles.ResizeRedraw | ControlStyles.Selectable | ControlStyles.ContainerControl | ControlStyles.UserPaint, true); this.SetStyle(ControlStyles.Opaque, false); this.UpdateStyles(); 绘制控件样式 Graphics g = e.Graphics;获取画布，如果是创建的使用完后要注销 FormWindowState.Maximized窗口状态 FormStartPosition.CenterParent窗体开启位置 继承form的重载类中WndProc有窗体循环，在该循环中提前捕获消息进行拦截。 设置背景图片 totalpic.ImageLocation = System.Windows.Forms.Application.StartupPath + “\\img\\” + comboBox2.Text.ToString() + “.jpg”; 使得panel1不可见的时候panel2填满panel1的区域，让panel1的dock设置为top，panel2的dock设置为fill。 ","date":"2018-12-05","objectID":"/2018/12/dotnetbase5-winform/:3:0","tags":["DotNet基础","winform"],"title":"DotNet基础 winform","uri":"/2018/12/dotnetbase5-winform/"},{"categories":"DotNet基础","content":"多线程和异步函数\r当异步线程在工作完成时如何通知调用线程 当异步线程出现异常的时候该如何处理 异步线程工作的进度如何实时的通知调用线程 如何在调用线程中取消正在工作的异步线程，并进行回滚操作 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:1:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"异步函数模型\r异步函数编程模式，只要是使用委托对象封装的函数都可以实现该函数的异步调用。因为委托类型有BeginInvoke和EndInvoke这两个方法来支持异步调用。 BeginInvoke无参数 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate void DoWork(); static void Main(string[] args) { DoWork d = new DoWork(WorkPro); d.BeginInvoke(null, null); for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread: {i}\"); } Console.WriteLine(\"Main Thread Done\"); Console.ReadKey(); } private static void WorkPro() { for (int i = 0; i \u003c 10; i++) { Thread.Sleep(10); Console.WriteLine($\"Asyn Thread: {i}\"); } Console.WriteLine(\"Asyn Thread Done\"); } } } 结果 Main Thread: 0 Asyn Thread: 0 Main Thread: 1 Asyn Thread: 1 Main Thread: 2 Asyn Thread: 2 Main Thread: 3 Asyn Thread: 3 Main Thread: 4 Main Thread Done Asyn Thread: 4 Asyn Thread: 5 Asyn Thread: 6 Asyn Thread: 7 Asyn Thread: 8 Asyn Thread: 9 Asyn Thread Done BeginInvoke有参数， BeginInvoke，IAsyncResult ，EndInvoke，使用这三个函数会等，异步调用EndInvoke返回再开启主线程，异步调用时间比主线程长，主线程会处于阻塞状态，阻塞位置在EndInvoke函数 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { DoWork d = new DoWork(WorkPro); IAsyncResult r = d.BeginInvoke(1000, null, null); int result = d.EndInvoke(r); Console.WriteLine($\"Asyn result:{result}\"); for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread: {i}\"); } Console.WriteLine(\"Main Thread Done\"); Console.ReadKey(); } private static int WorkPro(int count) { int sum = 0; for (int i = 0; i \u003c 10; i++) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread: {i}\"); } Console.WriteLine(\"Asyn Thread Done\"); return sum; } } } 结果： Asyn Thread: 0 Asyn Thread: 1 Asyn Thread: 2 Asyn Thread: 3 Asyn Thread: 4 Asyn Thread: 5 Asyn Thread: 6 Asyn Thread: 7 Asyn Thread: 8 Asyn Thread: 9 Asyn Thread Done Asyn result:45 Main Thread: 0 Main Thread: 1 Main Thread: 2 Main Thread: 3 Main Thread: 4 Main Thread Done 当调整EndInvoke的位置时， using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { DoWork d = new DoWork(WorkPro); IAsyncResult r = d.BeginInvoke(1000, null, null); for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread: {i}\"); } int result = d.EndInvoke(r); Console.WriteLine($\"Asyn result:{result}\"); Console.WriteLine(\"Main Thread Done\"); Console.ReadKey(); } private static int WorkPro(int count) { int sum = 0; for (int i = 0; i \u003c 10; i++) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread: {i}\"); } Console.WriteLine(\"Asyn Thread Done\"); return sum; } } } 结果： Main Thread: 0 Asyn Thread: 0 Main Thread: 1 Asyn Thread: 1 Main Thread: 2 Asyn Thread: 2 Main Thread: 3 Asyn Thread: 3 Main Thread: 4 Asyn Thread: 4 Asyn Thread: 5 Asyn Thread: 6 Asyn Thread: 7 Asyn Thread: 8 Asyn Thread: 9 Asyn Thread Done Asyn result:45 Main Thread Done 主线程执行时间比异步调用的长，并未看见阻塞 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { DoWork d = new DoWork(WorkPro); IAsyncResult r = d.BeginInvoke(1000, null, null); for (int i = 0; i \u003c 10; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread: {i}\"); } int result = d.EndInvoke(r); Console.WriteLine($\"Asyn result:{result}\"); Console.WriteLine(\"Main Thread Done\"); Console.ReadKey(); } private static int WorkPro(int count) { int sum = 0; for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread: {i}\"); } Console.WriteLine(\"Asyn Thread Done\"); return sum; } } } Main","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:1:1","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"自动通知主线程完成\r上面两个例子这并不是理想的状态，理想状态是，异步调用完成后自动通知主线程完成，主线程调用。 BeginInvoke 方法启动异步调用。该方法具有与你要异步执行的方法相同的参数，另加两个可选参数。 第一个参数是一个 AsyncCallback 委托，此委托引用在异步调用完成时要调用的方法。 第二个参数是一个用户定义的对象object，该对象将信息传递到回调方法。 BeginInvoke 将立即返回，而不会等待异步调用完成。 BeginInvoke 返回可用于监视异步调用的进度的 IAsyncResult。 EndInvoke 方法用于检索异步调用的结果。 它可以在调用 BeginInvoke之后的任意时间调用。 如果异步调用尚未完成，那么 EndInvoke 将阻止调用线程，直到完成异步调用。 EndInvoke 的参数包括要异步执行的方法的 out 和 ref 参数，以及 BeginInvoke 返回的 IAsyncResult。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { DoWork d = new DoWork(WorkPro); IAsyncResult r = d.BeginInvoke(1000, CallBack, d); for (int i = 0; i \u003c 10; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread: {i}\"); } Console.WriteLine(\"Main Thread Done\"); Console.ReadKey(); } private static int WorkPro(int count) { int sum = 0; for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread: {i}\"); } Console.WriteLine(\"Asyn Thread Done\"); return sum; } public static void CallBack(IAsyncResult r) { DoWork d = (DoWork)r.AsyncState; Console.WriteLine($\"Asyn result:{d.EndInvoke(r)}\"); } } } Main Thread: 0 Asyn Thread: 0 Main Thread: 1 Asyn Thread: 1 Main Thread: 2 Asyn Thread: 2 Main Thread: 3 Asyn Thread: 3 Main Thread: 4 Asyn Thread: 4 Asyn Thread Done Asyn result:10 Main Thread: 5 Main Thread: 6 Main Thread: 7 Main Thread: 8 Main Thread: 9 Main Thread Done 改进查看CallBack的执行情况 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { DoWork d = new DoWork(WorkPro); IAsyncResult r = d.BeginInvoke(1000, CallBack, d); for (int i = 0; i \u003c 10; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread: {i}\"); } Console.WriteLine(\"Main Thread Done\"); Console.ReadKey(); } private static int WorkPro(int count) { int sum = 0; for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread: {i}\"); } Console.WriteLine(\"Asyn Thread Done\"); return sum; } public static void CallBack(IAsyncResult r) { for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"CallBack: {i}\"); } DoWork d = (DoWork)r.AsyncState; Console.WriteLine($\"Asyn result:{d.EndInvoke(r)}\"); } } } Main Thread: 0 Asyn Thread: 0 Main Thread: 1 Main Thread: 2 Asyn Thread: 1 Asyn Thread: 2 Main Thread: 3 Asyn Thread: 3 Main Thread: 4 Asyn Thread: 4 Asyn Thread Done Main Thread: 5 Main Thread: 6 CallBack: 0 Main Thread: 7 CallBack: 1 Main Thread: 8 CallBack: 2 Main Thread: 9 Main Thread Done CallBack: 3 CallBack: 4 Asyn result:10 回调函数也处于另一个线程中，与主线程并行执行，并且执行时间不等 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:1:2","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"正常的线程调用\r.net在System.Threading和System.Threading.Tasks这两个命名空间中提供了Thread，ThreadPool，和Task三个类来处理多线程的问题，其中Thread是建立一个专用线程，ThreadPool是使用线程池中工作线程，而Task类是采用任务的方式，其内部也是使用线程池中的工作线程。 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:2:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"Thread类\r使用方法很简单，它开辟的是一个专用线程，不是线程池中的工作线程，不由线程池去管理。该类提供4个重载版本，常见的使用前面两个就好了。 public Thread( ThreadStart start )：其中ThreadStart是一个无参无返回值的委托类型。 public Thread( ParameterizedThreadStart start )：其中ParameterizedThreadStart 是一个带有一个Object类型的参数，无返回值的委托类型。 从Thread类提供了两个构造函数可以看出，Thread类能够异步调用无参无返回值的函数，也能够异步调用带一个Object类型的无返回值的函数。下面就给出一个例子简单的演示一下如何使用Thread异步执行一个带参数的函数。 using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { class Program { int interval = 200; static void Main(string[] args) { Program p = new Program(); Thread nonParameterThread = new Thread(new ThreadStart(p.NonParameterRun)); nonParameterThread.Start(); } /// \u003csummary\u003e /// 不带参数的启动方法 /// \u003c/summary\u003e public void NonParameterRun() { for (int i = 0; i \u003c 10; i++) { Console.WriteLine(\"系统当前时间毫秒值：\"+DateTime.Now.Millisecond.ToString()); Thread.Sleep(interval);//让线程暂停 } } } } 结果： 系统当前时间毫秒值：384 系统当前时间毫秒值：591 系统当前时间毫秒值：792 系统当前时间毫秒值：993 系统当前时间毫秒值：194 系统当前时间毫秒值：394 系统当前时间毫秒值：595 系统当前时间毫秒值：796 系统当前时间毫秒值：997 系统当前时间毫秒值：198 请按任意键继续. . . ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:2:1","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"带参数的线程\r线程输出10个值后就终止执行了，用ThreadStart委托作为构造函数来实例化thread是不带参数的，带参数的委托ParameterizedThreadStart，其带有一个Object参数的方法 using System; using System.Threading; namespace StartThread { class Program { int interval = 200; static void Main(string[] args) { Program p = new Program(); Thread parameterThread = new Thread(new ParameterizedThreadStart(p.ParameterRun)); parameterThread.Name = \"Thread A:\"; parameterThread.Start(5); } /// \u003csummary\u003e /// 带参数的启动方法 /// \u003c/summary\u003e /// \u003cparam name=\"ms\"\u003e让线程在运行过程中的休眠间隔\u003c/param\u003e public void ParameterRun(object ms) { int j = 10; int.TryParse(ms.ToString(), out j);//这里采用了TryParse方法，避免不能转换时出现异常 for (int i = 0; i \u003c j; i++) { Console.WriteLine(Thread.CurrentThread.Name + \"系统当前时间毫秒值：\" + DateTime.Now.Millisecond.ToString()); Thread.Sleep(j);//让线程暂停 } } } } 结果： Thread A:系统当前时间毫秒值：127 Thread A:系统当前时间毫秒值：136 Thread A:系统当前时间毫秒值：142 Thread A:系统当前时间毫秒值：148 Thread A:系统当前时间毫秒值：154 请按任意键继续. . . ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:3:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"两个线程参数不一样\r第一个线程启动后，线程实例就不需要存在了 两个线程间隔时间不一样 using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { class Program { int interval = 200; static void Main(string[] args) { Program p = new Program(); Thread parameterThread = new Thread(new ParameterizedThreadStart(p.ParameterRun)); parameterThread.Name = \"Thread A:\"; parameterThread.Start(30); //启动第二个线程 parameterThread = new Thread(new ParameterizedThreadStart(p.ParameterRun)); parameterThread.Name = \"Thread B:\"; parameterThread.Start(60); } /// \u003csummary\u003e /// 带参数的启动方法 /// \u003c/summary\u003e /// \u003cparam name=\"ms\"\u003e让线程在运行过程中的休眠间隔\u003c/param\u003e public void ParameterRun(object ms) { int j = 10; int.TryParse(ms.ToString(), out j);//这里采用了TryParse方法，避免不能转换时出现异常 for (int i = 0; i \u003c 10; i++) { Console.WriteLine(Thread.CurrentThread.Name+\"系统当前时间毫秒值：\" + DateTime.Now.Millisecond.ToString()); Thread.Sleep(j);//让线程暂停 } } } } 结果： Thread A:系统当前时间毫秒值：294 Thread B:系统当前时间毫秒值：294 Thread A:系统当前时间毫秒值：326 Thread B:系统当前时间毫秒值：357 Thread A:系统当前时间毫秒值：357 Thread A:系统当前时间毫秒值：388 Thread B:系统当前时间毫秒值：418 Thread A:系统当前时间毫秒值：419 Thread A:系统当前时间毫秒值：450 Thread B:系统当前时间毫秒值：479 Thread A:系统当前时间毫秒值：481 Thread A:系统当前时间毫秒值：511 Thread B:系统当前时间毫秒值：540 Thread A:系统当前时间毫秒值：543 Thread A:系统当前时间毫秒值：574 Thread B:系统当前时间毫秒值：600 Thread B:系统当前时间毫秒值：661 Thread B:系统当前时间毫秒值：723 Thread B:系统当前时间毫秒值：784 Thread B:系统当前时间毫秒值：845 请按任意键继续. . . ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:4:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"传递多参数\r如果需要传递两个参数怎么办呢，有两种方法 调用ParameterizedThreadStart，将参数封装成类，或者结构进行调用 构造线程类，将自己的线程和参数封装在一起 using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { class MyThreadParameter { private int interval; private int loopCount; /// \u003csummary\u003e /// 循环次数 /// \u003c/summary\u003e public int LoopCount { get { return loopCount; } } /// \u003csummary\u003e /// 线程的暂停间隔 /// \u003c/summary\u003e public int Interval { get { return interval; } } /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e /// \u003cparam name=\"interval\"\u003e线程的暂停间隔\u003c/param\u003e /// \u003cparam name=\"loopCount\"\u003e循环次数\u003c/param\u003e public MyThreadParameter(int interval,int loopCount) { this.interval = interval; this.loopCount = loopCount; } } class Program { int interval = 200; static void Main(string[] args) { Program p = new Program(); Thread parameterThread = new Thread(new ParameterizedThreadStart(p.MyParameterRun)); parameterThread.Name = \"Thread A:\"; MyThreadParameter paramter = new MyThreadParameter(50, 5); parameterThread.Start(paramter); } /// \u003csummary\u003e /// 带多个参数的启动方法 /// \u003c/summary\u003e /// \u003cparam name=\"ms\"\u003e方法参数\u003c/param\u003e public void MyParameterRun(object ms) { MyThreadParameter parameter = ms as MyThreadParameter;//类型转换 if (parameter != null) { for (int i = 0; i \u003c parameter.LoopCount; i++) { Console.WriteLine(Thread.CurrentThread.Name + \"系统当前时间毫秒值：\" + DateTime.Now.Millisecond.ToString()); Thread.Sleep(parameter.Interval);//让线程暂停 } } } } } 结果： Thread A:系统当前时间毫秒值：215 Thread A:系统当前时间毫秒值：270 Thread A:系统当前时间毫秒值：321 Thread A:系统当前时间毫秒值：372 Thread A:系统当前时间毫秒值：423 请按任意键继续. . . using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { class MyThreadParameter { private int interval; private int loopCount; private Thread thread; /// \u003csummary\u003e /// 构造函数 /// \u003c/summary\u003e /// \u003cparam name=\"interval\"\u003e线程的暂停间隔\u003c/param\u003e /// \u003cparam name=\"loopCount\"\u003e循环次数\u003c/param\u003e public MyThreadParameter(int interval,int loopCount) { this.interval = interval; this.loopCount = loopCount; thread = new Thread(new ThreadStart(Run)); } public void Start() { if (thread != null) { thread.Start(); } } private void Run() { for (int i = 0; i \u003c loopCount; i++) { Console.WriteLine(\"系统当前时间毫秒值：\" + DateTime.Now.Millisecond.ToString()); Thread.Sleep(interval);//让线程暂停 } } } class Program { static void Main(string[] args) { MyThreadParameter parameterThread = new MyThreadParameter(30, 5); parameterThread.Start(); } } } 结果 系统当前时间毫秒值：438 系统当前时间毫秒值：471 系统当前时间毫秒值：502 系统当前时间毫秒值：533 系统当前时间毫秒值：563 请按任意键继续. . . ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:5:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"多线程同干一件事\r多线程同干一件事的时候对发生一些问题 using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { public class ThreadLock { private Thread threadOne; private Thread threadTwo; private List\u003cstring\u003e ticketList; private object objLock = new object(); public ThreadLock() { threadOne = new Thread(new ThreadStart(Run)); threadOne.Name = \"Thread_1\"; threadTwo = new Thread(new ThreadStart(Run)); threadTwo.Name = \"Thread_2\"; } static void Main(string[] args) { ThreadLock th = new ThreadLock(); th.Start(); } public void Start() { ticketList = new List\u003cstring\u003e(10); for (int i = 1; i \u003c= 10; i++) { ticketList.Add(i.ToString().PadLeft(3, '0'));//实现3位的票号，如果不足3位数，则以0补足3位 } threadOne.Start(); threadTwo.Start(); } private void Run() { while (ticketList.Count \u003e 0)//① { string ticketNo = ticketList[0];//② Console.WriteLine(\"{0}:售出一张票，票号：{1}\", Thread.CurrentThread.Name, ticketNo); ticketList.RemoveAt(0);//③ Thread.Sleep(1); } } } } 结果： Thread_1:售出一张票，票号：001 Thread_2:售出一张票，票号：001 Thread_1:售出一张票，票号：003 Thread_2:售出一张票，票号：004 Thread_1:售出一张票，票号：005 Thread_2:售出一张票，票号：006 Thread_1:售出一张票，票号：007 Thread_2:售出一张票，票号：008 Thread_1:售出一张票，票号：008 Thread_2:售出一张票，票号：010 Thread_1:售出一张票，票号：010 未经处理的异常: System.ArgumentOutOfRangeException: 索引超出范围。必须为非负值并小于集合大小。 参数名: index 在 System.ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource) 在 System.Collections.Generic.List`1.RemoveAt(Int32 index) 在 StartThread.ThreadLock.Run() 位置 C:\\Users\\DuJinfeng\\Desktop\\C#源码\\test\\test\\练习\\test\\Program.cs:行号 79 在 System.Threading.ThreadHelper.ThreadStart_Context(Object state) 在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) 在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx) 在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state) 在 System.Threading.ThreadHelper.ThreadStart() 请按任意键继续. . . 该程序在③处会出现问题，如果第一个线程在③处的时间片段正好用完第二个线程调用就会出现一张票被卖两次的问题 同步问题的解决方法： lock、 Mutex、 Monitor、 Semaphore、 Interlocked ReaderWriterLock等 同步策略可以有同步上下文、同步代码区、手动同步 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"上下文同步策略\r上下文同步： 同步上下文的策略主要是依靠SynchronizationAttribute类来实现 using System; using System.Collections.Generic; using System.Text; //需要添加对System.EnterpriseServices.dll这个类库的引用采用使用这个dll using System.EnterpriseServices; namespace StartThread { [Synchronization(SynchronizationOption.Required)]//确保创建的对象已经同步 public class SynchronizationAttributeClass { public void Run() { } } } 所有在同一个上下文域的对象共享同一个锁。这样创建的对象实例属性、方法和字段就具有线程安全性，需要注意的是类的静态字段、属性和方法是不具有线程安全性的。 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:1","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"同步代码区\r同步代码区是另外一种策略，它是针对特定部分代码进行同步的一种方法 lock同步 private void Run() { while (ticketList.Count \u003e 0)//① { lock (objLock) { if (ticketList.Count \u003e 0)//必须要再一次判断在1之后可能进入其他线程 { string ticketNo = ticketList[0];//② Console.WriteLine(\"{0}:售出一张票，票号：{1}\", Thread.CurrentThread.Name, ticketNo); ticketList.RemoveAt(0);//③ Thread.Sleep(1); } } } } Monitor类同步 private void Run() { while (ticketList.Count \u003e 0)//① { Monitor.Enter(objLock); if (ticketList.Count \u003e 0) { string ticketNo = ticketList[0];//② Console.WriteLine(\"{0}:售出一张票，票号：{1}\", Thread.CurrentThread.Name, ticketNo); ticketList.RemoveAt(0);//③ Thread.Sleep(1); } Monitor.Exit(objLock); } } 使用lock关键字的代码实际上是用Monitor来实现的。 lock (objLock){ //同步代码 } //等价于 try{ Monitor.Enter(objLock); //同步代码 } finally { Monitor.Exit(objLock); } Monitor类除了Enter()和Exit()方法之外，还有Wait()和Pulse()方法。 Wait()方法是临时释放当前活得的锁，并使当前对象处于阻塞状态 Pulse()方法是通知处于等待状态的对象可以准备就绪了，它一会就会释放锁 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Collections; using System.Threading; public class ThreadDemo { private Thread threadOne; private Thread threadTwo; private ArrayList stringList; private event EventHandler OnNumberClear;//数据删除完成引发的事件 public static void Main() { ThreadDemo demo = new ThreadDemo(10); demo.Action(); Console.ReadKey(); } public ThreadDemo(int number) { Random random = new Random(100); stringList = new ArrayList(number); for (int i = 0; i \u003c number; i++) { stringList.Add(random.Next().ToString()); } threadOne = new Thread(new ThreadStart(Run));//两个线程共同做一件事情 threadTwo = new Thread(new ThreadStart(Run));//两个线程共同做一件事情 threadOne.Name = \"线程1\"; threadTwo.Name = \"线程2\"; for (int i = 0; i \u003c number; i++) { Console.WriteLine($\"主线程1：{i.ToString()}\"); } OnNumberClear += new EventHandler(ThreadDemo_OnNumberClear); } /// \u003csummary\u003e /// 开始工作 /// \u003c/summary\u003e public void Action() { threadOne.Start(); threadTwo.Start(); } /// \u003csummary\u003e /// 共同做的工作 /// \u003c/summary\u003e private void Run() { string stringValue = null; while (true) { Monitor.Enter(this);//锁定，保持同步 stringValue = (string)stringList[0]; Console.WriteLine(Thread.CurrentThread.Name + \"删除了\" + stringValue); stringList.RemoveAt(0);//删除ArrayList中的元素 if (stringList.Count == 0) { OnNumberClear(this, new EventArgs());//引发完成事件 } Monitor.Exit(this);//取消锁定 Thread.Sleep(5); } } //执行完成之后，停止所有线程 void ThreadDemo_OnNumberClear(object sender, EventArgs e) { Console.WriteLine(\"执行完了，停止了所有线程的执行。\"); threadTwo.Abort(); threadOne.Abort();//终止线程调用 } } 结果： 主线程1：0 主线程1：1 主线程1：2 主线程1：3 主线程1：4 主线程1：5 主线程1：6 主线程1：7 主线程1：8 主线程1：9 线程1删除了2080427802 线程2删除了341851734 线程1删除了1431988776 线程2删除了1938005744 线程1删除了761513014 线程2删除了2037243568 线程1删除了1528357293 线程2删除了1311292502 线程1删除了749943798 线程2删除了319576108 执行完了，停止了所有线程的执行。 using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { public class ThreadWaitAndPluse { private object lockObject; private int number; private Random random; public ThreadWaitAndPluse() { lockObject = new object(); random = new Random(); } //显示生成数据的线程要执行的方法 public void ThreadMethodOne() { Monitor.Enter(lockObject);//获取对象锁 Console.WriteLine(\"当前进入的线程：\" + Thread.CurrentThread.GetHashCode()); for (int i = 0; i \u003c 5; i++) { Monitor.Wait(lockObject);//释放对象锁，并阻止当前线程 Console.WriteLine(\"WaitAndPluse1:工作\"); Console.WriteLine(\"WaitAndPluse1:得到了数据，number=\" + number + \",Thread ID=\" + Thread.CurrentThread.GetHashCode()); //通知其它等待锁的对象状态已经发生改变,当这个对象释放锁之后等待锁的对象将会活得锁 Monitor.Pulse(lockObject); } Console.WriteLine(\"退出当前线程：\" + Thread.CurrentThread.GetHashCode()); Monitor.Exit(lockObject);//释放对象锁 } //生成随机数据线程要执行的方法 public void ThreadMethodTwo() { Monitor.Enter(lockObject);//获取对象锁 Console.WriteLine(\"当前进入的线程：\" + Thread.CurrentThread.GetHashCode()); for (int i = 0; i \u003c 5; i++) { //通知其它等待锁的对象状态已经发生改变,当这个对象释放锁之后等待锁的对象将会活得锁 Monitor.Pulse(lockObject); Console.WriteLine(\"WaitAndPluse2:工作\"); number =random.Next(DateTime.Now.Millisecond);//生成随机数 Console.WriteLine(\"WaitAndPluse2:生成了数据，number=\" + number + \",Thread ID=\"","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:2","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"手动同步\rReaderWriterLock：ReaderWriterLock支持单个写线程和多个读线程的锁，使用ReaderWriterLock来进行读写同步比使用监视的方式（如Monitor）效率要高 .NET Framework 具有两个读取器 / 编写器锁， ReaderWriterLockSlim 和 ReaderWriterLock。 ReaderWriterLockSlim 建议将所有新的开发的。 ReaderWriterLockSlim 类似于 ReaderWriterLock, ，只是简化了递归、 升级和降级锁定状态的规则。 ReaderWriterLockSlim 可避免潜在的死锁的很多情况。 此外，性能的 ReaderWriterLockSlim 明显优于 ReaderWriterLock。 ReaderWriterLock 用于同步对资源的访问。 在任何给定时间，它允许多个线程的并发读访问权限，或者一个单独的线程的写访问权限。 在某个资源，很少更改的情况下 ReaderWriterLock 提供了更好的吞吐量比简单的一次锁，如 Monitor。 ReaderWriterLock 其中大多数的访问权限是读取，而写入是很少和持续时间较短的效果最佳。 多个读取器交替使用单个编写器，以便读取器和编写器都不被阻止较长时间 下面的示例演示如何使用 ReaderWriterLock 若要保护的共享的资源，一个整数值，名为 resource, ，即并发读取和写入以独占方式由多个线程。 请注意， ReaderWriterLock 以便对所有线程可见的类级别声明。 using System; using System.Threading; public class Example { static ReaderWriterLock rwl = new ReaderWriterLock(); // 定义受ReaderWriterLock保护的共享资源。 static int resource = 0; /// \u003csummary\u003e /// 线程数量 /// \u003c/summary\u003e const int numThreads = 10; /// \u003csummary\u003e /// 线程启动开关 /// \u003c/summary\u003e static bool running = true; /// \u003csummary\u003e /// 随机 /// \u003c/summary\u003e static Random rnd = new Random(); // 读取超时时间 static int readerTimeouts = 0; //写入超时时间 static int writerTimeouts = 0; //读取次数 static int reads = 0; //写入次数 static int writes = 0; public static void Main() { // 启动一系列线程以随机读取和写入共享资源。 Thread[] t = new Thread[numThreads]; for (int i = 0; i \u003c numThreads; i++) { t[i] = new Thread(new ThreadStart(ThreadProc)); t[i].Name = new String(Convert.ToChar(i + 65), 1); t[i].Start(); Console.WriteLine($\"线程：{t[i].Name }启动\"); if (i \u003e 10) Thread.Sleep(300); } // 告诉线程关闭并等待它们全部完成。 running = false; for (int i = 0; i \u003c numThreads; i++) { t[i].Join();//阻止调用线程，直到某个线程终止时为止。 Console.WriteLine($\"线程：{t[i].Name }阻止\"); } // 显示统计信息 Console.WriteLine($\"\\n{reads} 次读, {writes} 次写, 读取请求超时时间{readerTimeouts} , 写请求超时时间{writerTimeouts} .\"); Console.Write(\"退出 \"); Console.ReadLine(); } static void ThreadProc() { // 随机选择线程从共享资源中读取和写入的方式 while (running) { double action = rnd.NextDouble();//返回一个0-1之间的随机数 if (action \u003c .7) ReadFromResource(10);//80%读 else if (action \u003c .81) ReleaseRestore(50); else if (action \u003c .90) UpgradeDowngrade(100); else WriteToResource(100); } } // 请求并释放读卡器锁，并处理超时。 static void ReadFromResource(int timeOut) { try { rwl.AcquireReaderLock(timeOut);//获取读线程锁。//使用一个int超时值获取读线程 try { // 此线程可以安全地从共享资源中读取。 Display(\"读取资源值:\" + resource); Interlocked.Increment(ref reads);//对资源操作 } finally { // 确保已释放锁定。 rwl.ReleaseReaderLock();//减少锁计数。 } } catch (ApplicationException) { //读卡器锁定请求超时。 Interlocked.Increment(ref readerTimeouts);//时间增加 } } // 请求并释放写入程序锁定，并处理超时。 static void WriteToResource(int timeOut) { try { rwl.AcquireWriterLock(timeOut);//获取写线程锁。//使用一个int超时值获取写线程 try { // 此线程可以安全地从共享资源进行访问。 resource = rnd.Next(100); Display(\"写资源值: \" + resource); Interlocked.Increment(ref writes);//写入次数 } finally { // 确保已释放锁定。 rwl.ReleaseWriterLock();//减少写线程上锁的计数 } } catch (ApplicationException) { // The writer lock request timed out. Interlocked.Increment(ref writerTimeouts); } } // 请求读取器锁定，将读取器锁定升级到写入器锁定，并再次将其降级为读取器锁定。 static void UpgradeDowngrade(int timeOut) { try { rwl.AcquireReaderLock(timeOut);//通过设置的读时间int值获取读线程锁 try { // 这个线程从共享资源中读取是安全的。 Display(\"读资源值: \" + resource); Interlocked.Increment(ref reads); // 要写入资源，要么释放读取器锁定并请求写入程序锁定，要么升级读取器锁定。 //升级读取器锁将线程置于写入队列中，位于可能正在等待写入器锁定的任何其他线程之后。 try { LockCookie lc = rwl.UpgradeToWriterLock(timeOut);//将一个设置超时int值的读线程锁升级为写线程锁 try { // 此线程可以安全地从共享资源读取或写入。 resource = rnd.Next(100); Display(\"从读锁变成写锁写资源值: \" + resource); Interlocked.Increment(ref writes);//写值 } finally { // 确保已释放锁定。 rwl.DowngradeFromWriterLock(ref lc);//将线程的锁状态还原为调用 UpgradeToWriterLock 前的状态。 } } catch (ApplicationException) { // 更新写线程时间 Interlocked.Increment(ref writerTimeouts); } // 如果锁被降级，从资源中读取仍然是安全的。 Display(\"从读锁变成写锁再变读锁读资源值: \" + resource); Interlocked.Increment(ref reads); } finally { // 确保已释放锁定。 rwl.ReleaseReaderLock(); } } catch (ApplicationException) { // 读卡器锁定请求超时。 Interlocked.Increment(ref readerTimeouts); } } //释放所有锁，然后恢复锁定状态。 //使用序列号来确定另一个线程是否已获得写入器锁定，因为此线程上次访问该资源。 static void ReleaseRestore(int timeOut) { ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:3","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"AutoResetEvent 类\r通知正在等待的线程已发生事件。MSCN介绍中，终止状态就是有信号 AutoResetEvent（bool isover）：构造函数指示是否指示是否将初始状态设置为终止的 Reset:将事件状态设置为非终止状态，导致线程阻止。 Set:将事件状态设置为终止状态，允许一个或多个等待线程继续。将事件状态设置为有信号 WaitOne():阻止当前线程，直到当前 WaitHandle 收到信号。会自动改变信号，讲有信号自动变成无信号，需要自己调用set WaitOne(Int32):阻止当前线程，直到当前 WaitHandle 收到信号，同时使用 32 位带符号整数指定时间间隔 using System; using System.Threading; class Example { //mscn中终止状态就是有信号 //全局 private static AutoResetEvent event_1 = new AutoResetEvent(true);//初始化为终止状态，有信号 private static AutoResetEvent event_2 = new AutoResetEvent(false);//初始状态为非终止状态，没有信号 static void Main() { Console.WriteLine(\"按Enter键创建三个线程并启动它们。\\r\\n\" + \"线程在创建的AutoResetEvent1上等待\\r\\n\" + \"在信号状态，所以第一个线程被释放。\\r\\n\" + \"这使AutoResetEvent1进入无信号状态.\"); Console.ReadLine(); for (int i = 1; i \u003c 4; i++) { Thread t = new Thread(ThreadProc); t.Name = i+ \"号线程\"; Console.WriteLine(\"{0}号线程开始\",t.Name); t.Start(); } Thread.Sleep(250); for (int i = 0; i \u003c 2; i++) { Console.WriteLine(\"按Enter键以释放另一个线程。\"); Console.ReadLine(); event_1.Set(); Thread.Sleep(250); } Console.WriteLine(\"\\r\\n所有线程现在都在等待AutoResetEvent＃2。\"); for (int i = 0; i \u003c 3; i++) { Console.WriteLine(\"按Enter键以释放线程。\"); Console.ReadLine(); event_2.Set(); Thread.Sleep(250); } } static void ThreadProc() { string name = Thread.CurrentThread.Name; Console.WriteLine(\"{0} 等待AutoResetEvent # 1。\", name); event_1.WaitOne(); Console.WriteLine(\"{0} 从AutoResetEvent # 1中释放。\", name); Console.WriteLine(\"{0} 等待AutoResetEvent # 2。\", name); event_2.WaitOne(); Console.WriteLine(\"{0} 从AutoResetEvent # 2中释放。\", name); Console.WriteLine(\"{0} 结束。\", name); } } 结果 按Enter键创建三个线程并启动它们。 线程在创建的AutoResetEvent1上等待 在信号状态，所以第一个线程被释放。 这使AutoResetEvent1进入无信号状态. 1号线程号线程开始 2号线程号线程开始 1号线程 等待AutoResetEvent # 1。 1号线程 从AutoResetEvent # 1中释放。 1号线程 等待AutoResetEvent # 2。 2号线程 等待AutoResetEvent # 1。 3号线程号线程开始 3号线程 等待AutoResetEvent # 1。 按Enter键以释放另一个线程。 2号线程 从AutoResetEvent # 1中释放。 2号线程 等待AutoResetEvent # 2。 按Enter键以释放另一个线程。 3号线程 从AutoResetEvent # 1中释放。 3号线程 等待AutoResetEvent # 2。 所有线程现在都在等待AutoResetEvent＃2。 按Enter键以释放线程。 1号线程 从AutoResetEvent # 2中释放。 1号线程 结束。 按Enter键以释放线程。 2号线程 从AutoResetEvent # 2中释放。 2号线程 结束。 按Enter键以释放线程。 3号线程 从AutoResetEvent # 2中释放。 3号线程 结束。 请按任意键继续. . . ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:4","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"ManualResetEvent 类\r通知一个或多个正在等待的线程已发生事件。 ManualResetEvent：用一个指示是否将初始状态设置为终止的布尔值初始化，初始状态是否有信号 set:将事件状态设置为终止状态，允许一个或多个等待线程继续。,设置有信号,设为有信号后就一直有信号，即使waitone后也信号，直到reset将其设为无信号 WaitOne()：阻止当前线程，直到当前 WaitHandle 收到信号。 WaitOne(Int32)：阻止当前线程，直到当前 WaitHandle 收到信号，同时使用 32 位带符号整数指定时间间隔（以毫秒为单位）。 Reset：将事件状态设置为非终止状态，导致线程阻止。 using System; using System.Threading; public class Example { private static ManualResetEvent mre = new ManualResetEvent(false);//初始状态没有信号 static void Main() { Console.WriteLine(\"\\n启动3个在ManualResetEvent上阻塞的命名线程：\\n\"); for (int i = 0; i \u003c= 2; i++) { Thread t = new Thread(ThreadProc); t.Name = i+\"号线程\"; Console.WriteLine(\"{0}开始\", t.Name); t.Start(); } Thread.Sleep(500); Console.WriteLine(\"\\n当所有三个线程都已启动时，按Enter键调用Set（）\" + \"\\n释放所有线程。\\n\"); Console.ReadLine(); mre.Set(); Thread.Sleep(500); Console.WriteLine(\"\\n发出ManualResetEvent信号时，调用WaitOne（）的线程\" + \"\\n不要阻止。 按Enter键显示此信息。\\n\"); Console.ReadLine(); for (int i = 3; i \u003c= 4; i++) { Thread t = new Thread(ThreadProc); t.Name = i + \"号线程\"; t.Start(); } Thread.Sleep(500); Console.WriteLine(\"\\n按Enter键调用Reset（），以便线程再次阻止\" + \"\\n当他们调用WaitOne（）时.\\n\"); Console.ReadLine(); mre.Reset(); // Start a thread that waits on the ManualResetEvent. Thread t5 = new Thread(ThreadProc); t5.Name = \"Thread_5\"; t5.Start(); Thread.Sleep(500); Console.WriteLine(\"\\nPress Enter to call Set() and conclude the demo.\"); Console.ReadLine(); mre.Set(); } private static void ThreadProc() { string name = Thread.CurrentThread.Name; Console.WriteLine(name + \" 启动并调用mre.WaitOne（）\"); mre.WaitOne(); Console.WriteLine(name + \" ends.\"); } } 结果： 启动3个在ManualResetEvent上阻塞的命名线程： 0号线程开始 1号线程开始 0号线程 启动并调用mre.WaitOne（） 2号线程开始 1号线程 启动并调用mre.WaitOne（） 2号线程 启动并调用mre.WaitOne（） 当所有三个线程都已启动时，按Enter键调用Set（） 释放所有线程。 2号线程 ends. 0号线程 ends. 1号线程 ends. 发出ManualResetEvent信号时，调用WaitOne（）的线程 不要阻止。 按Enter键显示此信息。 3号线程 启动并调用mre.WaitOne（） 3号线程 ends. 4号线程 启动并调用mre.WaitOne（） 4号线程 ends. 按Enter键调用Reset（），以便线程再次阻止 当他们调用WaitOne（）时. Thread_5 启动并调用mre.WaitOne（） Press Enter to call Set() and conclude the demo. Thread_5 ends. 请按任意键继续. . . ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:5","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"Interlocked 类\r为多个线程共享的变量提供原子操作。 Increment(Int32)：以原子操作的形式递增指定变量的值并存储结果。 Add(Int32, Int32)：对两个 32 位整数进行求和并用和替换第一个整数，上述操作作为一个原子操作完成。 CompareExchange(Double, Double, Double)：比较两个双精度浮点数是否相等，如果相等，则替换第一个值。 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:6","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"waithandle\rWaitHandle类是一个抽象类，有多个类直接或者间接继承自WaitHandle类 在WaitHandle类中SignalAndWait、WaitAll、WaitAny及WaitOne这几个方法都有重载形式，其中除WaitOne之外都是静态的。 WaitHandle方法常用作同步对象的基类。WaitHandle对象通知其他的线程它需要对资源排他性的访问，其他的线程必须等待，直到WaitHandle不再使用资源和等待句柄没有被使用。 WaitHandle方法有多个Wait的方法，这些方法的区别如下： WaitAll：等待指定数组中的所有元素收到信号。 WaitAny：等待指定数组中的任一元素收到信号。 WaitOne：当在派生类中重写时，阻塞当前线程，直到当前的 WaitHandle 收到信号。 MSCN上面的代码 using System; using System.Threading; namespace AutoResetEvent_Examples { class MyMainClass { //Initially not signaled. const int numIterations = 5; static AutoResetEvent myResetEvent = new AutoResetEvent(false); static int number; static void Main() { //Create and start the reader thread. Thread myReaderThread = new Thread(new ThreadStart(MyReadThreadProc)); myReaderThread.Name = \"ReaderThread\"; myReaderThread.Start(); for (int i = 1; i \u003c= numIterations; i++) { Console.WriteLine(\"Writer thread writing value: {0}\", i); number = i; //Signal that a value has been written. myResetEvent.Set(); //Give the Reader thread an opportunity to act. Thread.Sleep(1); } //Terminate the reader thread. myReaderThread.Abort(); } static void MyReadThreadProc() { while (true) { //The value will not be read until the writer has written // at least once since the last read. myResetEvent.WaitOne();//等待set Console.WriteLine(\"{0} reading value: {1}\", Thread.CurrentThread.Name, number); } } } } 结果 Writer thread writing value: 1 ReaderThread reading value: 1 Writer thread writing value: 2 ReaderThread reading value: 2 Writer thread writing value: 3 ReaderThread reading value: 3 Writer thread writing value: 4 ReaderThread reading value: 4 Writer thread writing value: 5 ReaderThread reading value: 5 请按任意键继续. . . using System; using System.Threading; public class Example { // mre is used to block and release threads manually. It is // created in the unsignaled state. private static ManualResetEvent mre = new ManualResetEvent(false);//设为非终止状态，线程会被阻塞 static void Main() { Console.WriteLine(\"\\n启动在MalualReSeTebug上阻止的3个命名线程:\\n\"); for (int i = 0; i \u003c= 2; i++) { Thread t = new Thread(ThreadProc); t.Name = i+\"线程\"; t.Start(); } Thread.Sleep(500); Console.WriteLine(\"\\n当所有三个线程都已启动时，按Enter调用SET（）\" + \"\\n释放所有线程。\\n\"); Console.ReadLine(); mre.Set();//事件状态被设置为有信号，允许线程执行，3个线程执行，同时ManualResetEvent 被设置为终止状态，线程不会阻塞 Thread.Sleep(500); Console.WriteLine(\"\\n当一个MavaReSeTeEvices被发出信号时，调用WAOTIONE（）的线程\" + \"\\n不要阻塞。按Enter显示这一点。\\n\"); Console.ReadLine(); for (int i = 3; i \u003c= 4; i++) { Thread t = new Thread(ThreadProc); t.Name = i + \"线程\"; t.Start(); } Thread.Sleep(500); Console.WriteLine(\"\\n按Enter调用REST（），使线程再次阻塞\" + \"\\n当他们调用WAOTIFEL（）时。\\n\"); Console.ReadLine(); mre.Reset();//将ManualResetEvent 重新设为非终止状态 // Start a thread that waits on the ManualResetEvent. Thread t5 = new Thread(ThreadProc); t5.Name = \"5线程\"; t5.Start(); Thread.Sleep(500); Console.WriteLine(\"\\n按Enter调用SET（）并结束演示。\"); Console.ReadLine(); mre.Set(); // If you run this example in Visual Studio, uncomment the following line: //Console.ReadLine(); } private static void ThreadProc() { string name = Thread.CurrentThread.Name; Console.WriteLine(name + \" starts and calls mre.WaitOne()\"); mre.WaitOne();//当ManualResetEvent 设为非终止状态时，线程会被阻塞 Console.WriteLine(name + \" ends.\"); } } 启动在MalualReSeTebug上阻止的3个命名线程: 0线程 starts and calls mre.WaitOne() 2线程 starts and calls mre.WaitOne() 1线程 starts and calls mre.WaitOne() 当所有三个线程都已启动时，按Enter调用SET（） 释放所有线程。 1线程 ends. 0线程 ends. 2线程 ends. 当一个MavaReSeTeEvices被发出信号时，调用WAOTIONE（）的线程 不要阻塞。按Enter显示这一点。 3线程 starts and calls mre.WaitOne() 3线程 ends. 4线程 starts and calls mre.WaitOne() 4线程 ends. 按Enter调用REST（），使线程再次阻塞 当他们调用WAOTIFEL（）时。 5线程 starts and calls mre.WaitOne() 按Enter调用SET（）并结束演示。 这个讲的是一个计算过程，最终的计算结果为第一项＋第二项＋第三项，在计算第一、二、三项时需要使用基数来进行计算。在代码中使用了线程池也就是ThreadPool来操作 using System; using System.Collections.Generic; using System.Text; using System.Threading; namespace StartThread { //下面的代码摘自MSDN，笔者做了中文代码注释 //周公 public class EventWaitHandleDemo { double baseNumber, firstTerm, secondTerm, thirdTerm; AutoResetEvent[] autoEvents; ManualResetEvent ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:7","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"线程池\r为了处理短时间内大量创建对象，简单处理下，又要销毁损耗性能的行为，线程过多后会增加操作系统资源的占用，多线程资源竞争变得复杂 线程池的优点： 缩短程序的响应时间 不必维护管理生存周期短暂的问题 线程池会根据当前系统特点对池内的线程进行优化处理 在.NET中有一个线程的类ThreadPool，它提供了线程池的管理 ThreadPool是一个静态类，它没有构造函数，对外提供的函数也全部是静态的。其中有一个QueueUserWorkItem方法，它有两种重载形式，如下： public static bool QueueUserWorkItem(WaitCallback callBack):将方法排入队列以便执行。此方法在有线程池线程变得可用时执行。 public static bool QueueUserWorkItem(WaitCallback callBack,Object state):将方法排入队列以便执行，并指定包含该方法所用数据的对象。此方法在有线程池线程变得可用时执行。 QueueUserWorkItem方法中使用的的WaitCallback参数表示一个delegate，它的声明如下： public delegate void WaitCallback(Object state) 如果需要传递任务信息可以利用WaitCallback中的state参数，类似于ParameterizedThreadStart委托 using System.Threading; using System.Collections; using System.Diagnostics; using System; using System.ComponentModel; namespace ThreadPoolDemo { class ThreadPoolDemo1 { public ThreadPoolDemo1() { } public void Work() { ThreadPool.QueueUserWorkItem(new WaitCallback(CountProcess)); ThreadPool.QueueUserWorkItem(new WaitCallback(GetEnvironmentVariables)); } /// \u003csummary\u003e /// 统计当前正在运行的系统进程信息 /// \u003c/summary\u003e /// \u003cparam name=\"state\"\u003e\u003c/param\u003e private void CountProcess(object state) { Process[] processes = Process.GetProcesses(); foreach (Process p in processes) { try { Console.WriteLine(\"Id:{0},ProcessName:{1},StartTime:{2}\", p.Id, p.ProcessName, p.StartTime); } catch (Win32Exception e) { Console.WriteLine(\"ProcessName:{0}\", p.ProcessName); } finally { } } Console.WriteLine(\"获取进程信息完毕。\"); } /// \u003csummary\u003e /// 获取当前机器系统变量设置 /// \u003c/summary\u003e /// \u003cparam name=\"state\"\u003e\u003c/param\u003e public void GetEnvironmentVariables(object state) { IDictionary list=System.Environment.GetEnvironmentVariables(); foreach (DictionaryEntry item in list) { Console.WriteLine(\"key={0},value={1}\", item.Key, item.Value); } Console.WriteLine(\"获取系统变量信息完毕。\"); } static void Main(string[] args) { ThreadPoolDemo1 tpd1 = new ThreadPoolDemo1(); tpd1.Work(); Thread.Sleep(5000); Console.WriteLine(\"OK\"); Console.ReadLine(); } } } 在上面的代码中我们使用了线程池，并让它执行了两个任务，一个是列出系统当前所有环境变量的值，一个是列出系统当前运行的进程名和它们的启动时间。 当然，优点和缺点总是同时存在的，使用ThreadPool也有一些缺点，使用线程池有如下缺点： 1、一旦加入到线程池中就没有办法让它停止，除非任务执行完毕自动停止； 2、一个进程共享一个线程池； 3、要执行的任务不能有返回值（当然，线程中要执行的方法也是不能有返回值，如果确实需要返回值必须采用其它技巧来解决）； 4、在线程池中所有任务的优先级都是一样的，无法设置任务的优先级； 5、不太适合需要长期执行的任务（比如在Windows服务中执行），也不适合大的任务； 6、不能为线程设置稳定的关联标识，比如为线程池中执行某个特定任务的线程指定名称或者其它属性。 如果我们要面临的情况正好是线程池的缺点，那么我们只好继续使用线程而不是线程池。不过在某些情况下使用线程池确实可以带来很多方便的，比如在WEB服务器中，可以使用线程池来处理来自客户端的请求，可以以比较高的性能运行。 ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:6:8","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"UI界面卡顿的问题\r在开发Windows应用程序时经常会使用到线程。对于耗时的操作如果不使用线程将会是UI界面长时间处于停滞状态，这种情况是用户非常不愿意看到的，在这种情况下我们希望使用线程来解决这个问题。 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Text; using System.Windows.Forms; using System.Threading; namespace ThreadPoolDemo { public partial class ThreadForm : Form { public ThreadForm() { InitializeComponent(); } private void btnThread_Click(object sender, EventArgs e) { Thread thread = new Thread(new ThreadStart(Run)); thread.Start(); } private void Run() { while (progressBar.Value \u003c progressBar.Maximum) { progressBar.PerformStep(); } } } } 本意是点击“启动”按钮来启动模拟一个操作，在进度条中显示操作的总体进度。不过如果我们真的点击“启动”按钮会很失望，因为它会抛出一个System.InvalidOperationException异常，异常描述就是“线程间操作无效: 从不是创建控件‘progressBar’的线程访问它。” 解决方案 CheckForIllegalCrossThreadCalls属性 因为在.NET中做了限制，不允许在调试环境下使用线程访问并非它自己创建的UI控件，这么做可能是怕在多线程环境下对界面控件进行操作会出现不可预知的情况， using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using System.Threading; namespace ThreadPoolDemo { public partial class ThreadForm : Form { public ThreadForm() { InitializeComponent(); } private void btnThread_Click(object sender, EventArgs e) { //指示是否对错误线程的调用，即是否允许在创建UI的线程之外访问线程 CheckForIllegalCrossThreadCalls = false; Thread thread = new Thread(new ThreadStart(Run)); thread.Start(); } private void Run() { while (progressBar.Value \u003c progressBar.Maximum) { progressBar.PerformStep(); } } } } 不过使用上面的代码我们可能还有些犯嘀咕，毕竟是不允许直接在线程中直接操作界面的，那么我们还可以用Invoke方法。 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using System.Threading; namespace ThreadPoolDemo { public partial class ThreadForm : Form { //定义delegate以便Invoke时使用 private delegate void SetProgressBarValue(int value); public ThreadForm() { InitializeComponent(); } private void btnThread_Click(object sender, EventArgs e) { progressBar.Value = 0; //指示是否对错误线程的调用，即是否允许在创建UI的线程之外访问线程 //CheckForIllegalCrossThreadCalls = false; Thread thread = new Thread(new ThreadStart(Run)); thread.Start(); } //使用线程来直接设置进度条 private void Run() { while (progressBar.Value \u003c progressBar.Maximum) { progressBar.PerformStep(); } } private void btnInvoke_Click(object sender, EventArgs e) { progressBar.Value = 0; Thread thread = new Thread(new ThreadStart(RunWithInvoke)); thread.Start(); } //使用Invoke方法来设置进度条 private void RunWithInvoke() { int value = progressBar.Value; while (value\u003c progressBar.Maximum) { //如果是跨线程调用 if (InvokeRequired) { this.Invoke(new SetProgressBarValue(SetProgressValue), value++); } else { progressBar.Value = ++value; } } } //跟SetProgressBarValue委托相匹配的方法 private void SetProgressValue(int value) { progressBar.Value = value; } } } 还可以使用BackgroundWorker类来完成同样的功能。 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using System.Threading; namespace ThreadPoolDemo { public partial class ThreadForm : Form { //定义delegate以便Invoke时使用 private delegate void SetProgressBarValue(int value); private BackgroundWorker worker; public ThreadForm() { InitializeComponent(); } private void btnThread_Click(object sender, EventArgs e) { progressBar.Value = 0; //指示是否对错误线程的调用，即是否允许在创建UI的线程之外访问线程 //CheckForIllegalCrossThreadCalls = false; Thread thread = new Thread(new ThreadStart(Run)); thread.Start(); } //使用线程来直接设置进度条 private void Run() { while (progressBar.Value \u003c progressBar.Maximum) { progressBar.PerformStep(); } } private void btnInvoke_Click(object sender, EventArgs e) { progressBar.Value = 0; Thread thread = new Thread(new ThreadStart(RunWithInvoke)); thread.Start(); } //使用Invoke方法来设置进度条 private void RunWithInvoke() { int value = progressBar.Value; while (value\u003c progressBar.Maximum) { //如果是跨线程调用 if (InvokeRequired) { this.Invoke(ne","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:7:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"Task类\rTask类是封装的一个任务类，内部使用的是ThreadPool类，提供了内建机制，让你知道什么时候异步完成以及如何获取异步执行的结果，并且还能取消异步执行的任务。下面看一个例子是如何使用Task类来执行异步操作的。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { Task t = new Task((c) =\u003e { int count = (int)c; for (int i = 0; i \u003c count; i++) { Thread.Sleep(10); Console.WriteLine($\"Asyn Thread:{i}\"); } Console.WriteLine(\"Asyn Thread Done\"); }, 10);//10为传递的参数C N0.1 t.Start(); for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread:{i}\"); } Console.WriteLine(\"Main Thread done\"); Console.ReadKey(); } } } Main Thread:0 Asyn Thread:0 Asyn Thread:1 Main Thread:1 Asyn Thread:2 Main Thread:2 Asyn Thread:3 Main Thread:3 Asyn Thread:4 Main Thread:4 Main Thread done Asyn Thread:5 Asyn Thread:6 Asyn Thread:7 Asyn Thread:8 Asyn Thread:9 Asyn Thread Done no.1处使用Task的构造函数为： public Task( Action\u003cObject\u003e action, Object state )一个Action\u003cObject\u003e类型的委托（即异步调用函数具有一个Object类型的参数），和一个Object类型的参数，也就是传递给异步函数的参数， Task类还有几种方式的重载，我们还可以传递一些TaskCreationOptions标志来控制Task的执行方式。在这里我使用的是lambda表达去写委托的，这样使得程序的结构更加的清晰，使用Start()来启动异步函数的调用。 有返回值，主线程阻塞 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { Task\u003cint\u003e t = new Task\u003cint\u003e((c) =\u003e { int count = (int)c; int sum = 0; for (int i = 0; i \u003c count; i++) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread:{i}\"); } Console.WriteLine(\"Asyn Thread Done\"); return sum; }, 10);//no.1 t.Start(); t.Wait(); Console.WriteLine($\"Asyn Result:{t.Result}\"); for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread:{i}\"); } Console.WriteLine(\"Main Thread done\"); Console.ReadKey(); } } } Asyn Thread:0 Asyn Thread:1 Asyn Thread:2 Asyn Thread:3 Asyn Thread:4 Asyn Thread:5 Asyn Thread:6 Asyn Thread:7 Asyn Thread:8 Asyn Thread:9 Asyn Thread Done Asyn Result:45 Main Thread:0 Main Thread:1 Main Thread:2 Main Thread:3 Main Thread:4 Main Thread done 如果任务中出现了异常，那么异常会被吞噬掉，并存储到一个集合中去，而线程可以返回到线程池中去。但是如果在代码中调用了Wait方法或者是Result属性，任务有异常发生就会被引发，不会被吞噬掉。其中Result属性内部本身也调用了Wati方法。Wait方法和上一节中的委托的EndInvoke方法类似，会使得调用线程阻塞直到异步任务完成。 取消正在运行的任务 取消任务要引用一个CancellationTokenSource 对象。在需要异步执行的方法中增加一个CancellationToken类型的形参。然后在异步函数的for循环代码中用一个if语句判断CancellationToken的CanBeCanceled属性，这个属性可以用来判断在调用线程是否取消任务的执行， 除CanBeCanceled属性之外，还可以使用ThrowIfCancellationRequested方法，该方法的作用是如果在调用线程调用CancellationTokenSource对象的Cancel方法，那么就会引发一个异常，然后在调用线程进行捕捉就好了，这是在异步函数中的处理方式。 no.1在构建任务之前需要建立一个CancellationTokenSource ， no2.并且把CancellationTokenSource传递给异步调用函数，传递的是CancellationTokenSource对象的Toke属性，该属性是一个CancellationToken类型的对象。这样就完成任务的取消模式，如果想在调用线程中取消任务的执行，只需要调用CancellationTokenSource 的Cancel方法就行啦。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; namespace testasy { class Program { public delegate int DoWork(int count); static void Main(string[] args) { CancellationTokenSource cts = new CancellationTokenSource();//NO.1 Task\u003cint\u003e t = new Task\u003cint\u003e((c) =\u003e Sum(cts.Token, (int)c), 10);//NO.2 t.Start(); //cts.Cancel();//NO.3如果任务没有完成，但是Task有可能完成了 for (int i = 0; i \u003c 5; i++) { Thread.Sleep(10); Console.WriteLine($\"Main Thread:{i}\"); } cts.Cancel(); Console.WriteLine(\"Main Thread done\"); Console.ReadKey(); } static int Sum(CancellationToken ct, int count) { int sum = 0; for (int i = 0; i \u003c count; i++) { //if (!ct.CanBeCanceled) if (!ct.IsCancellationRequested) { Thread.Sleep(10); sum += i; Console.WriteLine($\"Asyn Thread:{i}\"); } else { Console.WriteLine(\"任务取消\"); //return -1; } } Console.WriteLine(\"Asyn Thread Done\"); return sum; } } } 结果 Main Thread:0 Asyn Thread:0 Main Thread:1 Asyn Thread:1 Main Thread:2 Asyn Thread:2 Main Thread:3 Asyn Thread:3 Main Thread:4 Main Thread done","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:8:0","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"多线程UI的例子\rusing System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; using System.Threading; namespace testthreadui { public partial class Form1 : Form { private readonly TaskScheduler contextTaskScheduler;//声明一个任务调度器 public Form1() { InitializeComponent(); contextTaskScheduler = TaskScheduler.FromCurrentSynchronizationContext();//no.1获得一个上下文任务调度器 } private void button1_Click(object sender, EventArgs e) { Task\u003cint\u003e t = new Task\u003cint\u003e((n) =\u003e Sum((int)n), 100); t.Start(); t.ContinueWith(task =\u003e this.textBox1.Text = task.Result.ToString(), contextTaskScheduler);//当任务执行完之后执行 t.ContinueWith(task =\u003e MessageBox.Show(\"任务出现异常\"), CancellationToken.None, TaskContinuationOptions.OnlyOnFaulted, contextTaskScheduler);//当任务出现异常时才执行 for (int i = 0; i \u003c 10; i++) { textBox1.Text = i.ToString(); textBox2.Text = i.ToString(); Thread.Sleep(100); } } int Sum(int count) { try { int sum = 0; for (int i = 0; i \u003c count; i++) { Thread.Sleep(10); sum += i; //throw new Exception(\"错误\"); } Console.WriteLine(\"任务处理完成\"); return sum; } catch (Exception e) { MessageBox.Show(\"任务出现异常\"); } return -1; } private void button2_Click(object sender, EventArgs e) { textBox1.Text = 100.ToString(); } } } //未发现异常 实现实时更新UI 首先建立一个winform项目，在主窗体上拖入一个button，一个progressbar，一个lable。如下图所示。 编写一个处理数据的类（WriteDate），源代码如下 public class DataWrite { public delegate void UpdateUI(int step);//声明一个更新主线程的委托 public UpdateUI UpdateUIDelegate; public delegate void AccomplishTask();//声明一个在完成任务时通知主线程的委托 public AccomplishTask TaskCallBack; public void Write(object lineCount) { StreamWriter writeIO = new StreamWriter(\"text.txt\", false, Encoding.GetEncoding(\"gb2312\")); string head = \"编号,省,市\"; writeIO.Write(head); for (int i = 0; i \u003c (int)lineCount; i++) { writeIO.WriteLine(i.ToString() + \",湖南,衡阳\"); //写入一条数据，调用更新主线程ui状态的委托 UpdateUIDelegate(1); } //任务完成时通知主线程作出相应的处理 TaskCallBack(); writeIO.Close(); } } 主界面中的代码如下： 首先要建立一个委托来实现非创建控件的线程更新控件。 delegate void AsynUpdateUI(int step); 然后编写多线程去启动写入数据的方法以及回调的函数。 private void btnWrite_Click(object sender, EventArgs e) { int taskCount = 10000; //任务量为10000 this.pgbWrite.Maximum = taskCount; this.pgbWrite.Value = 0; DataWrite dataWrite = new DataWrite();//实例化一个写入数据的类 dataWrite.UpdateUIDelegate += UpdataUIStatus;//绑定更新任务状态的委托 dataWrite.TaskCallBack += Accomplish;//绑定完成任务要调用的委托 Thread thread = new Thread(new ParameterizedThreadStart(dataWrite.Write)); thread.IsBackground = true; thread.Start(taskCount); } //更新UI private void UpdataUIStatus(int step) { if (InvokeRequired) { this.Invoke(new AsynUpdateUI(delegate(int s) { this.pgbWrite.Value += s; this.lblWriteStatus.Text = this.pgbWrite.Value.ToString() + \"/\" + this.pgbWrite.Maximum.ToString(); }), step); } else { this.pgbWrite.Value += step; this.lblWriteStatus.Text = this.pgbWrite.Value.ToString() + \"/\" + this.pgbWrite.Maximum.ToString(); } } //完成任务时需要调用 private void Accomplish() { //还可以进行其他的一些完任务完成之后的逻辑处理 MessageBox.Show(\"任务完成\"); } 完整代码 using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; using System.Threading; using System.IO; namespace testthreadui { public partial class Form1 : Form { delegate void AsynUpdateUI(int step); public Form1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { int taskCount = 10000; //任务量为10000 this.pgbWrite.Maximum = taskCount; this.pgbWrite.Value = 0; DataWrite dataWrite = new DataWrite();//实例化一个写入数据的类 dataWrite.UpdateUIDelegate += UpdataUIStatus;//绑定更新任务状态的委托 dataWrite.TaskCallBack += Accomplish;//绑定完成任务要调用的委托 Thread thread = new Thread(new ParameterizedThreadStart(dataWrite.Write)); thread.IsBackground = true; thread.Start(taskCount); } private void UpdataUIStatus(int step) { if (InvokeRequired) { this.Invoke(new AsynUpdateUI(delegate (int s) { ","date":"2018-11-23","objectID":"/2018/11/dotnetbase4-thread/:8:1","tags":["DotNet基础","线程"],"title":"DotNet基础 线程","uri":"/2018/11/dotnetbase4-thread/"},{"categories":"DotNet基础","content":"基本信息\r","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:1:0","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"CIL和JIT\rCIL通用中间语言 JIT just-in-time使得CIT代码仅在需要时才编译 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:1:1","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"程序集\r包含可执行文件.exe和库函数.dll和资源文件，不必把程序集集中到一个地方，全局程序缓存 程序集完全自描述的，逻辑单元而不是物理单元 可执行代码和库代码使用相同程序集结构，可执行文件多了一个主程序入口点。 程序集的一个重要特征是它们包含元数据描述了对应代码中定义的类型和方法。 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:1:2","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"CLR\r公共语言运行库CLR：包含实时编译器JIT,在程序运行时，JIT编译器会从IL代码生成本地代码，其他部分是垃圾回收器GC,调试器扩展和线程实用工具。垃圾回收器负责回收内存，调试扩展器允许在不同编程语言之间启动调试会话，线程实用工具负责在底层平台创建线程。 管理着正在执行的代码包括管理内存，处理安全以及跨语言调试 代码托管最重要的是内存回收机制 winform基于像素 wpf基于pirectX CLR执行应用程序之前，编写好源代码都需要编译，编译分为两个阶段 将源代码编译成microsoft中间语言IL CLR将I编译成平台专用的的本地代码 clr还有一个类型加载器的类型系统，类型加载器负责从程序集中加载类型。 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:1:3","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"编译过程\r.net兼容语言编写程序，托管语言 将代码编译为中间代码CIL，这未必是单文件，可以有多个源代码文件，再把链接带一个程序集中，称之为链接 使用JIT编译为本机代码 在托管的CLR环境下运行本机代码 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:1:4","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"基本语法\r","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:0","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"注释\r/* */和一行// ///可以通过配置，将这些注释提取出来组成文档文件 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:1","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"命名空间\r","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:2","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"代码大纲功能\r#region Using directives #endregion，大纲的名字为Using directives ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:3","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"变量\r先声明后使用 变量初始化：变量是类或结构中的字段，如果没有显式初始化，则创建这些变量时，其默认值就是0.方法的局部变量必须在代码中显示初始化。 整数 sbyte System.SByte -128~127 byte System.Byte 0~255 short System.Int16 -32768~32767 ushort System.UInt16 0~65535 int System.Int32 -21亿~21亿 uint System.UInt32 42亿 long System.Int64 19位数字 ulong System.UInt64 20位数字 浮点类型 位是最小数据单位，只能表示0-1 字节，8个二进制位构成1个字节，是存储空间的基本计量单位， 字：由若干字节构成，不同计算机有不同的字长，8位计算机一个字等于一个字节，16位一个字等于两个字节，字是计算机数据处理和运算的单位 1kb等于1024个字节 1M等于1024KB 1G等于1024M 1T等于1024G float System.Single 4字节 double System.Double 8个字节 decimal System.Decimal 16个字节 布尔和文本 char System.Char Unicode 0~65535 2个字节 bool System.Boolean 1个字节 string System.String 转义字符 ' 单引号 0x0027 '’ 双引号 0x0022 \\ 反斜杠 0x005c \\0 空 0x0000 \\a 警告 0x0007 \\b 退格 0x0008 \\f 换页 0x000C \\n 换行 0x0000A \\r 回车 0x000D \\t 水平制表符 0x0009 \\v 垂直制表符 0x000B @转义字符，避免大量使用\\ 全局变量：Program.全局变量，在声明变量前要进行初始化 常量： 常量必须初始化，指定值后不能更改。 常量总是隐式静态的， 值类型和引用类型：值类型存储在栈中，应用类型存储在堆中。值类型和引用类型互换要经过装箱拆箱，在传递函数参数时，值类型会进行复制，而引用相当于传递指针，返回值相同。引用类型由垃圾回收器进行回收，值类型不需要，超出其作用域就会在内存中删除。 ref:如果是结构类型使用ref传递参数，则变成传递引用，**但如果是引用类型，即使参数在函数中变化了引用，新的应用还是会传递回去。**ref传递的值要先初始化。 out：用法基本和ref一样，但传入的值只需要定义 可空类型：int? 和int,唯一的多开销是一个可以确定它是否为空 的布尔成员，值可以直接转换可空，int?=int;可空转换成值需要强制int=(int)int?;但如果为空会生成一个异常，最好的方法是int=int?.hasvalue?int?.value:-1；可以转换成较短短语int=int??-1 枚举也是值类型：默认情况下，枚举是int,也可以改变成其他整数类型，强制转换将int转换成枚举，当分配给常量是不同位时，flags属性需要枚举设置，获得所有枚举，var day in Enum.GetName(typeof(Color)); 结构：值类型，不能继承，每个结构都自动由ValueType派生。 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:4","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"基本运算符\r一目运算符 二目运算符 = += -= *= /= %= 运算符优先级 ++,–(前缀);(),+,-,!,~ *,/,% +,- \u003e\u003e ,« \u003c,\u003e,\u003c=，\u003e= ==,！= \u0026 ^ | \u0026\u0026 || =,+=,-=,*=,/=,%= ++,–后缀 布尔运算符 ！ \u0026 | ^一真一否才为真 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:5","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"基本语句\rgoto语句 goto \u003clabelName\u003e \u003clabelName\u003e: if语句 if(\u003ctest\u003e) { \u003ccode executed if \u003ctestis true\u003e; } else { \u003ccode executed if \u003ctestis false\u003e; } switch switch(\u003ctestvar\u003e) { case\u003ccomparsionVall\u003e: \u003ccode to execute if \u003ctestVar\u003e\u003e==\u003ccomparisonvall\u003e\u003e break; ........ default: \u003ccode to execute if \u003ctestVar\u003e\u003e!=\u003ccomparisonvall\u003e\u003e break; } do do { \u003ccode to be looped\u003e } while(\u003cTest\u003e) while while(\u003ctest\u003e) { \u003ccode to looped\u003e } for for(\u003cinitialization\u003e;\u003ccondition\u003e;\u003coperation\u003e) { \u003ccode to loop\u003e } foreach foreach(\u003cbaseType\u003e\u003cname\u003ein\u003carray\u003e) { //can use \u003cnamefor each element }//该函数只能只读 循环中的中断 循环的中断： break立刻终止循环 continue立刻终止当前循环 goto可以跳出循环 return跳出循环,即包含循环的函数 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:6","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"基本数据结构\r转换 隐式转换：编译器执行转换 显示转换：需要额外转换 (\u003cdestinationType\u003e)\u003csourceVar\u003e 显示转换的检查：checked和unchecked checked( \u003cexpression\u003e)检查是否会溢出，溢出则出现错误 unchecked(\u003cexpression\u003e)溢出不出现错误 可以通过设置属性，使得显示转换都默认检查checked 枚举 enum\u003ctypename\u003e:\u003cunderlyingType\u003e { \u003cvalue1\u003e, \u003cvalue2\u003e=\u003cactualValue2\u003e, ... } 结构体：值类型 struct\u003ctypename\u003e:\u003cunderlyingType\u003e { \u003cmemberDeclarations\u003e, ... } 数组 数组声明：\u003cbaseType\u003e[]\u003cname\u003e; 二维数组声明：\u003cbaseType\u003e[,]\u003cname\u003e; 数组调用：frendName[index] 锯齿数组 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:2:7","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"基本函数\rConsole Console.WriteLine(“字符串”); Console.WriteLine(\"{0}{1}{2}\",n_a,n_b,n_c); str=Console.ReadLine(); Convert n_double=Convert.ToDouble();强制转换成double n_int=Convert.ToInt32();强制转换成int ToBase64CharArray 将 8 位无符号整数数组的子集转换为用 Base 64 数字编码的 Unicode 字符数组的等价子集。 ToBase64String 将 8 位无符号整数数组的值转换为它的等效 String 表示形式（使用 base 64 数字编码）。 ToBoolean 将指定的值转换为等效的布尔值。 ToByte 将指定的值转换为 8 位无符号整数。 ToChar 将指定的值转换为 Unicode 字符。 ToDateTime 将指定的值转换为 DateTime。 ToDecimal 将指定值转换为 Decimal 数字。 ToDouble 将指定的值转换为双精度浮点数字。 ToInt16 将指定的值转换为 16 位有符号整数。 ToInt32 将指定的值转换为 32 位有符号整数。 ToInt64 将指定的值转换为 64 位有符号整数。 ToSByte 将指定的值转换为 8 位有符号整数。 ToSingle 将指定的值转换为单精度浮点数字。 ToString 将指定值转换为其等效的 String 表示形式。 ToUInt16 将指定的值转换为 16 位无符号整数。 ToUInt32 将指定的值转换为 32 位无符号整数。 ToUInt64 将指定的值转换为 64 位无符号整数。 Convert.ReadKey( ); enum (enumerationType)Enum.Parse(typeof (enumerationType),enumerationValueString);字符串转换成枚举 string .ToCharArray()这个函数可以将String编程char[]数组 .Length字符串长度 .ToLower字符串全部小写 .ToUpper字符串全部大写 .Trim字符串删除空格 .PadLeft()和.PadRight()字符串左边或者右边添加空格 .IndexOf(’,’);定位到，的下标 .Split(’ ‘);切片 object 类的函数基本是object函数 .ToString()输出类名； 函数格式 static \u003creturnType\u003cFunctionName\u003e(\u003cparamType\u003e\u003cparaName\u003e,...) { ... renturn \u003creturnValue\u003e; }//普通函数定义 可以直接定义表达式函数public bool IsSquare(Reactangle rect)=\u003erect.height==rect.width; 参数函数 参数数组，C#允许函数指定一个特殊参数，该参数必须是函数的最后一个，称为参数素组， static \u003creturnType\u003cFunctionName\u003e(\u003cp1Type\u003e\u003cp1Name\u003e,...Params\u003ctype\u003e[]\u003cname\u003e) { ... renturn \u003creturnValue\u003e; } class Prigram { static int SunVals(params int [] vals) { int sum=0; foreach(int val in vals) { sum+=val; } return sum; } static void Main(string [] args) { int sum=SumVals(1,5,2,9,8); console.writeline(\"summed values={0}\",sum); } } 可选参数 public void TestMethod(int i,int j=12) { } 引用参数 引用参数，需要用关键字ref 调用引用函数\u003cFunctionName\u003e(ref \u003cparaName\u003e) static \u003creturnType\u003cFunctionName\u003e(ref \u003cparamType\u003e\u003cparaName\u003e,...) { ... renturn \u003creturnValue\u003e; } 扩展方法 public static int GetWordCount(this string s)=\u003es.split().length; 调用int wordcount=fox.GetWordCount(); 函数重载 特征标不一样就行 引用和非引用也属于重载 委托 委托，和重载差不多，只不过重载特征表不同，而委托特征标相同而函数名不同，可以根据需求NEW出不同的函数，委托的利用在于可以将其当成参数传递给函数，让函数因需求执行不同的操作，类似于多态 委托是一种存储函数引用的类型 委托声明类似于函数，但是不带函数体，且要使用关键字delegate，委托指定了一个返回类型和一个参数列表 定义了委托后，就可以声明该委托类型的变量，接着把这个变量初始化为与委托具有相同返回类型和参数列表的函数引用，之后就可以使用委托变量调用这个函数 例子，可以把委托变量作为参数传递给一个函数，这样，该函数就可以使用委托调用它引用的任何函数 class Program { delegate double ProcessDelegate(double param1, double param2); static double Multiply(double param1, double param2) { return param1 * param2; } static double Divide(double param1, double param2) { return param1 / param2; } static void Main(string[] args) { ProcessDelegate process; Console.WriteLine(\"imput two intege：\"); string input = Console.ReadLine(); string [] commaPos = input.Split(','); double param1 = Convert.ToDouble(commaPos[0]); double param2 = Convert.ToDouble(commaPos[1]); Console.WriteLine(\"Enter M to Multiply or D to divide:\"); input = Console.ReadLine(); if (input == \"M\") process = new ProcessDelegate(Multiply);//process=Multiply; else process = new ProcessDelegate(Divide);//process=Divide; Console.WriteLine(\"result :{0}\", process(param1, param2)); Console.ReadKey(); } } ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:3:0","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"调试\r","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:4:0","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"断点\r可以查看输出窗口，输出/调试， 语句Debug.WriteLine()将调试信息显示到调试窗口 Trace.WriteLine()，用法相同，可以用于发布 Debug.WriteLine(“Add 1 to i”,“MyFunc”);结果为： MyFunc:Add 1 to i; using System.Diagnostics; Debug.WriteLineIf()增加一个必选项，当是真的时候进行输出 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:4:1","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"跟踪点\r有点类似于Debug.WriteLine() ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:4:2","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"Trace\rTrace.Assert(myVar\u003c0,\"variable out of bounds\",\"please contact vendor with the error code KCW001.\") ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:4:3","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"异常\rtry抛出异常，catch抛出异常时执行的代码，finally包含最终执行的代码 即使try中有return， finally还是会执行，在finally中还是会改变return中的值 try {...} catch(\u003cexceptionType\u003ee) {...} finally {...} 抛出异常包括内容 throw(new ArgumentOutOfRangeException(\"MyIntProp\",value,\"MyIntProp must be assigned a value between 0 and 10\")); catch中捕获异常显示 catch (Exception e) { Console.WriteLine(\"Exception {0} thrown.\", e.GetType().FullName); Console.WriteLine(\"Message:\\n\\\"{0}\\\"\", e.Message); } ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:4:4","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"面向对象编程\r类包括：字段/属性/方法/常量/构造函数/索引器/运算符/事件/类型/析构函数 字段：不应该被设置为public 属性：自动实现的属性也就是没有声明私有字段，就可以使用初始化器来初始化；public int Age{set;get;}=42; set和get可以被访问修饰符修饰，但get和set中必须有一个具有属性的访问级别，属性其实并不怎么消耗资源，因为在JIT中，被变成内联函数， readonly:readonly只能在构造函数中赋值，然后就不好修改。 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:0","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"构造函数\r静态构造函数 创建包含静态构造函数的类实例 访问包含静态构造函数的类的静态成员时，（无论创建多少个实例，静态构造函数只调用一次。） 构造函数和析构函数，和C++一样 静态类不能实例化对象，只能包含静态成员， 如果没有构造函数，编译器会自动添加一个默认构造函数 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:1","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"派生类构造函数的调用\r构造函数总是按照层次结构顺序调用的：先调用object的构造函数，然后从上到下一次调用，直到达到编译器要实例化的类为止 如果要调用基类的非默认构造函数就需要使用构造函数初始化器。 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:2","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"访问修饰符\rpublic/ 所有类型成员/任何代码均可以访问该项 protected/类型和内嵌类型的所有成员/只有派生类型能够访问该类 internal/所有类型和成员/只能包含他的程序集中能够访问该类 private/类型和内嵌类型的所有成员/只能在它所属的类型中访问该项 protected internal/类型和内嵌类型的所有成员/只能在包含他的程序集和派生类型的任何代码中访问该项 new/static /virtual/abstract/override/sealed/extern ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:3","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"字段和属性\r统一建模语言Unified Modeling Language(UML) ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:4","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"接口\r接口可以看成是类的引用，可以引用任何实现该接口的类 一般情况下接口只能包含：方法，属性，索引器，事件的声明 把公共实例(非静态)方法和属性组合起来，以封装特定功能的一个集合,接口不能实例化 IDisposable接口的对象必须实现其Dispose()方法，当不再需要某个对象时就调用这个方法，释放重要资源， C#简化了这种方法，using关键字可以在代码块中初始化使用重要资源的对象，这个代码块的结尾会自动调用Dispose()方法 \u003cClassName\u003e\u003cVariableName\u003e=new \u003cClassName\u003e(); ... using(\u003cVariableName\u003e) { ... } 或 using(\u003cClassName\u003e\u003cVariableName\u003e=new \u003cClassName\u003e()) {...} 接口可以彼此集成，和类的集成差不多 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:5","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"继承\rC#类可以派生自另一个类和多个接口，只有虚方法和抽象方法才能使用override重写，不然是不能重写的，如果不重写虚方法或抽象方法，需要使用关键字new，那么调用的时候调用子类方法就可以使用base.方法 纯虚基类，重写方法，也可以不重写，虚方法可以实现，也可以实现（同属性） 基类成员的访问性 protected\\privated\\public 抽象基类不能实例化，抽象基类必须被继承，成员没有实现代码，在派生类中实现他们 抽象基类在UML中为斜体 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:6","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"is and as\rIBankAccount account= o as IBankAccount; if(o is IBankAccount){IBankAccount account = (IBankAccount)o;} ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:7","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"多态\r通过实例化不同的派生类调用派生类的重写方法 将派生类赋给基类调用基类重写方法，实际上调用了基类的重写方法 接口的多态性，尽管不能实例化接口，可以建立接口类型的变量，然后就可以在支持该接口的对象上，使用这个变量来访问接口提供的方法和属性 例如不适用基类提供的方法，而是把该方法放在接口上，实例化也支持该接口，唯一的区别是方法的实现代码不一样（接口不包含方法的实现），通过接口可以实现访问多个对象的方法而不依赖于一个公共的基类 Cow myCow=new Cow(); Chicken myChicken=new Chicken(); IConsume consumeInterface; consumeInterface = myCow; consumeInterface.EatFood(); consumeInterface = myChicken; consumeInterface.EatFood(); 对象之间的关系 包含关系，这个成员字段可以是公共字段，此时是继承关系一样，容器对象的用户就可以访问它的方法和属性，与继承不同的是，不能访问类的内部代码，类变成其私有变量 集合关系，增加了功能的数组 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:8","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"密封类和密封方法\r如果不允许创建派生自某个自定义类的类，该自定义类就应该是密封的，sealed 使用密封类可以提高性能，编译器知道该类没有派生，因此就没有虚函数表 string是密封的 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:9","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"托管和非托管\r托管和非托管资源，存储在托管或本机堆中的对象，垃圾回收器释放存储在托管堆中的对象，却不会释放本机堆中的对象。 值数据类型：window使用虚拟寻址系统，可以将程序所使用的内存地址映射内存中的实际地址（编译器来做）。每个进程都会有4G的内存，该内存被称为虚拟内存，从0开始往下排。在虚拟内存中有一个地方叫做栈，栈存储的是不是对象成员的值数据类型，调用方法时，栈存储传递给方法的所有参数副本。 栈实际上是向下填充的，先0x800000,然后0x799999 int a=10; double b=7999; 在运行到a=10时，int是四个字节，0x799999-0x799996被10占用，下一个空闲单元是0x799995,double 8个字节，就是0x799987 超出b的定义域后就会加8个字节，超出a的定义域后就会加4个字节。 ab进入栈的顺序是由编译器来决定的，编译器会查看作用域的顺序来决定哪个先进栈哪个后进栈。 引用类型的堆：堆上的内存是向上分配的 void Work() { Customer arabel;//1 arabel= new Customer();//2 Customer othercustomer2=new Customer();//3 } 首先1声明一个customer的引用arabel，在栈上给这个引用分配存储空间，该引用为4个字节， 2分配堆上的内存，以存储一个真正的Customer对象，然后把变量arabel的值设置为新分配的customer对象的内存地址，该customer可能包含32个字节，类的字节数和类的字段等成员有关 3是声明一个customer的引用，放在栈上，实例化一个customer对象放在堆上，将堆上的地址放到栈的引用上。 非托管堆： 当一个引用变量超出作用域时，它的引用会从栈中删除，但引用的对象任然在堆中，一直到程序终止，或垃圾回收器回收他们。 垃圾回收，删除堆中不再有被引用的所有对象，垃圾回收器（C++垃圾回收）在引用跟表中找到所有引用对象，在引用对象树中查找，在完成删除后，堆会立即把对象分散开来，与已经释放的内存混在一起。 托管堆： 如果托管堆也是这样，其给新对象分配内存时就是一个很难处理的问题，运行库必须遍历整个堆，才能找到足够大内存来存储新的对象。但垃圾回收器不会让堆处在这种状态，它在释放完可以释放的资源后，会将其他对象回推到堆的底部，再次形成连续数据块，在移动时所用引用都要更新，这需要垃圾回收器来完成。 垃圾回收期的压缩操作就是托管堆和非托管堆的区别，托管堆虽然要压缩，但分配内存时，只需要地址就好，不需要遍历地址列表。 创建对象时，会把对象放到托管堆上称为0代，创建新对象会被移动到这一部分，第一次回收后，保留下来的内容会被压缩移动到堆的下一部分上或世代部分，第1代对应部分，此时第0代对应的部分为空，新的对象依然被放到这个部分，遗留下来的内容让在第1代部分，第二次回收，第1代被压缩到第2代部分，第0代被压缩到第1代，第0代为空，放新的内容。如果新的对象超出第0代部分就会进行垃圾回收 垃圾回收可以提供应用程序性能，可以在架构堆上处理较大对象的方式， .NET较大对象有自己的堆，称为大对象堆，对象大于85000个字节就会被放在这个堆上，而不是主堆上，因为较大对象的压缩代价比较大，所以不放在主堆上压缩 第二代和大对象堆的回收即压缩过程是在后台线程中进行的 强引用和弱引用 仍在引用的对象的内存为强引用，可以回收不在根表中直接或间接引用的托管内存 A引用B,B引用C,C引用A，则GC会销毁所有对象。 实例化一个类，只要有代码引用它就是强引用 var myclassVariable = new MyClass(); var myCache=new MyCache(); myCache.Add(myclassVariable); myclassVariable=null//3 当第3步运行时就不能释放myclassVariable所引用的内存，因为缓存中还存在引用。在弱引用中就可以避免这种现象。 弱引用可以创建和使用对象，但是如果垃圾回收器在运行就可以回收 弱引用是由WeakReference创建的。需要使用IsAlive属性来确认是否被回收，Target属性可以返回一个强引用，不为null就可以访问 var myWeakReference = new WeakRefernece(new DataObject()); if(myWeakReference.IsActive) { DataObject strongReference=myWeakReference.Target as DataTarget; if(strongReference!=null) {} } else {} 垃圾回收器不释放非托管资源 比如：文件句柄，网络连接，数据库连接，等 定义类时，可以有两种机制来自动释放非托管资源 声明一个析构函数（或则终结器），作为类成员 class MyClass { ~MyClass() { } } 编译器在编译析构函数时，会隐式把析构函数的代码编译为等价于重写Finalize()方法的代码，从而确保父类的Finalize（）会被执行 等价 protected override void Finalize() { try {} finally { base.Finally(); } } C#析构函数具有不确定性，无法确定析构函数会被何时执行，同时析构函数会延迟对象从内存中删除的时间，有析构函数两次才能删除对象，第一次调用析构函数，第二次调用才真正删除，同时会被另起一个线程来调用Finally() 实现System.IDisposable 接口 该接口替代析构函数 class MyClass:IDisposable { public void Dispose() { } } Dispose()方法的实现显示释放由对象直接使用的所有非托管资源。Dispose为何时释放非托管资源提供了精确的控制。 using语句会自动调用Dispose()方法 上面的两种方法都实现了释放非托管资源 下面是一个双重实现的代码： using System; public class ResourceHolder:IDisposable { private bool _isDisposed=false; public void Dispose() { DisPose(true); GC.SuppressFinalize(this); } protected virtual void Dispose(bool disposing) { if(!_isDisposed) { if(disposing) { //cleanup managed objects by calling their dispose() methods } //clean up unmanaged objects } _isDisposed = true; } ~ResourceHolder() { Dispose(false); } public void SomeMethod() { //enture object not already disposed before execution of any method if(_isDisposed) { throw new ObjectDisposedException(\"ResourceHolder\"); } //method implementation } } ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:10","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"指针\rC#也是可以使用指针的，unsafe{}，在C#高级编程5.5不安全代码。留坑 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:11","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"运算符重载\r","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:12","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"事件\r对象可以激活和使用事件，作为他们处理的一部分，事件非常重要，可以在代码的其他部分起作用，类似于异常，但是功能更强大 可以在Animal对象添加到Animal集合中，执行特性的代码，而这部分代码不是Animal类的一部分，也不是调用Add()方法的代码的一部分，为此，需要给代码添加事件处理程序，这是一种特殊类型的函数，在事件发生时调用，还需要配置这个处理程序，以监听自己感兴趣的事情 private void Button1_Click_1(object sender, RoutedEventArgs e) { ((Button)sender).Content = \"clicked\"; Button newButton = new Button(); newButton.Content = \"NEW Button\"; newButton.Margin = new Thickness(10, 10, 200, 200); newButton.Click += newButton_click; ((Grid)((Button)sender).Parent).Children.Add(newButton); } private void newButton_click(object sender, RoutedEventArgs e) { ((Button)sender).Content = \"clicked\"; } ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:13","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"引用类型还是值类型\r在C#中，数据根据变量的类型以两种方法中的一种存储在一个变量中： 值类型的内存的同一个地方存储它们和它们的内容，栈 引用类型存储指向内存中其他某个位置的引用，实际内容存储在这个位置，堆 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:14","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"定义类\r类声明为内部，只有当前项目的代码能够访问 internal(默认) 其他项目代码也能访问public 类是抽象的，不能实例化，只能继承abstract，密封的sealed不能继承,如果基类是抽象的，在派生类必须全部实现 无或internal 只能在当前项目中访问 public可以在任何地方访问类 abstract或internal abstract类只能在当前项目访问，不能实例化，只能被继承 public abstracrt类可以在任何地方访问，不能实例化，只能继承 sealed或internal sealed类只能在当前项目访问，不能被继承，只能实例化 public sealed类可以在任何地方访问，不能被继承只能实例化 public sealed class MyClass { //Class members } 派生类的可访问性不能高于基类 类还可以指定接口，同时必须实现该接口的所有成员，如果不想使用给定的接口成员，就可以提供一个空的实现方法，继承类（只能有一个）再继承接口，接口可以有多个 接口的定义,不能在接口中使用abstract或sealed，可以使用继承的方式继承接口 interface IMyInterface { .... } 所有类都隐式继承System.Object类 多态性便可以使用，比较重要的基类方法GetType()ToStrign() if(myObject.GetType()==typeof(MyComplexClass)) { } 初始化列表 ：base(i) :this(5,6)调用自己的两个参数的构造函数，可以伪装成默认构造函数 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:15","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"定义类成员\rpublic,private,internal,protected readonly表示字段只能在执行构造函数的过程中赋值，static 静态变量，const也是静态的 方法 virtual方法可以重写 abstract方法必须在非抽象的派生类中重写（只用于抽象类中） override方法重写了一个基类方法（如果方法被重写，就必须要使用关键字）,如果使用了override,也可以使用sealed来指定在派生类中不能对这个方法做进一步修改即这个方法不能由派生类重写 extern方法定义在其他地方 多态测试，使用virtual和override多态测试成功 属性 定义与字段类似，get和set关键字来定义，可以控制属性的访问级别 右击refactor(重构)-Encapsulate Field可以快熟添加属性 自动属性： public int MyIntProp { get;set; } + 按通常的方式定义属性的名称、类型和可访问性，但是没有提供get和set的实现代码，实现代码由编译器提供（私有字段的名字也由编译器提供，将set变成private set即变成只读）\rprivate int myInt; public int myIntProp { get { return myInt; } public set { if(value\u003e0\u0026\u0026value\u003c10) myInt=value; else throw(new ArgumentOutOfRangeException(\"MyIntProp\",value,\"MyIntProp must be assigned a value between 0 and 10\")); } } 隐藏 隐藏基类方法，会产生2个警告（如果要确定隐藏需要加上new）,无论基类怎样限制，只要派生类没有调用override都是影藏 要对派生类的用户隐藏继承的公共成员，但仍能访问其功能，要给继承的虚拟成员添加实现代码，而不是简单地用重写的新实现代码替换它，可以使用base关键字：base.DoSomething() this最常用的功能是将当前对象实例的引用传递给一个方法，该方法有一个参数是指向基类的，this关键字的另一个常用方法是限定局部类型成员 class Animal { public void EatFood() { Console.WriteLine(\"Animal is adjusted\"); } } class Chicken : Animal { public void EatFood()//new public void EatFood() { Console.WriteLine(\"Chicken is adjusted\"); } } class Cow : Animal { public void EatFood()//new public void EatFood() { Console.WriteLine(\"Cow is adjusted\"); } } 套嵌类型成员 public class MyClass { public class MyNestedClass { public int NestedClassField; } }//实例化时： MyClass.MyNestedClass myObj=new MyClass.MyNestedClass(); public class ClassA { private int state = -1; public int State { get { return state; } } public class ClassB { public void SetPrivateState(ClassA target, int newState) { target.state = newState; } } } class Program { static void Main(string[] args) { ClassA myObject = new ClassA(); Console.WriteLine(\"myObject.State = {0}\", myObject.State); ClassA.ClassB myOtherObject = new ClassA.ClassB(); myOtherObject.SetPrivateState(myObject, 999); Console.WriteLine(\"myObject.State = {0}\", myObject.State); Console.ReadKey(); } }//嵌套类修改只读变量 接口 接口不会有访问修饰符 接口成员没有实现 接口没有字段成员(但是接口可以定义自动属性) 不能有关键字static/virtual/abstract/sealed来定义接口 但接口是可以继承的，如果要隐藏基类成员，需要加关键字new public interface IMyInterface { void DoSomething(); void DoSomethingElse(); } public class MyClass:IMyInterface { public void DoSomething() { } public void DoSomethingElse() { } }//接口类必须包含接口的所有成员包括匹配的指定签名包括get和set public interface IMyInterface { void DoSomething(); void DoSomethingElse(); } public class MyBaseClass { public void DoSomething() { } } public class MyDerivedClass:MyBaseClass,IMyInterface { public void DoSomethingElse() { } } public interface IMyInterface { void DoSomething(); void DoSomethingElse(); } public class MyBaseClass:IMyInterface { public virtual void DoSomething() { } public virtual void DoSomethingElse() { } } public class MyDerivedClass:MyBaseClass { public override void DoSomethingElse() { } public override void DoSomethingElse() { } } + 实现接口\rMyClass myObj=new MyClass(); IMyInterface myInt=myObj; myInt.DoSomething(); public class MyClass :IMyInterface { void IMyInterface.DoSomething()//显示调用 { } public void DoSomething()//隐式调用 { } } public interface IMyInterface { int MyIntProperty { get; } } public class MyBaseClass:IMyInterface { public int MyIntProperty{get;protected set;} } + 把接口放在不同的文件中partial\r//定义类时使用 public partial class MyClass { } //部分方法定义 public partial class MyClass { partial void DoSomethingElse(); public void DoSomething() { console.writeline(\"do something started\"); DoSomethingElse(); console.writeline(\"do something ended\"); } } public partial class MyClass { partial void DoSomethingElse() { console.writeline(\"DoSomethingElse called\"); } } //如果删除部分方法的实现部分，编译时编译器会以为调用了一个空的部分方法会直接删除部分方法的调用 集合 可以使用集合来维护对象组 集合大多是通过System.Collections名称空间中的接口而获得的，集合的语法已经标准化了 System.Collections包括几个接口： IEnumerable可以迭代集合中的项foreach ICollection继承上一个接口，可以获取集合中项的个数，并能把项复制到一个简单的数组类型中count()copyto(),add(),remove(),clear() IList继承上两个接口，提供了集合的项列表，允许访问这些项，并提供一些基本功能insert(),removeat(),派生于Icollection\u003cT\u003e接口 ISet获取两个集合的交集 IDictionary继承与前两个接口，可以通过键值访问项列表 ILookup接口，键和值 Icomparer实现compar","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:16","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"泛型\r泛型是以实例化的过程中提供的类型或类为基础建立的，可以毫不费力的对对象进行强类型化,使用泛型强化为各种类型。与C++不同，C++是在编译期间来强类型化，而C#是在运行期间强类型化 CollectionClass\u003cItemClass\u003e items= new CollectionClass\u003cItemClass\u003e(); items.Add(new ItemClass); .net 提供的泛型，包括System.Collections.Generic名称空间 可空类型，引用类型可以为空，值类型必须有一个值，扩展值类型让其可为空，泛型使用了System.Nullable类型提供了值类型为空的一种方法 System.Nullable\u003cint\u003e nullableInt;变量nullableInt可以包含int类型的任意值，还可以拥有null nullableInt=null;等价于nullableInt=new System.Nullable\u003cint\u003e(); nullableInt.HasValue,该方法不适用于引用类型，引用类型本身可能为NULL int？ nullableInt；int？是System.Nullable\u003cint\u003e 的缩写 可控类型null+任何数都为null,null在布尔运算中的大小介于FALSE和TRUE之间 ？？运算符为空结合运算符，是一个二元运算符，允许给可能等于NULL的表达式提供另一个值，op1??op2等价于op1==null?op2:op1; List\u003cT\u003e myCollection=new List\u003cT\u003e(); Item 获取或设置指定索引处的元素。 Count 获取 List 中实际包含的元素数。 Add 将对象添加到 List 的结尾处。 AddRange 将指定集合的元素添加到 List 的末尾。 Clear 从 List 中移除所有元素。 Contains 确定某元素是否在 List 中。 ConvertAll 将当前 List 中的元素转换为另一种类型，并返回包含转换后的元素的列表。 Equals(Object) 确定指定的 Object 是否等于当前的 Object。 （继承自 Object。） Remove 从 List 中移除特定对象的第一个匹配项。 Sort() 使用默认比较器对整个 List 中的元素进行排序。 ToArray 将 List 的元素复制到新数组中。 ToString 返回表示当前对象的字符串。 （继承自 Object。） using System.Collections.Generic; List\u003cAnimal\u003e animalCollection = new List\u003cAnimal\u003e(); animalCollection.Add(new Cow(\"Jack\")); animalCollection.Add(new Chicken(\"Vera\")); foreach (Animal myAnimal in animalCollection) { myAnimal.Feed(); } 或者 public class Animals:List\u003cAnimal\u003e {} 对泛型进行排序 System.Collections.Generic名称空间包含List\u003cT\u003eT类型对象集合,Dictionary\u003cK,V\u003e与K类型的键值相关的V类型的项的集合 List\u003cT\u003e 使用泛型接口IComparer\u003cT\u003e和IComparable\u003cT\u003e int IComparable\u003cT\u003e.CompareTo(T otherObj) bool IComparable\u003cT\u003e.Equals(T otherObj) int IComparer\u003cT\u003e.Compare(T objectA,T objectB) bool ICompare\u003cT\u003e.Equals(T objectA,T objectB) int IComparer\u003cT\u003e.GetHashCode(T objectA) 给列表排序，需要有一个方法来比较两个T类型的对象，要在列表中搜索，需要用一个方法来检查T类型的对象 两个泛型委托： Comparison\u003cT\u003e int method(T objectA,TobjectB) Predicate\u003cT\u003e bool method(T targetObject) public class Vectors : List\u003cVector\u003e { public Vectors() { } public Vectors(IEnumerable\u003cVector\u003e initialItems) { foreach (Vector vector in initialItems) { Add(vector); } } public string Sum() { StringBuilder sb = new StringBuilder();//表示可变字符字符串 Vector currentPoint = new Vector(0.0, 0.0); sb.Append(\"origin\"); foreach (Vector vector in this) { sb.AppendFormat(\" + {0}\", vector); currentPoint += vector; } sb.AppendFormat(\" = {0}\", currentPoint); return sb.ToString(); } } public static class VectorDelegates { public static int Compare(Vector x, Vector y) { if (x.R \u003e y.R) { return 1; } else if (x.R \u003c y.R) { return -1; } return 0; } public static bool TopRightQuadrant(Vector target) { if (target.Theta \u003e= 0.0 \u0026\u0026 target.Theta \u003c= 90.0) { return true; } else { return false; } } } class Program { static void Main(string[] args) { Vectors route = new Vectors(); route.Add(new Vector(2.0, 90.0)); route.Add(new Vector(1.0, 180.0)); route.Add(new Vector(0.5, 45.0)); route.Add(new Vector(2.5, 315.0)); Console.WriteLine(route.Sum()); Comparison\u003cVector\u003e sorter = new Comparison\u003cVector\u003e(VectorDelegates.Compare);//委托 route.Sort(sorter);//这个个语句可以简化route.Sort(VectorDelegates.Compare); Console.WriteLine(route.Sum()); Predicate\u003cVector\u003e searcher = new Predicate\u003cVector\u003e(VectorDelegates.TopRightQuadrant);//委托 Vectors topRightQuadrantRoute = new Vectors(route.FindAll(searcher)); Console.WriteLine(topRightQuadrantRoute.Sum()); Console.ReadKey(); } } + `Dictionary\u003cK,V\u003e`该类型建立键/值对应这个类需要实例化两个类型，分别用于键和值\rDictionary\u003cstring ,int\u003ethings=new Directionary\u003cstring ,int \u003e() things.Add(\"Green Things\",29); foreach(strign key in things.Values) { using key; } foreach(int value in things.Values) { usign value } foreach(KeyValuePair\u003cstring,int \u003e thing in things) { using things.key and things.value } + 每个键都独立的，如果相同抛出异常`Dictionary\u003cstring ,int\u003ethings=new Directionary\u003cstring ,int \u003e(stringComparer.CurrentCultureIgnoreCase)`自己的类用作键，不区分发小写比较，这样同一个类就会出现异常\r定义泛型 要创建泛型类 class MyGenericClass\u003cT1,T2,T3\u003e { } + 定义泛型后就可以像使用其他数据类型一样使用它们\r+ default关键字,default(T1),如果T1是值类型使之默认为0，如果为引用就默认为null\r+ 约束\rclass MyGenericClass\u003cT1,T2,T3\u003e where T:constraint1,constraint2 { } //约束必须在继承后面 + struct类型必须为值类型\r+ class类型必须为引用类型\r+ ba","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:17","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"事件\r事件必须订阅，可以由多个订阅 using System.Timers; class Program { static int counter = 0; static string displayString = \"This string will appear one letter at a time. \"; static void Main(string[] args) { Timer myTimer = new Timer(100);//创建定时器，毫秒 myTimer.Elapsed += new ElapsedEventHandler(WriteChar);//Elapsed事件该事件必须匹配System.Timers.ElapsedEventHandler委托类型的返回值 //处理程序和事件订阅起来，事件处理方法初始化为一个新的委托实例 //可以直接写成myTimer.Elapsed +=WriteChar； myTimer.Start();//启动定时器 System.Threading.Thread.Sleep(200);//将当前线程阻塞指定的毫秒数 Console.ReadKey(); } static void WriteChar(object source, ElapsedEventArgs e) { Console.Write(displayString[counter++ % displayString.Length]); } } System.Timers.ElapsedEventHandler委托类型是标准委托之一， void \u003cMethodName\u003e(object source,ElapsedEventArgs e) 定义事件 public delegate void MessageHandler(string messageText);//定义委托，该委托用于定义的事件必须指明返回值的参数值 public class Connection { public event MessageHandler MessageArrived;//给时间命名并指定委托的类型 private Timer pollTimer;//定时器 public Connection() { pollTimer = new Timer(100);//定时器时间 pollTimer.Elapsed += new ElapsedEventHandler(CheckForMessage);//定时器的事件委托 } public void Connect() { pollTimer.Start();//定时器开始 } public void Disconnect() { pollTimer.Stop();//定时器结束 } private static Random random = new Random(); private void CheckForMessage(object source, ElapsedEventArgs e)//定时器的委托函数； { Console.WriteLine(\"Checking for new messages.\"); if ((random.Next(9) == 0) \u0026\u0026 (MessageArrived != null))///生成一个0-9的数，如果是0，并且事件有订阅者，则事件实现委托就使用委托来 { MessageArrived(\"Hello Mum!\"); } } } public class Display { public void DisplayMessage(string message) { Console.WriteLine(\"Message arrived: {0}\", message); } } class Program { static void Main(string[] args) { Connection myConnection = new Connection(); Display myDisplay = new Display(); myConnection.MessageArrived +=new MessageHandler(myDisplay.DisplayMessage);//将委托和函数绑定 myConnection.Connect(); System.Threading.Thread.Sleep(200); Console.ReadKey(); } } 多用途事件处理程序 Timer.Elapsed事件的委托包含了事件处理程序中常见的两类参数 object source:引发事件对象的引用 ElapsdEventArgs:由事件传送的参数 由不同对象引发的几个相同事件使用相同事件处理程序 public class MessageArrivedEventArgs : EventArgs//定义消息类 { private string message; public string Message { get { return message; } } public MessageArrivedEventArgs() { message = \"No message sent.\"; } public MessageArrivedEventArgs(string newMessage) { message = newMessage; } } public class Connection { public event EventHandler\u003cMessageArrivedEventArgs\u003e MessageArrived;//事件，EventHandler\u003cT\u003e为委托模板，将消息类传入 private Timer pollTimer; public string Name { get; set; } public Connection() { pollTimer = new Timer(100); pollTimer.Elapsed += new ElapsedEventHandler(CheckForMessage); } public void Connect() { pollTimer.Start(); } public void Disconnect() { pollTimer.Stop(); } private static Random random = new Random(); private void CheckForMessage(object source, ElapsedEventArgs e) { Console.WriteLine(\"Checking for new messages.\"); if ((random.Next(9) == 0) \u0026\u0026 (MessageArrived != null)) { MessageArrived(this, new MessageArrivedEventArgs(\"Hello Mum!\"));//发送消息 } } } public class Display//事件响应函数 { public void DisplayMessage(object source, MessageArrivedEventArgs e) { Console.WriteLine(\"Message arrived from: {0}\", ((Connection)source).Name); Console.WriteLine(\"Message Text: {0}\", e.Message); } } class Program { static void Main(string[] args) { Connection myConnection1 = new Connection(); myConnection1.Name = \"First connection.\"; Connection myConnection2 = new Connection(); myConnection2.Name = \"Second connection.\"; Display myDisplay = new Display(); myConnection1.MessageArrived += myDisplay.DisplayMessage; myConnection2.MessageArrived += myDisplay.DisplayMessage; myConnection1.Connect(); myConnection2.Connect(); System.Threading.Thread.Sleep(200); Console.ReadKey(); } } + .net提供了两个委托类型：EventHandler和`EventHandler\u003cT\u003e`\r+ 匿名方法，纯粹是为了用作委托目的而创建的\rdelegate(parameters) { } parameters参数化列表 myConnection1.MessageArrived += delegate(Connection source,MessageArriveEventArgs e) {Console.writeline(\"message arrived from{0}\",source.Name);} ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:18","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"特性，元数据\r可以为代码段标记一些信息，这些信息可以从外部读取 [DebuggerStepThrough] public void DullMethod() {}该特性说明，在调试的时候不进入该方法进行逐句调试，而是跳过该方法,该特性通过DebuggerStepThroughAttribute这个类来实现的，这个类位于System.Diagnostics名称空间中 特性的参数可以自己设置[DoesInterestingThings(1000, WhatDoesItDo = “voodoo”)] 读取特性需要用到反射,Type.GetCustomAttributes来实现 ","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:5:19","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"补充\r对象初始化器 省略构造函数的括号，自动调用无参数构造函数，之后调用初始化器 同时对象初始化器还可以进行嵌套 //初始化器,使用默认构造函数实现赋值 \u003cclassname\u003e \u003cvariableName\u003e=new \u003cclaseename\u003e { \u003cpropertyOrField1\u003e=\u003cvalue1\u003e, \u003cpropertyOrField2\u003e=\u003cvalue2\u003e, \u003cpropertyOrField3\u003e=\u003cvalue3\u003e, ... } Curry tastyCurry=new Curry { MainInte=\"ddddd\"; Origin=new restaurant { Name=\"ddd\"; } }; 集合初始化器 类型推理：var ,编译器来确定类型，var关键字还可以通过数组初始化器来推断数组的类型：var myarray=new [] {4,5,6,7};4,5,6,7必须遵循：相同的类型，相同的引用类型或空，所有元素的类型都可以隐式转换为同一类型 匿名对象：为了减少创建对象所消耗的时间，其理念就是让编辑器根据要存储的数据自动创建类型，而不是定义简单的数据存储类型 匿名类型 var curry=new { MainIngredient=\"lamb\", Style=\"Dhansnk\", Spiciness=5 }; + 使用var关键字，因为匿名类型没有可以使用的标识符，\r+ new后面没有指定类型的名称\r+ 匿名对象的属性被定义为只读，如果在存储对象中修改属性的值，就不能使用匿名对象。\r+ 使用动态查找功能可以处理未知的C#类型\rclass Program { static void Main(string[] args) { var curries = new[] { new { MainIngredient = \"Lamb\", Style = \"Dhansak\", Spiciness = 5 }, new { MainIngredient = \"Lamb\", Style = \"Dhansak\", Spiciness = 5 }, new { MainIngredient = \"Chicken\", Style = \"Dhansak\", Spiciness = 5 } }; Console.WriteLine(curries[0].ToString()); Console.WriteLine(curries[0].GetHashCode()); Console.WriteLine(curries[1].GetHashCode()); Console.WriteLine(curries[2].GetHashCode()); Console.WriteLine(curries[0].Equals(curries[1]));//比较状态，即每个属性的值 Console.WriteLine(curries[0].Equals(curries[2])); Console.WriteLine(curries[0] == curries[1]); Console.WriteLine(curries[0] == curries[2]); Console.ReadKey(); } } { MainIngredient = Lamb, Style = Dhansak, Spiciness = 5 } 294897435 294897435 621671265 True False False False 动态类型：dynamic myDynamicVar;在编译期间会被object替代， 默认参数类型 可变参数 命名参数：首先选定必选参数，再指定命名的可选参数 public static List\u003cstring\u003e GetWords( string sentence, bool capitalizeWords = false, bool reverseOrder = false, bool reverseWords = false) { List\u003cstring\u003e words = new List\u003cstring\u003e(sentence.Split(' ')); if (capitalizeWords) words = CapitalizeWords(words); if (reverseOrder) words = ReverseOrder(words); if (reverseWords) words = ReverseWords(words); return words; } words = WordProcessor.GetWords( sentence, reverseWords: true, capitalizeWords: true); 扩展方法 要创建和使用扩展方法必须： 创建一个非泛型静态类 使用扩展方法的语法，为所创建的类添加扩展方法，做为静态方法 确保使用扩展方法的代码用using语法导入包含扩展方法类的名称空间 通过扩展类型的一个实例调用扩展方法，与调用扩展类型的其他方法一样。 扩展方法的要求： 方法必须是静态的 方法必须包含一个参数，表示调用扩展方法的类型实例 实例参数必须是方法定义的第一个参数， 除了this关键字外，实例参数不能有其他修饰符 public static class ExtensionClass { public static \u003cReturnType\u003e \u003cExtensionMethodName\u003e(this \u003cTyprToExtend\u003e instance ,\u003cotherParamters\u003e) { ... } } public static class ExtensionClass { public static \u003cReturnType\u003e \u003cExtensionMethodName\u003e(this \u003cTyprToExtend\u003e instance ,\u003cotherParamters\u003e) { ... } } \u003cTypeToExtend\u003e myVar; //myVar is initialized by code not shown here myVar.\u003cExtensionMethodName\u003e(); \u003cTypeToExtend\u003e myVar; ExtensionClass.\u003cExtensionMethodName\u003e(myVar); //导入后可以通过IntelliSense查看扩展方法 //定义了一个扩展方法后还可以将其运用到派生于这个类型的子类型中 namespace ExtensionLib { public static class WordProcessor { public static List\u003cstring\u003e GetWords( this string sentence, bool capitalizeWords = false, bool reverseOrder = false, bool reverseWords = false) { List\u003cstring\u003e words = new List\u003cstring\u003e(sentence.Split(' ')); if (capitalizeWords) words = CapitalizeWords(words); if (reverseOrder) words = ReverseOrder(words); if (reverseWords) words = ReverseWords(words); return words; } public static string ToStringReversed(this object inputObject) { return ReverseWord(inputObject.ToString()); } } } using ExtensionLib; static void Main(string[] args) { Console.WriteLine(\"Enter a string to convert:\"); string sourceString = Console.ReadLine(); Console.WriteLine(\"String with title casing: {0}\", sourceString.GetWords(capitalizeWords: true) .AsSentence()); Console.WriteLine(\"String backwards: {0}\", sourceString.GetWords(reverseOrder: true, reverseWords: true).AsSentence()); Console.WriteLine(\"String length backwards: {0}\", sourceString.Length.ToStringReversed()); Console.ReadKey(); } lambda表达式 定义一个事件处理方法，其返回类型和参数匹配要订阅的事件需要委托返回类型和参数 声明一个委托类型的变量 把委托变量初始化为委托类型的实例，实例指向事件处理方法 把委托变量添加到时间的订阅者列表中 正常的事件 Timer myTimer =new Timer(1000); myTimer.Elapsed+=new ElapsedEvendHandler(WriteChar); //可以直接写成 myTimer.Elapsed+=WriteChar； //使","date":"2018-11-22","objectID":"/2018/11/dotnetbase2-sql-adonet/:6:0","tags":["DotNet基础","入门"],"title":"DotNet基础 入门","uri":"/2018/11/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数据库\r","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:0:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数据库概述\rDBMS(DataBase Management System,数据库管理系统)和数据库。平时谈到“数据库”可能有两种含义：MSSQLServer、Oracle等某种DBMS；存放一堆数据表的一个分类(Catalog) 数据库的构成-管理软件/服务/数据文件(表,视图…) 不同品牌的DBMS有自己的不同的特点：MYSQL、MSSQLServer、DB2、Oracle、Access、Sybase等。对于开发人员来讲，大同小异 除了Access、SQLServerCE等文件型数据库之外，大部分数据库都需要数据库服务器才能运行。学习\\开发时是连接本机的数据库，上线运行时是数据库运行在单独的服务器 为什么要用数据库：我们平时把数据以文件的方式存放在硬盘里，但当数据量庞大的时候：文件大，操作效率很低下。所以，便有了很多种数据库软件(Mssql,Ora,DB2…)，它们代替我们做数据文件的操作(mdf,ndf,ldf)并提供高效的存储和检索等操作。还提供了很多接口给其他程序语言调用。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:1:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"为什么要使用数据库\r用文件保存数据与用数据库的优劣： 高效维护大量数据-检索/增/删/改 处理各个表之间的关系 压缩表数据 安全 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:2:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数据库的概念\rCatalog(分类)(又叫数据库DataBase,表空间TableSpace),不同类的数据应该放到不同的数据库中 便于对各个Catalog进行个性化管理 避免命名冲突3安全性更高 Table(表):书都放到书架上,碗都放到橱柜中,不同类型的资料放到不同的“格子”中，将这种区域叫做“表”(Table)。不同的表根据放的数据不同进行空间的优化，找起来也方便。 列(Column)、字段(Field) 主键(Primary Key)：主键就是一个表中每个数据行的唯一标识。不会有重复值的列才能当主键。一个表可以没有主键，但是会非常难以处理，因此没有特殊理由表都要设定主键 主键有两种选用策略：业务主键和逻辑主键。业务主键是使用有业务意义的字段做主键，比如身份证号、银行账号等；逻辑主键是使用没有任何业务意义的字段做主键，完全给程序看的，业务人员不会看的数据。因为很难保证业务主键不会重复（身份证号重复）、不会变化（帐号升位），因此推荐用逻辑主键。 外键(Foreign Key)—记录表与表的关联 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:3:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"SQLSERVER管理\r需要安装SQLServer2005或者SQLServer2008，若要使用SQLServer管理工具进行开发还要安装SQL Server Management Studio，还可以使用VisualStudio进行管理 使用免费的SQL Server Express版本，Express版本的服务器名称. \\SQLEXPRESS，对于开发人员来讲和其他版本没有区别。 SQLServer的两种验证方式：用户名验证和Windows验证，开发时用Windows验证就行。 开发人员关注点在开发上,而不是配置/备份等之上,那是DBA做的事情。 创建数据库，创建表，设置主键 SQLServer2008中：编辑200行；SQLServer2005中：打开表。 常用字段类型：bit(可选值0、1)、datetime、int、varchar、nvarchar（可能含有中文用nvarchar） Nvarchar(50)、Nvarchar(MAX) varchar、nvarchar 和char(n)的区别： char(n)不足长度n的部分用空格填充。Var：Variable，可变的。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:4:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"SQL语句入门\rSQL语句是和DBMS“交谈”专用的语句，不同DBMS都认SQL语法 SQL语句中字符串用单引号。 SQL语句是大小写不敏感的,不敏感指的是SQL关键字,字符串值还是大小写敏感的 创建表、删除表不仅可以手工完成,还可以执行SQL语句完成,在自动化部署、数据导入中用的很多,CREATE TABLE T_Person(Id int NOT NULL,Name nvarchar(50),Age int NULL)、Drop table T_Person1 简单的Insert语句。INSERT INTO T_Person(Id,Name,Age) VALUES(1,'Jim',20) （*） SQL主要分DDL（数据定义语言）和DML（数据操作语言）两类。Create Table、Drop Table、Alter Table等属于DDL，Select、Insert、Update、Delete等属于DML ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:5:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"主键的选择\rSQLServer中两种常用的主键数据类型：int（或bigint）+标识列(又称自动增长字段);uniqueidentifier(又称Guid、UUID) 用标识列实现字段自增可以避免并发等问题，不要开发人员控制自增。用标识列的字段在Insert的时候不用指定主键的值。将字段的“是标识列”设置为“是”，一个表只能有一个标识列。 Guid算法是一种可以产生唯一标识的高效算法，它使用网卡MAC、地址、纳秒级时间、芯片ID码等算出来的，这样保证每次生成的GUID永远不会重复，无论是同一个计算机上还是不同的计算机。在公元3400年以前产生的GUID与任何其他产生过的GUID都不相同。SQLServer中生成GUID的函数newid()，.Net中生成Guid的方法：Guid.NewGuid()，返回是Guid类型。 （*）Int自增字段的优点：占用空间小、无需开发人员干预、易读；缺点：效率低；数据导入导出的时候很痛苦。 （*）Guid的优点：效率高、数据导入导出方便；缺点占用空间大、不易读。 业界主流倾向于使用Guid。 Globally Unique Identifier(全球唯一标识符),也称作 UUID(Universally Unique IDentifier) GUID：用于指示产品的唯一性安装。是通过特定算法产生的一个二进制长度为128位的数字。在空间上和时间上具有唯一性，保证同一时间不同地方产生的数字不同。在公元3400年以前产生的UUID/GUID与任何其他产生过的UUIDs/GUIDs都不相同 GUID的长度固定，并且相对而言较短小，非常适合于排序、标识和存储。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:6:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"新增\r新增表和参数 CREATE TABLE T_Employee (FNumber VARCHAR(20),FName VARCHAR(20),FAge INT,FSalary NUMERIC(10,2),PRIMARY KEY (FNumber)); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('DEV001','Tom',25,8300); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('DEV002','Jerry',28,2300.80); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('SALES001','John',23,5000); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('SALES002','Kerry',28,6200); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('SALES003','Stone',22,1200); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('HR001','Jane',23,2200.88); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('HR002','Tina',25,5200.36); INSERT INTO T_Employee(FNumber,FName,FAge,FSalary) VALUES('IT001','Smith',28,3900); INSERT INTO T_Employee(FNumber,FAge,FSalary) VALUES('IT002',27,2800); 插入一列 ALTER TABLE T_Employee ADD FSubCompany VARCHAR(20); UPDATE T_Employee SET FSubCompany='Beijing',FDepartment='Development' WHERE FNumber='DEV001'; Insert语句可以省略表名后的列名，但是不推荐 如果插入的行中有些字段的值不确定，那么Insert的时候不指定那些列即可。 可以给字段默认值，如果Guid类型主键的默认值设定为newid()就会自动生成，很少这么干 主键： insert into Person3(Name,Age) values('lily',38); insert into Person4(Id,Name,Age) values(newid(),'tom',30); ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:7:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"更新\r更新一个列:UPDATE T_Person Set Age=30 更新多个列:UPDATE T_Person Set Age=30,Name=‘tom’ 更新一部分数据： UPDATE T_Person Set Age=30 where Name=‘tom’，用where语句表示只更新Name是’tom’的行，注意SQL中等于判断用单个=，而不是== Where中还可以使用复杂的逻辑判断UPDATE T_Person Set Age=30 where Name=‘tom’ or Age\u003c25，or相当于C#中的||（或者） update Person1 set NickName=N'二十岁' where (Age\u003e20 and Age\u003c30) or(Age=80) Where中可以使用的其他逻辑运算符：or、and、not、\u003c、\u003e、\u003e=、\u003c=、!=（或\u003c\u003e）等 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:8:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"删除\r删除表中全部数据：DELETE FROM T_Person。 Delete只是删除数据，表还在，和Drop Table不同。 Delete 也可以带where子句来删除一部分数据：DELETE FROM T_Person WHERE FAge \u003e 20 Truncate 删除所有行并重置标识 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:9:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"检索\r执行备注中的代码创建测试数据表。 简单的数据检索 ：SELECT * FROM T_Employee 只检索需要的列 ：SELECT FNumber FROM T_Employee 、SELECT FName,FAge FROM T_Employee 列别名：SELECT FNumber AS 编号,FName AS 姓名,FAge AS Age111 FROM T_Employee 使用where检索符合条件的数据：SELECT FName FROM T_Employee WHERE FSalary\u003c5000。故事：新员工的数据检索噩梦。 还可以检索不与任何表关联的数据：select 1+1;select newid();select getdate(); ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:10:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数据汇总\rSQL聚合函数：MAX（最大值）、MIN（最小值）、AVG （平均值）、SUM （和）、COUNT（数量） 大于25岁的员工的最高工资 ： SELECT MAX(FSalary) FROM T_Employee WHERE FAge\u003e25 最低工资和最高工资： SELECT MIN(FSalary),MAX(FSalary) FROM T_Employee ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:11:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"排序\rORDER BY子句位于SELECT语句的末尾，它允许指定按照一个列或者多个列进行排序，还可以指定排序方式是升序（从小到大排列，ASC）还是降序（从大到小排列，DESC）。 按照年龄升序排序所有员工信息的列表： SELECT * FROM T_Employee ORDER BY FAge ASC 按照年龄从大到小排序，如果年龄相同则按照工资从大到小排序 ：SELECT * FROM T_Employee ORDER BY FAge DESC,FSalary DESC（多个排序条件） ORDER BY子句要放到WHERE子句之后 ：SELECT * FROM T_Employee WHERE FAge\u003e23 ORDER BY FAge DESC,FSalary DESC ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:12:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"通配过滤符\r通配符过滤关键字使用LIKE 。 单字符匹配的通配符为半角下划线“_”，它匹配单个出现的字符。 eg:以任意字符开头，剩余部分为“erry” SELECT * FROM T_Employee WHERE FName LIKE '_erry' 多字符匹配的通配符为半角百分号“%”，它匹配任意次数（零或多个）出现的任意字符。 “k%”匹配以“k”开头、任意长度的字符串 eg:检索姓名中包含字母“n”的员工信息 SELECT * FROM T_Employee WHERE FName LIKE '%n%' ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:13:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"空值处理\r数据库中，一个列如果没有指定值，那么值就为null，这个null和C#中的null，数据库中的null表示“不知道”，而不是表示没有。 因此select null+1结果是null，因为“不知道”加1的结果还是“不知道”。 SELECT * FROM T_Employee WHERE FNAME=null ； SELECT * FROM T_Employee WHERE FNAME!=null ； 都没有任何返回结果，因为数据库也“不知道”。 SQL中使用is null、is not null来进行空值判断： SELECT * FROM T_Employee WHERE FNAME is null ； SELECT * FROM T_Employee WHERE FNAME is not null ； ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:14:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"多值匹配\r删除多条数据 Delete T_Employee where FId in (21,22) SELECT FAge,FNumber,FName FROM T_Employee WHERE FAge IN (23,25,28) 范围值： SELECT * FROM T_Employee WHERE FAGE\u003e=23 AND FAGE \u003c=27 SELECT * FROM T_Employee WHERE FAGE BETWEEN 23 AND 27 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:15:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数据分组\r按照年龄进行分组统计各个年龄段的人数：SELECT FAge,Count(*) FROM T_Employee GROUP BY Fage GROUP BY子句必须放到WHERE语句的之后 没有出现在GROUP BY子句中的列是不能放到SELECT语句后的列名列表中的 (聚合函数中除外) 错误： SELECT FAge,FSalary FROM T_Employee GROUP BY FAge 正确： SELECT FAge,AVG(FSalary) FROM T_Employee GROUP BY FAge ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:16:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"对分组进行过滤\r在Where中不能使用聚合函数，必须使用Having，Having要位于Group By之后： SELECT FAge,COUNT(*) AS 人数 FROM T_Employee GROUP BY FAge HAVING COUNT(*)\u003e1 在分组的时候对分组后的成员进行过滤 注意Having中不能使用未参与分组的列，Having不能替代where。作用不一样，Having是对组进行过滤。having和where不会同时出现 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:16:1","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"限制结果集行数\rSELECT top 5 * FROM T_Employee order by FSalary Desc （*）检索按照工资从高到低排序检索从第六名开始一共三个人的信息 ： SELECT top 3 * FROM T_Employee WHERE FNumber NOT IN (SELECT TOP 5 FNumber FROM T_Employee ORDER BY FSalary DESC) ORDER BY FSalary DESC 该语句用来分页语句。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:17:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"去掉重复数据\r执行备注中的SQL语句，Alter和Insert单独执行 SELECT FDepartment FROM T_Employee SELECT DISTINCT FDepartment FROM T_Employee DISTINCT是对整个结果集进行数据重复处理的，而不是针对每一个列，因此下面的语句并不会只保留Fdepartment进行重复值处理：SELECT DISTINCT FDepartment,FSubCompany FROM T_Employee ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:18:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"联合结果集\rCREATE TABLE T_TempEmployee (FIdCardNumber VARCHAR(20),FName VARCHAR(20),FAge INT, PRIMARY KEY (FIdCardNumber)); INSERT INTO T_TempEmployee(FIdCardNumber,FName,FAge) VALUES('1234567890121','Sarani',33); INSERT INTO T_TempEmployee(FIdCardNumber,FName,FAge) VALUES('1234567890122','Tom',26); INSERT INTO T_TempEmployee(FIdCardNumber,FName,FAge) VALUES('1234567890123','Yalaha',38); INSERT INTO T_TempEmployee(FIdCardNumber,FName,FAge) VALUES('1234567890124','Tina',26); INSERT INTO T_TempEmployee(FIdCardNumber,FName,FAge) VALUES('1234567890125','Konkaya',29); INSERT INTO T_TempEmployee(FIdCardNumber,FName,FAge) VALUES('1234567890126','Fotifa',46); 简单的结果集联合： SELECT FNumber,FName,FAge FROM T_Employee UNION SELECT FIdCardNumber,FName,FAge FROM T_TempEmployee 基本的原则：每个结果集必须有相同的列数；每个结果集的列必须类型相容。 SELECT FNumber,FName,FAge,FDepartment FROM T_Employee UNION SELECT FIdCardNumber,FName,FAge,‘临时工，无部门' FROM T_TempEmployee ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:19:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"union all\rSELECT FName FROM T_Employee UNION SELECT FName FROM T_TempEmployee UNION 合并两个查询结果集，并且将其中完全重复的数据行合并为一条 SELECT FName FROM T_Employee UNION ALL SELECT FName FROM T_TempEmployee Union因为要进行重复值扫描，所以效率低，因此如果确定不要合并重复行，那么就用UNION ALL ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:19:1","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数字函数\rABS() ：求绝对值。 CEILING()：舍入到最大整数 。3.33将被舍入为4、2.89将被舍入为3、-3.61将被舍入为-3。 Ceiling→天花板 FLOOR()：舍入到最小整数。3.33将被舍入为3、2.89将被舍入为2、-3.61将被舍入为-4。 Floor→地板。 ROUND()：四舍五入。舍入到“离我半径最近的数” 。Round→“半径”。Round(3.1425,2)。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:20:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"string\rLEN() ：计算字符串长度，求字符 Datalength():求字节 LOWER() 、UPPER () ：转小写、大写 LTRIM()：字符串左侧的空格去掉 RTRIM () ：字符串右侧的空格去掉 LTRIM(RTRIM(’ bb ‘)) SUBSTRING(string,start_position,length) 参数string为主字符串，start_position为子字符串在主字符串中的起始位置，length为子字符串的最大长度。SELECT SUBSTRING('abcdef111',2,3) ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:20:1","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"日期\rGETDATE() ：取得当前日期时间 DATEADD (datepart , number, date )，计算增加以后的日期。参数date为待计算的日期；参数number为增量；参数datepart为计量单位，可选值见备注。DATEADD(DAY, 3,date)为计算日期date3天后的日期，而DATEADD(MONTH ,-8,date)为计算日期date8个月之前的日期 DATEDIFF ( datepart , startdate , enddate ) ：计算两个日期之间的差额。 datepart 为计量单位，可取值参考DateAdd。 统计不同工龄的员工的个数： select DateDiff(year,FInDate,getdate()),count(*) from T_Employee group by DateDiff(year,FInDate,getdate()) DATEPART (datepart,date)：返回一个日期的特定部分 统计员工的入职年份个数： select DatePart(year,FInDate),count(*) from T_Employee group by DatePart(year,FInDate) ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:20:2","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"类型转换函数\rCAST ( expression AS data_type) CONVERT ( data_type, expression) SELECT FIdNumber, RIGHT(FIdNumber,3) as 后三位, CAST(RIGHT(FIdNumber,3) AS INTEGER) as 后三位的整数形式, CAST(RIGHT(FIdNumber,3) AS INTEGER)+1 as 后三位加1, CONVERT(INTEGER,RIGHT(FIdNumber,3))/2 as 后三位除以2 FROM T_Person ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:21:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"空值处理函数\rISNULL(expression,value) ： 如果expression不为空则返回expression，否则返回value SELECT ISNULL(FName,'佚名') as 姓名 FROM\rT_Employee ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:22:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"case\r单值判断，相当于switch case CASE expression WHEN value1 THEN returnvalue1 WHEN value2 THEN returnvalue2 WHEN value3 THEN returnvalue3 ELSE defaultreturnvalue END 例子SELECT SELECT FName, (CASE FLevel WHEN 1 THEN 'VIP客户' WHEN 2 THEN '高级客户' WHEN 3 THEN '普通客户' ELSE '客户类型错误' END) as FLevelName FROM T_Customer select FName, ( case when FSalary\u003c2000 then '低收入' when FSalary\u003e=2000 and FSalary\u003c=5000 then '中等收入' else '高收入' end ) as 收入水平 from T_Employee SELECT FName, FWeight, (CASE WHEN FWeight\u003c40 THEN '瘦瘦' WHEN FWeight\u003e50 THEN '肥肥' ELSE 'ok' END) as isnormal FROM T_Person ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:23:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"索引index\r分为聚集索引和非聚集索引， 聚集索：聚集索引就相当于使用字典的拼音查找，因为聚集索引存储记录是物理上连续，即拼音a过后一定是b. 非聚集索引，就相当于使用字典的首部查找，逻辑连续，物理不连续。 全表扫描：对数据进行检索（select）效率最差的是全表扫描，就是一条条的找。 如果没有目录，查汉语字典就要一页页的翻，而有了目录只要查询目录即可。为了提高检索的速度，可以为经常进行检索的列添加索引，相当于创建目录。 创建索引的方式，在表设计器中点击右键，选择“索引/键”→添加→在列中选择索引包含的列。不能为空 使用索引能提高查询效率，但是索引也是占据空间的，而且添加、更新、删除数据的时候也需要同步更新索引，因此会降低Insert、Update、Delete的速度。只在经常检索的字段上(Where)创建索引。 （*）即使创建了索引，仍然有可能全表扫描，比如like、函数、类型转换等。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:24:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"表连接\r有客户表（T_Customers）和订单表（T_Orders）两个表，客户表字段为：Id、Name、Age，订单表字段为：Id、BillNo、CustomerId，订单表通过CustomerId关联客户表。测试数据见备注。 SELECT o.BillNo,c.Name,c.Age from T_Orders as o\rJOIN T_Customers as c on o.CustomerId=c.Id join是和哪个表连接，on后是连接的关系是什么。(多表) 要求显示所有年龄大于15岁的顾客购买的订单号、客户姓名、客户年龄。 要求显示年龄大于平均年龄的顾客购买的订单 （*）Inner Join、Left Join、Right Join ：T_Orders ：T_Customers select o.BillNo,c.Name,c.Age\rfrom T_Orders as o\rjoin T_Customers as c on o.CustomerId=c.Id这个语句是以 T_Orders表为准，在其后添加join表的内容。 select o.BillNo,c.Name\rfrom T_Orders as o\rjoin T_Customers as c\ron o.CustomerId=c.Id\rwhere c.Age\u003e15 select o.BillNo,c.Name,c.Age\rfrom T_Orders as o\rjoin T_Customers as c on o.CustomerId=c.Id\rwhere c.Age\u003e(select AVG(Age) from T_Customers) ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:25:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"子查询\r将一个查询语句做为一个结果集供其他SQL语句使用，就像使用普通的表一样，被当作结果集的查询语句被称为子查询。所有可以使用表的地方几乎都可以使用子查询来代替。SELECT * FROM(SELECT * FROM T2 where FAge\u003c30) 单值做为子查询：SELECT 1 AS f1,2,(SELECT MIN(FYearPublished) FROM T_Book),(SELECT MAX(FYearPublished) FROM T_Book) AS f4 只有返回且仅返回一行、一列数据的子查询才能当成单值子查询。下面的是错误的：SELECT 1 AS f1,2,(SELECT FYearPublished FROM T_Book) SELECT * FROM T_ReaderFavorite WHERE FCategoryId=(SELECT FId FROM T_Category WHERE FName='Story') 如果子查询是多行单列的子查询，这样的子查询的结果集其实是一个集合。 SELECT * FROM T_Reader WHERE FYearOfJoin IN\r(\rselect FYearPublished FROM T_Book\r) 限制结果集。返回第3行到第5行的数据（ ROW_NUMBER 不能用在where子句中，所以将带行号的执行结果作为子查询，就可以将结果当成表一样用了）： SELECT * FROM ( SELECT ROW_NUMBER() OVER(ORDER BY FSalary DESC) AS rownum, FNumber,FName,FSalary,FAge FROM T_Employee ) AS a WHERE a.rownum\u003e=3 AND a.rownum\u003c=5 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:26:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"视图概述\r视图是一张虚拟表，它表示一张表的部分数据或多张表的综合数据，其结构和数据是建立在对表的查询基础上 视图在操作上和数据表没有什么区别，但两者的差异是其本质是不同:数据表是实际存储记录的地方，然而视图并不保存任何记录，它存储的实际上是查询语句 相同的数据表，根据不同用户的不同需求，可以创建不同的视图（不同的查询语句） 优点： 筛选表中的行 防止未经许可的用户访问敏感数据 降低数据库的复杂程度 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:27:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"局部变量\r声明局部变量 DECLARE @变量名 数据类型 DECLARE @bookName varchar(20) DECLARE @bId int 赋值 SET @变量名 =值 –set用于普通的赋值 SELECT @变量名 = 值 –用于从表中查询数据并赋值 例如： SET @ bookName =‘家宝’ SELECT @ bookName=b_title FROM Book WHERE b_id=2 declare @money money --声明变量 set @money = 2000 –赋值 select @money – 查询变量值 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:28:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"变量种类\r变量分为： 局部变量：局部变量必须以标记@作为前缀 ，如@Age int 局部变量：先声明，再赋值 全局变量（系统变量）： 全局变量必须以标记@@作为前缀，如@@version 全局变量由系统定义和维护，我们只能读取，不能修改全局变量的值 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:29:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"if else\rIF(条件表达式) BEGIN --相当于C#里的{ 语句1 …… END --相当于C#里的} ELSE BEGIN 语句1 …… END declare @money money select @money=AVG(b_money) from Book if @money \u003e50 begin select 'A' select top 2 * from Book order by b_money desc end else begin select 'B' select top 2 * from Book order by b_money asc end ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:30:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"while循环\rWHILE(条件表达式) BEGIN --相当于C#里的{ 语句 …… BREAK END --相当于C#里的} declare @a int set @a=1 while(@a\u003c50 ) begin print str(@a) set @a=@a+1 end DECLARE @num int WHILE(1=1) --条件永远成立 BEGIN SELECT @num=COUNT(*) FROM T_Book WHERE FYearPublished\u003c2000--统计不达标本数 IF (@num\u003e0) UPDATE T_Book --每本加2元 SET FYearPublished=FYearPublished+2 ELSE BREAK--退出循环(只有一行语句可省begin-end) END SELECT * FROM T_Book ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:31:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"事务\r借钱问题： 假定钱从A转到B，至少需要两步： A的资金减少 然后B的资金相应增加 UPDATE bank SET uMoney=uMoney-1000 WHERE uName='家宝‘ @@error UPDATE bank SET uMoney=uMoney+1000 WHERE uName='奥巴马‘ @@error 查看结果： SELECT * FROM bank 会出问题：不好回滚 指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)–也就是由多个sql语句组成，必须作为一个整体执行 这些sql语句作为一个整体一起向系统提交，要么都执行、要么都不执行 语法步骤： 开始事务：BEGIN TRANSACTION 事务提交：COMMIT TRANSACTION 事务回滚：ROLLBACK TRANSACTION 判断某条语句执行是否出错： 全局变量@@ERROR； @@ERROR只能判断当前一条T-SQL语句执行是否有错，为了判断事务中所有T-SQL语句是否有错，我们需要对错误进行累计； 例：SET @errorSum=@errorSum+@@error BEGIN TRANSACTION /*--定义变量，用于累计事务执行过程中的错误--*/ DECLARE @errorSum INT SET @errorSum=0 --初始化为0，即无错误 /*--转账：张三的账户少1000元，李四的账户多1000元*/ UPDATE bank SET currentMoney=currentMoney-1000 WHERE customerName='张三' SET @errorSum=@errorSum+@@error UPDATE bank SET currentMoney=currentMoney+1000 WHERE customerName='李四' SET @errorSum=@errorSum+@@error --累计是否有错误 If @errorSum\u003e0 Begin rollback transaction select ‘失败’ End Else Begin commit transaction select ‘成功’ End ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:32:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"存储过程\r存储过程—就像数据库中运行方法(函数) 和C#里的方法一样，由存储过程名/存储过程参数组成/可以有返回结果。 前面学的if else/while/变量 等，都可以在存储过程中使用 优点： 执行速度更快，在数据库中保存的语句是编译过的 允许模块化程序设计 ，方法的复用 提高系统安全性，防止SQL注入 减少网络流通量，只要传输存储过程的名称 系统存储过程 由系统定义，存放在master数据库中 名称以“sp_”开头或”xp_”开头 自定义存储过程 由用户在自己的数据库中创建的存储过程 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:33:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"系统存储过程\rEXEC sp_databases EXEC sp_renamedb 'Northwind','Northwind1' EXEC sp_tables EXEC sp_columns stuInfo EXEC sp_help stuInfo EXEC sp_helpconstraint stuInfo EXEC sp_helpindex stuMarks EXEC sp_helptext 'view_stuInfo_stuMarks' EXEC sp_stored_procedures ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:34:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"创建存储过程\r定义存储过程的语法 CREATE PROC[EDURE] 存储过程名 @参数1 数据类型 = 默认值 OUTPUT, @参数n 数据类型 = 默认值 OUTPUT AS SQL语句 参数说明： 参数可选 参数分为输入参数、输出参数 输入参数允许有默认值 EXEC 过程名 [参数] 例子–编写分页存储过程 create procedure proGetPageData @pageIndex int, @pageSize int as declare @sqlStr varchar(300) set @sqlStr='select top '+str(@pageSize)+' * from Category where c_id not in(select top '+str((@pageIndex-1)*@pageSize)+' c_id from Category order by c_addtime)order by c_addtime' print @sqlStr EXEC(@sqlStr) execute proGetPageData 3,3 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:35:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"调用带参数的存储过程\r无参数的存储过程调用： Exec pro_GetAge 有参数的存储过程两种调用法： EXEC proGetPageData 60,55 —按次序 EXEC proGetPageData @labPass=55,@writtenPass=60 –参数名 参数有默认值时： EXEC proGetPageData –都用默认值 EXEC proGetPageData 1 –页容量(@pageSize)默认值 EXEC proGetPageData 1,5 –不用默认值 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:36:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"存储过程中使用输出参数\rcreate procedure [dbo].[proGetPageData2] –带输出参数的存储过程 @pageIndex int=1, @pageSize int=3, @pageCount int output, --总页数 @rowCount int output -- 总行数 as declare @sqlStr nvarchar(300),@sqlCount nvarchar(300) SET @sqlCount = 'SELECT @rowCount=COUNT(b_id),@pageCount=CEILING((COUNT(b_id)+0.0)/'+ CAST(@pageSize AS VARCHAR)+') FROM Book' print @sqlCount EXEC SP_EXECUTESQL @sqlCount,N'@rowCount INT OUTPUT,@pageCount INT OUTPUT',@rowCount OUTPUT,@pageCount OUTPUT set @sqlStr='select top '+str(@pageSize)+' * from Category where c_id not in(select top '+str((@pageIndex-1)*@pageSize)+' c_id from Category order by c_addtime)order by c_addtime' print @sqlStr EXEC(@sqlStr) declare @pc int declare @rc int exec [proGetPageData2] 1,3,@pc output,@rc output select @pc,@rc ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:36:1","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"触发器\r触发器是一种特殊类型的存储过程，它不同于前面介绍过的一般的存储过程。 一般的存储过程通过存储过程名称被直接调用，而触发器主要是通过事件进行触发而被执行。 触发器是一个功能强大的工具，在表中数据发生变化时自动强制执行。触发器可以用于SQL Server约束、默认值和规则的完整性检查，还可以完成难以用普通约束实现的复杂功能。 那究竟何为触发器？在SQL Server里面也就是对某一个表的一定的操作，触发某种条件，从而执行的一段程序。 触发器是一个特殊的存储过程。 常见的触发器有三种： 分别应用于Insert , Update , Delete 事件 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:37:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"常用语法\rCREATE TRIGGER triggerName ON Table for UPDATE|INSERT|DELETE AS begin … end ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:37:1","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"更新\rCREATE TRIGGER testForFun ON dbo.T_Category for UPDATE AS begin select * from dbo.T_Book end update dbo.T_Category set FName = 'Android2' where FId=3 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:37:2","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"删除\rCREATE TRIGGER testForDel ON dbo.Category for delete AS begin select * from book end delete Category set c_name = 'Android2' where c_id=3 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:37:3","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"在触发器中获取值\rSELECT * FROM INSERTED 对于更新触发器，旧记录值在DELETED中可用，新记录值在INSERTED中 DECLARE @OldValue int，@ NewValue int SELECT @OldValue = Column1 FROM DELETED SELECT @NewValue = Column1 FROM INSERTED 通过保持旧值和新值，您可以比较它们的状态。 ADO.NET\r程序要和数据库交互要通过ADO.Net 进行 通过ADO.Net就能在程序中执行SQL了。 ADO.Net中提供了对各种不同数据库的统一操作接口。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:37:4","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"ADO.NET的组成\r如果要执行增删改和单个值查询的时候，可以直接让【车间工人】去【中央仓库】做。 如果要从【中央仓库】查询多行货物的时候，有两种方式： 可以选择叫一辆【货运卡车】去搬，卡车可以一次性的都搬过来，但【生产车间】一下子用不了，所以卡车就把货先放在【车间临时仓库】，这样车间需要的时候直接拿就可以了。 可以让【车间工人】把自己的【摩托车】拿来，骑【摩托车】去仓库拿货，但每次只能拿一行货物，所以需要往返的拿很多次才能拿完。但因为每次只拿一行货物过来，车间就直接使用了，不必存到【车间临时仓库】里。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:38:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"Connection 类\r和数据库交互，你必须连接它。连接帮助指明数据库服务器、数据库名字、用户名、密码，和连接数据库所需要的其它参数。Connection对象会被Command对象使用，这样就能够知道是在哪个数据源上面执行命令。 与数据库交互的过程意味着你必须指明想要执行的操作。这是依靠Command对象执行的。你使用Command对象来发送SQL语句给数据库。Command对象使用Connection对象来指出与哪个数据源进行连接。你能够单独使用Command对象来直接执行命令，或者将一个Command对象的引用传递给DataAdapter，它保存了一组能够操作下面描述的一组数据的命令。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:39:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"Command对象\r成功于数据建立连接后,就可以用Command对象来执行查询、修改、插入、删除等命令; Command对象常用的方法有ExecuteReader方法、ExecuteScalar()方法和ExecuteNonQuery()方法;插入数据可用ExecuteNonQuery()方法来执行插入命令。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:40:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"DataReader类\r许多数据操作要求你只是读取一串数据。DataReader对象允许你获得从Command对象的SELECT语句得到的结果。考虑性能的因素，从DataReader返回的数据都是快速的且只是“向前”的数据流。这意味着你只能按照一定的顺序从数据流中取出数据。这对于速度来说是有好处的，但是如果你需要操作数据，更好的办法是使用DataSet。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:41:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"DataSet对象\rDataSet对象是数据在内存中的表示形式。它包括多个DataTable对象，而DataTable包含列和行，就象一个普通的数据库中的表。你甚至能够定义表之间的关系来创建主从关系（parent-child relationships）。DataSet是在特定的场景下使用――帮助管理内存中的数据并支持对数据的断开操作的。DataSet是被所有Data Providers使用的对象，因此它并不像Data Provider一样需要特别的前缀。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:42:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"DataAdapter类\r某些时候你使用的数据主要是只读的，并且你很少需要将其改变至底层的数据源。同样一些情况要求在内存中缓存数据，以此来减少并不改变的数据被数据库调用的次数。DataAdapter通过断开模型来帮助你方便的完成对以上情况的处理。当在一单批次的对数据库的读写操作的持续的改变返回至数据库的时候，DataAdapter 填充（fill）DataSet对象。DataAadapter包含对连接对象以及当对数据库进行读取或者写入的时候自动的打开或者关闭连接的引用。另外，DataAdapter包含对数据的SELECT、INSERT、UPDATE和DELETE操作的Command对象引用。你将为DataSet中的每一个Table都定义DataAadapter，它将为你照顾所有与数据库的连接。所有你将做的工作是告诉DataAdapter什么时候装载或者写入到数据库。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:43:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"DataTable类\rDataTable 是一个数据网格控件,理解成一张表就可以了。 DataTable的实例化以及添加列： DataTable dt = new DataTable(); dt.Columns.Add(\"ID\"); dt.Columns.Add(\"Name\"); DataRow dr = dt.NewRow(); object[] objs = { 1, \"Name\" }; dr.ItemArray = objs; dt.Rows.Add(dr); this.dataGridView1.DataSource = dt; ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:44:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"ADO.Net基础\r直接在项目中内嵌mdf文件的方式使用SQLServer数据库（新建→数据→基于服务的数据库）。mdf文件随着项目走，用起来方便，和在数据库服务器上创建数据库没什么区别，运行的时候会自动附加（Attach） 双击mdf文件会在“服务器资源管理器”中打开，管理方式和在Management Studio没有什么本质不同。要拷贝mdf文件需要关闭所有指向mdf文件的连接。 正式生产运行的时候附加到SQLServer上、修改连接字符串即可，除此之外没有任何的区别，在“数据库”节点上点右键“附加”；在数据库节点上→任务→分离就可以得到可以拷来拷去mdf文件。 用的时候要在控制台、WinForm项目中在Main函数最开始的位置加入备注中的代码。ASP.Net项目中不需要。 连接字符串：程序通过连接字符串 指定要连哪台服务器上的、哪个实例的哪个数据库、用什么用户名密码等。 项目内嵌mdf文件形式的连接字符串\"DataSource=.\\SQLEXPRESS;AttachDBFilename=|DataDirectory|\\Database1.mdf;Integrated Security=True;User Instance=True\"。“.\\SQLEXPRESS”表示“本机上的SQLEXPRESS实例”，如果数据库实例名不是SQLEXPRESS，则需要修改。“Database1.mdf”为mdf的文件名。 ADO.Net中通过SqlConnection类创建到SQLServer的连接，SqlConnection代表一个数据库连接，ADO.Net中的连接等资源都实现了IDisposable接口，可以使用using进行资源管理。执行备注中的代码如果成功了就ok。 using (SqlConnection conn = new SqlConnection(@\"Data Source=.\\SQLEXPRESS;AttachDBFilename=|DataDirectory|\\Database1.mdf;Integrated Security=True;User Instance=True\")) { conn.Open(); Console.WriteLine(\"连接成功！\"); } 增删改查 SqlCommand表示向服务器提交的一个命令（SQL语句等） , CommandText属性为要执行的SQL语句，ExecuteNonQuery方法执行一个非查询语句（Update、Insert、Delete等） using (SqlCommand cmd = conn.CreateCommand()) { cmd.CommandText = \"Insert into T_Users(UserName,Password) values('admin','888888')\"; cmd.ExecuteNonQuery(); } ExecuteNonQuery返回值是执行的影响行数 常犯错： string username='test'; .... cmd.CommandText = \"Insert into T_Users(UserName,Password) values(username,'888888')\"; ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:45:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"查询单个值\rSqlCommand的ExecuteScalar方法用于执行查询，并返回查询所返回的结果集中第一行的第一列，因为不能确定返回值的类型，所以返回值是object类型。 cmd.CommandText = \"select count(*) from T_Users\"; int i = Convert.ToInt32(cmd.ExecuteScalar()) cmd.CommandText = \"select getdate()\"; DateTime dt = Convert.ToDateTime(cmd.ExecuteScalar()); 得到自动增长字段的主键值，用@@identity(目前工作阶段任何资料表中所产生的最后一个识别值 )，用ExecuteScalar执行最方便 cmd.CommandText = “Insert into T_Users(UserName,Password) values(‘admin’,‘888888’); select @@identity;\"; int i = Convert.ToInt32(cmd.ExecuteScalar()); ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:46:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"查询多行值\r执行有多行结果集的用ExecuteReader SqlDataReader reader = cmd.ExecuteReader(); while (reader.Read()) { Console.WriteLine(reader.GetString(1)); } reader的GetString、GetInt32等方法只接受整数参数，也就是序号，用GetOrdinal方法根据列名动态得到序号 为什么用using。Close：关闭以后还能打开。 Dispose：直接销毁，不能再次使用。 using在出了作用域以后调用Dispose， SqlConnection、FileStream等的Dispose内部都会做这样的判断：判断有没有close，如果没有Close就先Close再Dispose。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:47:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"注入漏洞攻击\r登录判断：select * from T_Users where UserName=... and Password=...，将参数拼到SQL语句中。 构造恶意的Password：' or '1'='1 if (reader.Read()) { Console.WriteLine(\"登录成功\"); } else { Console.WriteLine(\"登录失败\"); } 防范注入漏洞攻击的方法：不使用SQL语句拼接，通过参数赋值 using (SqlCommand cmd = conn.CreateCommand()) { string password = \"' or '1'='1\"; cmd.CommandText = \"select * from T_Users where UserName='admin' and Password='\" + password+\"'\"; using (SqlDataReader reader = cmd.ExecuteReader()) { if (reader.Read()) { Console.WriteLine(\"登录成功\"); } else { Console.WriteLine(\"登录失败\"); } } } ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:48:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"查询参数\rSQL语句使用@UserName表示“此处用参数代替”，向SqlCommand的Parameters中添加参数 cmd.CommandText = \"select * from T_Users where UserName=@UserName and Password=@Password\"; cmd.Parameters.Add(new SqlParameter(\"UserName\",\"admin\")); cmd.Parameters.Add(new SqlParameter(\"Password\",password)); 参数在SQLServer内部不是简单的字符串替换，SQLServer直接用添加的值进行数据比较，因此不会有注入漏洞攻击。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:49:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"案例\rComboBox的显示值：Items.Add的参数是Object类型，也就是可以放任意数据类型的数据，可以设置DisplayMember属性设定显示的属性，通过SelectedItem属性取得到就是选择的条目对应的对象。例子。疑问：取出来的是Object，怎么能转换为对应的类型？变量名只是“标签”。显示的值和实际的对象不一样，在ASP.Net中也有相同的东西 创建一个ProvinceItem类，将数据填充在这个对象中添加到ComboBox中。 将连接字符串写在代码中的缺点：多次重复，违反了DRY（Don’t Repeat Yourself）原则；如果要修改连接字符串就要修改代码。将连接字符串写在App.Config中： 添加App.config文件（文件名不能改）：添加→新建项→常规→应用程序配置文件。App.config是.Net的通用配置文件，在ASP.Net中也能同样使用。 在App.config中添加connectionStrings段，添加一个add项，用name属性起一个名字（比如DbConnStr），connectionString属性指定连接字符串。 在“引用”节点上点右键“添加引用”，找到System.configuration。不是所有.Net中的类都能直接调用，类所在的Assembly要被添加到项目的引用中才可以。 ConfigurationManager.ConnectionStrings[\" DbConnStr “].ConnectionString得到连接字符串。 如何在部署的程序中修改配置。 \u003c?xml version=\"1.0\" encoding=\"utf-8\" ?\u003e \u003cconfiguration\u003e \u003cconnectionStrings\u003e \u003cadd name=\"conStr\" connectionString =\"server=.;database=SimpleArticle;Integrated Security=True;\"/\u003e \u003c/connectionStrings\u003e \u003c/configuration\u003e ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:50:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"多行查询\rSqlDataReader是连接相关的， SqlDataReader中的查询结果并不是放到程序中的，而是放在数据库服务器中，SqlDataReader只是相当于放了一个指针（游标），只能读取当前游标指向的行，一旦连接断开就不能再读取。这样做的好处就是无论查询结果有多少条，对程序占用的内存都几乎没有影响。 SqlDataReader对于小数据量的数据来说带来的只有麻烦，优点可以忽略不计。ADO.Net中提供了数据集的机制，将查询结果填充到本地内存中，这样连接断开、服务器断开都不影响数据的读取。 DataSet dataset = new DataSet(); SqlDataAdapter adapter = new SqlDataAdapter(cmd); adapter.Fill(dataset); SqlDataAdapter是DataSet和数据库之间沟通的桥梁。数据集DataSet包含若干表DataTable，DataTable包含若干行DataRow。foreach (DataRow row in dataset.Tables[0].Rows) row[\"Name\"]。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:51:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"SQL Helper\r封装一个SQLHelper类方便使用，提供ExecuteDataTable(string sql,params SqlParameter[] parameters)、ExecuteNonQuery(string sql,params SqlParameter[] parameters)、ExecuteScalar(string sql,params SqlParameter[] parameters)等方法。 网上有微软提供的最全的SQLHelper类，是Enterprise Library中的一部分。 sqlconnection在程序中一直保持它open可以吗？对于数据库来说，连接是非常宝贵的资源，一定要用完了就close、dispose。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:52:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"DataSet\r可以更新行row[“Name”] = “yzk”、删除行datatable.Rows.Remove()、新增行datatable. NewRow()。这一切都是修改的内存中的DataSet，没有修改数据库。 可以调用SqlDataAdapter的Update方法将对DataSet的修改提交到数据库，Update方法有很多重载方法，可以提交整个DataSet、DataTable或者若干DataRow。但是需要为SqlDataAdapter提供DeleteCommand、UpdateCommand、InsertCommand它才知道如何将对DataSet的修改提交到数据库，由于这几个Command要求的格式非常苛刻，因此开发人员自己写非常困难，可以用SqlCommandBuilder自动生成这几个Command，用法很简单：new SqlCommandBuilder(adapter)。查看生成的Command（没有直接赋值给SqlDataAdapter ，看SqlCommandBuilder的）。SqlCommandBuilder要求表必须有主键。 (*)通过DataRow的RowState可以获得行的状态（删除、修改、新增等）；调用DataSet的GetChanges()方法得到变化的结果集，降低传递的资源占用。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:53:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"可空数据\rC#中值类型（int、Guid、bool等）是不可以为空的，int i=null是错误的，因此int、bool等这些类型不能表示数据库中的“Null” 。因此C#提供了“可空类型”这种语法，只要在类型后加?就构成了可空的数据类型，比如int?、bool?，这样int? i=null 就可以了。解决数据库中int可以为null，而C#中int不能为null的问题。 判断可空类型是否为空，i==null或者i.HasValue；得到可空变量的值，int i1=(int)i.Value或者int i1=i.Value。 类型转换：不可空类型赋值给可空类型无需显式转换（一定成功），可空类型赋值给不可空类型则需显式转换（不一定成功）。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:54:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"弱类型DataSet的缺点\r只能通过列名引用，dataset.Tables[0].Rows[0][“Age”]，如果写错了列名编译时不会发现错误，因此开发时必须要记着列名。 int age = Convert.ToInt32(dataset.Rows[0][“Age”])，取到的字段的值是object类型，必须小心翼翼的进行类型转换，不仅麻烦，而且容易出错。 将DataSet传递给其他使用者，使用者很难识别出有哪些列可以供使用 运行时才能知道所有列名，数据绑定麻烦，无法使用Winform、ASP.Net的快速开发功能。 自己动手写强类型DataSet(类型化DataSet，TypedDataSet)，创建继承自DataSet的PersonDataSet类，封装出int? Age等属性和bool IsAgeNull等方法，向PersonDataSet中填充。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:55:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"VS自动生成强类型DataSet\r添加→新建项→数据集 将表从服务器资源管理器拖放到DataSet中。注意拖放过程是自动根据表结构生成强类型DataSet等类，没有把数据也拖过来，程序还是连的那个数据库，自动将数据库连接字符串写在了App.Config中。 代码中使用DataSet示例：CC_RecordTableAdapter adapter = new CC_RecordTableAdapter(); 如何得知Adapter的类名？选中DataSet中下半部分的Adapter，Name属性就是类名。需要右键点击类名→解析 取得所有的数据：adapter.GetData()，例子程序：遍历显示所有数据，i\u003cadapter.GetData().Count;adapter.GetData()[i].Age。 常见问题：类名敲不对，表名+TableAdapter，表名+DataTable，表名+Row，然后用“解析”来填充类名，别照着我的代码敲。 常见问题：类的内部定义的类要通过包含namespace的全名来引用，不能省略。类的内部定义的类就能避免同一个namespace下类不能重名的问题。 强类型DataSet其实就是一种代码生成器的实现机制（DataSetPersons.Designer.cs）， 调用的 ***TableAdapter等类都是VS自动生成的，可以看到的，不要手动改生成的类代码，改xsd即可。 GetData和Fill的区别。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:56:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"强类型强在哪\r像使用类的属性一样使用列名，dsPerson[0].Age，可以使用VS的自动提示功能，绝对不会写错列名，写错了编译通不过。 将强类型DataSet传递给其他人，使用者可以轻松确定有哪些列 int age = dsPerson[0].Age，列名的类型是明确的，避免类型转换的麻烦。 编译时就可以确定 名词：强类型DataSet（类型化DataSet），英文：Typed DataSet。 DataSet包含DataTable、DataTable包含DataRow，强类型DataSet同样如此。查看源代码看看VS帮我们做了什么 GetData返回是什么类型？每一行是什么类型？看类型定义即可得知。一般规律：表类型名：表名+DataTable，行类型名：表名+row，忘了也没关系：“转到定义”。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:57:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"更新DataSet\r调用Adapter的Update方法就可以将DataSet的改变保存到数据库。adapter.Update(datatable) 要调用Update方法更新必须设置数据库主键，后面的Delete也是如此。 常见错误：“当传递具有已修改行的 DataRow 集合时，更新要求有效的 UpdateCommand”，要为表设置主键。“谁都变了，唯有主键不会变”，程序要通过主键来定位要更新的行。忘了设主键怎么办？先到数据库中设置主键，然后在DataSet的对应DataTable上点右键，选择“配置”，在对话框中点击【完成】。好习惯：所有表都要设置主键！！！看看为什么会自动帮我们GetData、Update、Delete。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:58:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"其他问题\r插入新行，调用Insert方法。 增加字段怎么办？DataSet设计器中点【配置】，对话框中点【查询生成器】，勾选新增加的字段即可。删除字段同样如此。如果是高手也可以直接手改SQL语句。 要修改字段就要重新配置生成，这就是强类型DataSet的弱点，因此强类型DataSet不一定真的就是“强”，还是叫“类型化DataSet”(Typed DataSet)吧 常见错误：报错：数据为空。判断列的值为空的方法：Is**Null 为什么Select方法会填充、Update方法会更新，Insert方法会插入？没有多么神奇，看看Adapter的SelectCommand等属性，是那些SQL语句在起作用，如果有需要完全可以手工调整 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:59:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"增加新的SQL语句\r设计器的Adapter中点右键，选择“添加查询”→“使用SQL语句”，就可以添加多种类型的SQL语句。如果是“SELECT（返回行）”则SQL语句的列必须是对应DataSet类的父集合，生成两个方法：FillBy和GetBy，方法名根据查询语句的意义定，比如FillByAge，FillBy是将结果填充到现有DataSet，GetBy是将结果以DataSet方式返回，建议两个都生成，方便以后用。看看默认生成的GetData就明白了 GetDataById、IncAge “SELECT（返回单个值）”就是ExecuteScalar 对于增加的SQL语句在代码中是以方法的形式使用的。方法的参数类型、顺序就是VS猜测的，如果不正确或者需要调整只要选中对应的语句，然后在【属性】窗口中修改Parameters属性即可 增加新的SQL语句本质论，探寻源码：不能并发调用。 像使用普通类的方法一样使用Adapter。SQL语句不用再写在界面代码中。这就是一种数据访问层（DAL：Data Access Layer） ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:60:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"强类型DataSet其他\r通过查看生成的源代码的值，生成的强类型TableAdapter默认每次调用方法都是打开连接、执行、关闭连接，而如果操作之前连接已经打开则不会自动帮我们连接、关闭，因此如果想批量操作提高效率可以操作之前先自己Open，操作完毕再Close。经测试：插入三千条数据，不优化用了45秒，优化后只用一两秒。回答面试问题：如何优化访问数据库的效率。 常见错误：DataSet ds = new DataSet()；ds = GetData();变量名和对象。 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:61:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"数据绑定\rDataGridView绑定。拖放TableAdapter、DataSet、bindingSource，将bindingSource的DataSource设定为DataSet，设定DataMember属性，然后DataGridView绑定到bindingSource。在Load的时候调用TableAdapter的Fill方法将数据填充到DataSet。绑定：双方能同步感知对方的变化。 DataGridView绑定到BindingSource， BindingSource绑定到DataSet，所以DataGridView显示的是DataSet中的数据。 修改列标题。 将保存提交到数据库，在DataGridView中修改会同步反应到DataSet中，这样只要将DataSet Update到数据库就是“保存修改”，Update，保存前要dataGridView1.EndEdit(); dataGridView1.CommitEdit(DataGridViewDataErrorContexts.Commit);bindingsource1.EndEdit()已提交正在编辑的修改。 删除当前选择行：cCRecordBindingSource.RemoveCurrent()，只是删除DataSet中的数据，需要Update才能提交到数据库。 绑定单独控件，在控件属性的DataBindings中将属性绑定到BindingSource 的指定字段，这样控件中的值就会显示这个字段的值了 ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:62:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"DotNet基础","content":"补充\r拖过来的控件是什么？控件就是控件类的对象，Winform中从Component类继承的类都可以拖到窗口中以控件的形式出来，本质上和new出来的对象没区别。控件的id就是变量名。 新建的强类型DataSet只有“生成”以后才会在工具箱中出现 并不是控件的所有属性都能绑定，只有显示在DataBindings节点下的属性才能绑定（*）只有标记了[Bindable(true)]的属性才能绑定。 只有移开焦点才会同步，并不是实时同步。 刷新查询窗口中的数据“执行SQL” BindingSource是做什么的？维持当前项。这就是为什么详细控件和DataGridView会联动。试试控件绑定到不同的BindingSource。 Adapter的作用是负责DataSet和数据库之间的数据传递。 绑定到ComboBox。给Person增加一个TypeId字段（表示是黄种人、白种人、黑种人还是其他人种）。ComboBox的绑定分为显示数据项的绑定、选中值的绑定两个，DataSource属性设定要数据项绑定的数据源，DisplayMember属性为显示的属性、ValueMember为值（通过SelectedValue取得）的属性；然后绑定SelectedValue属性到表的字段。 DataGridView中的ComboBox列：设定列的ColumnType为DataGridViewComboBoxColumn为，然后其他绑定和普通ComboBox一样，由于BindingSource是维持当前项，所以记住“专BindingSource专用” ","date":"2018-10-29","objectID":"/2018/10/dotnetbase2-sql-adonet/:63:0","tags":["DotNet基础","sql","ADO.NET"],"title":"DotNet基础 sql Ado.Net","uri":"/2018/10/dotnetbase2-sql-adonet/"},{"categories":"Web","content":"CSS（层叠样式表）是用来美化页面用的，可以对页面元素进行更精细的设置，样式主要描述元素的字体颜色、背景颜色、边框等。 CSS主要有元素内联、页面嵌入和外部引用三种使用方式。CSS是描述元素的皮肤！ 元素内联，直接将样式写入元素的style属性中，\u003cinput type=\"text\" readonly=\"readonly\" style=\"background-color: #FF00FF\" /\u003e，**style=“color:Red;background-color: #FF00FF”**为元素内联，适用于样式没有可复用性的场合。 页面嵌入：在head中加入 \u003cstyle type=\"text/css\"\u003e input{border-color:Yellow;color:Red;} \u003c/style\u003e 表示页面中所有input都是采用指定的样式。适合于样式复用，减小页面体积 \u003cstyle type=\"text/css\"\u003e P { color:Red; font-weight:bold; } \u003c/style\u003e 所有的P标签都变成红色字体，加粗。 外部引用，将css内容写入css后缀的文件 div{background:yellow} 然后在页面中引用，在head中加入 \u003clink type=\"text/css\" rel=\"Stylesheet\" href=\"s1.css\" /\u003e 适合于多个页面共享css。 更变原则：就近原则 ","date":"2018-10-22","objectID":"/2018/10/web2-css/:0:0","tags":["Web","css"],"title":"自学 CSS","uri":"/2018/10/web2-css/"},{"categories":"Web","content":"常见样式\rcss计量单位：css中表示宽度、距离时有多种计量单位：px（像素）、30%（百分比）、em（相对单位）等。width:20px。 background-color:Red;背景颜色；color：文本颜色 复合样式 background border border-style:solid;边框风格，实线solid（默认是没有），还有dotted(点)等值；border-color：边框颜色；border-width：边框宽度(默认是0)。例子：style=\"border-color:Red;border-width:1px;border-style:dotted;\" display：元素是否显示，可选值none（不显示,不占地儿）、block （显示为块级元素，此元素前后会带有换行符。）、inline（显示为内联元素，元素前后没有换行符 ）等。 cursor，鼠标在元素上时显示的光标图标，可选值：cursor（默认光标）、pointer（超链接上的手）、text（输入Bean）、wait（忙沙漏）、help（帮助）等。还可以通过cursor:url(dinosau2.ani)使用ani、cur格式的自定义光标图片。 LI不显示圆点：LIST-STYLE-TYPE: none;一般设在li或者ul上 应用：图片：不显示边框，见备注 图片：不显示边框 IMG { border:0px;BORDER-BOTTOM: medium none; BORDER-LEFT: medium none; BORDER-TOP: medium none; BORDER-RIGHT: medium none } ","date":"2018-10-22","objectID":"/2018/10/web2-css/:1:0","tags":["Web","css"],"title":"自学 CSS","uri":"/2018/10/web2-css/"},{"categories":"Web","content":"例子 外部引用\r* { /* 所有的元素 */ margin:0; padding:0; color:Red; } body { background:red url(/images/back_image.GIF); } span { /* block 块 display:block;*/ cursor:pointer; color:Blue; text-decoration:underline; } input { color:Green; } li { /* 去掉ul前面的黑点 */ list-style-type:none; } ","date":"2018-10-22","objectID":"/2018/10/web2-css/:1:1","tags":["Web","css"],"title":"自学 CSS","uri":"/2018/10/web2-css/"},{"categories":"Web","content":"样式选择器\r对于非元素内联的样式需要定义样式选择器，通俗的说就是这个样式适合于哪些元素，三种：标签选择器、class选择器和id选择器。 标签选择器 input{border-color:Yellow;color:Red;}，对于指定的标签采用统一的样式 class选择器，以定义一个命名的样式，然后在用到它的时候设定元素的class属性为样式的名称，还可以同时设定多个class，名称之间加空格 .d1 { color:Red; width:100px; } .d2 { color:Blue; width:200px; } .d3 { color:Green; width:300px; } \u003cdiv class=\"d1\"\u003e 123123123 \u003c/div\u003e \u003cdiv class=\"d2\"\u003e abc \u003c/div\u003e \u003cdiv class=\"d3\"\u003e 啊打发 \u003c/div\u003e 样式名称开头加“.” .warning{background:Yellow;} .highlight{font-size:xx-large;cursor:help;} \u003ctable\u003e \u003ctr\u003e \u003ctd class=\"highlight\"\u003eaaa\u003c/td\u003e \u003ctd class=\"warning\"\u003ebb\u003c/td\u003e \u003ctd class=\"highlight warning\"\u003eccc\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e 标签+类选择器:通过指定标签来确定不同的类适用范围 label.name { background-color:Gray; } input.name { color:Blue; } \u003clabel for=\"name\" class=\"name\"\u003e用户名：\u003c/label\u003e \u003cinput class=\"name\" id=\"name\" type=\"text\" value=\"\" /\u003e id选择器：与类选择器不同的地方就是.改成了#。 #wrap { border:solid 1px blue; width:300px; height:300px; } \u003cdiv id=\"wrap\"\u003e main \u003c/div\u003e 包含选择器：设置div中strong标签的格式，div中所有strong div strong { color:Red; } \u003cstrong\u003e测试\u003c/strong\u003e \u003cdiv\u003e \u003cstrong\u003e这是左边栏\u003c/strong\u003e left \u003c/div\u003e 后代选择器：直接属于div的strong才会属于这个样式。 div strong { color:Red; } \u003cdiv\u003e \u003cstrong\u003e这是左边栏\u003c/strong\u003e left \u003c/div\u003e 组合选择器 ：多个标签一个样式，组合选择器可以使用类选择器.h3,.p,.span {} h3,p,span { color:Yellow; } \u003ch3\u003e标题3\u003c/h3\u003e \u003cp\u003e这是段落\u003c/p\u003e \u003cspan\u003e这是span\u003c/span\u003e 伪选择器：超链接使用 A:visited：超链接点击过的样式；A:visited {TEXT-DECORATION: none}下划线 A:active：选中超链接时的样式；A:active {TEXT-DECORATION: none} A:link：超链接未被访问时的状态；A:link {TEXT-DECORATION: none} A:hover：鼠标移到超链接时的状态。A:hover {TEXT-DECORATION: underline} a:visited { color:Gray; } a:link { color:Red; } a:hover { color:Black; font-style:italic; } a:active { color:Yellow; } \u003ca href=\"http://www.itcast.cn\"\u003e传智播客\u003c/a\u003e \u003ca href=\"http://www.csdn.com\"\u003ecsdn\u003c/a\u003e \u003ca href=\"http://www.cnbeta.com\"\u003ecnbeta\u003c/a\u003e \u003ca href=\"http://www.123.com\"\u003e123\u003c/a\u003e ","date":"2018-10-22","objectID":"/2018/10/web2-css/:1:2","tags":["Web","css"],"title":"自学 CSS","uri":"/2018/10/web2-css/"},{"categories":"Web","content":"布局\r布局的分类：表格布局，框架布局，div+css布局 表格布局：表格套表格 ，代码多，table显示很慢，一块块的显示就比较麻烦，显示圆角就比较麻烦 框架布局：多个页面来显示： Frameset 框架页里不能有body \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003c/head\u003e \u003cframeset rows=\"30%,*\"\u003e \u003cframe name=\"top\" src=\"top.htm\" noresize=\"noresize\"/\u003e \u003cframeset cols=\"20%,*\"\u003e \u003cframe name=\"left\" src=\"left.htm\" noresize=\"noresize\"/\u003e \u003cframe name=\"main\" src=\"main.htm\" noresize=\"noresize\"/\u003e \u003c/frameset\u003e \u003c/frameset\u003e left.html \u003cbody\u003e \u003cul\u003e \u003cli\u003e\u003ca href=\"1-注册页面.htm\" target=\"main\"\u003e注册\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"5-选择器.htm\" target=\"if\"\u003e登陆\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/body\u003e iframe 嵌入页面 \u003ciframe src=\"iframe.htm\" name=\"0\" width=\"0\" height=\"0\"\u003e\u003c/iframe\u003e \u003cbody\u003e adsfasdf asdf \u003ciframe src=\"1-注册页面.htm\" width=\"0\" height=\"0\"\u003e\u003c/iframe\u003e adsf \u003c/body\u003e main.html iframe：在一个页面中嵌入一个页面 \u003cbody\u003e \u003ciframe src=\"1-注册页面.htm\" width=\"500px\" height=\"200px\" name=\"if\"\u003e\u003c/iframe\u003e adsf \u003c/body\u003e div+css布局： 网页布局就是“这块内容显示在左边，那两块内容并排显示，那块内容漂浮在页面上”。 不要使用\u003ctable\u003e进行布局，因为：table可能会在所有tr、td加载完成以后才显示，所以加载完成之前界面是一片空白；用table布局会将布局方式写在html中，违反了“语义性”原则；用table会影响搜索引擎的抓取，不利于SEO。因此Table用来表达真是表格状数据的东西，布局用Div(层)+Css来做,Div用来圈定元素，CSS用来定义元素的位置。 Div+CSS就是将要布局的内容用\u003cdiv\u003e切成块，然后使用css描述每个块的大小、位置等。 布局最重要的一个属性就是float， \u003chtml xmlns=\"http://www.w3.org/1999/xhtml\" \u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003clink href=\"css/style.css\" rel=\"stylesheet\" type=\"text/css\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"wrap\"\u003e \u003cdiv id=\"head\"\u003e \u003cdiv id=\"logo\"\u003e \u003cimg src=\"images/back_image.GIF\" width=\"100px\" height=\"50px\" /\u003e\u003c/div\u003e \u003cdiv id=\"menu\"\u003e \u003cul\u003e \u003cli\u003e首页\u003c/li\u003e \u003cli\u003e播客\u003c/li\u003e \u003cli\u003e相册\u003c/li\u003e \u003cli\u003e关于\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv id=\"body\"\u003e \u003cdiv id=\"nav\"\u003e \u003cul\u003e \u003cli\u003e好好学习\u003c/li\u003e \u003cli\u003e天天向上\u003c/li\u003e \u003cli\u003e不要睡觉\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cdiv id=\"content\"\u003e内容\u003c/div\u003e \u003c/div\u003e \u003cdiv id=\"footer\"\u003e版权\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e * { margin:0px; padding:0px; } body { background-color:Gray; } #wrap { width:98%; height:500px; margin:0px auto; } #head { height:150px; background-color:Red; } #head #menu { margin:80px auto 0px auto; padding-left:200px; } #head #menu ul { width:400px; } #head #menu li { float:left; width:100px; list-style-type:none; } #body { height:800px; background-color:White; } #body #nav { /* 强制英文换行 word-break:break-all; */ /* 溢出后显示滚动条 */ overflow:auto; background-color:Blue; width:200px; float:left; } #body #nav ul { padding-top:100px; } #body #nav li { list-style-type:none; height:30px; padding-left:30px; } #body #content { background-color:Green; } ","date":"2018-10-22","objectID":"/2018/10/web2-css/:2:0","tags":["Web","css"],"title":"自学 CSS","uri":"/2018/10/web2-css/"},{"categories":"Web","content":"HTML(HyperText Markup Language)：描述网页长什么样子、有什么内容的一个文本。查看网页的描述内容（HTML）的方式：使用IE浏览器的话，在网页上点击右键，选择“查看源文件”。 ","date":"2018-10-17","objectID":"/2018/10/web1-html/:0:0","tags":["Web","Html"],"title":"自学 HTML","uri":"/2018/10/web1-html/"},{"categories":"Web","content":"主要构架\r\u003chtml\u003e\r\u003chead\u003e\r\u003ctitle\u003e我的第一个网页\u003c/title\u003e\r\u003c/head\u003e\r\u003cbody bgcolor=\"red\" background=\"bg.jpg\"\u003e\rHello world\r\u003c/body\u003e\r\u003c/html\u003e\r所有内容都在\u003chtml\u003e\u003c/html\u003e标签之内； \u003chead\u003e\u003c/head\u003e内放的是头部信息，是对页面的描述，不会直接显示在页面中，\u003chead\u003e内的\u003ctitle\u003e中设置的是页面的标题，\u003ctitle\u003e只能放在\u003chead\u003e中； \u003cbody\u003e是页面的主体，大部分显示内容都定义在这里； \u003cmeta\u003e标签，\u003cmeta\u003e有指定name和指定http-equiv两种用法，\u003cmeta name=\"名字\" content=\"值\" /\u003e、\u003cmeta http-equiv=\"名字\" content=\"值\" /\u003e两种用法 \u003cmeta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\" /\u003e指定网页编码 \u003cmeta http-equiv=\"Refresh\" content=\"3\" /\u003e 三秒钟后刷新此网页 \u003cmeta http-equiv=\"Refresh\" content=\"3;url=http://www.rupeng.com\" /\u003e 三秒钟后重定向到新网页。发帖成功后提示“发帖成功，即将转向帖子查看页面” \u003cmeta http-equiv=\"Cache-Control\" content=\"no-cache\" /\u003e 禁止浏览器缓存页面 ","date":"2018-10-17","objectID":"/2018/10/web1-html/:1:0","tags":["Web","Html"],"title":"自学 HTML","uri":"/2018/10/web1-html/"},{"categories":"Web","content":"基本语法\r\u003ch\u003e：标签，HTML定义了\u003ch1\u003e\u003c/h1\u003e到\u003ch6\u003e\u003c/h6\u003e六个h标签，分别表示不同大小的字体。 \u003cbr\u003e：回车 \u003cp\u003e：分段。\u003cp\u003e前后会有比较大的空白，而\u003cbr\u003e则没有。 \u003ccenter\u003e这是居中\u003c/center\u003e居中显示 \u003cb\u003e粗体\u003c/b\u003e：粗体 \u003ci\u003e斜体\u003c/i\u003e：斜体 \u003cfont\u003e\u003c/font\u003e：字体标签，\u003cfont color=\"red\"\u003e红色\u003c/font\u003e \u003cfont size=\"30\" color=\"red\"\u003e红色\u003c/font\u003e 特殊字符：\u0026lt;（小于号，less than）；\u0026gt;（大于号，greater than）；\u0026nbsp;（空格，no-break space） \u003chr\u003e： 横线 color size width align=left,center,right \u003cpre\u003e：预格式化 保持本色 \u003cbody bgcolor=\"#006699\"\u003e背景颜色 \u003ca href=\"http://www.rupeng.com\"\u003e如鹏网\u003c/a\u003e超链接 \u003ca href=\"http://www.rupeng.com\"\u003e\u003cimg src=\"http://www.rupeng.com/forum/templates/uchome/images/logo.gif\"/\u003e\u003c/a\u003e镶嵌图片； “/”表示网站根目录，“../”表示父目录，“../../”表示父目录的父目录 将\u003ca\u003e的target属性设定为\"_blank\"就可以在新窗口中打开超链接。 锚记：用name属性为\u003ca\u003e 起名字：\u003ca name=\"Last\"\u003e这里是最后\u003c/a\u003e。这样可以通过\u003ca href=\"#Last\"\u003e转到平台\u003c/a\u003e来跳转到超链接的部分。去往评论、回到正文 \u003cimg src=\"a.jpg\"/\u003e注意图片是链接的，不是插入的，所以如果Src指向的文件不存在了，就看不了了。 alt： 图片无法显示时的显示文本，鼠标方式去也会有悬浮提示“点击查看大图” border属性指定边框，border=“0\"不显示边框 width、height属性指定图片的显示大小，如果不指定则是图片的原始大小 不要以为把bmp后缀改为jpg就是改文件格式了 如果网页上要显示小图（比如缩略图），不要仅仅是把大图设定一下width、height来缩小，因为仍然会下载大图，会使得加载速度很慢。 列表：\u003cul\u003e\u003cli\u003e灌水区\u003c/li\u003e\u003cli\u003e版务区\u003c/li\u003e\u003cli\u003e原创贴图\u003c/li\u003e\u003c/ul\u003e。无序列表。 有序的列表\u003col\u003e\u003c/ol\u003e 表格：\u003ctable\u003e\u003c/table\u003e为表格，在内部通过\u003ctr\u003e创建行，\u003ctr\u003e内部通过\u003ctd\u003e 创建单元格。可以将table的border属性设为0来隐藏表格线。 填充、间距Cellpadding内容和表格边线之间的距离 cellspacing单元格之间的间距s \u003ctr\u003e的属性：align，水平对齐，可选值left、right、center；valign，垂直对齐，可选值top、middle、bottom。 \u003ctd\u003e也有align和valign。\u003ctr align=\"right\"\u003e\u003ctd\u003etom\u003c/td\u003e\u003ctd align=\"left\"\u003e20\u003c/td\u003e\u003ctd\u003e男\u003c/td\u003e\u003c/tr\u003e：子标签默认继承父标签的属性，如果自己单独指定了属性，则会覆盖父标签的属性。 rowspan、colspan进行单元格的合并 表头的td可以用th代替，这样就会表头粗体、居中显示 表单：\u003cform\u003e标签为表单标签。如果要把数据提交到服务器，则需要将\u003cinput\u003e、\u003ctextarea\u003e、\u003cselect\u003e等表单元素放到form中 \u003cinput\u003e是主要的表单元素，type的可选值：submit（提交按钮）、button（普通按钮）、checkbox（复选框）、file（文件选择框）、hidden（隐藏字段）、image（图片按钮）、password（密码框）、radio（单选按钮）、reset（重置按钮）、text（文本框）。\u003cinput type=\"file\" /\u003e submit：点击submit按钮表单就会被提交给服务器，中文IE下默认按钮文本为“提交查询”，可以设置value属性修改按钮的显示文本 text：size属性为宽度，value为值，maxlength为可以输入的最大长度，readonly只读。\u003cinput type=\"text\" readonly/\u003e（只写属性名，不写属性值）或者\u003cinput type=\"text\" readonly=\"readonly\" /\u003e checkbox：checked属性表示是否被选中，\u003cinput type=\"checkbox\" checked /\u003e或者\u003cinput type=\"checkbox\" checked=\"checked\" /\u003e(推荐)checked、readonly等这种只有一个可选值的属性都可以省略属性值。 radio：相同name属性的为一组，不同radio设定不同的value值，这样通过取指定name的值就可以知道谁被选中了，不用单独的判断。 file：使用file，则form的enctype必须设置为multipart、form-data、form method属性为POST（*），get。get：少量数据，post：大量数据。\u003cform action=\"Default.aspx\" method=\"post\"\u003e\u003c/form\u003e image：使用src属性指定图片的地址，用来实现美化的“登录按钮”。 Reset:重置 \u003cselect\u003e:用来创建类似于WinForm中的ComboBox或者ListBox 如果size属性大于1就是ListBox（size的值为显示出来的列表数量），否则就是ComboBox。 \u003cselect multiple\u003e或者\u003cselect multiple=\"multiple\"\u003e（推荐），那么就是可以多选的ListBox。 select中的项是\u003coption\u003e，\u003coption\u003e北京\u003c/option\u003e还可以设定项的值\u003coption value=\"1\"\u003e北京\u003c/option\u003e。 将一个option设置为选中：\u003coption selected\u003e333\u003c/option\u003e或者\u003coption selected=\"selected\"\u003e333\u003c/option\u003e(推荐)就可以将这个项设定为选择项 如何实现“不选择”，添加一个\u003coption value=\"-1\"\u003e--不选择--\u003coption\u003e，然后编程判断select选中的值如果是-1就认为是不选择。 select分组选项，可以使用optgroup对数据进行分组，分组本身不会被选择，无论对于下拉列表还是列表框都适用。备注 \u003ctextarea\u003e多行文本（也是表单元素）：\u003ctextarea\u003e文本\u003c/textarea\u003e，cols、rows属性表示行数和列数。 \u003clabel\u003e：在\u003cinput type=\"text\"\u003e前可以写普通的文本来修饰，但是单击修饰文本的时候input并不会得到焦点，而用label则可以，for属性指定要修饰的控件的id，\u003clabel for=\"txt1\" \u003easdfad\u003c/label\u003e 为被修饰的控件设置一个唯一的id \u003clabel for=\"ma\"\u003e婚否\u003c/label\u003e \u003cinput id=\"ma\" type=\"checkbox\" /\u003e fieldset：GroupBox效果，将控件划分一个区域，看起来更规整 \u003cfieldset\u003e \u003clegend\u003e常用\u003c/legend\u003e \u003cinput type=\"text\" /\u003e \u003c/fieldset\u003e 滚动文字 \u003cmarquee\u003e scrolldelay控制速度 播放声音、显示flash， \u003cobject classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\" codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,29,0\" width=\"760\" height=\"700\"\r\u003cparam name=\"movie\" value=\"light-bot-2205.swf\" /\r\u003cparam name=\"quality\" value=\"high\" /\r\u003cembed src=\"light-bot-2205.swf\" quality=\"high\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" type=\"application/x-shockwave-flash\" width=\"760\" height=\"700\"\u003e\u003c/embed\r\u003c/object\u003e\r调用wmp的插件\u003cembed src=\"coder.mp3\" loop=true autostart=true name=bgss width=\"460\" height=\"68\"\u003e 只能播放wav和mid格式，只支持ie div：层\u003cdiv\u003e\u003c/div\u003e将内容放到层中，就以将这些内容当成一个整体进行处理，比如整体隐藏、整体移动等。div非常强大和常用。类似于WinForm的Panel。 span:div是将内容放到一个矩形的区块中，会影响布局，而span只是把一段内容定义成一个整体进行操作，但不影响布局、显示。 ","date":"2018-10-17","objectID":"/2018/10/web1-html/:2:0","tags":["Web","Html"],"title":"自学 HTML","uri":"/2018/10/web1-html/"},{"categories":"Web","content":"备注\rxml：描述存的什么数据 XHTML:可扩展超文本置标语言（eXtensible HyperText Markup Language，XHTML） DHTML：动态HTML； 格式标签：\u003cp\u003e\u003c/p\u003e创建段落；\u003cbr /\u003e回车，也可以写成\u003cbr\u003e，在HTML中有一些标签可以不关闭，\u003cbr\u003e就是一个，这是和XML不同的地方（常考），但是为了遵循XHTML规范，推荐像XML一样严格关闭。\u003cbr/\u003e\u003cimg src=\"1.gif\"/\u003e 属性值：HTML中属性值即可以用单引号括起来、也可以用双引号括起来、甚至不用引号都可以（不推荐），单双要配对。 注释：HTML使用和XML一样的来做注释。 ","date":"2018-10-17","objectID":"/2018/10/web1-html/:3:0","tags":["Web","Html"],"title":"自学 HTML","uri":"/2018/10/web1-html/"},{"categories":"设计模式","content":"上一章中对薪水支付案例的用例和类做了详细的阐述，在本篇会介绍薪水支付案例包的划分和数据库，UI的设计。 ","date":"2018-10-10","objectID":"/2018/10/designpattern3-case2/:0:0","tags":["敏捷软件开发原则模式与实践","薪水支付"],"title":"敏捷软件开发原则模式与实践 薪水支付","uri":"/2018/10/designpattern3-case2/"},{"categories":"设计模式","content":"包的划分\r一个错误包的划分 为什么这个包是错误的： 如果对classifications更改就要影响payrolldatabase更改，还会迫使transactions更改，tansactions重新发布和编译测试就是不负责的，transactions没有共享封闭性，每个类都有自己变化的敏感，所以发布的频率非常高，是不合理的。 调整一下： 将具体类和具体类打包，抽象类和抽象类打包，交互类单独打包。这已经是一个比较好打包设计了。 类的组件应该要符合共同重用原则，payrolldamain中的类没有形成最小的可重用单元，transaction类不必和组件中的其他类一起重用，可以把transaction迁移到transactionapplication类中 这样的划分太精细了，是否有这样的必要需要整体来看。 最终包的结构： ","date":"2018-10-10","objectID":"/2018/10/designpattern3-case2/:1:0","tags":["敏捷软件开发原则模式与实践","薪水支付"],"title":"敏捷软件开发原则模式与实践 薪水支付","uri":"/2018/10/designpattern3-case2/"},{"categories":"设计模式","content":"数据库的设计\remplogee是核心 完成这个设计需要进行重构： 提取出payrolldatabase接口， public interface PayrollDatabase { void AddEmployee(Employee employee); Employee GetEmployee(int id); void DeleteEmployee(int id); void AddUnionMember(int id, Employee e); Employee GetUnionMember(int id); void RemoveUnionMember(int memberId); ArrayList GetAllEmployeeIds(); IList GetAllEmployees(); } 内存表实例： public class InMemoryPayrollDatabase : PayrollDatabase { private static Hashtable employees = new Hashtable(); private static Hashtable unionMembers = new Hashtable(); public void AddEmployee(Employee employee) { employees[employee.EmpId] = employee; } // etc... public Employee GetEmployee(int id) { return employees[id] as Employee; } public void DeleteEmployee(int id) { employees.Remove(id); } public void AddUnionMember(int id, Employee e) { unionMembers[id] = e; } public Employee GetUnionMember(int id) { return unionMembers[id] as Employee; } public void RemoveUnionMember(int memberId) { unionMembers.Remove(memberId); } public ArrayList GetAllEmployeeIds() { return new ArrayList(employees.Keys); } public IList GetAllEmployees() { return new ArrayList(employees.Values); } public void Clear() { employees.Clear(); unionMembers.Clear(); } } 数据库 public class SqlPayrollDatabase : PayrollDatabase { private SqlConnection connection; public SqlPayrollDatabase() { connection = new SqlConnection(\"Initial Catalog=Payroll;Data Source=localhost;user id=sa;password=abc\"); connection.Open(); } ~SqlPayrollDatabase() { connection.Close(); } public void AddEmployee(Employee employee) { //增加员工策略 SaveEmployeeOperation operation = new SaveEmployeeOperation(employee, connection); operation.Execute(); } public Employee GetEmployee(int id) { //数据库事务 LoadEmployeeOperation loadOperation = new LoadEmployeeOperation(id, connection); loadOperation.Execute(); return loadOperation.Employee; } public void DeleteEmployee(int id) { throw new NotImplementedException(); } public void AddUnionMember(int id, Employee e) { throw new NotImplementedException(); } public Employee GetUnionMember(int id) { throw new NotImplementedException(); } public void RemoveUnionMember(int memberId) { throw new NotImplementedException(); } public ArrayList GetAllEmployeeIds() { throw new NotImplementedException(); } public IList GetAllEmployees() { throw new NotImplementedException(); } } 如果插入雇佣记录成功，但是支付记录失败，为了解决这个问题而使用事务的方式。 public class SaveEmployeeOperation { private readonly Employee employee; private readonly SqlConnection connection; private string methodCode; private string classificationCode; private SqlCommand insertPaymentMethodCommand; private SqlCommand insertEmployeeCommand; private SqlCommand insertClassificationCommand; public SaveEmployeeOperation(Employee employee, SqlConnection connection) { this.employee = employee; this.connection = connection; } public void Execute() { PrepareToSavePaymentMethod(employee); PrepareToSaveClassification(employee); PrepareToSaveEmployee(employee); SqlTransaction transaction = connection.BeginTransaction(\"Save Employee\"); try { ExecuteCommand(insertEmployeeCommand, transaction); ExecuteCommand(insertPaymentMethodCommand, transaction); ExecuteCommand(insertClassificationCommand, transaction); transaction.Commit(); } catch(Exception e) { transaction.Rollback(); throw e; } } private void ExecuteCommand(SqlCommand command, SqlTransaction transaction) { if(command != null) { command.Connection = connection; command.Transaction = transaction; command.ExecuteNonQuery(); } } private void PrepareToSaveEmployee(Employee employee) { string sql = \"insert into Employee values (\" + \"@EmpId, @Name, @Address, @ScheduleType, \" + \"@PaymentMethodType, @PaymentClassificationType)\"; insertEmployeeCommand = new SqlCommand(sql); this.insertEmployeeCommand.Parameters.Add(\"@EmpId\", employee.EmpId); this.insertEmployeeCommand.Parameters.Add(\"@Name\", employee.Name); this.insertEmployeeCommand.Parameters.Add(\"@Address\", employee.Address); this.insertEmployeeCommand.Parameters.Add(\"@ScheduleType\", Schedu","date":"2018-10-10","objectID":"/2018/10/designpattern3-case2/:2:0","tags":["敏捷软件开发原则模式与实践","薪水支付"],"title":"敏捷软件开发原则模式与实践 薪水支付","uri":"/2018/10/designpattern3-case2/"},{"categories":"设计模式","content":"界面设计\r界面设计时最好使得业务行为和UI分离，这里使用model view presenter模式（MVP） model：实体层和数据库交互 view：界面层 presenter：业务处理层 MVP的作用是解耦界面、业务和实体的关系 在presenter中主动使用view，界面的形态都是由presenter去控制，就是在presenter中去注册view事件，当用户触发事件时，这个事件会通过view传递到presenter中，并通过presenter调用model数据方法，最后presenter 调用引用的view实例去改变界面的形态。 public class AddEmployeePresenter { private TransactionContainer transactionContainer; private AddEmployeeView view; private PayrollDatabase database; private int empId; private string name; private string address; private bool isHourly; private double hourlyRate; private bool isSalary; private double salary; private bool isCommission; private double commissionSalary; private double commission; public AddEmployeePresenter(AddEmployeeView view, TransactionContainer container, PayrollDatabase database) { this.view = view; this.transactionContainer = container; this.database = database; } public int EmpId { get { return empId; } set { empId = value; UpdateView(); } } public string Name { get { return name; } set { name = value; UpdateView(); } } public string Address { get { return address; } set { address = value; UpdateView(); } } public bool IsHourly { get { return isHourly; } set { isHourly = value; UpdateView(); } } public double HourlyRate { get { return hourlyRate; } set { hourlyRate = value; UpdateView(); } } public bool IsSalary { get { return isSalary; } set { isSalary = value; UpdateView(); } } public double Salary { get { return salary; } set { salary = value; UpdateView(); } } public bool IsCommission { get { return isCommission; } set { isCommission = value; UpdateView(); } } public double CommissionSalary { get { return commissionSalary; } set { commissionSalary = value; UpdateView(); } } public double Commission { get { return commission; } set { commission = value; UpdateView(); } } private void UpdateView() { if(AllInformationIsCollected()) view.SubmitEnabled = true; else view.SubmitEnabled = false; } public bool AllInformationIsCollected() { bool result = true; result \u0026= empId \u003e 0; result \u0026= name != null \u0026\u0026 name.Length \u003e 0; result \u0026= address != null \u0026\u0026 address.Length \u003e 0; result \u0026= isHourly || isSalary || isCommission; if(isHourly) result \u0026= hourlyRate \u003e 0; else if(isSalary) result \u0026= salary \u003e 0; else if(isCommission) { result \u0026= commission \u003e 0; result \u0026= commissionSalary \u003e 0; } return result; } public TransactionContainer TransactionContainer { get { return transactionContainer; } } public virtual void AddEmployee() { transactionContainer.Add(CreateTransaction()); } public Transaction CreateTransaction() { if(isHourly) return new AddHourlyEmployee( empId, name, address, hourlyRate, database); else if(isSalary) return new AddSalariedEmployee( empId, name, address, salary, database); else return new AddCommissionedEmployee( empId, name, address, commissionSalary, commission, database); } } public interface ViewLoader { void LoadPayrollView(); void LoadAddEmployeeView( TransactionContainer transactionContainer); } public class WindowViewLoader : ViewLoader { private readonly PayrollDatabase database; private Form lastLoadedView; public WindowViewLoader(PayrollDatabase database) { this.database = database; } public void LoadPayrollView() { PayrollWindow view = new PayrollWindow(); PayrollPresenter presenter = new PayrollPresenter(database, this); view.Presenter = presenter; presenter.View = view; // 相互关联 LoadView(view); } public void LoadAddEmployeeView( TransactionContainer transactionContainer) { AddEmployeeWindow view = new AddEmployeeWindow(); AddEmployeePresenter presenter = new AddEmployeePresenter(view, transactionContainer, database); view.Presenter = presenter; LoadView(view); } private void LoadView(Form view) { view.Show(); lastLoadedView = view; } /// \u003csummary\u003e /// 最新的form /// \u003c/summary\u003e public Form LastLoadedView { get { return lastLoadedView; } } } public class PayrollMain { public static void Main(string[] args) { PayrollDatabase database = new InMemoryPayrollDatabase(); WindowViewLoader viewLoader = new WindowViewLoader(database);","date":"2018-10-10","objectID":"/2018/10/designpattern3-case2/:3:0","tags":["敏捷软件开发原则模式与实践","薪水支付"],"title":"敏捷软件开发原则模式与实践 薪水支付","uri":"/2018/10/designpattern3-case2/"},{"categories":"设计模式","content":"单一职责原则(single responsibilities principle,SRP)\r原理：一个类应该只有一个变化 分离职责：如果不耦合的职责那么很简单，如果两个职责耦合，将两个职责抽象为接口，通过继承两个接口将依赖关系抽离处理啊 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:1:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"开放封闭原则(open close principle,OCP)\r软件实体(类，模块，函数等)应该是可以扩展的，但是不可修改 对扩展开放：当需求改变时，对模块可以扩展。 对修改封闭：对模块进行扩展时，不必改动模块的源代码或则二进制代码， 仅仅抽象出容易变化的部分。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:2:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"里氏替换原则(liskov substitution principle,LSP)\r子类型必须能够替换掉它的基类型。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:3:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"依赖倒置原则(dependence inversion principle,DIP)\r高层模块不应该依赖于底层模块，二者都应该依赖抽象 抽象不应该依赖细节，细节应该依赖抽象 为什么叫倒置，在传统软件开发中，总倾向于创建一些高层模块依赖底层模块，策略依赖细节的软件结构。一个良好的面向对象程序，对传统设计结构而言就被倒置了。 其实就是都依赖接口编程，高层依赖接口，细节依赖接口，这样模块的改动不会影响其他模块。比较好的模块设计： 模块和模块间的依赖都是依赖接口。 倒置不仅仅是依赖关系的倒置，也是接口所有权的倒置，通常会认为工具库应该拥有自己的接口，但其实应该是客户拥有接口，而它们的服务者应该是接口的派生。著名的 holly wood原则：“Don’t call us, we’ll call you”不要调用我们，我们会调用你，低层模块实现在高层模块中声明并被高层模块调用的接口 程序所有的依赖关系都应该终止与抽象 任何变量都不应该持有一个指向具体类的引用 任何类都不应该从具体类派生 任何方法都不应该重写它的任何基类中已经实现的方法。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:4:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"接口隔离原则(interface segregation principle,ISP)\r","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:5:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"接口会被污染:\r当借口的职责不再单一时，接口就很容易受到污染。 一个常见的例子：一个门，可能是关着也可能是开着，而且门类知道只是是开着还是关着。 常见的接口设计，现在需要实现自动报警，当门开着超过一定的时间就进行报警。常见的方法是关联timer类，实现报警。 这种方案就造成了接口污染，所有的门都必须依赖timeclient，同时还会出现门检测到时间超时，还未报警时，门关闭了，然后又被打开了，门变成了错误的报警 通过增加一个报警id,来区别每一次报警和客户端。 接口隔离原则：不应该强迫客户程序依赖并未使用的方法。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:5:1","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"隔离接口\r通过适配器原则，实现timer类对door类的引用隔离doorclient.这样仅仅增加了一个类，而将引用关系倒置。 创建一个派生自timer的timerclient对象，并把该对象请求委托给timerdoor。 这样就实现了timer和door的隔离，即使对timer进行更改也不会影响到door。timerdoor也不需要和timerclient一样的接口， 另一种方法是使用timerdoor来多重继承，door和timerclient， 这种方案没有多余的开销，只有当doortimeradapter对象所做的转换是必须的时候或则不同的时候需要不同的转换的时候，才需要使用适配器方法。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:5:2","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"例子：\rAMT的一个例子，输出信息要转换成不同的语言，输出信息要显示在桌面上， 把不同的事务处理方法封装在transaction上，这样每个事务的修改都会造成UI的修改，如果把接口分解成不通的单独接口，就可以避免 打包原则\r大型系统的设计非常依赖于好的组件设计，这样每个团队只要关注于单个组件而不需要关注整个系统。 但类经常会和其他类发生依赖关系，这些依赖关系也会跨越组件的边界。 在向组件中分配类时应该依据什么原则 应该使用什么设计原则来管理组件之间的关系 组件的设计应该先于类（自顶而下），还是设计应该先于组件（自底而上） 组件的实体以什么方式存在 组件创建好后，用于何种目的 组件和组件间的依赖关系：不能依赖具体类。只能是具体依赖抽象，抽象依赖抽象。这样就可以将影响将至最低。 前三个原则来指导如何将类划分到包中，后三个原则来管理包之间的耦合(稳定)。组件之间的耦合越稳定就越好 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:5:3","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"重用发布等价原则(reuse release equivalence principle,REP)\r重用粒度就是发布粒度：一个组件的重用粒度和发布粒度一样大，重用的任何东西必须被同时发布和跟踪， 重用性必然是基于组件的，所以可重用的组件必须包含可重用的类，因至少某些组件应该由一组可重用的类组成 一个类中的组件要么都是可重用的，要么都是不可重用的。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:6:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"共同重用原则(common reuse principle , crp)\r一个组件中所有的类都应该是共同重用的，如果重用了组件中的一个类，那么就要重用组件中的所有类。 这个原则可以帮助我们确定哪些类应该在一个组件中，相互之间没有紧密联系的类不应该在同一个组件中。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:7:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"共同封闭原则(common closure principle,ccp)\r组件中所有的类对同一种性质的变化应该是共同封闭的，一个变化若对一个封闭的组件产生影响，则将对该组件中所有的类产生影响，而对其他组件不产生影响。类似于单一职责原则。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:8:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"无环依赖原则\r在组件的关系图中不允许存在环。 解除依赖环的方法：提取抽象接口，通过实现接口来替换关联。关联和实现的依赖关系相反。 ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:9:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"稳定依赖原则\r朝着稳定的方向进行依赖。 被依赖的越多，该组件就越不可能改动，则越稳定。 稳定性度量： ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:10:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"稳定抽象原则\r组件的抽象程度与其稳定性。 中间连接线称为主序列。 到主序列的距离： 越为0 越好 有了度量和标准就让我们划分组件吧！！！ ","date":"2018-10-09","objectID":"/2018/10/designpattern4-designpattern/:11:0","tags":["敏捷软件开发原则模式与实践","设计原则"],"title":"敏捷软件开发原则模式与实践 设计原则","uri":"/2018/10/designpattern4-designpattern/"},{"categories":"设计模式","content":"这本书的实例非常好，给了我非常多的启发。主要讲了两个实例，咖啡机和薪水支付实例，咖啡机实例比较简单并没有用什么设计模式，薪水支付实例用了很多设计模式，包括后面的打包等。 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:0:0","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"咖啡机实例\r做一个使用咖啡机的软件，驱动接口已经被写好。 咖啡机的硬件包括： 加热器加热棒（开关） 保温盘加热棒（开关） 保温盘传感器（保温盘空，杯子空，杯子不空） 加热器传感器（有水，没水） 冲煮按钮（开关） 指示灯（开关） 减压阀门（开关） 咖啡机的冲煮流程： 咖啡机一次煮12杯咖啡， 咖啡加入过滤器，过滤器加入支架，支架放到咖啡机。 倒入12杯水到滤水器，按下冲煮，水杯加热至沸腾，水蒸气碰洒到过滤器，形成水滴到咖啡壶，咖啡壶发现有水保温， 拿走水杯，停止工作。 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:1:0","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"方案一\r建立一个咖啡机超类，关联各个硬件类。这个方案是非常丑陋的，这不是根据行为划分的，有些类，比如light没有任何变量，仅仅调用了驱动接口，这种类叫水蒸气类。没有意义 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:1:1","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"方案二\r按照行为来划分，要确定一些类有没有意义，只需要确定谁使用他们，而且要到业务底层去看。把问题的本质和细节分离，忘掉一切，最根本的问题是如何煮咖啡。如何煮咖啡，将热水倒到咖啡上，把冲泡好的咖啡收集起来。水从哪来？咖啡放到哪里？那么就有两个类：热水类和支架类，大大多数人会考虑热水流到支架中，这是比较错误的，软件的行为应该按照软件的行为给出而不是基于一些物理关系。还需要考虑用户界面，这样就有三个类。 谁使用 最根本的问题 软件行为而不是物理行为 用例\r按下冲煮，启动水流，支架做好准备，都准备好就开始煮咖啡 接受器具准备好没有 冲煮完成 咖啡喝完 Containment Vessel:支架和保温壶 Resume:恢复 a，b，c，d表示四种逻辑： a 表示：用户按下冲煮，确保支架中有咖啡壶放在保温杯上，热水器中已经加满了水，然后才开始煮咖啡 b 表示：如果正在股咖啡的过程中咖啡壶被拿走，则必须中断咖啡流，停止送热水，再次放回咖啡壶继续煮咖啡 c 表示：热水器中传感器告诉我们水用完了就停止煮咖啡，同时告诉用户和支架（保温盘）已经停止煮咖啡 d 表示：冲煮结束时并且一个空的咖啡壶放在支架上（保温盘），热水器应该知道这个消息，同时用户也应该知道这个消息 这样整个咖啡机的抽象就完成了，按职责划分，各司其职。这三个抽象类不能知道任何关于咖啡机的任何信息。这就是依赖倒置原则。 系统的控制流如何检测传感器呢？是选择线程还是轮询。最好的总是假设消息都是可以异步发送的，就像存在有独立的线程一样，把使用轮询还是线程的决策推迟到最后一刻。 这样设置了一个接口，main()程序就待在一个循环中，不停地一遍遍调用这个方法实现轮询。 public static void Main(string[] args) { CoffeeMakerAPI api = new M4CoffeeMakerAPI(); M4UserInterface ui = new M4UserInterface(api); M4HotWaterSOurce hws = new M4HotWaterSOurce(api); M4ContainmentVessel cv = new M4ContainmentVessel(api); ui.Init(hws,cv); hws.Init(ui,cv); cv.Init(hws,ui); while(true) { ui.Poll(); hws.Poll(); cv.Poll(); } } 依赖倒置，不允许高层的咖啡制作中依赖底层实现。 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:1:2","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"薪水支付实例\r该案例主要有做一个薪水支付系统，主要有三类员工 临时工：基本时薪，超过8小时加班时间1.5倍工资，每天有考勤卡，每周5结算。 正式员工：月薪，每个月最后一天结算。 经理：月薪，每月最后一天结算，有项目提成，每隔一周的周五结算，加入公会扣会费。 公会会费分服务费和会费：会费每周都有从薪水中扣除，服务费从下个月薪水中扣除。 薪水支付方式：可以选择支票邮寄到家，支票保存自取，直接存入银行账号。 薪水支付每天运行一次，在当天为相应的雇员进行支付，上一次支付到本次支付应付的数额。 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:2:0","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"用例：\r新增雇员：雇员号，姓名，地址。（零时工，正式员工，经理） 删除雇员：雇员号 登记考勤卡：雇员号，日期，小时 登记销售凭条：雇员号，日期，销售记录 登记公会服务费：公会成员，服务费用 更改雇员细则：更改姓名，更改地址，更改每小时报酬，更改薪水，更改提成，更改支付方式，加入公会，离开公会 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:2:1","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"设计类和结构：\r通过迭代的方式进行实现。数据库是实现细节，应该尽推迟数据库的设计。通过用例来推导出应该有哪些类。 从用例的角度设计\r新增雇员 Hourly:小时工 Commissioned：正式员工 Balarid：经理 把每一项工作划分为自己的类中。这样有可能会创建三个雇员类，但是分析一下就会发现变化的东西太多了，正式由于雇员变化的东西引发雇员类型的改变，只需要将变化的东西抽象出来，在更改雇员细则时改变这些变化的东西就可以改变雇员类型。 登记考勤卡 考勤卡和雇员应该是聚合的关系 登记销售凭条 销售凭条和雇员也应该是聚合的关系 登机工会服务费 工会服务费维护着工会会员的编号，因此系统必须要把工会成员和雇员标识联系起俩，推迟这一行为。公会成员和服务费也是聚合的关系 更改雇员细则 这是由多个更改策略组合而成。 最后各个类之间的关系 从程序运行的角度补充细节\r运行薪水支付系统：找到所有进行支付的雇员，确定扣款额，根据他们的支付方式支付。 抽象出变化的东西：雇员的支付类别抽象，支付时间抽象 工会服务费抽象。Affillation:联系 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:2:2","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"实现\r事务 事务是使用命令模式。 增加雇员事务，雇员有三个类型，所以使用模板模式来实现增加雇员，此处模板模式的唯一任务就是创建对象 public abstract class AddEmployeeTransaction : Transaction { private readonly int empid; private readonly string name; private readonly string address; public AddEmployeeTransaction(int empid, string name, string address, PayrollDatabase database) : base (database) { this.empid = empid; this.name = name; this.address = address; } protected abstract PaymentClassification MakeClassification(); protected abstract PaymentSchedule MakeSchedule(); public override void Execute() { PaymentClassification pc = MakeClassification(); PaymentSchedule ps = MakeSchedule(); PaymentMethod pm = new HoldMethod(); Employee e = new Employee(empid, name, address); e.Classification = pc; e.Schedule = ps; e.Method = pm; database.AddEmployee(e); } public override string ToString() { return String.Format(\"{0} id:{1} name:{2} address:{3}\", GetType().Name, empid, name,address); } } public class AddSalariedEmployee : AddEmployeeTransaction { private readonly double salary; public AddSalariedEmployee(int id, string name, string address, double salary, PayrollDatabase database) : base(id, name, address, database) { this.salary = salary; } protected override PaymentClassification MakeClassification() { return new SalariedClassification(salary); } protected override PaymentSchedule MakeSchedule() { return new MonthlySchedule(); } } 删除雇员 提供雇员id，去数据库删除雇员，没啥好说的。 考勤卡、销售凭条、服务费 考勤卡：需要参数，雇员id,日期，工作时间 public class TimeCard { private readonly DateTime date; private readonly double hours; public TimeCard(DateTime date, double hours) { this.date = date; this.hours = hours; } public double Hours { get { return hours; } } public DateTime Date { get { return date; } } } public class TimeCardTransaction : Transaction { private readonly DateTime date; private readonly double hours; private readonly int empId; public TimeCardTransaction(DateTime date, double hours, int empId, PayrollDatabase database) : base(database) { this.date = date; this.hours = hours; this.empId = empId; } public override void Execute() { Employee e = database.GetEmployee(empId); if (e != null) { HourlyClassification hc = e.Classification as HourlyClassification; if (hc != null) hc.AddTimeCard(new TimeCard(date, hours)); else throw new ApplicationException( \"Tried to add timecard to\" + \"non-hourly employee\"); } else throw new ApplicationException( \"No such employee.\"); } } 其他两种与这类似 更改雇员属性 更改雇员属性由多个事务集合而成 改名字事务： public abstract class ChangeEmployeeTransaction : Transaction { private readonly int empId; public ChangeEmployeeTransaction(int empId, PayrollDatabase database) : base (database) { this.empId = empId; } public override void Execute() { Employee e = database.GetEmployee(empId); if(e != null) Change(e); else throw new ApplicationException( \"No such employee.\"); } protected abstract void Change(Employee e); } public class ChangeNameTransaction : ChangeEmployeeTransaction { private readonly string newName; public ChangeNameTransaction(int id, string newName, PayrollDatabase database) : base(id, database) { this.newName = newName; } protected override void Change(Employee e) { e.Name = newName; } } 更改雇员类别 public abstract class ChangeClassificationTransaction : ChangeEmployeeTransaction { public ChangeClassificationTransaction(int id, PayrollDatabase database) : base (id, database) {} protected override void Change(Employee e) { e.Classification = Classification; e.Schedule = Schedule; } protected abstract PaymentClassification Classification { get; } protected abstract PaymentSchedule Schedule { get; } } public class ChangeHourlyTransaction : ChangeClassificationTransaction { private readonly double hourlyRate; public ChangeHourlyTransaction(int id, double hourlyRate, PayrollDatabase database) : base(id, database) { this.hourlyRate = hourlyRate; } protected override PaymentClassification Classification { get { return new HourlyClassification(hourlyRate); } } protected override PaymentSchedule Schedule { get { return new WeeklySchedule(","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:2:3","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"总结\r到目前为止基本功能已经实现，仅仅只是用了模板，空值，命令等设计模式，下一篇将会进一步使用更多的设计模式进行打包处理。 ","date":"2018-09-29","objectID":"/2018/09/designpattern2-case1/:3:0","tags":["敏捷软件开发原则模式与实践","咖啡机"],"title":"敏捷软件开发原则模式与实践 咖啡机","uri":"/2018/09/designpattern2-case1/"},{"categories":"设计模式","content":"所看书籍是：敏捷软件开发_原则、模式与实践_C#版（美）马丁著，这本书写的非常棒，感谢作者。该归纳总结的过程按照我读的顺序写。 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:0:0","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"UML\r在建造桥梁，零件，自动化设备之前需要建模分析可行性，软件在编写之前也需要建立模型，看看类和逻辑的设计是否合理，这样的建模过程就是UML。 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:0","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"类图\r类图就是来描述一个类本身或和其他类的调用关系。 +public -private #protected 实现/泛化\r集成 实现接口 组合\r部分可以离开整体 聚合\r部分不能离开整体 关联\r持有对其他对象引用的实例变量 依赖\r局部变量/方法的参数或则静态方法的调用 注意 关系的强弱：泛化/实现\u003e组合\u003e聚合\u003e关联\u003e依赖 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:1","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"对象图\r表示系统执行的某个特定时刻的一组对象和关系，可以看成是内存快照。 该图大部分是从相应的类图中推导而来没啥用。 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:2","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"顺序图\r描述算法的实现，重点在于消息的顺序。比较常绘制的动态模型。 例子\r对象下面画有横线，类没有，对象名：类 垂下来的线为生命线 中间矩形垂下来的矩形：激活，表示一个函数的执行时间 虚线表示返回参与者并传回返回值 箭头：消息。返回值：消息名称（参数） 带圆圈的箭头：消息的参数 注意\r循环：框起来 [for each id in idlist] 容易被勿用和滥用 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:3","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"协作图\r描述算法的实现，重点在于对象之间的关系 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:4","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"状态图\r其实就是有限状态机（FSM）。 例子:\r实心黑球：初始伪状态，从这个状态开始运转 圆矩形：状态。上层放状态的名字，下层放一些特定动作和事件，表示进入或则退出时要做什么， 箭头：迁移。上面有触发该迁移的事件名称和要执行的动作 注意 entry和exit：标准事件，不管写不写都会触发 超状态：几个状态迁移时间相同时，可以组成一个超状态。迁移时会出发超状态的entry和exit ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:1:5","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"如何使用UML\r在使用UML的过程中，需要先通过行为优先的方式写出状态图，先是局部状态再是整体状态，抽象出会改变的，将每一种改变的类型实例化，中间再通过各种设计模式隔离 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:2:0","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"行为优先\r从项目的功能入手，用户的交互入手写出每一种功能，大体的类有了后，再抽象出会改变的类，通过设计模式隔离 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:2:1","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"检查结构\r检查每一种功能实现是否合理 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:2:2","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":"设计模式","content":"想象代码\r想想出代码的样子做微调 ","date":"2018-09-26","objectID":"/2018/09/designpattern1-uml/:2:3","tags":["敏捷软件开发原则模式与实践","UML"],"title":"敏捷软件开发原则模式与实践 UML","uri":"/2018/09/designpattern1-uml/"},{"categories":null,"content":"关于我\r92年，儿子、丈夫、父亲，新时代农民工。 从事上位机开发多年，熟悉制药(层析超滤)和IVD(生化免疫)设备软件。 喜欢研究和学习各类技术，保持好奇心，持续探索。 熟悉的编程语言：C#,C,C++,Vue。 可以通过邮件978089234@qq.com与我联系！ Blog\r小时候夏天很长，长大了一年很短。每天都感觉很忙碌，却不知道在忙些什么。 想要记录些东西，表明那些年真的存在过。 写的文章，分享的想法观点可能早就有人写过，分享过。 没有关系，这算是自我的一种成长和探索，走一下别人走过的路，站在巨人的肩膀上，能不能看到不一样的风景？ ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]